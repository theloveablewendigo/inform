!% -s
!% $ALLOC_CHUNK_SIZE=32000
!% $MAX_ARRAYS=10000
!% $MAX_CLASSES=200
!% $MAX_VERBS=255
!% $MAX_LABELS=200000
!% $MAX_ZCODE_SIZE=500000
!% $MAX_STATIC_DATA=180000
!% $MAX_PROP_TABLE_SIZE=200000
!% $MAX_INDIV_PROP_TABLE_SIZE=20000
!% $MAX_STACK_SIZE=65536
!% $MAX_SYMBOLS=20000
!% $MAX_EXPRESSION_NODES=256
!% $MAX_LOCAL_VARIABLES=256



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Other Configuration
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant Grammar__Version 2;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Identification
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

! This file was compiled by Inform 7: the build number and version of the
! I6 template layer used are as follows.
Constant NI_BUILD_COUNT "6L38";

Constant LibSerial = "080126";
Constant LibRelease = "6/12N";
Constant LIBRARY_VERSION = 612;

Constant PLUGIN_FILES;


Array UUID_ARRAY string "UUID://2050509A-8423-4982-B5DC-DC6D318DBE72//";

Global Story = BC_0;
Constant Headline BC_1;
Constant Story_Author BC_2;
Release 1;
Serial "150320";

Default Story 0;
Default Headline 0;

[ ShowExtensionVersions ;
    print "Standard Rules version 3/120430 by Graham Nelson^";
    print "Exit Descriptions version 3 by Matthew Fletcher^";
    print "Second Gender version 1 by Felix Larsson (based on original Inform 6 code by Fredrik Ramsberg)^";
    print "Useful Functions version 1 by ShadowChaser^";
];
[ ShowFullExtensionVersions ;
    print "Standard Rules version 3/120430 by Graham Nelson^";
    print "English Language version 1 by Graham Nelson^";
    print "Exit Descriptions version 3 by Matthew Fletcher^";
    print "Locksmith version 12 by Emily Short^";
    print "Second Gender version 1 by Felix Larsson (based on original Inform 6 code by Fredrik Ramsberg)^";
    print "Plurality version 8 by Emily Short^";
    print "Useful Functions version 1 by ShadowChaser^";
    print "Menus version 3 by Emily Short^";
    print "Basic Screen Effects version 7/140425 by Emily Short^";
];
[ ShowOneExtension 
    id ! Implied call parameter
    ;
    if (id == 1) print "Standard Rules version 3/120430 by Graham Nelson";
    if (id == 2) print "English Language version 1 by Graham Nelson";
    if (id == 3) print "Exit Descriptions version 3 by Matthew Fletcher";
    if (id == 4) print "Locksmith version 12 by Emily Short";
    if (id == 5) print "Second Gender version 1 by Felix Larsson (based on original Inform 6 code by Fredrik Ramsberg)";
    if (id == 6) print "Plurality version 8 by Emily Short";
    if (id == 7) print "Useful Functions version 1 by ShadowChaser";
    if (id == 8) print "Menus version 3 by Emily Short";
    if (id == 9) print "Basic Screen Effects version 7/140425 by Emily Short";
];



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Use options
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

! Use option:
 Constant DynamicMemoryAllocation = 8192; 
! Use option:
 Constant TEXT_TY_BufferSize = 1024+3; 
! Use option:
 Constant MAX_FIGURE_THUMBNAILS_IN_INDEX = 50; 
! Use option:
 Constant MATCH_LIST_WORDS = 100; 
! Use option:
 Constant DIALECT_US; 
! Use option:
 Constant SERIAL_COMMA; 
! Use option:
 Constant I7_LOOKMODE = 2; 
! Use option:
 Constant USE_SCORING = 1; 


#Ifndef USE_SCORING;
Constant USE_SCORING = 0;
#Endif;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Constants
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: VM Target Constants
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#Ifndef WORDSIZE; ! compiling with Z-code only compiler
Constant TARGET_ZCODE;
Constant WORDSIZE 2;
#Endif;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Wordsize-Dependent Definitions
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#Iftrue (WORDSIZE == 2);
Constant NULL = $ffff;
Constant WORD_HIGHBIT = $8000;
Constant WORD_NEXTTOHIGHBIT = $4000;
Constant IMPROBABLE_VALUE = $7fe3;
Constant MAX_POSITIVE_NUMBER 32767;
Constant MIN_NEGATIVE_NUMBER -32768;
Constant REPARSE_CODE = 10000;
#Endif;

#Iftrue (WORDSIZE == 4);
Constant NULL = $ffffffff;
Constant WORD_HIGHBIT = $80000000;
Constant WORD_NEXTTOHIGHBIT = $40000000;
Constant IMPROBABLE_VALUE = $deadce11;
Constant MAX_POSITIVE_NUMBER 2147483647;
Constant MIN_NEGATIVE_NUMBER -2147483648;
Constant REPARSE_CODE = $40000000;
#Endif;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Z-Machine Definitions
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#Ifdef TARGET_ZCODE;

Global max_z_object;

Constant INDIV_PROP_START 64;

! Offsets into Z-machine header:

Constant HDR_ZCODEVERSION     = $00;     ! byte
Constant HDR_TERPFLAGS        = $01;     ! byte
Constant HDR_GAMERELEASE      = $02;     ! word
Constant HDR_HIGHMEMORY       = $04;     ! word
Constant HDR_INITIALPC        = $06;     ! word
Constant HDR_DICTIONARY       = $08;     ! word
Constant HDR_OBJECTS          = $0A;     ! word
Constant HDR_GLOBALS          = $0C;     ! word
Constant HDR_STATICMEMORY     = $0E;     ! word
Constant HDR_GAMEFLAGS        = $10;     ! word
Constant HDR_GAMESERIAL       = $12;     ! six ASCII characters
Constant HDR_ABBREVIATIONS    = $18;     ! word
Constant HDR_FILELENGTH       = $1A;     ! word
Constant HDR_CHECKSUM         = $1C;     ! word
Constant HDR_TERPNUMBER       = $1E;     ! byte
Constant HDR_TERPVERSION      = $1F;     ! byte
Constant HDR_SCREENHLINES     = $20;     ! byte
Constant HDR_SCREENWCHARS     = $21;     ! byte
Constant HDR_SCREENWUNITS     = $22;     ! word
Constant HDR_SCREENHUNITS     = $24;     ! word
Constant HDR_FONTWUNITS       = $26;     ! byte
Constant HDR_FONTHUNITS       = $27;     ! byte
Constant HDR_ROUTINEOFFSET    = $28;     ! word
Constant HDR_STRINGOFFSET     = $2A;     ! word
Constant HDR_BGCOLOUR         = $2C;     ! byte
Constant HDR_FGCOLOUR         = $2D;     ! byte
Constant HDR_TERMCHARS        = $2E;     ! word
Constant HDR_PIXELSTO3        = $30;     ! word
Constant HDR_TERPSTANDARD     = $32;     ! two bytes
Constant HDR_ALPHABET         = $34;     ! word
Constant HDR_EXTENSION        = $36;     ! word
Constant HDR_UNUSED           = $38;     ! two words
Constant HDR_INFORMVERSION    = $3C;     ! four ASCII characters

#Endif;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Glulx Definitions
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#IFDEF TARGET_GLULX;

Global unicode_gestalt_ok; ! Set if interpreter supports Unicode

! Offsets into Glulx header and start of ROM:

Constant HDR_MAGICNUMBER      = $00;     ! long word
Constant HDR_GLULXVERSION     = $04;     ! long word
Constant HDR_RAMSTART         = $08;     ! long word
Constant HDR_EXTSTART         = $0C;     ! long word
Constant HDR_ENDMEM           = $10;     ! long word
Constant HDR_STACKSIZE        = $14;     ! long word
Constant HDR_STARTFUNC        = $18;     ! long word
Constant HDR_DECODINGTBL      = $1C;     ! long word
Constant HDR_CHECKSUM         = $20;     ! long word
Constant ROM_INFO             = $24;     ! four ASCII characters
Constant ROM_MEMORYLAYOUT     = $28;     ! long word
Constant ROM_INFORMVERSION    = $2C;     ! four ASCII characters
Constant ROM_COMPVERSION      = $30;     ! four ASCII characters
Constant ROM_GAMERELEASE      = $34;     ! short word
Constant ROM_GAMESERIAL       = $36;     ! six ASCII characters

#Endif;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Powers of Two
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Array PowersOfTwo_TB
  --> $$100000000000
      $$010000000000
      $$001000000000
      $$000100000000
      $$000010000000
      $$000001000000
      $$000000100000
      $$000000010000
      $$000000001000
      $$000000000100
      $$000000000010
      $$000000000001;

Array IncreasingPowersOfTwo_TB
  --> $$0000000000000001
      $$0000000000000010
      $$0000000000000100
      $$0000000000001000
      $$0000000000010000
      $$0000000000100000
      $$0000000001000000
      $$0000000010000000
      $$0000000100000000
      $$0000001000000000
      $$0000010000000000
	  $$0000100000000000
	  $$0001000000000000
	  $$0010000000000000
	  $$0100000000000000
	  $$1000000000000000;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Text Styles
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant NORMAL_VMSTY     = 0;
Constant HEADER_VMSTY     = 3;
Constant SUBHEADER_VMSTY  = 4;
Constant ALERT_VMSTY      = 5;
Constant NOTE_VMSTY       = 6;
Constant BLOCKQUOTE_VMSTY = 7;
Constant INPUT_VMSTY      = 8;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Colour Numbers
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant CLR_DEFAULT = 1;
Constant CLR_BLACK   = 2;
Constant CLR_RED     = 3;
Constant CLR_GREEN   = 4;
Constant CLR_YELLOW  = 5;
Constant CLR_BLUE    = 6;
Constant CLR_MAGENTA = 7; Constant CLR_PURPLE  = 7;
Constant CLR_CYAN    = 8; Constant CLR_AZURE   = 8;
Constant CLR_WHITE   = 9;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Window Numbers
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant WIN_ALL     = 0; ! Both windows at once
Constant WIN_STATUS  = 1;
Constant WIN_MAIN    = 2;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Paragraphing Flags
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant PARA_COMPLETED          = 1;
Constant PARA_PROMPTSKIP         = 2;
Constant PARA_SUPPRESSPROMPTSKIP = 4;
Constant PARA_NORULEBOOKBREAKS   = 8;
Constant PARA_CONTENTEXPECTED    = 16;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Descriptors in the Language of Play
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant POSSESS_PK  = $100;
Constant DEFART_PK   = $101;
Constant INDEFART_PK = $102;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Run-Time Problem Numbers
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant RTP_BACKDROP                = 1;
Constant RTP_EXITDOOR                = 2;
Constant RTP_NOEXIT                  = 3;
Constant RTP_CANTCHANGE              = 4;
Constant RTP_IMPREL                  = 5;
Constant RTP_RULESTACK               = 6; ! Now out of use
Constant RTP_TOOMANYRULEBOOKS        = 7;
Constant RTP_TOOMANYEVENTS           = 8;
Constant RTP_BADPROPERTY             = 9;
Constant RTP_UNPROVIDED              = 10;
Constant RTP_UNSET                   = 11;
Constant RTP_TOOMANYACTS             = 12;
Constant RTP_CANTABANDON             = 13;
Constant RTP_CANTEND                 = 14;
Constant RTP_CANTMOVENOTHING         = 15;
Constant RTP_CANTREMOVENOTHING       = 16;
Constant RTP_DIVZERO                 = 17;
Constant RTP_BADVALUEPROPERTY        = 18;
Constant RTP_NOTBACKDROP             = 19;
Constant RTP_TABLE_NOCOL             = 20;
Constant RTP_TABLE_NOCORR            = 21;
Constant RTP_TABLE_NOROW             = 22;
Constant RTP_TABLE_NOENTRY           = 23;
Constant RTP_TABLE_NOTABLE           = 24;
Constant RTP_TABLE_NOMOREBLANKS      = 25;
Constant RTP_TABLE_NOROWS            = 26;
Constant RTP_TABLE_CANTSORT          = 27;
Constant RTP_NOTINAROOM              = 28;
Constant RTP_BADTOPIC                = 29;
Constant RTP_ROUTELESS               = 30;
Constant RTP_PROPOFNOTHING           = 31;
Constant RTP_DECIDEONWRONGKIND       = 32;
Constant RTP_DECIDEONNOTHING         = 33;
Constant RTP_TABLE_CANTSAVE          = 34;
Constant RTP_TABLE_WONTFIT           = 35;
Constant RTP_TABLE_BADFILE           = 36;
Constant RTP_LOWLEVELERROR           = 37;
Constant RTP_DONTIGNORETURNSEQUENCE  = 38;
Constant RTP_SAYINVALIDSNIPPET       = 39;
Constant RTP_SPLICEINVALIDSNIPPET    = 40;
Constant RTP_INCLUDEINVALIDSNIPPET   = 41;
Constant RTP_LISTWRITERMEMORY        = 42;
Constant RTP_CANTREMOVEPLAYER        = 43;
Constant RTP_CANTREMOVEDOORS         = 44;
Constant RTP_CANTCHANGEOFFSTAGE      = 45;
Constant RTP_MSTACKMEMORY            = 46;
Constant RTP_TYPECHECK               = 47;
Constant RTP_FILEIOERROR             = 48;
Constant RTP_HEAPERROR               = 49;
Constant RTP_LISTRANGEERROR          = 50;
Constant RTP_REGEXPSYNTAXERROR       = 51;
Constant RTP_NOGLULXUNICODE          = 52;
Constant RTP_BACKDROPONLY            = 53;
Constant RTP_NOTTHING                = 54;
Constant RTP_SCENEHASNTSTARTED       = 55;
Constant RTP_SCENEHASNTENDED         = 56;
Constant RTP_NEGATIVEROOT            = 57;
Constant RTP_TABLE_CANTRUNTHROUGH    = 58;
Constant RTP_CANTITERATE             = 59;
Constant RTP_WRONGASSIGNEDKIND       = 60;
Constant RTP_CANTBEOFFSTAGE          = 61;
Constant RTP_RELKINDVIOLATION        = 62;
Constant RTP_CANTMAKEPART       	 = 63;
Constant RTP_TEXTTOKENTOOHARD        = 64;
Constant RTP_TABLE_NOTABLE2          = 65;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Template Activities
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant PRINTING_THE_NAME_ACT           = 0;
Constant PRINTING_THE_PLURAL_NAME_ACT    = 1;
Constant PRINTING_A_NUMBER_OF_ACT        = 2;
Constant PRINTING_ROOM_DESC_DETAILS_ACT  = 3;
Constant PRINTING_INVENTORY_DETAILS_ACT  = 4;
Constant LISTING_CONTENTS_ACT            = 5;
Constant GROUPING_TOGETHER_ACT           = 6;
Constant WRITING_A_PARAGRAPH_ABOUT_ACT   = 7;
Constant LISTING_NONDESCRIPT_ITEMS_ACT   = 8;

Constant PRINTING_NAME_OF_DARK_ROOM_ACT  = 9;
Constant PRINTING_DESC_OF_DARK_ROOM_ACT  = 10;
Constant PRINTING_NEWS_OF_DARKNESS_ACT   = 11;
Constant PRINTING_NEWS_OF_LIGHT_ACT      = 12;
Constant REFUSAL_TO_ACT_IN_DARK_ACT      = 13;

Constant CONSTRUCTING_STATUS_LINE_ACT    = 14;
Constant PRINTING_BANNER_TEXT_ACT        = 15;

Constant READING_A_COMMAND_ACT           = 16;
Constant DECIDING_SCOPE_ACT              = 17;
Constant DECIDING_CONCEALED_POSSESS_ACT  = 18;
Constant DECIDING_WHETHER_ALL_INC_ACT    = 19;
Constant CLARIFYING_PARSERS_CHOICE_ACT   = 20;
Constant ASKING_WHICH_DO_YOU_MEAN_ACT    = 21;
Constant PRINTING_A_PARSER_ERROR_ACT     = 22;
Constant SUPPLYING_A_MISSING_NOUN_ACT    = 23;
Constant SUPPLYING_A_MISSING_SECOND_ACT  = 24;
Constant IMPLICITLY_TAKING_ACT           = 25;
Constant STARTING_VIRTUAL_MACHINE_ACT    = 26;

Constant AMUSING_A_VICTORIOUS_PLAYER_ACT = 27;
Constant PRINTING_PLAYERS_OBITUARY_ACT   = 28;
Constant DEALING_WITH_FINAL_QUESTION_ACT = 29;

Constant PRINTING_LOCALE_DESCRIPTION_ACT = 30;
Constant CHOOSING_NOTABLE_LOCALE_OBJ_ACT = 31;
Constant PRINTING_LOCALE_PARAGRAPH_ACT   = 32;

Constant PRINTING_RESPONSE_ACT           = 33;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Template Rulebooks
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant STARTUP_RB                      = 0;
Constant TURN_SEQUENCE_RB                = 1;
Constant SHUTDOWN_RB                     = 2;

Constant WHEN_PLAY_BEGINS_RB             = 4;
Constant WHEN_PLAY_ENDS_RB               = 5;
Constant WHEN_SCENE_BEGINS_RB            = 6;
Constant WHEN_SCENE_ENDS_RB              = 7;

Constant ACTION_PROCESSING_RB            = 9;
Constant SETTING_ACTION_VARIABLES_RB     = 10;
Constant SPECIFIC_ACTION_PROCESSING_RB   = 11;

Constant ACCESSIBILITY_RB                = 13;
Constant REACHING_INSIDE_RB              = 14;
Constant REACHING_OUTSIDE_RB             = 15;
Constant VISIBLE_RB                      = 16;

Constant PERSUADE_RB                     = 17;
Constant UNSUCCESSFUL_ATTEMPT_RB         = 18;

Constant AFTER_RB                        = 23;
Constant REPORT_RB                       = 24;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Kind IDs
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant UNKNOWN_TY = 1;
Constant VALUE_TY = 2;
Constant POINTER_VALUE_TY = 3;
Constant WORD_VALUE_TY = 4;
Constant ARITHMETIC_VALUE_TY = 5;
Constant REAL_ARITHMETIC_VALUE_TY = 6;
Constant ENUMERATED_VALUE_TY = 7;
Constant SAYABLE_VALUE_TY = 8;
Constant COMBINED_VALUE_TY = 9;
Constant OBJECT_TY = 10;
Constant NUMBER_TY = 11;
Constant REAL_NUMBER_TY = 12;
Constant TRUTH_STATE_TY = 13;
Constant TEXT_TY = 14;
Constant UNICODE_CHARACTER_TY = 15;
Constant USE_OPTION_TY = 16;
Constant RESPONSE_TY = 17;
Constant VERB_TY = 18;
Constant SNIPPET_TY = 19;
Constant TABLE_TY = 20;
Constant EQUATION_TY = 21;
Constant RULEBOOK_OUTCOME_TY = 22;
Constant UNDERSTANDING_TY = 23;
Constant INTERMEDIATE_TY = 24;
Constant NIL_TY = 25;
Constant KIND_VARIABLE_TY = 26;
Constant PHRASE_TY = 27;
Constant TUPLE_ENTRY_TY = 28;
Constant RELATION_TY = 29;
Constant RULE_TY = 30;
Constant RULEBOOK_TY = 31;
Constant ACTIVITY_TY = 32;
Constant LIST_OF_TY = 33;
Constant DESCRIPTION_OF_TY = 34;
Constant PROPERTY_TY = 35;
Constant TABLE_COLUMN_TY = 36;
Constant COMBINATION_TY = 37;
Constant DESCRIPTION_OF_ACTION_TY = 38;
Constant STORED_ACTION_TY = 39;
Constant ACTION_NAME_TY = 40;
Constant TIME_TY = 41;
Constant SCENE_TY = 42;
Constant FIGURE_NAME_TY = 43;
Constant SOUND_NAME_TY = 44;
Constant EXTERNAL_FILE_TY = 45;
Constant BASE_KIND_HWM = 53; ! Base kind high-water-mark



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Parser Error Numbers
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant STUCK_PE         = 1;
Constant UPTO_PE          = 2;
Constant NUMBER_PE        = 3;
Constant ANIMA_PE         = 4;
Constant CANTSEE_PE       = 5;
Constant TOOLIT_PE        = 6;
Constant NOTHELD_PE       = 7;
Constant MULTI_PE         = 8;
Constant MMULTI_PE        = 9;
Constant VAGUE_PE         = 10;
Constant EXCEPT_PE        = 11;
Constant VERB_PE          = 12;
Constant SCENERY_PE       = 13;
Constant ITGONE_PE        = 14;
Constant JUNKAFTER_PE     = 15;
Constant TOOFEW_PE        = 16;
Constant NOTHING_PE       = 17;
Constant ASKSCOPE_PE      = 18;
Constant NOTINCONTEXT_PE  = 19;
Constant BLANKLINE_PE     = 20; ! Not formally a parser error, but used by I7 as if
Constant ANIMAAGAIN_PE    = 21;
Constant COMMABEGIN_PE    = 22;
Constant MISSINGPERSON_PE = 23;
Constant ANIMALISTEN_PE   = 24;
Constant TOTALK_PE        = 25;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Scope Searching Reasons
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant PARSING_REASON       = 0;
Constant TALKING_REASON       = 1;
Constant EACH_TURN_REASON     = 2;
Constant LOOPOVERSCOPE_REASON = 5;
Constant TESTSCOPE_REASON     = 6;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Token Types
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant ILLEGAL_TT         = 0;    ! Types of grammar token: illegal
Constant ELEMENTARY_TT      = 1;    !     (one of those below)
Constant PREPOSITION_TT     = 2;    !     e.g. 'into'
Constant ROUTINE_FILTER_TT  = 3;    !     e.g. noun=CagedCreature
Constant ATTR_FILTER_TT     = 4;    !     e.g. edible
Constant SCOPE_TT           = 5;    !     e.g. scope=Spells
Constant GPR_TT             = 6;    !     a general parsing routine

Constant NOUN_TOKEN         = 0;    ! The elementary grammar tokens, and
Constant HELD_TOKEN         = 1;    ! the numbers compiled by I6 to
Constant MULTI_TOKEN        = 2;    ! encode them
Constant MULTIHELD_TOKEN    = 3;
Constant MULTIEXCEPT_TOKEN  = 4;
Constant MULTIINSIDE_TOKEN  = 5;
Constant CREATURE_TOKEN     = 6;
Constant SPECIAL_TOKEN      = 7;
Constant NUMBER_TOKEN       = 8;
Constant TOPIC_TOKEN        = 9;
Constant ENDIT_TOKEN        = 15;   ! Value used to mean "end of grammar line"


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: GPR Return Values
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant GPR_FAIL           = -1;   ! Return values from General Parsing
Constant GPR_PREPOSITION    = 0;    ! Routines
Constant GPR_NUMBER         = 1;
Constant GPR_MULTIPLE       = 2;
Constant GPR_REPARSE        = REPARSE_CODE;
Constant GPR_NOUN           = -256; ! Reparse, but as |NOUN_TOKEN| this time
Constant GPR_HELD           = GPR_NOUN + 1; ! And so on
Constant GPR_MULTI          = GPR_NOUN + 2;
Constant GPR_MULTIHELD      = GPR_NOUN + 3;
Constant GPR_MULTIEXCEPT    = GPR_NOUN + 4;
Constant GPR_MULTIINSIDE    = GPR_NOUN + 5;
Constant GPR_CREATURE       = GPR_NOUN + 6;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: List Styles
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant NEWLINE_BIT        = $$0000000000000001; ! New-line after each entry
Constant INDENT_BIT         = $$0000000000000010; ! Indent each entry by depth
Constant FULLINV_BIT        = $$0000000000000100; ! Full inventory information after entry
Constant ENGLISH_BIT        = $$0000000000001000; ! English sentence style, with commas and and
Constant RECURSE_BIT        = $$0000000000010000; ! Recurse downwards with usual rules
Constant ALWAYS_BIT         = $$0000000000100000; ! Always recurse downwards
Constant TERSE_BIT          = $$0000000001000000; ! More terse English style
Constant PARTINV_BIT        = $$0000000010000000; ! Only brief inventory information after entry
Constant DEFART_BIT         = $$0000000100000000; ! Use the definite article in list
Constant WORKFLAG_BIT       = $$0000001000000000; ! At top level (only), only list objects
                                                  ! which have the "workflag" attribute
Constant ISARE_BIT          = $$0000010000000000; ! Print " is" or " are" before list
Constant CONCEAL_BIT        = $$0000100000000000; ! Omit objects with "concealed" or "scenery":
                                                  ! if WORKFLAG_BIT also set, then does not
                                                  ! apply at top level, but does lower down
Constant NOARTICLE_BIT      = $$0001000000000000; ! Print no articles, definite or not
Constant EXTRAINDENT_BIT    = $$0010000000000000; ! New in I7: extra indentation of 1 level
Constant CFIRSTART_BIT      = $$0100000000000000; ! Capitalise first article in list


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Lengths Of Time
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant QUARTER_HOUR = 15;
Constant HALF_HOUR = 30;
Constant ONE_HOUR = 60;
Constant TWELVE_HOURS = 720;
Constant TWENTY_FOUR_HOURS = 1440;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Empty Text
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant EMPTY_TEXT_PACKED "";
Array EMPTY_TEXT_VALUE --> CONSTANT_PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Empty Table
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Array TheEmptyTable --> 0 0;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Empty Set
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ Prop_Falsity reason obj; return 0; ];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Score and Rankings Table
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


#Ifndef MAX_SCORE;
Global MAX_SCORE = 0;
#Endif;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Template Attributes
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Attribute absent; ! Used to mark objects removed from play
Attribute animate; ! I6-level marker for I7 kind "person"
Attribute clothing; ! = I7 "wearable"
Attribute concealed; ! = I7 "undescribed"
Attribute container; ! I6-level marker for I7 kind "container"
Attribute door; ! I6-level marker for I7 kind "door"
Attribute edible; ! = I7 "edible" vs "inedible"
Attribute enterable; ! = I7 "enterable"
Attribute light; ! = I7 "lighted" vs "dark"
Attribute lockable; ! = I7 "lockable"
Attribute locked; ! = I7 "locked"
Attribute moved; ! = I7 "handled"
Attribute on; ! = I7 "switched on" vs "switched off"
Attribute open; ! = I7 "open" vs "closed"
Attribute openable; ! = I7 "openable"
Attribute scenery; ! = I7 "scenery"
Attribute static; ! = I7 "fixed in place" vs "portable"
Attribute supporter; ! I6-level marker for I7 kind "supporter"
Attribute switchable; ! I6-level marker for I7 kind "device"
Attribute talkable; ! Not currently used by I7, but retained for possible future use
Attribute transparent; ! = I7 "transparent" vs "opaque"
Attribute visited; ! = I7 "visited"
Attribute worn; ! marks that an object tree edge represents wearing

Attribute male; ! not directly used by I7, but available for languages with genders
Attribute female; ! = I7 "female" vs "male"
Attribute neuter; ! = I7 "neuter"
Attribute pluralname; ! = I7 "plural-named"
Attribute ambigpluralname; ! = I7 "ambiguously plural"
Attribute proper; ! = I7 "proper-named"
Attribute remove_proper; ! remember to remove proper again when using ChangePlayer next

Attribute privately_named; ! New in I7
Attribute mentioned; ! New in I7
Attribute pushable; ! New in I7

Attribute mark_as_room; ! Used in I7 to speed up testing "ofclass K1_room"
Attribute mark_as_thing; ! Used in I7 to speed up testing "ofclass K2_thing"

Attribute workflag; ! = I7 "marked for listing", but basically temporary workspace 
Attribute workflag2; ! new in I7 and also temporary workspace
Constant list_filter_permits = privately_named; ! another I7 listwriter convenience


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Template Properties
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Property add_to_scope; ! used as in I6 to place component parts in scope
Property article "a"; ! used as in I6 to implement articles
Property capacity 100; ! = I7 "carrying capacity"
Property component_child; ! new in I7: forest structure holding "part of" relation
Property component_parent; ! new in I7
Property component_sibling; ! new in I7
Property description; ! = I7 "description"
Property door_dir; ! used to implement two-sided doors, but holds direction object, not a property
Property door_to; ! used as in I6 to implement two-sided doors
Property found_in; ! used as in I6 to implement two-sided doors and backdrops
Property initial; ! = I7 "initial description"
Property list_together; ! used as in I6 to implement "grouping together" activity
Property map_region; ! new in I7
Property parse_name 0; ! used as in I6 to implement "Understand... as..." grammars
Property plural; ! used as in I6 to implement plural names for duplicate objects
Property regional_found_in; ! new in I7
Property room_index; ! new in I7: storage for route-finding
Property short_name 0; ! = I7 "printed name"
Property vector; ! new in I7: storage for route-finding
Property with_key; ! = I7 "matching key"

Property KD_Count; ! Instance count of the kind of the current object
Property IK1_Count; ! These are instance counts within kinds K1, K2, ...
Property IK2_Count; ! and it is efficient to declare the common ones with Property
Property IK4_Count; ! since this results in a slightly smaller story file
Property IK5_Count;
Property IK6_Count;
Property IK8_Count;

Property IK1_link; ! These are for linked lists used to make searches faster
Property IK2_link; ! and again it's memory-efficient to declare the common ones
Property IK5_link; ! 
Property IK6_link; ! 
Property IK8_link; ! 

Property articles; ! not used by I7, but an interesting hook in the parser
Property grammar; ! not used by I7, but an interesting hook in the parser
Property inside_description; ! not used by I7, but an interesting hook in the locale code
Property short_name_indef 0; ! not used by I7, but an interesting hook in the listmaker


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Loss of Life
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant life = NULL;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Action Count
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant ActionCount = 80;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Fake Actions
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Fake_Action ListMiscellany;
Fake_Action Miscellany;
Fake_Action PluralFound;
Fake_Action TheSame;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Formal Parameters
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Global formal_rv;
Global formal_par0;
Global formal_par1;
Global formal_par2;
Global formal_par3;
Global formal_par4;
Global formal_par5;
Global formal_par6;
Global formal_par7;
Global unicode_temp;

	Constant RUCKSACK_CLASS = K15_player_s_holdall;



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Global Variables
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

! [1]
Global location = InformLibrary; ! does not = I7 "location": see below
Global sline1; Global sline2;

! [2]
Global say__p = 1; Global say__pc = 0; Global say__pc_save = 0;
Global say__n; Global say__comp;
Global los_rv = false;
Global parameter_object; ! = I7 "parameter-object" = I7 "container in question"
Global parameter_value; ! not typesafe in I7
Array deferred_calling_list --> 27;
Global property_to_be_totalled; ! used to implement "total P of..."
Global property_loop_sign; ! $+1$ for increasing order, $-1$ for decreasing
Global suppress_scope_loops;
Global temporary_value; ! can be used anywhere side-effects can't occur

#ifdef TARGET_ZCODE;
Constant BLOCKV_STACK_SIZE = 224;
#ifnot;
Constant BLOCKV_STACK_SIZE = DynamicMemoryAllocation/4;
#endif;

Array blockv_stack --> BLOCKV_STACK_SIZE;
Global I7SFRAME;

Global TEXT_TY_RE_Err = 0;

Array LocalParking --> 64;

! [3]
Global standard_interpreter = 0;
Global undo_flag;

! [4]
Global deadflag = 0;
Global story_complete = 0;
Global resurrect_please = false;

! [5]
Global not_yet_in_play = true; ! set false when first command received
Global turns = 1; ! = I7 "turn count"
Global the_time = NULL; ! = I7 "time of day"
Global time_rate = 1;

Constant NUMBER_SCENES_CREATED = 15;
Constant SCENE_ARRAY_SIZE = (NUMBER_SCENES_CREATED+2);
Array scene_started --> SCENE_ARRAY_SIZE;
Array scene_ended --> SCENE_ARRAY_SIZE;
Array scene_status --> SCENE_ARRAY_SIZE;
Array scene_endings --> SCENE_ARRAY_SIZE;
Array scene_latest_ending --> SCENE_ARRAY_SIZE;

! [6]
Global score; ! = I7 "score"
Global last_score; ! = I7 "last notified score"
Global notify_mode = 1; ! score notification on or off
Global left_hand_status_line = T_SL_Location; ! = I7 "left hand status line"
Global right_hand_status_line = T_SL_Score_Moves; ! = I7 "right hand status line"

! [7]
Global player; ! = I7 "player"
Global real_location; ! = I7 "location"
Global visibility_ceiling; ! highest object in tree visible to player
Global visibility_levels; ! distance in tree to that

Global SACK_OBJECT; ! current player's holdall item in use

! [8]
Global act_requester;
Global actor; ! = I7 "person asked" = I7 "person reaching"
Global actors_location; ! like real_location, but for the actor
Global actor_location; ! = I7 "actor-location"
Global action;
Global meta; ! action is out of world
Global inp1;
Global inp2;
Array  multiple_object --> MATCH_LIST_WORDS; ! multiple-object list (I6 table array)
Global toomany_flag; ! multiple-object list overflowed
Global multiflag; ! multiple-object being processed
Global multiple_object_item; ! item currently being processed in multiple-object list
Global noun; ! = I7 "noun"
Global second; ! = I7 "second noun"
Global keep_silent; ! true if current action is being tried silently
Global etype; ! parser error number if command not recognised
Global trace_actions = 0;

Global untouchable_object;
Global untouchable_silence;
Global touch_persona;

Global special_word; ! dictionary address of first word in "[text]" token
Global consult_from; ! word number of start of "[text]" token
Global consult_words; ! number of words in "[text]" token
Global parsed_number; ! value from any token not an object
Global special_number1; ! first value, if token not an object
Global special_number2; ! second value, if token not an object

Array  parser_results --> 16; ! for parser to write its results in
Global parser_trace = 0; ! normally 0, but 1 to 5 traces parser workings
Global pronoun_word; ! records which pronoun ("it", "them", ...) caused an error
Global pronoun_obj; ! and what object it was thought to refer to

Global players_command = 100; ! = I7 "player's command"
Global matched_text; ! = I7 "matched text"
Global reason_the_action_failed; ! = I7 "reason the action failed"
Global understand_as_mistake_number; ! which form of "Understand... as a mistake"
Global particular_possession; ! = I7 "particular possession"

! [9]
Global parser_action; ! written by the parser for the benefit of GPRs
Global parser_one;
Global parser_two;
Global parameters; ! number of I7 tokens parsed on the current line
Global action_to_be; ! (if the current line were accepted)
Global action_reversed; ! (parameters would be reversed in order)
Global wn; ! word number within "parse" buffer (from 1)
Global num_words; ! number of words in buffer
Global verb_word; ! dictionary address of command verb
Global verb_wordnum; ! word number of command verb

! [10]
Global scope_reason = PARSING_REASON; ! current reason for searching scope
Global scope_token; ! for "scope=Routine" grammar tokens
Global scope_error;
Global scope_stage; ! 1, 2 then 3
Global advance_warning; ! what a later-named thing will be
Global reason_code = NULL; ! for the I6 veneer

Global ats_flag = 0; ! for AddToScope routines
Global ats_hls;

! [11]
Global move_pushing;
Global move_from;
Global move_to;
Global move_by;
Global move_through;

! [12]
#Ifdef DEFAULT_BRIEF_DESCRIPTIONS;
Global lookmode = 1; ! 1 = BRIEF, 2 = VERBOSE, 3 = SUPERBRIEF
#Endif;
#Ifdef DEFAULT_VERBOSE_DESCRIPTIONS; 
Global lookmode = 2; ! 1 = BRIEF, 2 = VERBOSE, 3 = SUPERBRIEF
#Endif;
#Ifdef DEFAULT_SUPERBRIEF_DESCRIPTIONS; 
Global lookmode = 3; ! 1 = BRIEF, 2 = VERBOSE, 3 = SUPERBRIEF
#Endif;
#Ifndef lookmode;
Global lookmode = 2; ! 1 = BRIEF, 2 = VERBOSE, 3 = SUPERBRIEF
#Endif;
Global c_style; ! current list-writer style
Global c_depth; ! current recursion depth
Global c_iterator; ! current iteration function
Global lt_value = EMPTY_TEXT_VALUE; ! common value of list_together
Global listing_together; ! object number of one member of a group being listed together
Global listing_size; ! size of such a group
Global c_margin; ! current level of indentation printed by WriteListFrom()
Global inventory_stage = 1; ! 1 or 2 according to the context in which list_together uses
Global prior_named_noun; ! for adaptive text generation
Global prior_named_list; ! ditto: length of list of items
Global prior_named_list_gender; ! ditto: common gender of list of items, or -1
Global story_tense = 1; ! ditto: present tense
Global story_viewpoint = 2; ! ditto: second person singular

! [13]
Global clr_fg = 1; ! foreground colour
Global clr_bg = 1; ! background colour
Global clr_fgstatus = 1; ! foreground colour of statusline
Global clr_bgstatus = 1; ! background colour of statusline
Global clr_on; ! has colour been enabled by the player?
Global statuswin_current; ! if writing to top window

! [14]
Global statuswin_cursize = 0;
Global statuswin_size = 1;

! [16]
Global debug_flag = 0;
Global debug_rules = 0;
Global debug_scenes = 0;
Global debug_rule_nesting;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: VM-Specific Code
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#Ifdef TARGET_GLULX;

! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Summary
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Variables and Arrays
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Array gg_event --> 4;
Array gg_arguments buffer 28;
Global gg_mainwin = 0;
Global gg_statuswin = 0;
Global gg_quotewin = 0;
Global gg_scriptfref = 0;
Global gg_scriptstr = 0;
Global gg_savestr = 0;
Global gg_commandstr = 0;
Global gg_command_reading = 0;      ! true if gg_commandstr is being replayed
Global gg_foregroundchan = 0;
Global gg_backgroundchan = 0;

Constant GLK_NULL 0;

Constant INPUT_BUFFER_LEN = 260;    ! No extra byte necessary
Constant MAX_BUFFER_WORDS = 20;
Constant PARSE_BUFFER_LEN = 61;

Array  buffer    buffer INPUT_BUFFER_LEN;
Array  buffer2   buffer INPUT_BUFFER_LEN;
Array  buffer3   buffer INPUT_BUFFER_LEN;
Array  parse     --> PARSE_BUFFER_LEN;
Array  parse2    --> PARSE_BUFFER_LEN;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Infglk
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

! infglk.h -- auto-generated by parse_dispatch.py.
! Generated for Glk API version 0.7.4

Constant evtype_Arrange = 5;
Constant evtype_CharInput = 2;
Constant evtype_Hyperlink = 8;
Constant evtype_LineInput = 3;
Constant evtype_MouseInput = 4;
Constant evtype_None = 0;
Constant evtype_Redraw = 6;
Constant evtype_SoundNotify = 7;
Constant evtype_Timer = 1;
Constant evtype_VolumeNotify = 9;
Constant filemode_Read = 2;
Constant filemode_ReadWrite = 3;
Constant filemode_Write = 1;
Constant filemode_WriteAppend = 5;
Constant fileusage_BinaryMode = 0;
Constant fileusage_Data = 0;
Constant fileusage_InputRecord = 3;
Constant fileusage_SavedGame = 1;
Constant fileusage_TextMode = 256;
Constant fileusage_Transcript = 2;
Constant fileusage_TypeMask = 15;
Constant gestalt_CharInput = 1;
Constant gestalt_CharOutput = 3;
Constant gestalt_CharOutput_ApproxPrint = 1;
Constant gestalt_CharOutput_CannotPrint = 0;
Constant gestalt_CharOutput_ExactPrint = 2;
Constant gestalt_DateTime = 20;
Constant gestalt_DrawImage = 7;
Constant gestalt_Graphics = 6;
Constant gestalt_GraphicsCharInput = 23;
Constant gestalt_GraphicsTransparency = 14;
Constant gestalt_HyperlinkInput = 12;
Constant gestalt_Hyperlinks = 11;
Constant gestalt_LineInput = 2;
Constant gestalt_LineInputEcho = 17;
Constant gestalt_LineTerminatorKey = 19;
Constant gestalt_LineTerminators = 18;
Constant gestalt_MouseInput = 4;
Constant gestalt_ResourceStream = 22;
Constant gestalt_Sound = 8;
Constant gestalt_Sound2 = 21;
Constant gestalt_SoundMusic = 13;
Constant gestalt_SoundNotify = 10;
Constant gestalt_SoundVolume = 9;
Constant gestalt_Timer = 5;
Constant gestalt_Unicode = 15;
Constant gestalt_UnicodeNorm = 16;
Constant gestalt_Version = 0;
Constant imagealign_InlineCenter = 3;
Constant imagealign_InlineDown = 2;
Constant imagealign_MarginLeft = 4;
Constant imagealign_MarginRight = 5;
Constant imagealign_InlineUp = 1;
Constant keycode_Delete = 4294967289;
Constant keycode_Down = 4294967291;
Constant keycode_End = 4294967283;
Constant keycode_Escape = 4294967288;
Constant keycode_Func1 = 4294967279;
Constant keycode_Func10 = 4294967270;
Constant keycode_Func11 = 4294967269;
Constant keycode_Func12 = 4294967268;
Constant keycode_Func2 = 4294967278;
Constant keycode_Func3 = 4294967277;
Constant keycode_Func4 = 4294967276;
Constant keycode_Func5 = 4294967275;
Constant keycode_Func6 = 4294967274;
Constant keycode_Func7 = 4294967273;
Constant keycode_Func8 = 4294967272;
Constant keycode_Func9 = 4294967271;
Constant keycode_Home = 4294967284;
Constant keycode_Left = 4294967294;
Constant keycode_MAXVAL = 28;
Constant keycode_PageDown = 4294967285;
Constant keycode_PageUp = 4294967286;
Constant keycode_Return = 4294967290;
Constant keycode_Right = 4294967293;
Constant keycode_Tab = 4294967287;
Constant keycode_Unknown = 4294967295;
Constant keycode_Up = 4294967292;
Constant seekmode_Current = 1;
Constant seekmode_End = 2;
Constant seekmode_Start = 0;
Constant style_Alert = 5;
Constant style_BlockQuote = 7;
Constant style_Emphasized = 1;
Constant style_Header = 3;
Constant style_Input = 8;
Constant style_NUMSTYLES = 11;
Constant style_Normal = 0;
Constant style_Note = 6;
Constant style_Preformatted = 2;
Constant style_Subheader = 4;
Constant style_User1 = 9;
Constant style_User2 = 10;
Constant stylehint_BackColor = 8;
Constant stylehint_Indentation = 0;
Constant stylehint_Justification = 2;
Constant stylehint_NUMHINTS = 10;
Constant stylehint_Oblique = 5;
Constant stylehint_ParaIndentation = 1;
Constant stylehint_Proportional = 6;
Constant stylehint_ReverseColor = 9;
Constant stylehint_Size = 3;
Constant stylehint_TextColor = 7;
Constant stylehint_Weight = 4;
Constant stylehint_just_Centered = 2;
Constant stylehint_just_LeftFlush = 0;
Constant stylehint_just_LeftRight = 1;
Constant stylehint_just_RightFlush = 3;
Constant winmethod_Above = 2;
Constant winmethod_Below = 3;
Constant winmethod_Border = 0;
Constant winmethod_BorderMask = 256;
Constant winmethod_DirMask = 15;
Constant winmethod_DivisionMask = 240;
Constant winmethod_Fixed = 16;
Constant winmethod_Left = 0;
Constant winmethod_NoBorder = 256;
Constant winmethod_Proportional = 32;
Constant winmethod_Right = 1;
Constant wintype_AllTypes = 0;
Constant wintype_Blank = 2;
Constant wintype_Graphics = 5;
Constant wintype_Pair = 1;
Constant wintype_TextBuffer = 3;
Constant wintype_TextGrid = 4;

[ glk_exit _vararg_count;
  ! glk_exit()
  @glk 1 _vararg_count 0;
  return 0;
];

[ glk_tick _vararg_count;
  ! glk_tick()
  @glk 3 _vararg_count 0;
  return 0;
];

[ glk_gestalt _vararg_count ret;
  ! glk_gestalt(uint, uint) => uint
  @glk 4 _vararg_count ret;
  return ret;
];

[ glk_gestalt_ext _vararg_count ret;
  ! glk_gestalt_ext(uint, uint, uintarray, arraylen) => uint
  @glk 5 _vararg_count ret;
  return ret;
];

[ glk_window_iterate _vararg_count ret;
  ! glk_window_iterate(window, &uint) => window
  @glk 32 _vararg_count ret;
  return ret;
];

[ glk_window_get_rock _vararg_count ret;
  ! glk_window_get_rock(window) => uint
  @glk 33 _vararg_count ret;
  return ret;
];

[ glk_window_get_root _vararg_count ret;
  ! glk_window_get_root() => window
  @glk 34 _vararg_count ret;
  return ret;
];

[ glk_window_open _vararg_count ret;
  ! glk_window_open(window, uint, uint, uint, uint) => window
  @glk 35 _vararg_count ret;
  return ret;
];

[ glk_window_close _vararg_count;
  ! glk_window_close(window, &{uint, uint})
  @glk 36 _vararg_count 0;
  return 0;
];

[ glk_window_get_size _vararg_count;
  ! glk_window_get_size(window, &uint, &uint)
  @glk 37 _vararg_count 0;
  return 0;
];

[ glk_window_set_arrangement _vararg_count;
  ! glk_window_set_arrangement(window, uint, uint, window)
  @glk 38 _vararg_count 0;
  return 0;
];

[ glk_window_get_arrangement _vararg_count;
  ! glk_window_get_arrangement(window, &uint, &uint, &window)
  @glk 39 _vararg_count 0;
  return 0;
];

[ glk_window_get_type _vararg_count ret;
  ! glk_window_get_type(window) => uint
  @glk 40 _vararg_count ret;
  return ret;
];

[ glk_window_get_parent _vararg_count ret;
  ! glk_window_get_parent(window) => window
  @glk 41 _vararg_count ret;
  return ret;
];

[ glk_window_clear _vararg_count;
  ! glk_window_clear(window)
  @glk 42 _vararg_count 0;
  return 0;
];

[ glk_window_move_cursor _vararg_count;
  ! glk_window_move_cursor(window, uint, uint)
  @glk 43 _vararg_count 0;
  return 0;
];

[ glk_window_get_stream _vararg_count ret;
  ! glk_window_get_stream(window) => stream
  @glk 44 _vararg_count ret;
  return ret;
];

[ glk_window_set_echo_stream _vararg_count;
  ! glk_window_set_echo_stream(window, stream)
  @glk 45 _vararg_count 0;
  return 0;
];

[ glk_window_get_echo_stream _vararg_count ret;
  ! glk_window_get_echo_stream(window) => stream
  @glk 46 _vararg_count ret;
  return ret;
];

[ glk_set_window _vararg_count;
  ! glk_set_window(window)
  @glk 47 _vararg_count 0;
  return 0;
];

[ glk_window_get_sibling _vararg_count ret;
  ! glk_window_get_sibling(window) => window
  @glk 48 _vararg_count ret;
  return ret;
];

[ glk_stream_iterate _vararg_count ret;
  ! glk_stream_iterate(stream, &uint) => stream
  @glk 64 _vararg_count ret;
  return ret;
];

[ glk_stream_get_rock _vararg_count ret;
  ! glk_stream_get_rock(stream) => uint
  @glk 65 _vararg_count ret;
  return ret;
];

[ glk_stream_open_file _vararg_count ret;
  ! glk_stream_open_file(fileref, uint, uint) => stream
  @glk 66 _vararg_count ret;
  return ret;
];

[ glk_stream_open_memory _vararg_count ret;
  ! glk_stream_open_memory(nativechararray, arraylen, uint, uint) => stream
  @glk 67 _vararg_count ret;
  return ret;
];

[ glk_stream_close _vararg_count;
  ! glk_stream_close(stream, &{uint, uint})
  @glk 68 _vararg_count 0;
  return 0;
];

[ glk_stream_set_position _vararg_count;
  ! glk_stream_set_position(stream, int, uint)
  @glk 69 _vararg_count 0;
  return 0;
];

[ glk_stream_get_position _vararg_count ret;
  ! glk_stream_get_position(stream) => uint
  @glk 70 _vararg_count ret;
  return ret;
];

[ glk_stream_set_current _vararg_count;
  ! glk_stream_set_current(stream)
  @glk 71 _vararg_count 0;
  return 0;
];

[ glk_stream_get_current _vararg_count ret;
  ! glk_stream_get_current() => stream
  @glk 72 _vararg_count ret;
  return ret;
];

[ glk_stream_open_resource _vararg_count ret;
  ! glk_stream_open_resource(uint, uint) => stream
  @glk 73 _vararg_count ret;
  return ret;
];

[ glk_fileref_create_temp _vararg_count ret;
  ! glk_fileref_create_temp(uint, uint) => fileref
  @glk 96 _vararg_count ret;
  return ret;
];

[ glk_fileref_create_by_name _vararg_count ret;
  ! glk_fileref_create_by_name(uint, string, uint) => fileref
  @glk 97 _vararg_count ret;
  return ret;
];

[ glk_fileref_create_by_prompt _vararg_count ret;
  ! glk_fileref_create_by_prompt(uint, uint, uint) => fileref
  @glk 98 _vararg_count ret;
  return ret;
];

[ glk_fileref_destroy _vararg_count;
  ! glk_fileref_destroy(fileref)
  @glk 99 _vararg_count 0;
  return 0;
];

[ glk_fileref_iterate _vararg_count ret;
  ! glk_fileref_iterate(fileref, &uint) => fileref
  @glk 100 _vararg_count ret;
  return ret;
];

[ glk_fileref_get_rock _vararg_count ret;
  ! glk_fileref_get_rock(fileref) => uint
  @glk 101 _vararg_count ret;
  return ret;
];

[ glk_fileref_delete_file _vararg_count;
  ! glk_fileref_delete_file(fileref)
  @glk 102 _vararg_count 0;
  return 0;
];

[ glk_fileref_does_file_exist _vararg_count ret;
  ! glk_fileref_does_file_exist(fileref) => uint
  @glk 103 _vararg_count ret;
  return ret;
];

[ glk_fileref_create_from_fileref _vararg_count ret;
  ! glk_fileref_create_from_fileref(uint, fileref, uint) => fileref
  @glk 104 _vararg_count ret;
  return ret;
];

[ glk_put_char _vararg_count;
  ! glk_put_char(uchar)
  @glk 128 _vararg_count 0;
  return 0;
];

[ glk_put_char_stream _vararg_count;
  ! glk_put_char_stream(stream, uchar)
  @glk 129 _vararg_count 0;
  return 0;
];

[ glk_put_string _vararg_count;
  ! glk_put_string(string)
  @glk 130 _vararg_count 0;
  return 0;
];

[ glk_put_string_stream _vararg_count;
  ! glk_put_string_stream(stream, string)
  @glk 131 _vararg_count 0;
  return 0;
];

[ glk_put_buffer _vararg_count;
  ! glk_put_buffer(nativechararray, arraylen)
  @glk 132 _vararg_count 0;
  return 0;
];

[ glk_put_buffer_stream _vararg_count;
  ! glk_put_buffer_stream(stream, nativechararray, arraylen)
  @glk 133 _vararg_count 0;
  return 0;
];

[ glk_set_style _vararg_count;
  ! glk_set_style(uint)
  @glk 134 _vararg_count 0;
  return 0;
];

[ glk_set_style_stream _vararg_count;
  ! glk_set_style_stream(stream, uint)
  @glk 135 _vararg_count 0;
  return 0;
];

[ glk_get_char_stream _vararg_count ret;
  ! glk_get_char_stream(stream) => int
  @glk 144 _vararg_count ret;
  return ret;
];

[ glk_get_line_stream _vararg_count ret;
  ! glk_get_line_stream(stream, nativechararray, arraylen) => uint
  @glk 145 _vararg_count ret;
  return ret;
];

[ glk_get_buffer_stream _vararg_count ret;
  ! glk_get_buffer_stream(stream, nativechararray, arraylen) => uint
  @glk 146 _vararg_count ret;
  return ret;
];

[ glk_char_to_lower _vararg_count ret;
  ! glk_char_to_lower(uchar) => uchar
  @glk 160 _vararg_count ret;
  return ret;
];

[ glk_char_to_upper _vararg_count ret;
  ! glk_char_to_upper(uchar) => uchar
  @glk 161 _vararg_count ret;
  return ret;
];

[ glk_stylehint_set _vararg_count;
  ! glk_stylehint_set(uint, uint, uint, int)
  @glk 176 _vararg_count 0;
  return 0;
];

[ glk_stylehint_clear _vararg_count;
  ! glk_stylehint_clear(uint, uint, uint)
  @glk 177 _vararg_count 0;
  return 0;
];

[ glk_style_distinguish _vararg_count ret;
  ! glk_style_distinguish(window, uint, uint) => uint
  @glk 178 _vararg_count ret;
  return ret;
];

[ glk_style_measure _vararg_count ret;
  ! glk_style_measure(window, uint, uint, &uint) => uint
  @glk 179 _vararg_count ret;
  return ret;
];

[ glk_select _vararg_count;
  ! glk_select(&{uint, window, uint, uint})
  @glk 192 _vararg_count 0;
  return 0;
];

[ glk_select_poll _vararg_count;
  ! glk_select_poll(&{uint, window, uint, uint})
  @glk 193 _vararg_count 0;
  return 0;
];

[ glk_request_line_event _vararg_count;
  ! glk_request_line_event(window, nativechararray, arraylen, uint)
  @glk 208 _vararg_count 0;
  return 0;
];

[ glk_cancel_line_event _vararg_count;
  ! glk_cancel_line_event(window, &{uint, window, uint, uint})
  @glk 209 _vararg_count 0;
  return 0;
];

[ glk_request_char_event _vararg_count;
  ! glk_request_char_event(window)
  @glk 210 _vararg_count 0;
  return 0;
];

[ glk_cancel_char_event _vararg_count;
  ! glk_cancel_char_event(window)
  @glk 211 _vararg_count 0;
  return 0;
];

[ glk_request_mouse_event _vararg_count;
  ! glk_request_mouse_event(window)
  @glk 212 _vararg_count 0;
  return 0;
];

[ glk_cancel_mouse_event _vararg_count;
  ! glk_cancel_mouse_event(window)
  @glk 213 _vararg_count 0;
  return 0;
];

[ glk_request_timer_events _vararg_count;
  ! glk_request_timer_events(uint)
  @glk 214 _vararg_count 0;
  return 0;
];

[ glk_image_get_info _vararg_count ret;
  ! glk_image_get_info(uint, &uint, &uint) => uint
  @glk 224 _vararg_count ret;
  return ret;
];

[ glk_image_draw _vararg_count ret;
  ! glk_image_draw(window, uint, int, int) => uint
  @glk 225 _vararg_count ret;
  return ret;
];

[ glk_image_draw_scaled _vararg_count ret;
  ! glk_image_draw_scaled(window, uint, int, int, uint, uint) => uint
  @glk 226 _vararg_count ret;
  return ret;
];

[ glk_window_flow_break _vararg_count;
  ! glk_window_flow_break(window)
  @glk 232 _vararg_count 0;
  return 0;
];

[ glk_window_erase_rect _vararg_count;
  ! glk_window_erase_rect(window, int, int, uint, uint)
  @glk 233 _vararg_count 0;
  return 0;
];

[ glk_window_fill_rect _vararg_count;
  ! glk_window_fill_rect(window, uint, int, int, uint, uint)
  @glk 234 _vararg_count 0;
  return 0;
];

[ glk_window_set_background_color _vararg_count;
  ! glk_window_set_background_color(window, uint)
  @glk 235 _vararg_count 0;
  return 0;
];

[ glk_schannel_iterate _vararg_count ret;
  ! glk_schannel_iterate(schannel, &uint) => schannel
  @glk 240 _vararg_count ret;
  return ret;
];

[ glk_schannel_get_rock _vararg_count ret;
  ! glk_schannel_get_rock(schannel) => uint
  @glk 241 _vararg_count ret;
  return ret;
];

[ glk_schannel_create _vararg_count ret;
  ! glk_schannel_create(uint) => schannel
  @glk 242 _vararg_count ret;
  return ret;
];

[ glk_schannel_destroy _vararg_count;
  ! glk_schannel_destroy(schannel)
  @glk 243 _vararg_count 0;
  return 0;
];

[ glk_schannel_create_ext _vararg_count ret;
  ! glk_schannel_create_ext(uint, uint) => schannel
  @glk 244 _vararg_count ret;
  return ret;
];

[ glk_schannel_play_multi _vararg_count ret;
  ! glk_schannel_play_multi(schannelarray, arraylen, uintarray, arraylen, uint) => uint
  @glk 247 _vararg_count ret;
  return ret;
];

[ glk_schannel_play _vararg_count ret;
  ! glk_schannel_play(schannel, uint) => uint
  @glk 248 _vararg_count ret;
  return ret;
];

[ glk_schannel_play_ext _vararg_count ret;
  ! glk_schannel_play_ext(schannel, uint, uint, uint) => uint
  @glk 249 _vararg_count ret;
  return ret;
];

[ glk_schannel_stop _vararg_count;
  ! glk_schannel_stop(schannel)
  @glk 250 _vararg_count 0;
  return 0;
];

[ glk_schannel_set_volume _vararg_count;
  ! glk_schannel_set_volume(schannel, uint)
  @glk 251 _vararg_count 0;
  return 0;
];

[ glk_sound_load_hint _vararg_count;
  ! glk_sound_load_hint(uint, uint)
  @glk 252 _vararg_count 0;
  return 0;
];

[ glk_schannel_set_volume_ext _vararg_count;
  ! glk_schannel_set_volume_ext(schannel, uint, uint, uint)
  @glk 253 _vararg_count 0;
  return 0;
];

[ glk_schannel_pause _vararg_count;
  ! glk_schannel_pause(schannel)
  @glk 254 _vararg_count 0;
  return 0;
];

[ glk_schannel_unpause _vararg_count;
  ! glk_schannel_unpause(schannel)
  @glk 255 _vararg_count 0;
  return 0;
];

[ glk_set_hyperlink _vararg_count;
  ! glk_set_hyperlink(uint)
  @glk 256 _vararg_count 0;
  return 0;
];

[ glk_set_hyperlink_stream _vararg_count;
  ! glk_set_hyperlink_stream(stream, uint)
  @glk 257 _vararg_count 0;
  return 0;
];

[ glk_request_hyperlink_event _vararg_count;
  ! glk_request_hyperlink_event(window)
  @glk 258 _vararg_count 0;
  return 0;
];

[ glk_cancel_hyperlink_event _vararg_count;
  ! glk_cancel_hyperlink_event(window)
  @glk 259 _vararg_count 0;
  return 0;
];

[ glk_buffer_to_lower_case_uni _vararg_count ret;
  ! glk_buffer_to_lower_case_uni(uintarray, arraylen, uint) => uint
  @glk 288 _vararg_count ret;
  return ret;
];

[ glk_buffer_to_upper_case_uni _vararg_count ret;
  ! glk_buffer_to_upper_case_uni(uintarray, arraylen, uint) => uint
  @glk 289 _vararg_count ret;
  return ret;
];

[ glk_buffer_to_title_case_uni _vararg_count ret;
  ! glk_buffer_to_title_case_uni(uintarray, arraylen, uint, uint) => uint
  @glk 290 _vararg_count ret;
  return ret;
];

[ glk_buffer_canon_decompose_uni _vararg_count ret;
  ! glk_buffer_canon_decompose_uni(uintarray, arraylen, uint) => uint
  @glk 291 _vararg_count ret;
  return ret;
];

[ glk_buffer_canon_normalize_uni _vararg_count ret;
  ! glk_buffer_canon_normalize_uni(uintarray, arraylen, uint) => uint
  @glk 292 _vararg_count ret;
  return ret;
];

[ glk_put_char_uni _vararg_count;
  ! glk_put_char_uni(uint)
  @glk 296 _vararg_count 0;
  return 0;
];

[ glk_put_string_uni _vararg_count;
  ! glk_put_string_uni(unicode)
  @glk 297 _vararg_count 0;
  return 0;
];

[ glk_put_buffer_uni _vararg_count;
  ! glk_put_buffer_uni(uintarray, arraylen)
  @glk 298 _vararg_count 0;
  return 0;
];

[ glk_put_char_stream_uni _vararg_count;
  ! glk_put_char_stream_uni(stream, uint)
  @glk 299 _vararg_count 0;
  return 0;
];

[ glk_put_string_stream_uni _vararg_count;
  ! glk_put_string_stream_uni(stream, unicode)
  @glk 300 _vararg_count 0;
  return 0;
];

[ glk_put_buffer_stream_uni _vararg_count;
  ! glk_put_buffer_stream_uni(stream, uintarray, arraylen)
  @glk 301 _vararg_count 0;
  return 0;
];

[ glk_get_char_stream_uni _vararg_count ret;
  ! glk_get_char_stream_uni(stream) => int
  @glk 304 _vararg_count ret;
  return ret;
];

[ glk_get_buffer_stream_uni _vararg_count ret;
  ! glk_get_buffer_stream_uni(stream, uintarray, arraylen) => uint
  @glk 305 _vararg_count ret;
  return ret;
];

[ glk_get_line_stream_uni _vararg_count ret;
  ! glk_get_line_stream_uni(stream, uintarray, arraylen) => uint
  @glk 306 _vararg_count ret;
  return ret;
];

[ glk_stream_open_file_uni _vararg_count ret;
  ! glk_stream_open_file_uni(fileref, uint, uint) => stream
  @glk 312 _vararg_count ret;
  return ret;
];

[ glk_stream_open_memory_uni _vararg_count ret;
  ! glk_stream_open_memory_uni(uintarray, arraylen, uint, uint) => stream
  @glk 313 _vararg_count ret;
  return ret;
];

[ glk_stream_open_resource_uni _vararg_count ret;
  ! glk_stream_open_resource_uni(uint, uint) => stream
  @glk 314 _vararg_count ret;
  return ret;
];

[ glk_request_char_event_uni _vararg_count;
  ! glk_request_char_event_uni(window)
  @glk 320 _vararg_count 0;
  return 0;
];

[ glk_request_line_event_uni _vararg_count;
  ! glk_request_line_event_uni(window, uintarray, arraylen, uint)
  @glk 321 _vararg_count 0;
  return 0;
];

[ glk_set_echo_line_event _vararg_count;
  ! glk_set_echo_line_event(window, uint)
  @glk 336 _vararg_count 0;
  return 0;
];

[ glk_set_terminators_line_event _vararg_count;
  ! glk_set_terminators_line_event(window, uintarray, arraylen)
  @glk 337 _vararg_count 0;
  return 0;
];

[ glk_current_time _vararg_count;
  ! glk_current_time(&{int, uint, int})
  @glk 352 _vararg_count 0;
  return 0;
];

[ glk_current_simple_time _vararg_count ret;
  ! glk_current_simple_time(uint) => int
  @glk 353 _vararg_count ret;
  return ret;
];

[ glk_time_to_date_utc _vararg_count;
  ! glk_time_to_date_utc(&{int, uint, int}, &{int, int, int, int, int, int, int, int})
  @glk 360 _vararg_count 0;
  return 0;
];

[ glk_time_to_date_local _vararg_count;
  ! glk_time_to_date_local(&{int, uint, int}, &{int, int, int, int, int, int, int, int})
  @glk 361 _vararg_count 0;
  return 0;
];

[ glk_simple_time_to_date_utc _vararg_count;
  ! glk_simple_time_to_date_utc(int, uint, &{int, int, int, int, int, int, int, int})
  @glk 362 _vararg_count 0;
  return 0;
];

[ glk_simple_time_to_date_local _vararg_count;
  ! glk_simple_time_to_date_local(int, uint, &{int, int, int, int, int, int, int, int})
  @glk 363 _vararg_count 0;
  return 0;
];

[ glk_date_to_time_utc _vararg_count;
  ! glk_date_to_time_utc(&{int, int, int, int, int, int, int, int}, &{int, uint, int})
  @glk 364 _vararg_count 0;
  return 0;
];

[ glk_date_to_time_local _vararg_count;
  ! glk_date_to_time_local(&{int, int, int, int, int, int, int, int}, &{int, uint, int})
  @glk 365 _vararg_count 0;
  return 0;
];

[ glk_date_to_simple_time_utc _vararg_count ret;
  ! glk_date_to_simple_time_utc(&{int, int, int, int, int, int, int, int}, uint) => int
  @glk 366 _vararg_count ret;
  return ret;
];

[ glk_date_to_simple_time_local _vararg_count ret;
  ! glk_date_to_simple_time_local(&{int, int, int, int, int, int, int, int}, uint) => int
  @glk 367 _vararg_count ret;
  return ret;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Rocks
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant GG_MAINWIN_ROCK        201;
Constant GG_STATUSWIN_ROCK      202;
Constant GG_QUOTEWIN_ROCK       203;
Constant GG_SAVESTR_ROCK        301;
Constant GG_SCRIPTSTR_ROCK      302;
Constant GG_COMMANDWSTR_ROCK    303;
Constant GG_COMMANDRSTR_ROCK    304;
Constant GG_SCRIPTFREF_ROCK     401;
Constant GG_FOREGROUNDCHAN_ROCK 410;
Constant GG_BACKGROUNDCHAN_ROCK 411;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Stubs
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#Stub HandleGlkEvent    2;
#Stub IdentifyGlkObject 4;
#Stub InitGlkWindow     1;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Starting Up
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_PreInitialise res;
    @gestalt 4 2 res; ! Test if this interpreter has Glk...
    if (res == 0) quit; ! ...without which there would be nothing we could do

	unicode_gestalt_ok = false;
	if (glk_gestalt(gestalt_Unicode, 0))
		unicode_gestalt_ok = true;

    ! Set the VM's I/O system to be Glk.
    @setiosys 2 0;
];

[ VM_Initialise res sty i;
    @gestalt 4 2 res; ! Test if this interpreter has Glk...
    if (res == 0) quit; ! ...without which there would be nothing we could do

    ! First, we must go through all the Glk objects that exist, and see
    ! if we created any of them. One might think this strange, since the
    ! program has just started running, but remember that the player might
    ! have just typed "restart".

    GGRecoverObjects();

	! Sound channel initialisation, and RNG fixing, must be done now rather
	! than later in case InitGlkWindow() returns a non-zero value.

	if (glk_gestalt(gestalt_Sound, 0)) {
		if (gg_foregroundchan == 0)
			gg_foregroundchan = glk_schannel_create(GG_FOREGROUNDCHAN_ROCK);
		if (gg_backgroundchan == 0)
			gg_backgroundchan = glk_schannel_create(GG_BACKGROUNDCHAN_ROCK);
	}

	#ifdef FIX_RNG;
	@random 10000 i;
	i = -i-2000;
	print "[Random number generator seed is ", i, "]^";
	@setrandom i;
	#endif; ! FIX_RNG

    res = InitGlkWindow(0);
    if (res ~= 0) return;

    ! Now, gg_mainwin and gg_storywin might already be set. If not, set them.

    if (gg_mainwin == 0) {
        ! Open the story window.
        res = InitGlkWindow(GG_MAINWIN_ROCK);
        if (res == 0) {
        	! Left-justify the header style
			glk_stylehint_set(wintype_TextBuffer, style_Header, stylehint_Justification, 0);
			! Try to make emphasized type in italics and not boldface
			glk_stylehint_set(wintype_TextBuffer, style_Emphasized, stylehint_Weight, 0);
			glk_stylehint_set(wintype_TextBuffer, style_Emphasized, stylehint_Oblique, 1);
            gg_mainwin = glk_window_open(0, 0, 0, wintype_TextBuffer, GG_MAINWIN_ROCK);
		}
        if (gg_mainwin == 0) quit; ! If we can't even open one window, give in
    } else {
        ! There was already a story window. We should erase it.
        glk_window_clear(gg_mainwin);
    }

    if (gg_statuswin == 0) {
        res = InitGlkWindow(GG_STATUSWIN_ROCK);
        if (res == 0) {
            statuswin_cursize = statuswin_size;
			for (sty=0: sty<style_NUMSTYLES: sty++)
				glk_stylehint_set(wintype_TextGrid, sty, stylehint_ReverseColor, 1);
            gg_statuswin =
            	glk_window_open(gg_mainwin, winmethod_Fixed + winmethod_Above,
            		statuswin_cursize, wintype_TextGrid, GG_STATUSWIN_ROCK);
        }
    }
    ! It's possible that the status window couldn't be opened, in which case
    ! gg_statuswin is now zero. We must allow for that later on.

    glk_set_window(gg_mainwin);

    InitGlkWindow(1);
];

[ GGRecoverObjects id;
    ! If GGRecoverObjects() has been called, all these stored IDs are
    ! invalid, so we start by clearing them all out.
    ! (In fact, after a restoreundo, some of them may still be good.
    ! For simplicity, though, we assume the general case.)
    gg_mainwin = 0;
    gg_statuswin = 0;
    gg_quotewin = 0;
    gg_scriptfref = 0;
    gg_scriptstr = 0;
    gg_savestr = 0;
    statuswin_cursize = 0;
    gg_foregroundchan = 0;
    gg_backgroundchan = 0;
    #Ifdef DEBUG;
    gg_commandstr = 0;
    gg_command_reading = false;
    #Endif; ! DEBUG
    ! Also tell the game to clear its object references.
    IdentifyGlkObject(0);

    id = glk_stream_iterate(0, gg_arguments);
    while (id) {
        switch (gg_arguments-->0) {
            GG_SAVESTR_ROCK: gg_savestr = id;
            GG_SCRIPTSTR_ROCK: gg_scriptstr = id;
            #Ifdef DEBUG;
            GG_COMMANDWSTR_ROCK: gg_commandstr = id;
                                 gg_command_reading = false;
            GG_COMMANDRSTR_ROCK: gg_commandstr = id;
                                 gg_command_reading = true;
            #Endif; ! DEBUG
            default: IdentifyGlkObject(1, 1, id, gg_arguments-->0);
        }
        id = glk_stream_iterate(id, gg_arguments);
    }

    id = glk_window_iterate(0, gg_arguments);
    while (id) {
        switch (gg_arguments-->0) {
            GG_MAINWIN_ROCK: gg_mainwin = id;
            GG_STATUSWIN_ROCK: gg_statuswin = id;
            GG_QUOTEWIN_ROCK: gg_quotewin = id;
            default: IdentifyGlkObject(1, 0, id, gg_arguments-->0);
        }
        id = glk_window_iterate(id, gg_arguments);
    }

    id = glk_fileref_iterate(0, gg_arguments);
    while (id) {
        switch (gg_arguments-->0) {
            GG_SCRIPTFREF_ROCK: gg_scriptfref = id;
            default: IdentifyGlkObject(1, 2, id, gg_arguments-->0);
        }
        id = glk_fileref_iterate(id, gg_arguments);
    }

	if (glk_gestalt(gestalt_Sound, 0)) {
		id = glk_schannel_iterate(0, gg_arguments);
		while (id) {
			switch (gg_arguments-->0) {
				GG_FOREGROUNDCHAN_ROCK: gg_foregroundchan = id;
				GG_BACKGROUNDCHAN_ROCK: gg_backgroundchan = id;
			}
			id = glk_schannel_iterate(id, gg_arguments);
		}
		if (gg_foregroundchan ~= 0) { glk_schannel_stop(gg_foregroundchan); }
		if (gg_backgroundchan ~= 0) { glk_schannel_stop(gg_backgroundchan); }
	}

    ! Tell the game to tie up any loose ends.
    IdentifyGlkObject(2);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Enable Acceleration
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ENABLE_GLULX_ACCEL_R addr res;
	@gestalt 9 0 res;
	if (res == 0) return;
	addr = #classes_table;
	@accelparam 0 addr;
	@accelparam 1 INDIV_PROP_START;
	@accelparam 2 Class;
	@accelparam 3 Object;
	@accelparam 4 Routine;
	@accelparam 5 String;
	addr = #globals_array + WORDSIZE * #g$self;
	@accelparam 6 addr;
	@accelparam 7 NUM_ATTR_BYTES;
	addr = #cpv__start;
	@accelparam 8 addr;
	@accelfunc 1 Z__Region;
	@accelfunc 2 CP__Tab;
	@accelfunc 3 RA__Pr;
	@accelfunc 4 RL__Pr;
	@accelfunc 5 OC__Cl;
	@accelfunc 6 RV__Pr;
	@accelfunc 7 OP__Pr;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Release Number
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_Describe_Release i;
	print "Release ";
	@aloads ROM_GAMERELEASE 0 i;
	print i;
	print " / Serial number ";
	for (i=0 : i<6 : i++) print (char) ROM_GAMESERIAL->i;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Keyboard Input
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_KeyChar win nostat done res ix jx ch;
    jx = ch; ! squash compiler warnings
    if (win == 0) win = gg_mainwin;
    if (gg_commandstr ~= 0 && gg_command_reading ~= false) {
        done = glk_get_line_stream(gg_commandstr, gg_arguments, 31);
        if (done == 0) {
            glk_stream_close(gg_commandstr, 0);
            gg_commandstr = 0;
            gg_command_reading = false;
            ! fall through to normal user input.
        } else {
            ! Trim the trailing newline
            if (gg_arguments->(done-1) == 10) done = done-1;
            res = gg_arguments->0;
            if (res == '\') {
                res = 0;
                for (ix=1 : ix<done : ix++) {
                    ch = gg_arguments->ix;
                    if (ch >= '0' && ch <= '9') {
                        @shiftl res 4 res;
                        res = res + (ch-'0');
                    } else if (ch >= 'a' && ch <= 'f') {
                        @shiftl res 4 res;
                        res = res + (ch+10-'a');
                    } else if (ch >= 'A' && ch <= 'F') {
                        @shiftl res 4 res;
                        res = res + (ch+10-'A');
                    }
                }
            }
       		jump KCPContinue;
        }
    }
    done = false;
    glk_request_char_event(win);
    while (~~done) {
        glk_select(gg_event);
        switch (gg_event-->0) {
          5: ! evtype_Arrange
            if (nostat) {
                glk_cancel_char_event(win);
                res = $80000000;
                done = true;
                break;
            }
            DrawStatusLine();
          2: ! evtype_CharInput
            if (gg_event-->1 == win) {
                res = gg_event-->2;
                done = true;
                }
        }
        ix = HandleGlkEvent(gg_event, 1, gg_arguments);
        if (ix == 2) {
            res = gg_arguments-->0;
            done = true;
        } else if (ix == -1)  done = false;
    }
    if (gg_commandstr ~= 0 && gg_command_reading == false) {
        if (res < 32 || res >= 256 || (res == '\' or ' ')) {
            glk_put_char_stream(gg_commandstr, '\');
            done = 0;
            jx = res;
            for (ix=0 : ix<8 : ix++) {
                @ushiftr jx 28 ch;
                @shiftl jx 4 jx;
                ch = ch & $0F;
                if (ch ~= 0 || ix == 7) done = 1;
                if (done) {
                    if (ch >= 0 && ch <= 9) ch = ch + '0';
                    else                    ch = (ch - 10) + 'A';
                    glk_put_char_stream(gg_commandstr, ch);
                }
            }
        } else {
            glk_put_char_stream(gg_commandstr, res);
        }
        glk_put_char_stream(gg_commandstr, 10); ! newline
    }
  .KCPContinue;
    return res;
];

[ VM_KeyDelay tenths  key done ix;
    glk_request_char_event(gg_mainwin);
    glk_request_timer_events(tenths*100);
    while (~~done) {
        glk_select(gg_event);
        ix = HandleGlkEvent(gg_event, 1, gg_arguments);
        if (ix == 2) {
            key = gg_arguments-->0;
            done = true;
        }
        else if (ix >= 0 && gg_event-->0 == 1 or 2) {
            key = gg_event-->2;
            done = true;
        }
    }
    glk_cancel_char_event(gg_mainwin);
    glk_request_timer_events(0);
    return key;
];

[ VM_ReadKeyboard  a_buffer a_table done ix;
    if (gg_commandstr ~= 0 && gg_command_reading ~= false) {
        done = glk_get_line_stream(gg_commandstr, a_buffer+WORDSIZE,
        	(INPUT_BUFFER_LEN-WORDSIZE)-1);
        if (done == 0) {
            glk_stream_close(gg_commandstr, 0);
            gg_commandstr = 0;
            gg_command_reading = false;
        }
        else {
            ! Trim the trailing newline
            if ((a_buffer+WORDSIZE)->(done-1) == 10) done = done-1;
            a_buffer-->0 = done;
            VM_Style(INPUT_VMSTY);
            glk_put_buffer(a_buffer+WORDSIZE, done);
            VM_Style(NORMAL_VMSTY);
            print "^";
            jump KPContinue;
        }
    }
    done = false;
    glk_request_line_event(gg_mainwin, a_buffer+WORDSIZE, INPUT_BUFFER_LEN-WORDSIZE, 0);
    while (~~done) {
        glk_select(gg_event);
        switch (gg_event-->0) {
          5: ! evtype_Arrange
            DrawStatusLine();
          3: ! evtype_LineInput
            if (gg_event-->1 == gg_mainwin) {
                a_buffer-->0 = gg_event-->2;
                done = true;
            }
        }
        ix = HandleGlkEvent(gg_event, 0, a_buffer);
        if (ix == 2) done = true;
        else if (ix == -1) done = false;
    }
    if (gg_commandstr ~= 0 && gg_command_reading == false) {
        glk_put_buffer_stream(gg_commandstr, a_buffer+WORDSIZE, a_buffer-->0);
        glk_put_char_stream(gg_commandstr, 10); ! newline
    }
  .KPContinue;
    VM_Tokenise(a_buffer,a_table);
    ! It's time to close any quote window we've got going.
    if (gg_quotewin) {
        glk_window_close(gg_quotewin, 0);
        gg_quotewin = 0;
    }
    #ifdef ECHO_COMMANDS;
    print "** ";
    for (ix=WORDSIZE: ix<(a_buffer-->0)+WORDSIZE: ix++) print (char) a_buffer->ix;
    print "^";
    #endif; ! ECHO_COMMANDS
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Buffer Functions
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_CopyBuffer bto bfrom i;
    for (i=0: i<INPUT_BUFFER_LEN: i++) bto->i = bfrom->i;
];

[ VM_PrintToBuffer buf len a b c;
    if (b) {
        if (metaclass(a) == Object && a.#b == WORDSIZE
            && metaclass(a.b) == String)
            buf-->0 = Glulx_PrintAnyToArray(buf+WORDSIZE, len, a.b);
		else if (metaclass(a) == Routine)
			buf-->0 = Glulx_PrintAnyToArray(buf+WORDSIZE, len, a, b, c);
        else
            buf-->0 = Glulx_PrintAnyToArray(buf+WORDSIZE, len, a, b);
    }
    else if (metaclass(a) == Routine)
        buf-->0 = Glulx_PrintAnyToArray(buf+WORDSIZE, len, a, b, c);
    else
		buf-->0 = Glulx_PrintAnyToArray(buf+WORDSIZE, len, a);
    if (buf-->0 > len) buf-->0 = len;
    return buf-->0;
];

[ VM_Tokenise buf tab
    cx numwords len bx ix wx wpos wlen val res dictlen entrylen;
    len = buf-->0;
    buf = buf+WORDSIZE;

    ! First, split the buffer up into words. We use the standard Infocom
    ! list of word separators (comma, period, double-quote).

    cx = 0;
    numwords = 0;
    while (cx < len) {
        while (cx < len && buf->cx == ' ') cx++;
        if (cx >= len) break;
        bx = cx;
        if (buf->cx == '.' or ',' or '"') cx++;
        else {
            while (cx < len && buf->cx ~= ' ' or '.' or ',' or '"') cx++;
        }
        tab-->(numwords*3+2) = (cx-bx);
        tab-->(numwords*3+3) = WORDSIZE+bx;
        numwords++;
        if (numwords >= MAX_BUFFER_WORDS) break;
    }
    tab-->0 = numwords;

    ! Now we look each word up in the dictionary.

    dictlen = #dictionary_table-->0;
    entrylen = DICT_WORD_SIZE + 7;

    for (wx=0 : wx<numwords : wx++) {
        wlen = tab-->(wx*3+2);
        wpos = tab-->(wx*3+3);

        ! Copy the word into the gg_tokenbuf array, clipping to DICT_WORD_SIZE
        ! characters and lower case.
        if (wlen > DICT_WORD_SIZE) wlen = DICT_WORD_SIZE;
        cx = wpos - WORDSIZE;
        for (ix=0 : ix<wlen : ix++) gg_tokenbuf->ix = VM_UpperToLowerCase(buf->(cx+ix));
        for (: ix<DICT_WORD_SIZE : ix++) gg_tokenbuf->ix = 0;

        val = #dictionary_table + WORDSIZE;
        @binarysearch gg_tokenbuf DICT_WORD_SIZE val entrylen dictlen 1 1 res;
        tab-->(wx*3+1) = res;
    }
];

[ LTI_Insert i ch  b y;

    ! Protect us from strict mode, as this isn't an array in quite the
    ! sense it expects
    b = buffer;

    ! Insert character ch into buffer at point i.
    ! Being careful not to let the buffer possibly overflow:
    y = b-->0;
    if (y > INPUT_BUFFER_LEN) y = INPUT_BUFFER_LEN;

    ! Move the subsequent text along one character:
    for (y=y+WORDSIZE : y>i : y--) b->y = b->(y-1);
    b->i = ch;

    ! And the text is now one character longer:
    if (b-->0 < INPUT_BUFFER_LEN) (b-->0)++;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Dictionary Functions
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_InvalidDictionaryAddress addr;
	if (addr < 0) rtrue;
	rfalse;
];

[ VM_DictionaryAddressToNumber w; return w; ];
[ VM_NumberToDictionaryAddress n; return n; ];

Array gg_tokenbuf -> DICT_WORD_SIZE;

[ GGWordCompare str1 str2 ix jx;
    for (ix=0 : ix<DICT_WORD_SIZE : ix++) {
        jx = (str1->ix) - (str2->ix);
        if (jx ~= 0) return jx;
    }
    return 0;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: SHOWVERB support
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#Ifdef DEBUG;
[ DebugAction a str;
    if (a >= 4096) { print "<fake action ", a-4096, ">"; return; }
    if (a < 0 || a >= #identifiers_table-->7) print "<invalid action ", a, ">";
    else {
        str = #identifiers_table-->6;
        str = str-->a;
        if (str) print (string) str; else print "<unnamed action ", a, ">";
    }
];

[ DebugAttribute a str;
    if (a < 0 || a >= NUM_ATTR_BYTES*8) print "<invalid attribute ", a, ">";
    else {
        str = #identifiers_table-->4;
        str = str-->a;
        if (str) print (string) str; else print "<unnamed attribute ", a, ">";
    }
];
#Endif;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Command Tables
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_CommandTableAddress i;
	return (#grammar_table)-->(i+1);
];

[ VM_PrintCommandWords i wd j dictlen entrylen;
    dictlen = #dictionary_table-->0;
    entrylen = DICT_WORD_SIZE + 7;
    for (j=0 : j<dictlen : j++) {
        wd = #dictionary_table + WORDSIZE + entrylen*j;
        if (DictionaryWordToVerbNum(wd) == i)
            print "'", (address) wd, "' ";
    }
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Random Number Generator
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_Seed_RNG n;
	@setrandom n;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Memory Allocation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_AllocateMemory amount i;
	@gestalt 7 0 i;
	if (i == 0) return i;
	@malloc amount i;
	return i;
];

[ VM_FreeMemory address i;
	@gestalt 7 0 i;
	if (i == 0) return;
	@mfree address;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Audiovisual Resources
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_Picture resource_ID;
	if (glk_gestalt(gestalt_Graphics, 0)) {
		glk_image_draw(gg_mainwin, resource_ID, imagealign_InlineCenter, 0);
	} else {
		print "[Picture number ", resource_ID, " here.]^";
	}
];

[ VM_SoundEffect resource_ID;
	if (glk_gestalt(gestalt_Sound, 0)) {
		glk_schannel_play(gg_foregroundchan, resource_ID);
	} else {
		print "[Sound effect number ", resource_ID, " here.]^";
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Typography
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_Style sty;
	switch (sty) {
		NORMAL_VMSTY:     glk_set_style(style_Normal);
		HEADER_VMSTY:     glk_set_style(style_Header);
		SUBHEADER_VMSTY:  glk_set_style(style_Subheader);
		NOTE_VMSTY:       glk_set_style(style_Note);
		ALERT_VMSTY:      glk_set_style(style_Alert);
		BLOCKQUOTE_VMSTY: glk_set_style(style_BlockQuote);
		INPUT_VMSTY:      glk_set_style(style_Input);
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Character Casing
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_UpperToLowerCase c; return glk_char_to_lower(c); ];
[ VM_LowerToUpperCase c; return glk_char_to_upper(c); ];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Glulx-Only Printing Routines
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

! Glulx_PrintAnything()                    <nothing printed>
! Glulx_PrintAnything(0)                   <nothing printed>
! Glulx_PrintAnything("string");           print (string) "string";
! Glulx_PrintAnything('word')              print (address) 'word';
! Glulx_PrintAnything(obj)                 print (name) obj;
! Glulx_PrintAnything(obj, prop)           obj.prop();
! Glulx_PrintAnything(obj, prop, args...)  obj.prop(args...);
! Glulx_PrintAnything(func)                func();
! Glulx_PrintAnything(func, args...)       func(args...);

[ Glulx_PrintAnything _vararg_count obj mclass;
    if (_vararg_count == 0) return;
    @copy sp obj;
    _vararg_count--;
    if (obj == 0) return;

    if (obj->0 == $60) {
        ! Dictionary word. Metaclass() can't catch this case, so we do it manually
        print (address) obj;
        return;
    }

    mclass = metaclass(obj);
    switch (mclass) {
      nothing:
        return;
      String:
        print (string) obj;
        return;
      Routine:
        ! Call the function with all the arguments which are already
        ! on the stack.
        @call obj _vararg_count 0;
        return;
      Object:
        if (_vararg_count == 0) {
            print (name) obj;
        }
        else {
            ! Push the object back onto the stack, and call the
            ! veneer routine that handles obj.prop() calls.
            @copy obj sp;
            _vararg_count++;
            @call CA__Pr _vararg_count 0;
        }
        return;
    }
];

[ Glulx_PrintAnyToArray _vararg_count arr arrlen str oldstr len;
    @copy sp arr;
    @copy sp arrlen;
    _vararg_count = _vararg_count - 2;

    oldstr = glk_stream_get_current();
    str = glk_stream_open_memory(arr, arrlen, 1, 0);
    if (str == 0) return 0;

    glk_stream_set_current(str);

    @call Glulx_PrintAnything _vararg_count 0;

    glk_stream_set_current(oldstr);
    @copy $ffffffff sp;
    @copy str sp;
    @glk $0044 2 0; ! stream_close
    @copy sp len;
    @copy sp 0;
    return len;
];

Constant GG_ANYTOSTRING_LEN 66;
Array AnyToStrArr -> GG_ANYTOSTRING_LEN+1;

[ Glulx_ChangeAnyToCString _vararg_count ix len;
    ix = GG_ANYTOSTRING_LEN-2;
    @copy ix sp;
    ix = AnyToStrArr+1;
    @copy ix sp;
    ix = _vararg_count+2;
    @call Glulx_PrintAnyToArray ix len;
    AnyToStrArr->0 = $E0;
    if (len >= GG_ANYTOSTRING_LEN)
        len = GG_ANYTOSTRING_LEN-1;
    AnyToStrArr->(len+1) = 0;
    return AnyToStrArr;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: The Screen
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_ClearScreen window;
    if (window == WIN_ALL or WIN_MAIN) {
        glk_window_clear(gg_mainwin);
        if (gg_quotewin) {
            glk_window_close(gg_quotewin, 0);
            gg_quotewin = 0;
        }
    }
    if (gg_statuswin && window == WIN_ALL or WIN_STATUS) glk_window_clear(gg_statuswin);
];

[ VM_ScreenWidth  id;
    id=gg_mainwin;
    if (gg_statuswin && statuswin_current) id = gg_statuswin;
    glk_window_get_size(id, gg_arguments, 0);
    return gg_arguments-->0;
];

[ VM_ScreenHeight;
    glk_window_get_size(gg_mainwin, 0, gg_arguments);
    return gg_arguments-->0;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Window Colours
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_SetWindowColours f b window doclear  i fwd bwd swin;
    if (clr_on && f && b) {
        if (window) swin = 5-window; ! 4 for TextGrid, 3 for TextBuffer

        fwd = MakeColourWord(f);
        bwd = MakeColourWord(b);
        for (i=0 : i<style_NUMSTYLES: i++) {
            if (f == CLR_DEFAULT || b == CLR_DEFAULT) {  ! remove style hints
                glk_stylehint_clear(swin, i, stylehint_TextColor);
                glk_stylehint_clear(swin, i, stylehint_BackColor);
            } else {
                glk_stylehint_set(swin, i, stylehint_TextColor, fwd);
                glk_stylehint_set(swin, i, stylehint_BackColor, bwd);
            }
        }

        ! Now re-open the windows to apply the hints
        if (gg_statuswin) glk_window_close(gg_statuswin, 0);
        gg_statuswin = 0;

        if (doclear || ( window ~= 1 && (clr_fg ~= f || clr_bg ~= b) ) ) {
            glk_window_close(gg_mainwin, 0);
            gg_mainwin = glk_window_open(0, 0, 0, wintype_TextBuffer, GG_MAINWIN_ROCK);
            if (gg_scriptstr ~= 0)
                glk_window_set_echo_stream(gg_mainwin, gg_scriptstr);
        }

        gg_statuswin =
        	glk_window_open(gg_mainwin, winmethod_Fixed + winmethod_Above,
        		statuswin_cursize, wintype_TextGrid, GG_STATUSWIN_ROCK);
        if (statuswin_current && gg_statuswin) VM_MoveCursorInStatusLine(); else VM_MainWindow();

        if (window ~= 2) {
            clr_fgstatus = f;
            clr_bgstatus = b;
        }
        if (window ~= 1) {
            clr_fg = f;
            clr_bg = b;
        }
    }
];

[ VM_RestoreWindowColours; ! used after UNDO: compare I6 patch L61007
    if (clr_on) { ! check colour has been used
        VM_SetWindowColours(clr_fg, clr_bg, 2); ! make sure both sets of variables are restored
        VM_SetWindowColours(clr_fgstatus, clr_bgstatus, 1, true);
        VM_ClearScreen();
    }
];

[ MakeColourWord c;
    if (c > 9) return c;
    c = c-2;
    return $ff0000*(c&1) + $ff00*(c&2 ~= 0) + $ff*(c&4 ~= 0);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Main Window
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_MainWindow;
    glk_set_window(gg_mainwin); ! set_window
    statuswin_current=0;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Status Line
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_StatusLineHeight hgt;
    if (gg_statuswin == 0) return;
    if (hgt == statuswin_cursize) return;
    glk_window_set_arrangement(glk_window_get_parent(gg_statuswin), $12, hgt, 0);
    statuswin_cursize = hgt;
];

[ VM_MoveCursorInStatusLine line column;
    if (gg_statuswin == 0) return;
    glk_set_window(gg_statuswin);
    if (line == 0) { line = 1; column = 1; }
    glk_window_move_cursor(gg_statuswin, column-1, line-1);
    statuswin_current=1;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Quotation Boxes
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ Box__Routine maxwid arr ix lines lastnl parwin;
    maxwid = 0; ! squash compiler warning
    lines = arr-->0;

    if (gg_quotewin == 0) {
        gg_arguments-->0 = lines;
        ix = InitGlkWindow(GG_QUOTEWIN_ROCK);
        if (ix == 0)
            gg_quotewin =
            	glk_window_open(gg_mainwin, winmethod_Fixed + winmethod_Above,
            		lines, wintype_TextBuffer, GG_QUOTEWIN_ROCK);
    } else {
        parwin = glk_window_get_parent(gg_quotewin);
        glk_window_set_arrangement(parwin, $12, lines, 0);
    }

    lastnl = true;
    if (gg_quotewin) {
        glk_window_clear(gg_quotewin);
        glk_set_window(gg_quotewin);
        lastnl = false;
    }

	VM_Style(BLOCKQUOTE_VMSTY);
    for (ix=0 : ix<lines : ix++) {
        print (string) arr-->(ix+1);
        if (ix < lines-1 || lastnl) new_line;
    }
	VM_Style(NORMAL_VMSTY);

    if (gg_quotewin) glk_set_window(gg_mainwin);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: GlkList Command
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#Ifdef DEBUG;
[ GlkListSub id val;
    id = glk_window_iterate(0, gg_arguments);
    while (id) {
        print "Window ", id, " (", gg_arguments-->0, "): ";
        val = glk_window_get_type(id);
        switch (val) {
          1: print "pair";
          2: print "blank";
          3: print "textbuffer";
          4: print "textgrid";
          5: print "graphics";
          default: print "unknown";
        }
        val = glk_window_get_parent(id);
        if (val) print ", parent is window ", val;
        else     print ", no parent (root)";
        val = glk_window_get_stream(id);
        print ", stream ", val;
        val = glk_window_get_echo_stream(id);
        if (val) print ", echo stream ", val;
        print "^";
        id = glk_window_iterate(id, gg_arguments);
    }
    id = glk_stream_iterate(0, gg_arguments);
    while (id) {
        print "Stream ", id, " (", gg_arguments-->0, ")^";
        id = glk_stream_iterate(id, gg_arguments);
    }
    id = glk_fileref_iterate(0, gg_arguments);
    while (id) {
        print "Fileref ", id, " (", gg_arguments-->0, ")^";
        id = glk_fileref_iterate(id, gg_arguments);
    }
    if (glk_gestalt(gestalt_Sound, 0)) {
        id = glk_schannel_iterate(0, gg_arguments);
        while (id) {
            print "Soundchannel ", id, " (", gg_arguments-->0, ")^";
            id = glk_schannel_iterate(id, gg_arguments);
        }
    }
];

Verb meta 'glklist'

    *                                           -> Glklist;
#Endif;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Undo
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_Undo result_code;
	@restoreundo result_code;
	return (~~result_code);
];

[ VM_Save_Undo result_code;
    @saveundo result_code;
    if (result_code == -1) { GGRecoverObjects(); return 2; }
    return (~~result_code);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Quit The Game Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ QUIT_THE_GAME_R;
	if (actor ~= player) rfalse;
	if ((actor == player) && (untouchable_silence == false))
		QUIT_THE_GAME_RM('A');
	if (YesOrNo()~=0) quit;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Restart The Game Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ RESTART_THE_GAME_R;
	if (actor ~= player) rfalse;
	RESTART_THE_GAME_RM('A');
	if (YesOrNo()~=0) {
		@restart;
		RESTART_THE_GAME_RM('B'); new_line;
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Restore The Game Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ RESTORE_THE_GAME_R res fref;
	if (actor ~= player) rfalse;
	fref = glk_fileref_create_by_prompt($01, $02, 0);
	if (fref == 0) jump RFailed;
	gg_savestr = glk_stream_open_file(fref, $02, GG_SAVESTR_ROCK);
	glk_fileref_destroy(fref);
	if (gg_savestr == 0) jump RFailed;
	@restore gg_savestr res;
	glk_stream_close(gg_savestr, 0);
	gg_savestr = 0;
	.RFailed;
	RESTORE_THE_GAME_RM('A'); new_line;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Save The Game Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SAVE_THE_GAME_R res fref;
	if (actor ~= player) rfalse;
	fref = glk_fileref_create_by_prompt($01, $01, 0);
	if (fref == 0) jump SFailed;
	gg_savestr = glk_stream_open_file(fref, $01, GG_SAVESTR_ROCK);
	glk_fileref_destroy(fref);
	if (gg_savestr == 0) jump SFailed;
	@save gg_savestr res;
	if (res == -1) {
		! The player actually just typed "restore". We first have to recover
		! all the Glk objects; the values in our global variables are all wrong.
		GGRecoverObjects();
		glk_stream_close(gg_savestr, 0); ! stream_close
		gg_savestr = 0;
		RESTORE_THE_GAME_RM('B'); new_line;
		rtrue;
	}
	glk_stream_close(gg_savestr, 0); ! stream_close
	gg_savestr = 0;
	if (res == 0) { SAVE_THE_GAME_RM('B'); new_line; rtrue; }
	.SFailed;
	SAVE_THE_GAME_RM('A'); new_line;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Verify The Story File Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VERIFY_THE_STORY_FILE_R res;
	if (actor ~= player) rfalse;
	@verify res;
	if (res == 0) { VERIFY_THE_STORY_FILE_RM('A'); new_line; rtrue; }
	VERIFY_THE_STORY_FILE_RM('B'); new_line;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Switch Transcript On Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SWITCH_TRANSCRIPT_ON_R;
	if (actor ~= player) rfalse;
	if (gg_scriptstr ~= 0) { SWITCH_TRANSCRIPT_ON_RM('A'); new_line; rtrue; }
	if (gg_scriptfref == 0) {
		gg_scriptfref = glk_fileref_create_by_prompt($102, $05, GG_SCRIPTFREF_ROCK);
		if (gg_scriptfref == 0) jump S1Failed;
	}
	! stream_open_file
	gg_scriptstr = glk_stream_open_file(gg_scriptfref, $05, GG_SCRIPTSTR_ROCK);
	if (gg_scriptstr == 0) jump S1Failed;
	glk_window_set_echo_stream(gg_mainwin, gg_scriptstr);
	SWITCH_TRANSCRIPT_ON_RM('B'); new_line;
	VersionSub();
	return;
	.S1Failed;
	SWITCH_TRANSCRIPT_ON_RM('C'); new_line;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Switch Transcript Off Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SWITCH_TRANSCRIPT_OFF_R;
	if (actor ~= player) rfalse;
	if (gg_scriptstr == 0) { SWITCH_TRANSCRIPT_OFF_RM('A'); new_line; rtrue; }
	SWITCH_TRANSCRIPT_OFF_RM('B'); new_line;
	glk_stream_close(gg_scriptstr, 0); ! stream_close
	gg_scriptstr = 0;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Announce Story File Version Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ANNOUNCE_STORY_FILE_VERSION_R ix;
	if (actor ~= player) rfalse;
	Banner();
	print "Identification number: ";
	for (ix=6: ix <= UUID_ARRAY->0: ix++) print (char) UUID_ARRAY->ix;
	print "^";
	@gestalt 1 0 ix;
	print "Interpreter version ", ix / $10000, ".", (ix & $FF00) / $100,
	".", ix & $FF, " / ";
	@gestalt 0 0 ix;
	print "VM ", ix / $10000, ".", (ix & $FF00) / $100, ".", ix & $FF, " / ";
	print "Library serial number ", (string) LibSerial, "^";
	#Ifdef LanguageVersion;
	print (string) LanguageVersion, "^";
	#Endif; ! LanguageVersion
	ShowExtensionVersions();
	say__p = 1;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Descend To Specific Action Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ DESCEND_TO_SPECIFIC_ACTION_R;
	indirect(#actions_table-->(action+1));
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Veneer
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ Unsigned__Compare x y;
	@jleu x y ?lesseq;
	return 1;
	.lesseq;
	@jeq x y ?equal;
	return -1;
	.equal;
	return 0;
];

[ RT__ChLDW x y;
	@aload x y sp;
	@return sp;
];

[ RT__ChLDB x y;
	@aloadb x y sp;
	@return sp;
];

#Endif;

#Ifdef TARGET_ZCODE;

! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Summary
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Variables and Arrays
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Global top_object; ! largest valid number of any tree object
Global xcommsdir; ! true if command recording is on
Global transcript_mode; ! true if game scripting is on

Constant INPUT_BUFFER_LEN = 120; ! Length of buffer array

Array  buffer    -> 123;            ! Buffer for parsing main line of input
Array  buffer2   -> 123;            ! Buffers for supplementary questions
Array  buffer3   -> 123;            ! Buffer retaining input for "again"
Array  parse     buffer 63;         ! Parse table mirroring it
Array  parse2    buffer 63;         !

Global dict_start;
Global dict_entry_size;
Global dict_end;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Starting Up
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_Initialise i;
	standard_interpreter = HDR_TERPSTANDARD-->0;
	transcript_mode = ((HDR_GAMEFLAGS-->0) & 1);

	dict_start = HDR_DICTIONARY-->0;
	dict_entry_size = dict_start->(dict_start->0 + 1);
	dict_start = dict_start + dict_start->0 + 4;
	dict_end = dict_start + ((dict_start - 2)-->0) * dict_entry_size;

	buffer->0  = INPUT_BUFFER_LEN;
	buffer2->0 = INPUT_BUFFER_LEN;
	buffer3->0 = INPUT_BUFFER_LEN;
	parse->0   = 15;
	parse2->0  = 15;

	top_object = #largest_object-255;

	#ifdef FIX_RNG;
	@random 10000 -> i;
	i = -i-2000;
	print "[Random number generator seed is ", i, "]^";
	@random i -> i;
	#endif; ! FIX_RNG	
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Enable Acceleration
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ENABLE_GLULX_ACCEL_R;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Release Number
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_Describe_Release i;
	print "Release ", (HDR_GAMERELEASE-->0) & $03ff, " / Serial number ";
	for (i=0 : i<6 : i++) print (char) HDR_GAMESERIAL->i;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Keyboard Input
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_KeyChar win  key;
    if (win) @set_window win;
    @read_char 1 -> key;
    return key;
];

[ VM_KeyDelay tenths  key;
    @read_char 1 tenths VM_KeyDelay_Interrupt -> key;
    return key;
];
[ VM_KeyDelay_Interrupt; rtrue; ];

[ VM_ReadKeyboard  a_buffer a_table i;
    read a_buffer a_table;
    #ifdef ECHO_COMMANDS;
    print "** ";
    for (i=2: i<=(a_buffer->1)+1: i++) print (char) a_buffer->i;
    print "^";
    #ifnot;
    i=0;  ! suppress compiler warning
    #endif;

    #Iftrue (#version_number == 6);
    @output_stream -1;
    @loadb a_buffer 1 -> sp;
    @add a_buffer 2 -> sp;
    @print_table sp sp;
    new_line;
    @output_stream 1;
    #Endif;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Buffer Functions
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_CopyBuffer bto bfrom i;
    for (i=0: i<INPUT_BUFFER_LEN: i++) bto->i = bfrom->i;
];

[ VM_PrintToBuffer buf len a b c;
    @output_stream 3 buf;
    switch (metaclass(a)) {
		String: print (string) a;
		Routine: a(b, c);
		Object, Class: if (b) PrintOrRun(a, b, true); else print (name) a;
    }
    @output_stream -3;
    if (buf-->0 > len) print "Error: Overflow in VM_PrintToBuffer.^";
    return buf-->0;
];

[ VM_Tokenise b p; b->(2 + b->1) = 0; @tokenise b p; ];

[ LTI_Insert i ch  b y;
    ! Protect us from strict mode, as this isn't an array in quite the
    ! sense it expects
    b = buffer;

    ! Insert character ch into buffer at point i.
    ! Being careful not to let the buffer possibly overflow:
    y = b->1;
    if (y > b->0) y = b->0;

    ! Move the subsequent text along one character:
    for (y=y+2 : y>i : y--) b->y = b->(y-1);
    b->i = ch;

    ! And the text is now one character longer:
    if (b->1 < b->0) (b->1)++;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Dictionary Functions
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_InvalidDictionaryAddress addr;
    if ((UnsignedCompare(addr, dict_start) < 0) ||
		(UnsignedCompare(addr, dict_end) >= 0) ||
		((addr - dict_start) % dict_entry_size ~= 0)) rtrue;
	rfalse;
];

[ VM_DictionaryAddressToNumber w; return (w-(HDR_DICTIONARY-->0 + 7))/9; ];
[ VM_NumberToDictionaryAddress n; return HDR_DICTIONARY-->0 + 7 + 9*n; ];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Command Tables
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_CommandTableAddress i;
	return (HDR_STATICMEMORY-->0)-->i;
];

[ VM_PrintCommandWords i da j;
    da = HDR_DICTIONARY-->0;
    for (j=0 : j<(da+5)-->0 : j++)
        if (da->(j*9 + 14) == $ff-i)
        	print "'", (address) VM_NumberToDictionaryAddress(j), "' ";
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: SHOWVERB support
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#Ifdef DEBUG;
[ DebugAction a anames;
    if (a >= 4096) { print "<fake action ", a-4096, ">"; return; }
    anames = #identifiers_table;
    anames = anames + 2*(anames-->0) + 2*48;
    print (string) anames-->a;
];

[ DebugAttribute a anames;
    if (a < 0 || a >= 48) print "<invalid attribute ", a, ">";
    else {
        anames = #identifiers_table; anames = anames + 2*(anames-->0);
        print (string) anames-->a;
    }
];
#Endif;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: RNG
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_Seed_RNG n;
	if (n > 0) n = -n;
	@random n -> n;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Memory Allocation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_AllocateMemory amount;
	return 0;
];

[ VM_FreeMemory address;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Audiovisual Resources
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_Picture resource_ID;
	#IFTRUE #version_number == 6; ! Z-machine version 6
	@draw_picture resource_ID;
	#ENDIF;
];

[ VM_SoundEffect resource_ID;
	#IFTRUE #version_number == 6; ! Z-machine version 6
	@sound_effect resource_ID;
	#ENDIF;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Typography
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_Style sty;
	switch (sty) {
		NORMAL_VMSTY, NOTE_VMSTY: style roman;
		HEADER_VMSTY, SUBHEADER_VMSTY, ALERT_VMSTY: style bold;
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Character Casing
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_UpperToLowerCase c;
   switch (c) {
		'A' to 'Z': c = c + 32;
		202, 204, 212, 214, 221: c--;
		217, 218: c = c - 2;
		158 to 160, 167 to 168, 208 to 210: c = c - 3;
		186 to 190, 196 to 200: c = c - 5 ;
		175 to 180: c = c - 6;
   }
   return c;
];

[ VM_LowerToUpperCase c;
   switch (c) {
		'a' to 'z': c = c - 32;
		201, 203, 211, 213, 220: c++;
		215, 216: c = c + 2;
		155 to 157, 164 to 165, 205 to 207: c = c + 3;
		181 to 185, 191 to 195: c = c + 5 ;
		169 to 174: c = c + 6;
   }
   return c;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: The Screen
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_ClearScreen window;
    switch (window) {
		WIN_ALL:    @erase_window -1; statuswin_cursize = 0;
		WIN_STATUS: @erase_window 1;
		WIN_MAIN:   @erase_window 0;
    }
];

#Iftrue (#version_number == 6);
[ VM_ScreenWidth  width charw;
    @get_wind_prop 1 3 -> width;
    @get_wind_prop 1 13 -> charw;
    charw = charw & $FF;
    return (width+charw-1) / charw;
];
#Ifnot;
[ VM_ScreenWidth; return (HDR_SCREENWCHARS->0); ];
#Endif;

[ VM_ScreenHeight; return (HDR_SCREENHLINES->0); ];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Window Colours
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_SetWindowColours f b window;
    if (clr_on && f && b) {
        if (window == 0) {  ! if setting both together, set reverse
            clr_fgstatus = b;
            clr_bgstatus = f;
            }
        if (window == 1) {
            clr_fgstatus = f;
            clr_bgstatus = b;
        }
        if (window == 0 or 2) {
            clr_fg = f;
            clr_bg = b;
        }
        if (statuswin_current)
            @set_colour clr_fgstatus clr_bgstatus;
        else
            @set_colour clr_fg clr_bg;
    }
];

[ VM_RestoreWindowColours; ! compare I6 library patch L61007
    if (clr_on) { ! check colour has been used
        VM_SetWindowColours(clr_fg, clr_bg, 2); ! make sure both sets of variables are restored
        VM_SetWindowColours(clr_fgstatus, clr_bgstatus, 1, true);
        VM_ClearScreen();
    }
    #Iftrue (#version_number == 6); ! request screen update
    (0-->8) = (0-->8) | $$00000100;
    #Endif;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Main Window
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_MainWindow;
    if (statuswin_current) {
        if (clr_on && clr_bgstatus > 1) @set_colour clr_fg clr_bg;
        else style roman;
        @set_window 0;
    }
    statuswin_current = false;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Status Line
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_MoveCursorInStatusLine line column; ! 1-based position on text grid
    if (~~statuswin_current) {
         @set_window 1;
         if (clr_on && clr_bgstatus > 1) @set_colour clr_fgstatus clr_bgstatus;
         else                            style reverse;
    }
    if (line == 0) {
        line = 1;
        column = 1;
    }
    #Iftrue (#version_number == 6);
    Z6_MoveCursor(line, column);
    #Ifnot;
    @set_cursor line column;
    #Endif;
	statuswin_current = true;
];

#Iftrue (#version_number == 6);
[ Z6_MoveCursor line column  charw charh; ! 1-based position on text grid
	@get_wind_prop 1 13 -> charw; ! font size
	@log_shift charw $FFF8 -> charh;
	charw = charw / $100;
	line = 1 + charh*(line-1);
	column = 1 + charw*(column-1);
	@set_cursor line column;
];
#Endif;

#Iftrue (#version_number == 6);
[ VM_StatusLineHeight height  wx wy x y charh;
    ! Split the window. Standard 1.0 interpreters should keep the window 0
    ! cursor in the same absolute position, but older interpreters,
    ! including Infocom's don't - they keep the window 0 cursor in the
    ! same position relative to its origin. We therefore compensate
    ! manually.
    @get_wind_prop 0 0 -> wy; @get_wind_prop 0 1 -> wx;
    @get_wind_prop 0 13 -> charh; @log_shift charh $FFF8 -> charh;
    @get_wind_prop 0 4 -> y; @get_wind_prop 0 5 -> x;
    height = height * charh;
    @split_window height;
    y = y - height + wy - 1;
    if (y < 1) y = 1;
    x = x + wx - 1;
    @set_cursor y x 0;
    statuswin_cursize = height;
];
#Ifnot;
[ VM_StatusLineHeight height;
    if (statuswin_cursize ~= height)
        @split_window height;
    statuswin_cursize = height;
];
#Endif;

#Iftrue (#version_number == 6);
[ Z6_DrawStatusLine width x charw scw;
	(0-->8) = (0-->8) &~ $$00000100;
	@push say__p; @push say__pc;
	BeginActivity(CONSTRUCTING_STATUS_LINE_ACT);
	VM_StatusLineHeight(statuswin_size);
	! Now clear the window. This isn't totally trivial. Our approach is to select the
	! fixed space font, measure its width, and print an appropriate
	! number of spaces. We round up if the screen isn't a whole number
	! of characters wide, and rely on window 1 being set to clip by default.
	VM_MoveCursorInStatusLine(1, 1);
	@set_font 4 -> x;
	width = VM_ScreenWidth();
	spaces width;
	ClearParagraphing(8);
	if (ForActivity(CONSTRUCTING_STATUS_LINE_ACT) == false) {
		! Back to standard font for the display. We use output_stream 3 to
		! measure the space required, the aim being to get 50 characters
		! worth of space for the location name.
		VM_MoveCursorInStatusLine(1, 2);
		@set_font 1 -> x;
		TEXT_TY_Say(left_hand_status_line);
		@get_wind_prop 1 3 -> width;
		@get_wind_prop 1 13 -> charw;
		charw = charw & $FF;
		@output_stream 3 StorageForShortName;
		TEXT_TY_Say(right_hand_status_line);
		@output_stream -3; scw = HDR_PIXELSTO3-->0 + charw;
		x = 1+width-scw;
		@set_cursor 1 x; TEXT_TY_Say(right_hand_status_line);
	}
	! Reselect roman, as Infocom's interpreters go funny if reverse is selected twice.
	VM_MainWindow();
	ClearParagraphing(8);
	EndActivity(CONSTRUCTING_STATUS_LINE_ACT);
	@pull say__pc; @pull say__p;
];
#Endif;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Quotation Boxes
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Undo
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_Undo result_code;
	@restore_undo result_code;
	return result_code;
];

[ VM_Save_Undo result_code;
    @save_undo result_code;
	return result_code;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Quit The Game Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ QUIT_THE_GAME_R;
	if (actor ~= player) rfalse;
	QUIT_THE_GAME_RM('A');
	if (YesOrNo()~=0) quit;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Restart The Game Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ RESTART_THE_GAME_R;
	if (actor ~= player) rfalse;
	RESTART_THE_GAME_RM('A');
	if (YesOrNo()~=0) {
		@restart;
		RESTART_THE_GAME_RM('B'); new_line;
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Restore The Game Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ RESTORE_THE_GAME_R;
	if (actor ~= player) rfalse;
	restore Rmaybe;
	RESTORE_THE_GAME_RM('A'); new_line;
	rtrue;
	.RMaybe; RESTORE_THE_GAME_RM('B'); new_line;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Save The Game Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SAVE_THE_GAME_R flag;
	if (actor ~= player) rfalse;
	#IFV5;
	@save -> flag;
	switch (flag) {
		0: SAVE_THE_GAME_RM('A'); new_line;
		1: SAVE_THE_GAME_RM('B'); new_line;
		2: RESTORE_THE_GAME_RM('B'); new_line;
	}
	#IFNOT;
	save Smaybe;
	SAVE_THE_GAME_RM('A'); new_line; rtrue;
	.SMaybe; SAVE_THE_GAME_RM('B'); new_line;
	#ENDIF;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Verify The Story File Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VERIFY_THE_STORY_FILE_R;
	if (actor ~= player) rfalse;
	@verify ?Vmaybe;
	jump Vwrong;
	.Vmaybe; VERIFY_THE_STORY_FILE_RM('A'); new_line; rtrue;
	.Vwrong;
	VERIFY_THE_STORY_FILE_RM('B'); new_line;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Switch Transcript On Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SWITCH_TRANSCRIPT_ON_R;
	if (actor ~= player) rfalse;
	transcript_mode = ((0-->8) & 1);
	if (transcript_mode) { SWITCH_TRANSCRIPT_ON_RM('A'); new_line; rtrue; }
	@output_stream 2;
	if (((0-->8) & 1) == 0) { SWITCH_TRANSCRIPT_ON_RM('C'); new_line; rtrue; }
	SWITCH_TRANSCRIPT_ON_RM('B'); new_line; VersionSub();
	transcript_mode = true;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Switch Transcript Off Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SWITCH_TRANSCRIPT_OFF_R;
	if (actor ~= player) rfalse;
	transcript_mode = ((0-->8) & 1);
	if (transcript_mode == false) { SWITCH_TRANSCRIPT_OFF_RM('A'); new_line; rtrue; }
	SWITCH_TRANSCRIPT_OFF_RM('B'); new_line;
	@output_stream -2;
	if ((0-->8) & 1) { SWITCH_TRANSCRIPT_ON_RM('C'); new_line; rtrue; }
	transcript_mode = false;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Announce Story File Version Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ANNOUNCE_STORY_FILE_VERSION_R ix;
	if (actor ~= player) rfalse;
	Banner();
	print "Identification number: ";
	for (ix=6: ix <= UUID_ARRAY->0: ix++) print (char) UUID_ARRAY->ix;
	print "^";
	ix = 0; ! shut up compiler warning
	if (standard_interpreter > 0) {
		print "Standard interpreter ",
			standard_interpreter/256, ".", standard_interpreter%256,
			" (", HDR_TERPNUMBER->0;
		#Iftrue (#version_number == 6);
		print (char) '.', HDR_TERPVERSION->0;
		#Ifnot;
		print (char) HDR_TERPVERSION->0;
		#Endif;
		print ") / ";
	} else {
		print "Interpreter ", HDR_TERPNUMBER->0, " Version ";
		#Iftrue (#version_number == 6);
		print HDR_TERPVERSION->0;
		#Ifnot;
		print (char) HDR_TERPVERSION->0;
		#Endif;
		print " / ";
	}
	print "Library serial number ", (string) LibSerial, "^";
	#Ifdef LanguageVersion;
	print (string) LanguageVersion, "^";
	#Endif; ! LanguageVersion
	#ifdef ShowExtensionVersions;
	ShowExtensionVersions();
	#endif;
	say__p = 1;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Descend To Specific Action Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ DESCEND_TO_SPECIFIC_ACTION_R;
	indirect(#actions_table-->action);
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Veneer
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ OC__Cl obj cla j a n objflag;

	@jl obj 1 ?NotObj;
	@jg obj max_z_object ?NotObj;
	@inc objflag;
	@je cla K1_room ?~NotRoom;
	@test_attr obj mark_as_room ?rtrue;
	@rfalse;
	.NotRoom;
	@je cla K2_thing ?~NotObj;
	@test_attr obj mark_as_thing ?rtrue;
	@rfalse;
	.NotObj;

	@je cla Object Class ?ObjOrClass;
	@je cla Routine String ?RoutOrStr;

	@jin cla 1 ?~Mistake;

	@jz objflag ?rfalse;
	@get_prop_addr obj 2 -> a;
	@jz a ?rfalse;
	@get_prop_len a -> n;

	@div n 2 -> n;
	.Loop;
	@loadw a j -> sp;
	@je sp cla ?rtrue;
	@inc j;
	@jl j n ?Loop;
	@rfalse;

	.ObjOrClass;
	@jz objflag ?rfalse;
	@je cla Object ?JustObj;

	! So now cla is Class
	@jg obj String ?~rtrue;
	@jin obj Class ?rtrue;
	@rfalse;

	.JustObj;
	! So now cla is Object
	@jg obj String ?~rfalse;
	@jin obj Class ?rfalse;
	@rtrue;

	.RoutOrStr;
	@jz objflag ?~rfalse;
	@call_2s Z__Region obj -> sp;
	@inc sp;
	@je sp cla ?rtrue;
	@rfalse;

	.Mistake;
	RT__Err("apply 'ofclass' for", cla, -1);
	rfalse;
];

[ Unsigned__Compare x y u v;
	@je x y ?rfalse; ! i.e., return 0
	@jl x 0 ?XNegative;
	! So here x >= 0 and x ~= y
	@jl y 0 ?XPosYNeg;

	! Here x >=0, y >= 0, x ~= y

	@jg x y ?rtrue; ! i.e., return 1
	@ret -1;

	.XPosYNeg;
	! Here x >= 0, y < 0, x ~= y
	@ret -1;

	.XNegative;
	@jl y 0 ?~rtrue; ! if x < 0, y >= 0, return 1
	
	! Here x < 0, y < 0, x ~= y
	@jg x y ?rtrue;
	@ret -1;
];

[ RT__ChLDW base offset;
    @loadw base offset -> sp;
    @ret sp;
];

#Endif;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Compass
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Object Compass "compass" has concealed;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Language of Play
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Language.i6t: Vocabulary
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant AGAIN1__WD     = 'again';
Constant AGAIN2__WD     = 'g//';
Constant AGAIN3__WD     = 'again';
Constant OOPS1__WD      = 'oops';
Constant OOPS2__WD      = 'o//';
Constant OOPS3__WD      = 'oops';
Constant UNDO1__WD      = 'undo';
Constant UNDO2__WD      = 'undo';
Constant UNDO3__WD      = 'undo';

Constant ALL1__WD       = 'all';
Constant ALL2__WD       = 'each';
Constant ALL3__WD       = 'every';
Constant ALL4__WD       = 'everything';
Constant ALL5__WD       = 'both';
Constant AND1__WD       = 'and';
Constant AND2__WD       = 'and';
Constant AND3__WD       = 'and';
Constant BUT1__WD       = 'but';
Constant BUT2__WD       = 'except';
Constant BUT3__WD       = 'but';
Constant ME1__WD        = 'me';
Constant ME2__WD        = 'myself';
Constant ME3__WD        = 'self';
Constant OF1__WD        = 'of';
Constant OF2__WD        = 'of';
Constant OF3__WD        = 'of';
Constant OF4__WD        = 'of';
Constant OTHER1__WD     = 'another';
Constant OTHER2__WD     = 'other';
Constant OTHER3__WD     = 'other';
Constant THEN1__WD      = 'then';
Constant THEN2__WD      = 'then';
Constant THEN3__WD      = 'then';

Constant NO1__WD        = 'n//';
Constant NO2__WD        = 'no';
Constant NO3__WD        = 'no';
Constant YES1__WD       = 'y//';
Constant YES2__WD       = 'yes';
Constant YES3__WD       = 'yes';

Constant AMUSING__WD    = 'amusing';
Constant FULLSCORE1__WD = 'fullscore';
Constant FULLSCORE2__WD = 'full';
Constant QUIT1__WD      = 'q//';
Constant QUIT2__WD      = 'quit';
Constant RESTART__WD    = 'restart';
Constant RESTORE__WD    = 'restore';



Array LanguagePronouns table 
! word possible GNAs connected 
! to follow: to: 
!        a     i 
!        s  p  s  p 
!        mfnmfnmfnmfn 
'it'   $$001000001000 NULL 
'her'  $$010000010000 NULL 
'him'  $$100000100000 NULL 
'them' $$000111000111 NULL; 


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Language.i6t: Pronouns (skipping)
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Language.i6t: Descriptors
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Array LanguageDescriptors table

  ! word        possible GNAs   descriptor      connected
  !             to follow:      type:           to:
  !             a     i
  !             s  p  s  p
  !             mfnmfnmfnmfn

    'my'      $$111111111111    POSSESS_PK      0
    'this'    $$111111111111    POSSESS_PK      0
    'these'   $$000111000111    POSSESS_PK      0
    'that'    $$111111111111    POSSESS_PK      1
    'those'   $$000111000111    POSSESS_PK      1
    'his'     $$111111111111    POSSESS_PK      'him'
    'her'     $$111111111111    POSSESS_PK      'her'
    'their'   $$111111111111    POSSESS_PK      'them'
    'its'     $$111111111111    POSSESS_PK      'it'
    'the'     $$111111111111    DEFART_PK       NULL
    'a//'     $$111000111000    INDEFART_PK     NULL
    'an'      $$111000111000    INDEFART_PK     NULL
    'some'    $$000111000111    INDEFART_PK     NULL
    'lit'     $$111111111111    light           NULL
    'lighted' $$111111111111    light           NULL
    'unlit'   $$111111111111    (-light)        NULL;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Language.i6t: Numbers
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Array LanguageNumbers table
    'one' 1 'two' 2 'three' 3 'four' 4 'five' 5
    'six' 6 'seven' 7 'eight' 8 'nine' 9 'ten' 10
    'eleven' 11 'twelve' 12 'thirteen' 13 'fourteen' 14 'fifteen' 15
    'sixteen' 16 'seventeen' 17 'eighteen' 18 'nineteen' 19 'twenty' 20
    'twenty-one' 21 'twenty-two' 22 'twenty-three' 23 'twenty-four' 24
	'twenty-five' 25 'twenty-six' 26 'twenty-seven' 27 'twenty-eight' 28
	'twenty-nine' 29 'thirty' 30
;

[ LanguageNumber n f;
    if (n == 0)    { print "zero"; rfalse; }
    if (n < 0)     { print "minus "; n = -n; }
#Iftrue (WORDSIZE == 4);
    if (n >= 1000000000) {
        if (f == 1) print ", ";
    	print (LanguageNumber) n/1000000000, " billion"; n = n%1000000000; f = 1;
    }
    if (n >= 1000000) {
        if (f == 1) print ", ";
    	print (LanguageNumber) n/1000000, " million"; n = n%1000000; f = 1;
    }
#Endif;
    if (n >= 1000) {
        if (f == 1) print ", ";
    	print (LanguageNumber) n/1000, " thousand"; n = n%1000; f = 1;
    }
    if (n >= 100)  {
        if (f == 1) print ", ";
        print (LanguageNumber) n/100, " hundred"; n = n%100; f = 1;
    }
    if (n == 0) rfalse;
    #Ifdef DIALECT_US;
    if (f == 1) print " ";
    #Ifnot;
    if (f == 1) print " and ";
    #Endif;
    switch (n) {
      1:    print "one";
      2:    print "two";
      3:    print "three";
      4:    print "four";
      5:    print "five";
      6:    print "six";
      7:    print "seven";
      8:    print "eight";
      9:    print "nine";
      10:   print "ten";
      11:   print "eleven";
      12:   print "twelve";
      13:   print "thirteen";
      14:   print "fourteen";
      15:   print "fifteen";
      16:   print "sixteen";
      17:   print "seventeen";
      18:   print "eighteen";
      19:   print "nineteen";
      20 to 99: switch (n/10) {
        2:  print "twenty";
        3:  print "thirty";
        4:  print "forty";
        5:  print "fifty";
        6:  print "sixty";
        7:  print "seventy";
        8:  print "eighty";
        9:  print "ninety";
        }
        if (n%10 ~= 0) print "-", (LanguageNumber) n%10;
    }
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Language.i6t: Time
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LanguageTimeOfDay hours mins i;
    i = hours%12;
    if (i == 0) i = 12;
    if (i < 10) print " ";
    print i, ":", mins/10, mins%10;
    if ((hours/12) > 0) print " pm"; else print " am";
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Language.i6t: Directions
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LanguageDirection d;
	print (name) d;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Language.i6t: Translation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LanguageToInformese; ];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Language.i6t: Articles
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant LanguageAnimateGender   = male;
Constant LanguageInanimateGender = neuter;

Constant LanguageContractionForms = 2;     ! English has two:
                                           ! 0 = starting with a consonant
                                           ! 1 = starting with a vowel

[ LanguageContraction text;
    if (text->0 == 'a' or 'e' or 'i' or 'o' or 'u'
                or 'A' or 'E' or 'I' or 'O' or 'U') return 1;
    return 0;
];

Array LanguageArticles -->

 !   Contraction form 0:     Contraction form 1:
 !   Cdef   Def    Indef     Cdef   Def    Indef

     "The " "the " "a "      "The " "the " "an "          ! Articles 0
     "The " "the " "some "   "The " "the " "some ";       ! Articles 1

                   !             a           i
                   !             s     p     s     p
                   !             m f n m f n m f n m f n

Array LanguageGNAsToArticles --> 0 0 0 1 1 1 0 0 0 1 1 1;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Language.i6t: Commands
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LanguageVerb i;
    switch (i) {
      'i//','inv','inventory':
               print "take inventory";
      'l//':   print "look";
      'x//':   print "examine";
      'z//':   print "wait";
      default: rfalse;
    }
    rtrue;
];

[ LanguageVerbLikesAdverb w;
    if (w == 'look' or 'go' or 'push' or 'walk')
        rtrue;
    rfalse;
];

[ LanguageVerbMayBeName w;
    if (w == 'long' or 'short' or 'normal' or 'brief' or 'full' or 'verbose')
        rtrue;
    rfalse;
];


Default LanguageCases 1;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: The Old Library
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Light.i6t: Darkness
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Object thedark "(darkness object)";


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Light.i6t: Light Measurement
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ OffersLight obj j;
    while (obj) {
		if (obj has light) rtrue;
		objectloop (j in obj) if (HasLightSource(j)) rtrue;
		if ((obj has container) && (obj hasnt open) && (obj hasnt transparent)) rfalse;
		if ((obj provides component_parent) && (obj.component_parent))
			obj = obj.component_parent;
		else
			obj = parent(obj);
	}
    rfalse;
];

[ HasLightSource i j ad sr po;
	if (i == 0) rfalse;
    if (i has light) rtrue;
    if ((IsSeeThrough(i)) && (~~(HidesLightSource(i))))
        objectloop (j in i)
            if (HasLightSource(j)) rtrue;
    ad = i.&add_to_scope;
    if (parent(i) ~= 0 && ad ~= 0) {
        if (metaclass(ad-->0) == Routine) {
            ats_hls = 0; ats_flag = 1;
            sr = scope_reason; po = parser_one;
            scope_reason = LOOPOVERSCOPE_REASON; parser_one = 0;
            RunRoutines(i, add_to_scope);
            scope_reason = sr; parser_one = po;
            ats_flag = 0; if (ats_hls == 1) rtrue;
        }
        else {
            for (j=0 : (WORDSIZE*j)<i.#add_to_scope : j++)
                if ((ad-->j) && (HasLightSource(ad-->j) == 1)) rtrue;
        }
    }
    if (ComponentHasLight(i)) rtrue;
    rfalse;
];

[ ComponentHasLight o obj next_obj;
	if (o provides component_child) {
		obj = o.component_child;
		while (obj) {
			next_obj = obj.component_sibling;
			if (obj has light) rtrue;
			if (HasLightSource(obj)) rtrue;
			if ((obj provides component_child) && (ComponentHasLight(obj))) rtrue;
			obj = next_obj;
		}
	}
	rfalse;
];

[ HidesLightSource obj;
    if (obj == player) rfalse;
    if (obj has transparent or supporter) rfalse;
    if (obj has animate) rfalse;
    if (obj has container) return (obj hasnt open);
    return (obj hasnt enterable);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Light.i6t: Invariant
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Global lightflag = false;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Light.i6t: Adjust Light Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ADJUST_LIGHT_R previous_light_condition;
    previous_light_condition = lightflag;
    lightflag = OffersLight(parent(player));

    if ((previous_light_condition == false) && (lightflag == false)) {
    	location = thedark;
    	rfalse;
    }

    if ((previous_light_condition == false) && (lightflag == true)) {
        location = real_location;
        CarryOutActivity(PRINTING_NEWS_OF_LIGHT_ACT);
        rfalse;
    }

    if ((previous_light_condition == true) && (lightflag == false)) {
        location = thedark;
		DivideParagraphPoint();
		BeginActivity(PRINTING_NEWS_OF_DARKNESS_ACT);
		if (ForActivity(PRINTING_NEWS_OF_DARKNESS_ACT) == false) {
			ADJUST_LIGHT_RM('A'); new_line;
		}
		EndActivity(PRINTING_NEWS_OF_DARKNESS_ACT);
		rfalse;
    }

    if ((previous_light_condition == true) && (lightflag == true)) {
    	location = real_location;
    	rfalse;
    }

    rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Light.i6t: Silent Light Consideration
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SilentlyConsiderLight;
    lightflag = OffersLight(parent(player));
	if (lightflag) location = real_location; else location = thedark;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Light.i6t: Translucency
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ IsSeeThrough obj;
    if ((obj has supporter)
    	|| (obj has transparent)
    	|| (obj has animate)
    	|| ((obj has container) && (obj has open)))
        rtrue;
   rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Light.i6t: Visibility Parent
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VisibilityParent o;
    if (o && (o has container) && (o hasnt open) && (o hasnt transparent)) return nothing;
	if (o) o = CoreOfParentOfCoreOf(o);
    return o;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Light.i6t: Find Visibility Levels
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FindVisibilityLevels lc up;
	if (location == thedark) {
		visibility_ceiling = thedark;
		visibility_levels = 0;	
	} else {
		visibility_ceiling = player;
		while (true) {
			up = VisibilityParent(visibility_ceiling);
			if (up == 0) break;
			visibility_ceiling = up;
			lc++;
		}
		visibility_levels = lc;
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Light.i6t: Touchability Ceiling
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TouchabilityCeiling original o p;
	o = original;
	while (o) {
	    p = CoreOfParentOfCoreOf(o);
	    if (p ofclass K1_room) return p;
	    if (p == nothing) return o;
	    if ((FollowRulebook(REACHING_OUTSIDE_RB, p)) && (RulebookFailed()))
	    	return p;
	    o = p;
	}
	return o;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Light.i6t: Scope Ceiling
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ScopeCeiling pos c;
	if (pos == player && location == thedark) return thedark;
	c = parent(pos);
	if (c == 0) return pos;
	while (VisibilityParent(c)) c = VisibilityParent(c);
	return c;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Light.i6t: Object Is Untouchable
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ObjectIsUntouchable item silent_flag p save_sp decision moving x;
	if (LocationOf(p) ~= real_location) {
		for (x = CoreOf(item): x: x = CoreOfParentOfCoreOf(x)) {
			if (x ofclass K4_door or K7_backdrop) {
				moving = true;
				MoveFloatingObjects(LocationOf(p));
				break;
			}
		}
	}
	untouchable_object = item; untouchable_silence = silent_flag;
	touch_persona = p; if (p == actor) touch_persona = 0;
	save_sp = say__p; say__p = 0;
	@push actor; actor = p;
	if (FollowRulebook(ACCESSIBILITY_RB, 0, true)) {
		if (RulebookSucceeded()) decision = false;
		else decision = true;
	} else decision = false;
	@pull actor;
	if (say__p == false) say__p = save_sp;
	if (moving) MoveFloatingObjects();
	untouchable_silence = 0;
	return decision;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Light.i6t: Access Through Barriers Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ACCESS_THROUGH_BARRIERS_R ancestor i j external p;
	p = touch_persona; if (p == 0) p = actor;

	ancestor = CommonAncestor(p, untouchable_object);
	if ((ancestor == 0) && (LocationOf(untouchable_object) == nothing)
		&& ((untouchable_object ofclass K4_door or K7_backdrop) == false)) {
		if (touch_persona == 0) {
			if ((actor == player) && (untouchable_silence == false)) {
				ACCESS_THROUGH_BARRIERS_RM('A', untouchable_object);
				new_line;
			}
		}
		RulebookFails();
		rtrue;
	}

	! First, a barrier between the player and the ancestor.

	if (CoreOf(p) ~= ancestor) {
		i = parent(CoreOf(p)); j = CoreOf(i); external = false;
		if (j ~= i) { i = j; external = true; }
		while (i~=ancestor && i) {
			if ((external == false)
				&& (FollowRulebook(REACHING_OUTSIDE_RB, i))
				&& (RulebookFailed())) rtrue; ! Barrier
			i = parent(CoreOf(i)); external = false;
			if (~~(i ofclass K5_container)) {
				j = CoreOf(i);
				if (j ~= i) { i = j; external = true; }
			}
		}
	}

	! Second, a barrier between the item and the ancestor.

	if (CoreOf(untouchable_object) ~= ancestor) {
		! We can always get to the core of the item.
		i = CoreOf(untouchable_object);
		! This will be on the inside of its parent, if its parent is a
		! container, so there should be no exemption.
		i = parent(i); external = false;
		while (i~=ancestor && i) {
			if ((external == false) &&
				(FollowRulebook(REACHING_INSIDE_RB, i)) &&
				(RulebookFailed())) rtrue; ! Barrier
			i = CoreOf(i);
			if (i == ancestor) break;
			i = parent(i); external = false;
			if (~~(i ofclass K5_container)) {
				j = CoreOf(i);
				if (j ~= i) { i = j; external = true; }
			}
		}
	}

	RulebookSucceeds(); ! No barrier
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Light.i6t: Can't Reach Inside Closed Containers Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ CANT_REACH_INSIDE_CLOSED_R;
	if (parameter_value has container && parameter_value hasnt open) {
		if (touch_persona == 0) {
			if ((actor == player) && (untouchable_silence == false)) {
				CANT_REACH_INSIDE_CLOSED_RM('A', parameter_value);
				new_line;
			}
		}
		RulebookFails(); rtrue;
	}
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Light.i6t: Can't Reach Outside Closed Containers Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ CANT_REACH_OUTSIDE_CLOSED_R;
	if (parameter_value has container && parameter_value hasnt open) {
		if (touch_persona == 0) {
			if ((actor == player) && (untouchable_silence == false)) {
				CANT_REACH_OUTSIDE_CLOSED_RM('A', parameter_value);
				new_line;
			}
		}
		RulebookFails(); rtrue;
	}
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Light.i6t: Can't Reach Inside Rooms Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ CANT_REACH_INSIDE_ROOMS_R;
	if (parameter_value && parameter_value ofclass K1_room) {
		if (touch_persona == 0) {
			if ((actor == player) && (untouchable_silence == false)) {
				CANT_REACH_INSIDE_ROOMS_RM('A', parameter_value);
				new_line;
			}
		}
		RulebookFails(); rtrue;
	}
	rfalse;
];



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: Specification
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: Memory
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant REQUISITION_STACK_SIZE = 3*286;
Array requisition_stack --> REQUISITION_STACK_SIZE;
Global requisition_stack_pointer = 0;

[ RequisitionStack len top addr;
	top = requisition_stack_pointer + len;
	if (top > REQUISITION_STACK_SIZE) return false;
	addr = requisition_stack + requisition_stack_pointer*WORDSIZE;
	! print "Allocating ", addr, " at pointer ", requisition_stack_pointer, "^";
	requisition_stack_pointer = top;
	return addr;
];

[ FreeStack addr;
	if (addr == 0) return;
	requisition_stack_pointer = (addr - requisition_stack)/WORDSIZE;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: WriteListOfMarkedObjects
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Global MarkedObjectArray = 0;
Global MarkedObjectLength = 0;

[ WriteListOfMarkedObjects style
	obj common_parent first mixed_parentage length g gc;

	gc = -2;
	objectloop (obj ofclass Object && obj has workflag2) {
		length++;
		if (first == nothing) { first = obj; common_parent = parent(obj); }
		else { if (parent(obj) ~= common_parent) mixed_parentage = true; }
		g = GetGNAOfObject(obj); g = g%3;
		if (gc == -2) gc = g;
		else if (gc ~= g) gc = -1;
	}
	if (mixed_parentage) common_parent = nothing;

	if (length == 0) {
    	if (style & ISARE_BIT ~= 0) LIST_WRITER_INTERNAL_RM('W');
    	else if (style & CFIRSTART_BIT ~= 0) LIST_WRITER_INTERNAL_RM('X');
		else LIST_WRITER_INTERNAL_RM('Y');
	} else {
		@push MarkedObjectArray; @push MarkedObjectLength;
		MarkedObjectArray = RequisitionStack(length);
		MarkedObjectLength = length;
		if (MarkedObjectArray == 0) return RunTimeProblem(RTP_LISTWRITERMEMORY); 

		if (common_parent) {
			ObjectTreeCoalesce(child(common_parent));
			length = 0;
			objectloop (obj in common_parent) ! object tree order
				if (obj has workflag2) MarkedObjectArray-->length++ = obj;
		} else {
			length = 0;
			objectloop (obj ofclass Object) ! object number order
				if (obj has workflag2) MarkedObjectArray-->length++ = obj;
		}

		WriteListFrom(first, style, 0, false, MarkedListIterator);

		FreeStack(MarkedObjectArray);
		@pull MarkedObjectLength; @pull MarkedObjectArray;
	}
	prior_named_list = length;
	prior_named_list_gender = gc;
	return;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: List Number and Gender
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ RegardingMarkedObjects
	obj length g gc;
	gc = -2;
	objectloop (obj ofclass Object && obj has workflag2) {
		length++;
		g = GetGNAOfObject(obj); g = g%3;
		if (gc == -2) {
			gc = g;
			prior_named_noun = obj;
		} else if (gc ~= g) gc = -1;
	}
	prior_named_list = length;
	prior_named_list_gender = gc;
	if (length == 0) { prior_named_noun = nothing; prior_named_list_gender = -1; }
	return;	
];

[ RegardingSingleObject obj;
	prior_named_list = 1;
	prior_named_list_gender = -1;
	prior_named_noun = obj;
];

[ PNToVP gna;
	if (prior_named_noun == player) return story_viewpoint;
	if (prior_named_noun) gna = GetGNAOfObject(prior_named_noun);
	if (((gna%6)/3 == 1) || (prior_named_list >= 2)) return 6;
	return 3;
];

[ PrintVerbAsValue vb;
	if (vb == 0) print "(no verb)";
	else { print "verb "; vb(1); }
];

[ VerbIsMeaningful vb;
	if ((vb) && (BlkValueCompare(vb(CV_MEANING), Rel_Record_0) ~= 0)) rtrue;
	rfalse;
];

[ VerbIsModal vb;
	if ((vb) && (vb(CV_MODAL))) rtrue;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: List Writer Regard Storage
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Array LWI_Storage --> 1 (-1) nothing;
[ SetLWI a b c;
	LWI_Storage-->0 = a;
	LWI_Storage-->1 = b;
	LWI_Storage-->2 = c;
];
[ RegardingLWI;
	prior_named_list = LWI_Storage-->0;
	prior_named_list_gender = LWI_Storage-->1;
	prior_named_noun = LWI_Storage-->2;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: Response Printing
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ResponseViaActivity R;
	@push prior_named_noun; @push prior_named_list; @push prior_named_list_gender;
	RegardingSingleObject(nothing);
	CarryOutActivity(PRINTING_RESPONSE_ACT, R);
	@pull prior_named_list_gender; @pull prior_named_list; @pull prior_named_noun;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: About Iterator Functions
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant SEEK_ITF = 0;
Constant ADVANCE_ITF = 1;
Constant COALESCE_ITF = 2;
Constant START_ITF = 3;

! Constant DBLW; ! Uncomment this to provide debugging information at run-time


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: Marked List Iterator
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ MarkedListIterator obj depth required_lt function i;
    if (obj == nothing) return nothing;
    if (required_lt == 0) required_lt = EMPTY_TEXT_VALUE;
	switch(function) {
    	START_ITF: return MarkedObjectArray-->0;
    	COALESCE_ITF: return MarkedListCoalesce();
    	SEEK_ITF, ADVANCE_ITF:
			for (i=0: i<MarkedObjectLength: i++)
				if (MarkedObjectArray-->i == obj) {
					if (function == ADVANCE_ITF) i++;
					for (:i<MarkedObjectLength: i++) {
						obj = MarkedObjectArray-->i;
						if ((LT_Compare(required_lt, EMPTY_TEXT_VALUE) ~= 0) &&
							(LT_Compare(obj.list_together, required_lt) ~= 0)) continue;
						if ((c_style & WORKFLAG_BIT) && (depth==0) && (obj hasnt workflag))
							continue;
						if ((c_style & CONCEAL_BIT) &&
							((obj has concealed) || (obj has scenery))) continue;
						return obj;
					}
					return nothing;
				}
	}
	return nothing;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: Coalesce Marked List
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ MarkedListCoalesce o i lt l swap m;
	for (i=0: i<MarkedObjectLength: i++) {
		lt = (MarkedObjectArray-->i).list_together;
		if (LT_Compare(lt, EMPTY_TEXT_VALUE) ~= 0) {
			! Find first object in list after contiguous run with this list_together value:
			for (i++: (i<MarkedObjectLength) &&
				(LT_Compare((MarkedObjectArray-->i).list_together, lt) == 0): i++) ;
			! If the contiguous run extends to end of list, the list is now perfect:
			if (i == MarkedObjectLength) return MarkedObjectArray-->0;
			! And otherwise we look to see if any future entries belong in the earlier run:
			for (l=i+1: l<MarkedObjectLength: l++)
				if (LT_Compare((MarkedObjectArray-->l).list_together, lt) == 0) {
					! Yes, they do: so we perform a rotation to insert it before element i:
					swap = MarkedObjectArray-->l;
					for (m=l: m>i: m--) MarkedObjectArray-->m = MarkedObjectArray-->(m-1);
					MarkedObjectArray-->i = swap;
					! And now the run is longer:
					i++;
					if (i == MarkedObjectLength) return MarkedObjectArray-->0;
				}
			i--;
		}
	}
	return MarkedObjectArray-->0;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: Object Tree Iterator
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Global list_filter_routine;

[ ObjectTreeIterator obj depth required_lt function;
    if ((obj == nothing) || (parent(obj) == nothing)) return nothing;
	if (function == START_ITF) obj = child(parent(obj));
	if (function == COALESCE_ITF) return ObjectTreeCoalesce(obj);
    if (function == ADVANCE_ITF) obj = sibling(obj);
    if (required_lt == 0) required_lt = EMPTY_TEXT_VALUE;
    for (:: obj = sibling(obj)) {
        if (obj == nothing) return nothing;
!if (function == ADVANCE_ITF) print "Considering ", (the) obj, ": ", (TEXT_TY_Say) obj.list_together, ": ", (TEXT_TY_Say) required_lt, ": ", ": ", (TEXT_TY_Say) lt_value, ": ", LT_Compare(obj.list_together, required_lt), "^";
		if ((LT_Compare(required_lt, EMPTY_TEXT_VALUE) ~= 0) &&
			(LT_Compare(obj.list_together, required_lt) ~= 0)) continue;
		if ((c_style & WORKFLAG_BIT) && (depth==0) && (obj hasnt workflag)) continue;
		if (obj hasnt list_filter_permits) continue;
		if ((c_style & CONCEAL_BIT) &&
			((obj has concealed) || (obj has scenery))) continue;
		return obj;
    }
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: Coalesce Object Tree
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ObjectTreeCoalesce obj memb lt later;
	#Ifdef DBLW; print "^^Sorting out: "; DiagnoseSortList(obj); #Endif;
	.StartAgain;
	for (memb=obj: memb~=nothing: memb=sibling(memb)) {
		lt = memb.list_together;
		if (LT_Compare(lt, EMPTY_TEXT_VALUE) ~= 0) {
			! Find first object in list after contiguous run with this list_together value:
			for (memb=sibling(memb):
				(memb) && (LT_Compare(memb.list_together, lt) == 0): memb = sibling(memb)) ;
			! If the contiguous run extends to end of list, the list is now perfect:
			if (memb == 0) return obj;
			! And otherwise we look to see if any future entries belong in the earlier run:
			for (later=sibling(memb): later: later=sibling(later))
				if (LT_Compare(later.list_together, lt) == 0) {
					! Yes, they do: so we perform a regrouping of the list and start again:
					obj = GroupChildren(parent(obj), lt);
					#Ifdef DBLW; print "^^Sorted to: "; DiagnoseSortList(obj); #Endif;
					jump StartAgain;
				}
		}
	}
	return obj;
];
#Ifdef DBLW;
[ DiagnoseSortList obj memb;
    for (memb=child(obj): memb~=nothing: memb=sibling(memb)) print memb, " --> "; new_line;
];
#Endif;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: WriteListFrom
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ WriteListFrom first style depth noactivity iter a ol;
	@push c_iterator; @push c_style; @push c_depth; @push c_margin;
    if (iter) c_iterator = iter; else c_iterator = ObjectTreeIterator;
    c_style = style; c_depth = depth;
	c_margin = 0; if (style & EXTRAINDENT_BIT) c_margin = 1;

	objectloop (a ofclass Object) {
		give a list_filter_permits;
		if ((list_filter_routine) && (list_filter_routine(a) == false))
			give a ~list_filter_permits;
	}

    first = c_iterator(first, depth, 0, START_ITF);
	if (first == nothing) {
		if (style & ISARE_BIT ~= 0) LIST_WRITER_INTERNAL_RM('W');
        else LIST_WRITER_INTERNAL_RM('Y');
        if (style & NEWLINE_BIT ~= 0) new_line;
    } else {
		if ((noactivity) || (iter)) {
			WriteListR(first, c_depth, true);
			say__p = 1;
		} else {
			objectloop (ol provides list_together)
				BlkValueCopy(ol.list_together, EMPTY_TEXT_VALUE);
			CarryOutActivity(LISTING_CONTENTS_ACT, parent(first));
		}
	}

    @pull c_margin; @pull c_depth; @pull c_style; @pull c_iterator;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: Standard Contents Listing Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ STANDARD_CONTENTS_LISTING_R;
	WriteListFrom(child(parameter_value), c_style, c_depth, true);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: Partitioning
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#Ifdef DBLW;
Global DBLW_no_classes; Global DBLW_no_objs;
[ DebugPartition partition_class_sizes partition_classes first depth i k o;
	print "[Length of list is ", DBLW_no_objs, " with ", k, " plural.]^";
	print "[Partitioned into ", DBLW_no_classes, " equivalence classes.]^";
    for (i=1: i<=DBLW_no_classes : i++) {
    	print "Class ", i, " has size ", partition_class_sizes->i, "^";
	}
	for (k=0, o=first: k<DBLW_no_objs : k++, o = c_iterator(o, depth, lt_value, ADVANCE_ITF)) {
    	print "Entry ", k, " has class ", partition_classes->k,
    		" represented by ", o, " with L=", o.list_together, "^";
	}
];
#Endif;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: Partition List
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PartitionList first no_objs depth partition_classes partition_class_sizes
	i k l n m;
    for (i=0: i<no_objs: i++) partition_classes->i = 0;
    n = 1;
    for (i=first, k=0: k<no_objs: i=c_iterator(i, depth, lt_value, ADVANCE_ITF), k++)
        if (partition_classes->k == 0) {
            partition_classes->k = n; partition_class_sizes->n = 1;
            for (l=c_iterator(i, depth, lt_value, ADVANCE_ITF), m=k+1:
            	(l~=0) && (m<no_objs):
            	l=c_iterator(l, depth, lt_value, ADVANCE_ITF), m++) {
                if ((partition_classes->m == 0) && (ListEqual(i, l))) {
                    if (partition_class_sizes->n < 255) (partition_class_sizes->n)++;
                    partition_classes->m = n;
                }
            }
            if (n < 255) n++;
        }
    n--;
	#Ifdef DBLW;
	DBLW_no_classes = n; DBLW_no_objs = no_objs;
	DebugPartition(partition_class_sizes, partition_classes, first, depth);
	#Endif;
    return n;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: Equivalence Relation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ListEqual o1 o2;
	if ((o1.plural == 0) || (o2.plural == 0)) rfalse;
 	if (child(o1) ~= 0 && WillRecurs(o1) ~= 0) rfalse;
    if (child(o2) ~= 0 && WillRecurs(o2) ~= 0) rfalse;
    if (c_style & (FULLINV_BIT + PARTINV_BIT) ~= 0) {
        if ((o1 hasnt worn && o2 has worn) || (o2 hasnt worn && o1 has worn)) rfalse;
        if ((o1 hasnt light && o2 has light) || (o2 hasnt light && o1 has light)) rfalse;
        if (o1 has container) {
            if (o2 hasnt container) rfalse;
            if ((o1 has open && o2 hasnt open) || (o2 has open && o1 hasnt open))
                rfalse;
        }
        else if (o2 has container)
            rfalse;
    }
    return Identical(o1, o2);
];

[ WillRecurs o;
    if (c_style & ALWAYS_BIT ~= 0) rtrue;
    if (c_style & RECURSE_BIT == 0) rfalse;
    if ((o has supporter) || ((o has container) && (o has open or transparent))) rtrue;
    rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: Grouping
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ NumberOfGroupsInList o no_classes depth partition_classes partition_class_sizes
	no_groups cl memb k current_lt lt;
	current_lt = EMPTY_TEXT_VALUE;
	lt = EMPTY_TEXT_VALUE;
	no_groups = no_classes;
    for (cl=1, memb=o, k=0: cl<=no_classes: cl++) {
    	! Advance to first member of class number cl
        while (partition_classes->k ~= cl) {
            k++; memb = c_iterator(memb, depth, lt_value, ADVANCE_ITF);
        }
        if (memb) { ! In case of accidents, but should always happen
        	lt = memb.list_together;
        	if ((LT_Compare(lt, lt_value) ~= 0) &&
            	(LT_Compare(lt, EMPTY_TEXT_VALUE) ~= 0) &&
            	(LT_Compare(lt, current_lt) == 0)) {
            	no_groups--;
            }
            current_lt = lt;
        }
    }
 	#Ifdef DBLW; print "[There are ", no_groups, " groups.]^"; #Endif;
	return no_groups;
];

[ LT_Compare lt1 lt2;
	if (lt1 == lt2) return 0;
	if (lt1 == 0) lt1 = EMPTY_TEXT_VALUE;
	if (lt2 == 0) lt2 = EMPTY_TEXT_VALUE;
	if (TEXT_TY_IsSubstituted(lt1) == false) {
		if (TEXT_TY_IsSubstituted(lt2) == false) return (lt1-->1)-(lt2-->1);
		return -1;
	}
	if (TEXT_TY_IsSubstituted(lt2) == false) {
		return -1;
	}
	return BlkValueCompare(lt1, lt2);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: Write List Recursively
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ WriteListR o depth from_start
	partition_classes partition_class_sizes
	cl memb index k2 l m no_classes q groups_to_do current_lt;
    if (o == nothing) return; ! An empty list: no output

    if (from_start) {
    	o = c_iterator(o, depth, 0, COALESCE_ITF); ! Coalesce list and choose new start
	}
    o = c_iterator(o, depth, 0, SEEK_ITF); ! Find first entry in list from o
    if (o == nothing) return;

	! Count index = length of list
    for (memb=o, index=0: memb: memb=c_iterator(memb, depth, lt_value, ADVANCE_ITF)) index++;

    if (c_style & ISARE_BIT ~= 0) {
    	SetLWI(index, -1, o);
    	LIST_WRITER_INTERNAL_RM('V', o);
    	if (c_style & NEWLINE_BIT ~= 0)   print ":^";
        else                              print (char) ' ';
        c_style = c_style - ISARE_BIT;
    }

    partition_classes = RequisitionStack(index/WORDSIZE + 2);
    partition_class_sizes = RequisitionStack(index/WORDSIZE + 2);
    if ((partition_classes == 0) || (partition_class_sizes == 0))
    	return RunTimeProblem(RTP_LISTWRITERMEMORY);

	no_classes =
		PartitionList(o, index, depth, partition_classes, partition_class_sizes);

	groups_to_do =
		NumberOfGroupsInList(o, no_classes, depth, partition_classes, partition_class_sizes);

    for (cl=1, memb=o, index=0, current_lt=EMPTY_TEXT_VALUE: groups_to_do>0: cl++) {
		! Set memb to first object of partition class cl
        while (partition_classes->index ~= cl) {
        	index++; memb=c_iterator(memb, depth, lt_value, ADVANCE_ITF);
            if (memb==0) { print "*** Error in list-writer ***^"; return; }
        }

    	#Ifdef DBLW;
		! DebugPartition(partition_class_sizes, partition_classes, o, depth);
		print "^[Class ", cl, " of ", no_classes, ": first object ", memb,
			" (", memb.list_together, "); groups_to_do ", groups_to_do, ",
			current_lt=", current_lt, " listing_size=", listing_size,
			" lt_value=", lt_value, " memb.list_together=", memb.list_together, "]^";
    	#Endif;

		if ((LT_Compare(memb.list_together, lt_value) == 0) ||
        	(LT_Compare(memb.list_together, EMPTY_TEXT_VALUE) == 0)) current_lt = EMPTY_TEXT_VALUE;
		else {
            if (LT_Compare(memb.list_together, current_lt) == 0) continue;
            
            ! Otherwise this class begins a new group
            @push listing_size;
            q = memb; listing_size = 1; l = index; m = cl;
			while (m < no_classes &&
				(LT_Compare(q.list_together, memb.list_together) == 0)) {
				m++;
				while (partition_classes->l ~= m) {
					l++; q = c_iterator(q, depth, lt_value, ADVANCE_ITF);
				}
				if (LT_Compare(q.list_together, memb.list_together) == 0)
					listing_size++;
			}

			if (listing_size > 1) {
				! The new group contains more than one partition class
				WriteMultiClassGroup(cl, memb, depth, partition_class_sizes);
				current_lt = memb.list_together;
				jump GroupComplete;
			}
			current_lt = EMPTY_TEXT_VALUE;
			@pull listing_size;
		}

		WriteSingleClassGroup(cl, memb, depth, partition_class_sizes->cl);

		.GroupComplete;
		groups_to_do--;
        if (c_style & ENGLISH_BIT ~= 0) {
            if (groups_to_do == 1) {
            	#ifdef SERIAL_COMMA; if (cl > 1) print ","; #endif;
               LIST_WRITER_INTERNAL_RM('C');
            }
            if (groups_to_do > 1) print ", ";
        }
    }

    FreeStack(partition_class_sizes);
    FreeStack(partition_classes);
]; ! end of WriteListR


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: Write Multiple Class Group
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ WriteMultiClassGroup cl memb depth partition_class_sizes pv q k2 l;
	! Save the style, because the activity below is allowed to change it
	q = c_style;
	if (c_style & INDENT_BIT ~= 0) PrintSpaces(2*(depth+c_margin));

	BeginActivity(GROUPING_TOGETHER_ACT, memb);

	if (ForActivity(GROUPING_TOGETHER_ACT, memb)) {
		c_style = c_style &~ NEWLINE_BIT;
	} else {
		pv = memb.list_together;
		if (TEXT_TY_IsSubstituted(pv) == false) {
			inventory_stage = 1;
			parser_one = memb; parser_two = depth + c_margin;
			if ((pv-->1)() == 1) jump Omit__Sublist2;
		} else if (pv) {
			! Set k2 to the number of objects covered by the group
			k2 = 0;
			for (l=0 : l<listing_size : l++) k2 = k2 + partition_class_sizes->(l+cl);
			EnglishNumber(k2); print " ";
			print (TEXT_TY_Say) pv;
			if (c_style & ENGLISH_BIT ~= 0) print " (";
			if (c_style & INDENT_BIT ~= 0)  print ":^";
		}

		c_margin++;
		@push lt_value; @push listing_together; @push listing_size;
		
		lt_value = memb.list_together; listing_together = memb;
		#Ifdef DBLW; print "^^DOWN lt_value = ", lt_value, " listing_together = ", memb, "^^";
		@push DBLW_no_classes; @push DBLW_no_objs; #Endif;
		WriteListR(memb, depth, false); 
		#Ifdef DBLW; print "^^UP^^"; @pull DBLW_no_objs; @pull DBLW_no_classes; #Endif;

		@pull listing_size; @pull listing_together; @pull lt_value;
		c_margin--;
		
		pv = memb.list_together;
		if (TEXT_TY_IsSubstituted(pv) == false) {
			inventory_stage = 2;
			parser_one = memb; parser_two = depth+c_margin;
			(pv-->1)();
		} else if (LT_Compare(pv, EMPTY_TEXT_VALUE) ~= 0) {
			if (q & ENGLISH_BIT ~= 0) print ")";
		}
		.Omit__Sublist2;
	}
  
	EndActivity(GROUPING_TOGETHER_ACT, memb);

	! If the NEWLINE_BIT has been forced by the activity, act now
	! before it vanishes...
	if (q & NEWLINE_BIT ~= 0 && c_style & NEWLINE_BIT == 0) new_line;

	! ...when the original style is restored again:
	c_style = q;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: Write Single Class Group
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ WriteSingleClassGroup cl memb depth size q;
	q = c_style;
    if (c_style & INDENT_BIT) PrintSpaces(2*(depth+c_margin));
	if (size == 1) {
		if (c_style & NOARTICLE_BIT ~= 0) print (name) memb;
		else {
			if (c_style & DEFART_BIT) {
				if ((cl == 1) && (c_style & CFIRSTART_BIT)) print (The) memb;
				else print (the) memb;
			} else {
				if ((cl == 1) && (c_style & CFIRSTART_BIT)) print (CIndefArt) memb;
				else print (a) memb;
			}
		}
	} else {
		if (c_style & DEFART_BIT) {
			if ((cl == 1) && (c_style & CFIRSTART_BIT)) PrefaceByArticle(memb, 0, size);
			else PrefaceByArticle(memb, 1, size);
		}
		@push listing_size; listing_size = size;
		CarryOutActivity(PRINTING_A_NUMBER_OF_ACT, memb);
		@pull listing_size;
	}
	if ((size > 1) && (memb hasnt pluralname)) {
		give memb pluralname;
		WriteAfterEntry(memb, depth);
		give memb ~pluralname;
	} else WriteAfterEntry(memb, depth);
	c_style = q;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: Write After Entry
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ WriteAfterEntry o depth
    p recurse_flag parenth_flag eldest_child child_count combo;

    inventory_stage = 2;
    if (c_style & PARTINV_BIT) {
        BeginActivity(PRINTING_ROOM_DESC_DETAILS_ACT, o);
        if (ForActivity(PRINTING_ROOM_DESC_DETAILS_ACT, o) == false) {
			combo = 0;
			if (o has light && location hasnt light) combo=combo+1;
			if (o has container && o hasnt open)     combo=combo+2;
			if ((o has container && (o has open || o has transparent))
				&& (child(o)==0))                    combo=combo+4;
			if (combo) LIST_WRITER_INTERNAL_RM('A'); ! space and open bracket
			switch (combo) {
				1: LIST_WRITER_INTERNAL_RM('D', o);
				2: LIST_WRITER_INTERNAL_RM('E', o);
				3: LIST_WRITER_INTERNAL_RM('H', o);
				4: LIST_WRITER_INTERNAL_RM('F', o);
				5: LIST_WRITER_INTERNAL_RM('I', o);
				6: LIST_WRITER_INTERNAL_RM('G', o);
				7: LIST_WRITER_INTERNAL_RM('J', o);
			}
			if (combo) LIST_WRITER_INTERNAL_RM('B'); ! close bracket
		}
        EndActivity(PRINTING_ROOM_DESC_DETAILS_ACT, o);
    }   ! end of PARTINV_BIT processing

    if (c_style & FULLINV_BIT) {
        BeginActivity(PRINTING_INVENTORY_DETAILS_ACT, o);
        if (ForActivity(PRINTING_INVENTORY_DETAILS_ACT, o) == false) {
			if (o has light && o has worn) { LIST_WRITER_INTERNAL_RM('A'); LIST_WRITER_INTERNAL_RM('K', o);  parenth_flag = true; }
			else {
				if (o has light)           { LIST_WRITER_INTERNAL_RM('A'); LIST_WRITER_INTERNAL_RM('D', o);  parenth_flag = true; }
				if (o has worn)            { LIST_WRITER_INTERNAL_RM('A'); LIST_WRITER_INTERNAL_RM('L', o); parenth_flag = true; }
			}
	
			if (o has container)
				if (o has openable) {
					if (parenth_flag) {
						#Ifdef SERIAL_COMMA; print ","; #Endif;
						LIST_WRITER_INTERNAL_RM('C');
					} else            LIST_WRITER_INTERNAL_RM('A', o);
					if (o has open)
						if (child(o)) LIST_WRITER_INTERNAL_RM('M', o);
						else          LIST_WRITER_INTERNAL_RM('N', o);
					else
						if (o has lockable && o has locked) LIST_WRITER_INTERNAL_RM('P', o);
						else                                LIST_WRITER_INTERNAL_RM('O', o);
					parenth_flag = true;
				}
				else
					if (child(o)==0 && o has transparent)
						if (parenth_flag) { LIST_WRITER_INTERNAL_RM('C'); LIST_WRITER_INTERNAL_RM('F'); }
						else              { LIST_WRITER_INTERNAL_RM('A'); LIST_WRITER_INTERNAL_RM('F'); LIST_WRITER_INTERNAL_RM('B'); }
	
			if (parenth_flag) LIST_WRITER_INTERNAL_RM('B');
		}
        EndActivity(PRINTING_INVENTORY_DETAILS_ACT, o);
    }   ! end of FULLINV_BIT processing

	child_count = 0;
	eldest_child = nothing;
	objectloop (p in o)
		if ((c_style & CONCEAL_BIT == 0) || (p hasnt concealed && p hasnt scenery))
			if (p has list_filter_permits) {
				child_count++;
				if (eldest_child == nothing) eldest_child = p;
			}

    if (child_count && (c_style & ALWAYS_BIT)) {
        if (c_style & ENGLISH_BIT) { print " "; LIST_WRITER_INTERNAL_RM('Q', o); print " "; }
        recurse_flag = true;
    }
    
    if (child_count && (c_style & RECURSE_BIT)) {
        if (o has supporter) {
            if (c_style & ENGLISH_BIT) {
                if (c_style & TERSE_BIT) {
                	LIST_WRITER_INTERNAL_RM('A', o);
                	LIST_WRITER_INTERNAL_RM('R', o);
                } else LIST_WRITER_INTERNAL_RM('S', o);
            }
            recurse_flag = true;
        }
        if (o has container && (o has open || o has transparent)) {
            if (c_style & ENGLISH_BIT) {
                if (c_style & TERSE_BIT) {
                	LIST_WRITER_INTERNAL_RM('A', o);
                	LIST_WRITER_INTERNAL_RM('T', o);
                } else LIST_WRITER_INTERNAL_RM('U', o);
            }
            recurse_flag = true;
        }
    }

    if (recurse_flag && (c_style & ENGLISH_BIT)) {
    	SetLWI(child_count, -1, eldest_child);
    	LIST_WRITER_INTERNAL_RM('V', o); print " ";
	}

    if (c_style & NEWLINE_BIT) new_line;

    if (recurse_flag) {
        o = child(o);
        @push lt_value; @push listing_together; @push listing_size;
        @push c_iterator;
        c_iterator = ObjectTreeIterator;
        lt_value = EMPTY_TEXT_VALUE; listing_together = 0; listing_size = 0;
        WriteListR(o, depth+1, true);
        @pull c_iterator;
        @pull listing_size; @pull listing_together; @pull lt_value;
        if (c_style & TERSE_BIT) LIST_WRITER_INTERNAL_RM('B');
    }
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: Internal Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LIST_WRITER_INTERNAL_R;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Utilities.i6t: Saying Phrases
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SayPhraseName closure;
	if (closure == 0) print "nothing";
	else print (string) closure-->2;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Utilities.i6t: Kinds
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ KindAtomic kind;
	if ((kind >= 0) && (kind < BASE_KIND_HWM)) return kind;
	return kind-->0;
];

[ KindBaseArity kind;
	if ((kind >= 0) && (kind < BASE_KIND_HWM)) return 0;
	return kind-->1;
];

[ KindBaseTerm kind n;
	if ((kind >= 0) && (kind < BASE_KIND_HWM)) return UNKNOWN_TY;
	return kind-->(2+n);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Utilities.i6t: DigitToValue
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ DigitToValue c n;
	n = c-'0';
	if ((n<0) || (n>9)) return -1;
	return n;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Utilities.i6t: GenerateRandomNumber
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ GenerateRandomNumber n m s;
	if (n==m) return n;
	if (n>m) { s = n; n = m; m = s; }
	n--;
	return random(m-n) + n;
];
Constant R_DecimalNumber = GenerateRandomNumber;
Constant R_PrintTimeOfDay = GenerateRandomNumber;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Utilities.i6t: GroupChildren
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ GroupChildren par value;
    while (child(par) ~= 0) {
        if (LT_Compare(child(par).list_together, value) ~= 0)
        	move child(par) to out_obj;
        else
        	move child(par) to in_obj;
    }
    while (child(in_obj) ~= 0)  move child(in_obj) to par;
    while (child(out_obj) ~= 0) move child(out_obj) to par;
    return child(par);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Utilities.i6t: PrintSpaces
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PrintSpaces n;
    while (n > 0) {
        print " ";
        n = n - 1;
    }
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Utilities.i6t: RunRoutines
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ RunRoutines obj prop;
    if (obj == thedark) obj = real_location;
    if ((obj.&prop == 0) && (prop >= INDIV_PROP_START)) rfalse;
    return obj.prop();
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Utilities.i6t: SwapWorkflags
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SwapWorkflags obj lst;
	objectloop (obj ofclass Object) {
		lst = false;
		if (obj has workflag2) lst = true;
		give obj ~workflag2;
		if (obj has workflag) give obj workflag2;
		give obj ~workflag;
		if (lst) give obj workflag;
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Utilities.i6t: TestUseOption
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant NO_USE_OPTIONS = 30;
[ TestUseOption 
    UO ! Implied call parameter
    ;
    if (UO == 1) rtrue;
    if (UO == 2) rtrue;
    if (UO == 3) rtrue;
    if (UO == 4) rtrue;
    if (UO == 5) rtrue;
    if (UO == 6) rtrue;
    if (UO == 7) rtrue;
    if (UO == 11) rtrue;
    rfalse;
];
[ PrintUseOption 
    UO ! Implied call parameter
    ;
    switch(UO) {
        0: print "ineffectual option";
        1: print "dynamic memory allocation option [8192]";
        2: print "maximum text length option [1024]";
        3: print "index figure thumbnails option [50]";
        4: print "maximum things understood at once option [100]";
        5: print "American dialect option";
        6: print "serial comma option";
        7: print "full-length room descriptions option";
        8: print "abbreviated room descriptions option";
        9: print "memory economy option";
        10: print "authorial modesty option";
        11: print "scoring option";
        12: print "no scoring option";
        13: print "engineering notation option";
        14: print "unabbreviated object names option";
        15: print "command line echoing option";
        16: print "manual pronouns option";
        17: print "undo prevention option";
        18: print "predictable randomisation option";
        19: print "fast route-finding option";
        20: print "slow route-finding option";
        21: print "numbered rules option";
        22: print "telemetry recordings option";
        23: print "no deprecated features option";
        24: print "gn testing version option";
        25: print "VERBOSE room descriptions option";
        26: print "BRIEF room descriptions option";
        27: print "SUPERBRIEF room descriptions option";
        28: print "sequential action option";
        29: print "Manual Pronouns option";
    }
];



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Utilities.i6t: IntegerDivide
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ IntegerDivide A B;
	if (B == 0) { RunTimeProblem(RTP_DIVZERO); rfalse; }
	return A/B;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Utilities.i6t: IntegerRemainder
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ IntegerRemainder A B;
	if (B == 0) { RunTimeProblem(RTP_DIVZERO); rfalse; }
	return A%B;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Utilities.i6t: UnsignedCompare
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ UnsignedCompare x y u v;
	#Ifdef TARGET_GLULX;
	@jleu x y ?lesseq;
	return 1;
	.lesseq;
	@jeq x y ?equal;
	return -1;
	.equal;
	return 0;
	#Ifnot;
    if (x == y) return 0;
    if (x < 0 && y >= 0) return 1;
    if (x >= 0 && y < 0) return -1;
    u = x&~WORD_HIGHBIT; v= y&~WORD_HIGHBIT;
    if (u > v) return 1;
    return -1;
    #Endif;
];



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Utilities.i6t: SignedCompare
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SignedCompare x y;
	if (x > y) return 1;
	if (x == y) return 0;
	return -1;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Utilities.i6t: ZRegion
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ZRegion addr;
    switch (metaclass(addr)) {
		nothing: return 0;
		Object, Class: return 1;
		Routine: return 2;
		String: return 3;
    }
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Utilities.i6t: Memcpy
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ Memcpy to_addr from_addr size  n;
	for (n = size/WORDSIZE: (n--) > 0: ) to_addr-->n = from_addr-->n;
	for (n = size: ((n--) % WORDSIZE ~= 0): ) to_addr->n = from_addr->n;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Utilities.i6t: Arrcpy
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ Arrcpy to_array to_entry_size from_array from_entry_size no_entries  n val;
	if (to_entry_size == from_entry_size)
		Memcpy(to_array, from_array, to_entry_size*no_entries);
	else if ((to_entry_size == 2) && (from_entry_size == 4)) {
		for (n = 0: n<no_entries: n++) {
			val = from_array-->n;
			to_array->0 = (val/256)%256; to_array->1 = val%256;
			to_array = to_array + 2;
		}
	} else "*** Arrcpy doesn't support this ***";
];



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Parser
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Object InformParser "(Inform Parser)" has proper;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Grammar Line Variables
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Global best_etype;                  ! Preferred error number so far
Global nextbest_etype;              ! Preferred one, if ASKSCOPE_PE disallowed

Global parser_inflection;           ! A property (usually "name") to find object names in

Array pattern --> 32;               ! For the current pattern match
Global pcount;                      ! and a marker within it
Array pattern2 --> 32;              ! And another, which stores the best match
Global pcount2;                     ! so far

Array  line_ttype-->32;             ! For storing an analysed grammar line
Array  line_tdata-->32;
Array  line_token-->32;

Global nsns;                        ! Number of special_numbers entered so far

Global params_wanted;               ! Number of parameters needed (which may change in parsing)

Global inferfrom;                   ! The point from which the rest of the command must be inferred
Global inferword;                   ! And the preposition inferred
Global dont_infer;                  ! Another dull flag

Global cobj_flag = 0;

Global oops_from;                   ! The "first mistake" word number
Global saved_oops;                  ! Used in working this out
Array  oops_workspace -> 64;        ! Used temporarily by "oops" routine

Global held_back_mode;              ! Flag: is there some input from last time
Global hb_wn;                       ! left over?  (And a save value for wn.)
                                    ! (Used for full stops and "then".)

Global usual_grammar_after;         ! Point from which usual grammar is parsed (it may vary from
                                    ! the above if user's routines match multi-word verbs)


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Grammar Token Variables
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant PATTERN_NULL = $ffff;      ! Entry for a token producing no text

Global found_ttype;                 ! Used to break up tokens into type
Global found_tdata;                 ! and data (by AnalyseToken)
Global token_filter;                ! For noun filtering by user routines

Global length_of_noun;              ! Set by NounDomain to no of words in noun

Global lookahead;                   ! The token after the one now being matched

Global multi_mode;                  ! Multiple mode
Global multi_wanted;                ! Number of things needed in multitude
Global multi_had;                   ! Number of things actually found
Global multi_context;               ! What token the multi-obj was accepted for

Global indef_mode;                  ! "Indefinite" mode - ie, "take a brick"
                                    ! is in this mode
Global indef_type;                  ! Bit-map holding types of specification
Global indef_wanted;                ! Number of items wanted (INDEF_ALL_WANTED for all)
Constant INDEF_ALL_WANTED = 32767;
Global indef_guess_p;               ! Plural-guessing flag
Global indef_owner;                 ! Object which must hold these items
Global indef_cases;                 ! Possible gender and numbers of them
Global indef_possambig;             ! Has a possibly dangerous assumption
                                    ! been made about meaning of a descriptor?
Global indef_nspec_at;              ! Word at which a number like "two" was parsed
                                    ! (for backtracking)
Global allow_plurals;               ! Whether plurals presently allowed or not

Global take_all_rule;               ! Slightly different rules apply to "take all" than other uses
                                    ! of multiple objects, to make adjudication produce more
                                    ! pragmatically useful results
                                    ! (Not a flag: possible values 0, 1, 2)

Global dict_flags_of_noun;          ! Of the noun currently being parsed
                                    ! (a bitmap in #dict_par1 format)
Global pronoun__word;               ! Saved value
Global pronoun__obj;                ! Saved value

Constant comma_word = 'comma,';     ! An "untypeable word" used to substitute
                                    ! for commas in parse buffers


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Match List Variables
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Array  match_list --> MATCH_LIST_WORDS;    ! An array of matched objects so far
Array  match_classes --> MATCH_LIST_WORDS; ! An array of equivalence classes for them
Array  match_scores --> MATCH_LIST_WORDS;  ! An array of match scores for them
Global number_matched;              ! How many items in it?  (0 means none)
Global number_of_classes;           ! How many equivalence classes?
Global match_length;                ! How many words long are these matches?
Global match_from;                  ! At what word of the input do they begin?


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Words
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#Ifdef TARGET_ZCODE;
[ WordCount; return parse->1; ];
[ WordAddress wordnum; return buffer + parse->(wordnum*4+1); ];
[ WordLength wordnum; return parse->(wordnum*4); ];
#Ifnot;
[ WordCount; return parse-->0; ];
[ WordAddress wordnum; return buffer + parse-->(wordnum*3); ];
[ WordLength wordnum; return parse-->(wordnum*3-1); ];
#Endif;

[ WordFrom w p i j wc;
	#Ifdef TARGET_ZCODE; wc = p->1; i = w*2-1;
	#Ifnot; wc = p-->0; i = w*3-2; #Endif;
    if ((w < 1) || (w > wc)) return 0;
    j = p-->i;
    if (j == ',//') j = comma_word;
    if (j == './/') j = THEN1__WD;
    return j;
];

[ NextWord i j wc;
	#Ifdef TARGET_ZCODE; wc = parse->1; i = wn*2-1;
	#Ifnot; wc = parse-->0; i = wn*3-2; #Endif;
    wn++;
    if ((wn < 2) || (wn > wc+1)) return 0;
    j = parse-->i;
    if (j == ',//') j = comma_word;
    if (j == './/') j = THEN1__WD;
    return j;
];

[ NextWordStopped wc;
	#Ifdef TARGET_ZCODE; wc = parse->1; #Ifnot; wc = parse-->0; #Endif;
	if ((wn < 1) || (wn > wc)) { wn++; return -1; }
    return NextWord();
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Snippets
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PrintSnippet snip from to i w1 w2;
	w1 = snip/100; w2 = w1 + (snip%100) - 1;
	if ((w2<w1) || (w1<1) || (w2>WordCount())) {
		if ((w1 == 1) && (w2 == 0)) rfalse;
		return RunTimeProblem(RTP_SAYINVALIDSNIPPET, w1, w2);
	}
	from = WordAddress(w1); to = WordAddress(w2) + WordLength(w2) - 1;
	for (i=from: i<=to: i++) print (char) i->0;
];

[ SpliceSnippet snip t i w1 w2 nextw at endsnippet newlen;
	w1 = snip/100; w2 = w1 + (snip%100) - 1;
	if ((w2<w1) || (w1<1)) {
		if ((w1 == 1) && (w2 == 0)) return;
		return RunTimeProblem(RTP_SPLICEINVALIDSNIPPET, w1, w2);
	}
	@push say__p; @push say__pc;
	nextw = w2 + 1;
	at = WordAddress(w1) - buffer;
	if (nextw <= WordCount()) endsnippet = 100*nextw + (WordCount() - nextw + 1);
	buffer2-->0 = 120;
	newlen = VM_PrintToBuffer(buffer2, 120, SpliceSnippet__TextPrinter, t, endsnippet);
	for (i=0: (i<newlen) && (at+i<120): i++) buffer->(at+i) = buffer2->(WORDSIZE+i);
	#Ifdef TARGET_ZCODE; buffer->1 = at+i; #ifnot; buffer-->0 = at+i; #endif;
	for (:at+i<120:i++) buffer->(at+i) = ' ';
	VM_Tokenise(buffer, parse);
	players_command = 100 + WordCount();
	@pull say__pc; @pull say__p;
];

[ SpliceSnippet__TextPrinter t endsnippet;
	TEXT_TY_Say(t);
	if (endsnippet) { print " "; PrintSnippet(endsnippet); }
];

[ SnippetIncludes test snippet w1 w2 wlen i j;
	w1 = snippet/100; w2 = w1 + (snippet%100) - 1;
	if ((w2<w1) || (w1<1)) {
		if ((w1 == 1) && (w2 == 0)) rfalse;
		return RunTimeProblem(RTP_INCLUDEINVALIDSNIPPET, w1, w2);
	}
	if (metaclass(test) == Routine) {
		wlen = snippet%100;
		for (i=w1, j=wlen: j>0: i++, j--) {
			if (((test)(i, 0)) ~= GPR_FAIL) return i*100+wn-i;
		}
	}
	rfalse;
];

[ SnippetMatches snippet topic_gpr rv;
	wn=1;
	if (topic_gpr == 0) rfalse;
	if (metaclass(topic_gpr) == Routine) {
		rv = (topic_gpr)(snippet/100, snippet%100);
		if (rv ~= GPR_FAIL) rtrue;
		rfalse;
	}
	RunTimeProblem(RTP_BADTOPIC);
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Unpacking Grammar Lines
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ UnpackGrammarLine line_address i size;
    for (i=0 : i<32 : i++) {
        line_token-->i = ENDIT_TOKEN;
        line_ttype-->i = ELEMENTARY_TT;
        line_tdata-->i = ENDIT_TOKEN;
    }
#Ifdef TARGET_ZCODE;
    action_to_be = 256*(line_address->0) + line_address->1;
    action_reversed = ((action_to_be & $400) ~= 0);
    action_to_be = action_to_be & $3ff;
    line_address--;
    size = 3;
#Ifnot; ! GLULX
    @aloads line_address 0 action_to_be;
    action_reversed = (((line_address->2) & 1) ~= 0);
    line_address = line_address - 2;
    size = 5;
#Endif;
    params_wanted = 0;
    for (i=0 : : i++) {
        line_address = line_address + size;
        if (line_address->0 == ENDIT_TOKEN) break;
        line_token-->i = line_address;
        AnalyseToken(line_address);
        if (found_ttype ~= PREPOSITION_TT) params_wanted++;
        line_ttype-->i = found_ttype;
        line_tdata-->i = found_tdata;
    }
    return line_address + 1;
];

[ AnalyseToken token;
    if (token == ENDIT_TOKEN) {
        found_ttype = ELEMENTARY_TT;
        found_tdata = ENDIT_TOKEN;
        return;
    }
    found_ttype = (token->0) & $$1111;
    found_tdata = (token+1)-->0;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Extracting Verb Numbers
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ DictionaryWordToVerbNum dword verbnum;
#Ifdef TARGET_ZCODE;
	verbnum = $ff-(dword->#dict_par2);
#Ifnot; ! GLULX
	dword = dword + #dict_par2 - 1;
    @aloads dword 0 verbnum;
    verbnum = $ffff-verbnum;
#Endif;
	return verbnum;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Keyboard Primitive
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ KeyboardPrimitive a_buffer a_table;
#Ifdef DEBUG; #Iftrue (0 > 0);
	return TestKeyboardPrimitive(a_buffer, a_table);
#Endif; #Endif;
	return VM_ReadKeyboard(a_buffer, a_table);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Reading the Command
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ Keyboard  a_buffer a_table  nw i w w2 x1 x2;
	sline1 = score; sline2 = turns;

	while (true) {
		! Save the start of the buffer, in case "oops" needs to restore it
		for (i=0 : i<64 : i++) oops_workspace->i = a_buffer->i;
	
		! In case of an array entry corruption that shouldn't happen, but would be
		! disastrous if it did:
		#Ifdef TARGET_ZCODE;
		a_buffer->0 = INPUT_BUFFER_LEN;
		a_table->0 = 15;  ! Allow to split input into this many words
		#Endif; ! TARGET_
	
		! Print the prompt, and read in the words and dictionary addresses
		PrintPrompt();
		DrawStatusLine();
		KeyboardPrimitive(a_buffer, a_table);
	
		! Set nw to the number of words
		#Ifdef TARGET_ZCODE; nw = a_table->1; #Ifnot; nw = a_table-->0; #Endif;
	
		! If the line was blank, get a fresh line
		if (nw == 0) {
			@push etype; etype = BLANKLINE_PE;
			players_command = 100;
			BeginActivity(PRINTING_A_PARSER_ERROR_ACT);
			if (ForActivity(PRINTING_A_PARSER_ERROR_ACT) == false) {
				PARSER_ERROR_INTERNAL_RM('X', noun); new_line;
			}
			EndActivity(PRINTING_A_PARSER_ERROR_ACT);
			@pull etype;
			continue;
		}
	
		! Unless the opening word was OOPS, return
		! Conveniently, a_table-->1 is the first word on both the Z-machine and Glulx
	
		w = a_table-->1;
		if (w == OOPS1__WD or OOPS2__WD or OOPS3__WD) {
			if (oops_from == 0) { PARSER_COMMAND_INTERNAL_RM('A'); new_line; continue; }
			if (nw == 1) { PARSER_COMMAND_INTERNAL_RM('B'); new_line; continue; }
			if (nw > 2) { PARSER_COMMAND_INTERNAL_RM('C'); new_line; continue; }
		
			! So now we know: there was a previous mistake, and the player has
			! attempted to correct a single word of it.
		
			for (i=0 : i<INPUT_BUFFER_LEN : i++) buffer2->i = a_buffer->i;
			#Ifdef TARGET_ZCODE;
			x1 = a_table->9;  ! Start of word following "oops"
			x2 = a_table->8;  ! Length of word following "oops"
			#Ifnot; ! TARGET_GLULX
			x1 = a_table-->6; ! Start of word following "oops"
			x2 = a_table-->5; ! Length of word following "oops"
			#Endif; ! TARGET_
		
			! Repair the buffer to the text that was in it before the "oops"
			! was typed:
			for (i=0 : i<64 : i++) a_buffer->i = oops_workspace->i;
			VM_Tokenise(a_buffer,a_table);
		
			! Work out the position in the buffer of the word to be corrected:
			#Ifdef TARGET_ZCODE;
			w = a_table->(4*oops_from + 1); ! Start of word to go
			w2 = a_table->(4*oops_from);    ! Length of word to go
			#Ifnot; ! TARGET_GLULX
			w = a_table-->(3*oops_from);      ! Start of word to go
			w2 = a_table-->(3*oops_from - 1); ! Length of word to go
			#Endif; ! TARGET_
		
			! Write spaces over the word to be corrected:
			for (i=0 : i<w2 : i++) a_buffer->(i+w) = ' ';
		
			if (w2 < x2) {
				! If the replacement is longer than the original, move up...
				for (i=INPUT_BUFFER_LEN-1 : i>=w+x2 : i--)
					a_buffer->i = a_buffer->(i-x2+w2);
		
				! ...increasing buffer size accordingly.
				#Ifdef TARGET_ZCODE;
				a_buffer->1 = (a_buffer->1) + (x2-w2);
				#Ifnot; ! TARGET_GLULX
				a_buffer-->0 = (a_buffer-->0) + (x2-w2);
				#Endif; ! TARGET_
			}
		
			! Write the correction in:
			for (i=0 : i<x2 : i++) a_buffer->(i+w) = buffer2->(i+x1);
		
			VM_Tokenise(a_buffer, a_table);
			#Ifdef TARGET_ZCODE; nw = a_table->1; #Ifnot; nw = a_table-->0; #Endif;
		
			return nw;
		}

		! Undo handling
	
		if ((w == UNDO1__WD or UNDO2__WD or UNDO3__WD) && (nw==1)) {
			Perform_Undo();
			continue;
		}
		i = VM_Save_Undo();
		#ifdef PREVENT_UNDO; undo_flag = 0; #endif;
		#ifndef PREVENT_UNDO; undo_flag = 2; #endif;
		if (i == -1) undo_flag = 0;
		if (i == 0) undo_flag = 1;
		if (i == 2) {
			VM_RestoreWindowColours();
			VM_Style(SUBHEADER_VMSTY);
			SL_Location(); print "^";
			! print (name) location, "^";
			VM_Style(NORMAL_VMSTY);
			IMMEDIATELY_UNDO_RM('E'); new_line;
			continue;
		}
		return nw;
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Parser Proper
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ Parser__parse
	syntax line num_lines line_address i j k token l m inferred_go;
	cobj_flag = 0;
	parser_results-->ACTION_PRES = 0;
	parser_results-->NO_INPS_PRES = 0;
	parser_results-->INP1_PRES = 0;
	parser_results-->INP2_PRES = 0;
	meta = false;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Parser Letter A
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

    if (held_back_mode == 1) {
        held_back_mode = 0;
        VM_Tokenise(buffer, parse);
        jump ReParse;
    }

  .ReType;

	cobj_flag = 0;
	actors_location = ScopeCeiling(player);
    BeginActivity(READING_A_COMMAND_ACT); if (ForActivity(READING_A_COMMAND_ACT)==false) {
		Keyboard(buffer,parse);
		num_words = WordCount(); players_command = 100 + num_words;
    } if (EndActivity(READING_A_COMMAND_ACT)) jump ReType;

  .ReParse;

    parser_inflection = name;

    ! Initially assume the command is aimed at the player, and the verb
    ! is the first word

    num_words = WordCount(); players_command = 100 + num_words;
    wn = 1; inferred_go = false;

    #Ifdef LanguageToInformese;
    LanguageToInformese();
    ! Re-tokenise:
    VM_Tokenise(buffer,parse);
    #Endif; ! LanguageToInformese

    num_words = WordCount(); players_command = 100 + num_words;

    k=0;
    #Ifdef DEBUG;
    if (parser_trace >= 2) {
        print "[ ";
        for (i=0 : i<num_words : i++) {

            #Ifdef TARGET_ZCODE;
            j = parse-->(i*2 + 1);
            #Ifnot; ! TARGET_GLULX
            j = parse-->(i*3 + 1);
            #Endif; ! TARGET_
            k = WordAddress(i+1);
            l = WordLength(i+1);
            print "~"; for (m=0 : m<l : m++) print (char) k->m; print "~ ";

            if (j == 0) print "?";
            else {
                #Ifdef TARGET_ZCODE;
                if (UnsignedCompare(j, HDR_DICTIONARY-->0) >= 0 &&
                    UnsignedCompare(j, HDR_HIGHMEMORY-->0) < 0)
                     print (address) j;
                else print j;
                #Ifnot; ! TARGET_GLULX
                if (j->0 == $60) print (address) j;
                else print j;
                #Endif; ! TARGET_
            }
            if (i ~= num_words-1) print " / ";
        }
        print " ]^";
    }
    #Endif; ! DEBUG
    verb_wordnum = 1;
    actor = player;
    actors_location = ScopeCeiling(player);
    usual_grammar_after = 0;

  .AlmostReParse;

    scope_token = 0;
    action_to_be = NULL;

    ! Begin from what we currently think is the verb word

  .BeginCommand;

    wn = verb_wordnum;
    verb_word = NextWordStopped();

    ! If there's no input here, we must have something like "person,".

    if (verb_word == -1) {
        best_etype = STUCK_PE; jump GiveError;
    }
	if (verb_word == comma_word) {
		best_etype = COMMABEGIN_PE; jump GiveError;
	}

    ! Now try for "again" or "g", which are special cases: don't allow "again" if nothing
    ! has previously been typed; simply copy the previous text across

    if (verb_word == AGAIN2__WD or AGAIN3__WD) verb_word = AGAIN1__WD;
    if (verb_word == AGAIN1__WD) {
        if (actor ~= player) {
            best_etype = ANIMAAGAIN_PE;
			jump GiveError;
        }
        #Ifdef TARGET_ZCODE;
        if (buffer3->1 == 0) {
            PARSER_COMMAND_INTERNAL_RM('D'); new_line;
            jump ReType;
        }
        #Ifnot; ! TARGET_GLULX
        if (buffer3-->0 == 0) {
            PARSER_COMMAND_INTERNAL_RM('D'); new_line;
            jump ReType;
        }
        #Endif; ! TARGET_
        for (i=0 : i<INPUT_BUFFER_LEN : i++) buffer->i = buffer3->i;
        VM_Tokenise(buffer,parse);
		num_words = WordCount(); players_command = 100 + num_words;
    	jump ReParse;
    }

    ! Save the present input in case of an "again" next time

    if (verb_word ~= AGAIN1__WD)
        for (i=0 : i<INPUT_BUFFER_LEN : i++) buffer3->i = buffer->i;

    if (usual_grammar_after == 0) {
        j = verb_wordnum;
        i = RunRoutines(actor, grammar); 
        #Ifdef DEBUG;
        if (parser_trace >= 2 && actor.grammar ~= 0 or NULL)
            print " [Grammar property returned ", i, "]^";
        #Endif; ! DEBUG

        if ((i ~= 0 or 1) && (VM_InvalidDictionaryAddress(i))) {
            usual_grammar_after = verb_wordnum; i=-i;
        }

        if (i == 1) {
            parser_results-->ACTION_PRES = action;
            parser_results-->NO_INPS_PRES = 0;
            parser_results-->INP1_PRES = noun;
            parser_results-->INP2_PRES = second;
            if (noun) parser_results-->NO_INPS_PRES = 1;
            if (second) parser_results-->NO_INPS_PRES = 2;
            rtrue;
        }
        if (i ~= 0) { verb_word = i; wn--; verb_wordnum--; }
        else { wn = verb_wordnum; verb_word = NextWord(); }
    }
    else usual_grammar_after = 0;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Parser Letter B
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

    #Ifdef LanguageIsVerb;
    if (verb_word == 0) {
        i = wn; verb_word = LanguageIsVerb(buffer, parse, verb_wordnum);
        wn = i;
    }
    #Endif; ! LanguageIsVerb

    ! If the first word is not listed as a verb, it must be a direction
    ! or the name of someone to talk to

    if (verb_word == 0 || ((verb_word->#dict_par1) & 1) == 0) {

        ! So is the first word an object contained in the special object "compass"
        ! (i.e., a direction)?  This needs use of NounDomain, a routine which
        ! does the object matching, returning the object number, or 0 if none found,
        ! or REPARSE_CODE if it has restructured the parse table so the whole parse
        ! must be begun again...

        wn = verb_wordnum; indef_mode = false; token_filter = 0; parameters = 0;
        @push actor; @push action; @push action_to_be;
        actor = player; meta = false; action = ##Go; action_to_be = ##Go;
        l = NounDomain(compass, 0, 0);
        @pull action_to_be; @pull action; @pull actor;
        if (l == REPARSE_CODE) jump ReParse;

        ! If it is a direction, send back the results:
        ! action=GoSub, no of arguments=1, argument 1=the direction.

        if ((l~=0) && (l ofclass K3_direction)) {
            parser_results-->ACTION_PRES = ##Go;
            parser_results-->NO_INPS_PRES = 1;
            parser_results-->INP1_PRES = l;
            inferred_go = true;
            jump LookForMore;
        }

    } ! end of first-word-not-a-verb


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Parser Letter C
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

	! Only check for a comma (a "someone, do something" command) if we are
	! not already in the middle of one.  (This simplification stops us from
	! worrying about "robot, wizard, you are an idiot", telling the robot to
	! tell the wizard that she is an idiot.)
	
	if (actor == player) {
		for (j=2 : j<=num_words : j++) {
			i=NextWord();
			if (i == comma_word) jump Conversation;
		}
	}
	jump NotConversation;
	
	! NextWord nudges the word number wn on by one each time, so we've now
	! advanced past a comma.  (A comma is a word all on its own in the table.)
	
	.Conversation;
	
	j = wn - 1;
	
	! Use NounDomain (in the context of "animate creature") to see if the
	! words make sense as the name of someone held or nearby
	
	wn = 1; lookahead = HELD_TOKEN;
	scope_reason = TALKING_REASON;
	l = NounDomain(player,actors_location,6);
	scope_reason = PARSING_REASON;
	if (l == REPARSE_CODE) jump ReParse;
	if (l == 0) {
		if (verb_word && ((verb_word->#dict_par1) & 1)) jump NotConversation;
		best_etype = MISSINGPERSON_PE; jump GiveError;
	}
	
	.Conversation2;
	
	! The object addressed must at least be "talkable" if not actually "animate"
	! (the distinction allows, for instance, a microphone to be spoken to,
	! without the parser thinking that the microphone is human).
	
	if (l hasnt animate && l hasnt talkable) {
 		best_etype = ANIMALISTEN_PE; noun = l; jump GiveError;
	}
	
	! Check that there aren't any mystery words between the end of the person's
	! name and the comma (eg, throw out "dwarf sdfgsdgs, go north").
	
	if (wn ~= j) {
		if (verb_word && ((verb_word->#dict_par1) & 1)) jump NotConversation;
		best_etype = TOTALK_PE; jump GiveError;
	}
	
	! The player has now successfully named someone.  Adjust "him", "her", "it":
	
	PronounNotice(l);
	
	! Set the global variable "actor", adjust the number of the first word,
	! and begin parsing again from there.
	
	verb_wordnum = j + 1;
	
	! Stop things like "me, again":
	
	if (l == player) {
		wn = verb_wordnum;
		if (NextWordStopped() == AGAIN1__WD or AGAIN2__WD or AGAIN3__WD) {
			best_etype = ANIMAAGAIN_PE;
			jump GiveError;
		}
	}
	
	actor = l;
	actors_location = ScopeCeiling(l);
	#Ifdef DEBUG;
	if (parser_trace >= 1)
		print "[Actor is ", (the) actor, " in ", (name) actors_location, "]^";
	#Endif; ! DEBUG
	jump BeginCommand;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Parser Letter D
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

	.NotConversation;
	if (verb_word == 0 || ((verb_word->#dict_par1) & 1) == 0) {
		if (actor == player) {
			verb_word = UnknownVerb(verb_word);
			if (verb_word ~= 0) jump VerbAccepted;
		}
		best_etype = VERB_PE;
		jump GiveError;
	}
	.VerbAccepted;

    ! We now definitely have a verb, not a direction, whether we got here by the
    ! "take ..." or "person, take ..." method.  Get the meta flag for this verb:

    meta = ((verb_word->#dict_par1) & 2)/2;

    ! You can't order other people to "full score" for you, and so on...

    if (meta == 1 && actor ~= player) {
        best_etype = VERB_PE;
        meta = 0;
        jump GiveError;
    }

    ! Now let i be the corresponding verb number...

    i = DictionaryWordToVerbNum(verb_word);

    ! ...then look up the i-th entry in the verb table, whose address is at word
    ! 7 in the Z-machine (in the header), so as to get the address of the syntax
    ! table for the given verb...

    #Ifdef TARGET_ZCODE;
    syntax = (HDR_STATICMEMORY-->0)-->i;
    #Ifnot; ! TARGET_GLULX
    syntax = (#grammar_table)-->(i+1);
    #Endif; ! TARGET_

    ! ...and then see how many lines (ie, different patterns corresponding to the
    ! same verb) are stored in the parse table...

    num_lines = (syntax->0) - 1;

    ! ...and now go through them all, one by one.
    ! To prevent pronoun_word 0 being misunderstood,

    pronoun_word = NULL; pronoun_obj = NULL;

    #Ifdef DEBUG;
    if (parser_trace >= 1)
    	print "[Parsing for the verb '", (address) verb_word, "' (", num_lines+1, " lines)]^";
    #Endif; ! DEBUG

    best_etype = STUCK_PE; nextbest_etype = STUCK_PE;
    multiflag = false;

    ! "best_etype" is the current failure-to-match error - it is by default
    ! the least informative one, "don't understand that sentence".
    ! "nextbest_etype" remembers the best alternative to having to ask a
    ! scope token for an error message (i.e., the best not counting ASKSCOPE_PE).
    ! multiflag is used here to prevent inappropriate MULTI_PE errors
    ! in addition to its unrelated duties passing information to action routines


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Parser Letter E
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

    line_address = syntax + 1;

    for (line=0 : line<=num_lines : line++) {

        ! Unpack the syntax line from Inform format into three arrays; ensure that
        ! the sequence of tokens ends in an ENDIT_TOKEN.

        line_address = UnpackGrammarLine(line_address);

        #Ifdef DEBUG;
        if (parser_trace >= 1) {
            if (parser_trace >= 2) new_line;
            print "[line ", line; DebugGrammarLine();
            print "]^";
        }
        #Endif; ! DEBUG

        ! We aren't in "not holding" or inferring modes, and haven't entered
        ! any parameters on the line yet, or any special numbers; the multiple
        ! object is still empty.

        inferfrom = 0;
        parameters = 0;
        nsns = 0; special_word = 0;
        multiple_object-->0 = 0;
        multi_context = 0;
        etype = STUCK_PE;

        ! Put the word marker back to just after the verb

        wn = verb_wordnum+1;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Parser Letter F
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

        advance_warning = -1; indef_mode = false;
        for (i=0,m=false,pcount=0 : line_token-->pcount ~= ENDIT_TOKEN : pcount++) {
            scope_token = 0;

            if (line_ttype-->pcount ~= PREPOSITION_TT) i++;

            if (line_ttype-->pcount == ELEMENTARY_TT) {
                if (line_tdata-->pcount == MULTI_TOKEN) m = true;
                if (line_tdata-->pcount == MULTIEXCEPT_TOKEN or MULTIINSIDE_TOKEN  && i == 1) {
                    ! First non-preposition is "multiexcept" or
                    ! "multiinside", so look ahead.

                    #Ifdef DEBUG;
                    if (parser_trace >= 2) print " [Trying look-ahead]^";
                    #Endif; ! DEBUG

                    ! We need this to be followed by 1 or more prepositions.

                    pcount++;
                    if (line_ttype-->pcount == PREPOSITION_TT) {
                        ! skip ahead to a preposition word in the input
                        do {
                            l = NextWord();
                        } until ((wn > num_words) ||
                                 (l && (l->#dict_par1) & 8 ~= 0));
                        
                        if (wn > num_words) {
                            #Ifdef DEBUG;
                            if (parser_trace >= 2)
                                print " [Look-ahead aborted: prepositions missing]^";
                            #Endif;
                            jump EmptyLine;
                        }
                        
                        do {
                            if (PrepositionChain(l, pcount) ~= -1) {
                                ! advance past the chain
                                if ((line_token-->pcount)->0 & $20 ~= 0) {
                                    pcount++;
                                    while ((line_token-->pcount ~= ENDIT_TOKEN) &&
                                           ((line_token-->pcount)->0 & $10 ~= 0))
                                        pcount++;
                                } else {
                                    pcount++;
                                }
                            } else {
                                ! try to find another preposition word
                                do {
                                    l = NextWord();
                                } until ((wn >= num_words) ||
                                         (l && (l->#dict_par1) & 8 ~= 0));
                                
                                if (l && (l->#dict_par1) & 8) continue;
                                
                                ! lookahead failed
                                #Ifdef DEBUG;
                                if (parser_trace >= 2)
                                    print " [Look-ahead aborted: prepositions don't match]^";
                                #endif;
                                jump LineFailed;
                            }
                            if (wn <= num_words) l = NextWord();
                        } until (line_ttype-->pcount ~= PREPOSITION_TT);
                        
                        .EmptyLine;
                        ! put back the non-preposition we just read
                        wn--;

                        if ((line_ttype-->pcount == ELEMENTARY_TT) &&
                        	(line_tdata-->pcount == NOUN_TOKEN)) {
                            l = Descriptors();  ! skip past THE etc
                            if (l~=0) etype=l;  ! don't allow multiple objects
                        	k = parser_results-->INP1_PRES; @push k; @push parameters;
                        	parameters = 1; parser_results-->INP1_PRES = 0;
                            l = NounDomain(actors_location, actor, NOUN_TOKEN, true);
                            @pull parameters; @pull k; parser_results-->INP1_PRES = k;
                            #Ifdef DEBUG;
                            if (parser_trace >= 2) {
                                print " [Advanced to ~noun~ token: ";
                                if (l == REPARSE_CODE) print "re-parse request]^";
                                else {
                                	if (l == 1) print "but multiple found]^";
                                	if (l == 0) print "error ", etype, "]^";
                                	if (l >= 2) print (the) l, "]^";
                                }
                            }
                            #Endif; ! DEBUG
                            if (l == REPARSE_CODE) jump ReParse;
                            if (l >= 2) advance_warning = l;
                        }
                    }
                    break;
                }
            }
        }

        ! Slightly different line-parsing rules will apply to "take multi", to
        ! prevent "take all" behaving correctly but misleadingly when there's
        ! nothing to take.

        take_all_rule = 0;
        if (m && params_wanted == 1 && action_to_be == ##Take)
            take_all_rule = 1;

        ! And now start again, properly, forearmed or not as the case may be.
        ! As a precaution, we clear all the variables again (they may have been
        ! disturbed by the call to NounDomain, which may have called outside
        ! code, which may have done anything!).

        inferfrom = 0;
        parameters = 0;
        nsns = 0; special_word = 0;
        multiple_object-->0 = 0;
        etype = STUCK_PE;
        wn = verb_wordnum+1;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Parser Letter G
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

		m = true;
        for (pcount=1 : : pcount++)
            if (line_token-->(pcount-1) == ENDIT_TOKEN) {
            	if (pcount >= 2) {
            		while ((((line_token-->(pcount-2))->0) & $10) ~= 0) pcount--;
            		AnalyseToken(line_token-->(pcount-2));
            		if (found_ttype == PREPOSITION_TT) {
            			l = -1;
            			while (true) {
            				m = NextWordStopped();
            				if (m == -1) break;
            				l = m;
            			}
            			if (PrepositionChain(l, pcount-2) == -1) {
            				m = false;
							#Ifdef DEBUG;
							if (parser_trace >= 2)
								print "[line rejected for not ending with correct preposition]^";
							#Endif; ! DEBUG
						} else m = true;
	           		}
            	}
            	break;
            }
		wn = verb_wordnum+1;

		if (m) for (pcount=1 : : pcount++) {
            pattern-->pcount = PATTERN_NULL; scope_token = 0;

            token = line_token-->(pcount-1);
            lookahead = line_token-->pcount;

            #Ifdef DEBUG;
            if (parser_trace >= 2)
                print " [line ", line, " token ", pcount, " word ", wn, " : ", (DebugToken) token,
                  "]^";
            #Endif; ! DEBUG

            if (token ~= ENDIT_TOKEN) {
                scope_reason = PARSING_REASON;
                AnalyseToken(token);

                l = ParseToken(found_ttype, found_tdata, pcount-1, token);
                while ((l >= GPR_NOUN) && (l < -1)) l = ParseToken(ELEMENTARY_TT, l + 256);
                scope_reason = PARSING_REASON;

                if (l == GPR_PREPOSITION) {
                    if (found_ttype~=PREPOSITION_TT && (found_ttype~=ELEMENTARY_TT ||
                        found_tdata~=TOPIC_TOKEN)) params_wanted--;
                    l = true;
                }
                else
                    if (l < 0) l = false;
                    else
                        if (l ~= GPR_REPARSE) {
                            if (l == GPR_NUMBER) {
                                if (nsns == 0) special_number1 = parsed_number;
                                else special_number2 = parsed_number;
                                nsns++; l = 1;
                            }
                            if (l == GPR_MULTIPLE) l = 0;
                            parser_results-->(parameters+INP1_PRES) = l;
                            parameters++;
                            pattern-->pcount = l;
                            l = true;
                        }

                #Ifdef DEBUG;
                if (parser_trace >= 3) {
                    print "  [token resulted in ";
                    if (l == REPARSE_CODE) print "re-parse request]^";
                    if (l == 0) print "failure with error type ", etype, "]^";
                    if (l == 1) print "success]^";
                }
                #Endif; ! DEBUG

                if (l == REPARSE_CODE) jump ReParse;
                if (l == false) break;
            }
            else {

                ! If the player has entered enough already but there's still
                ! text to wade through: store the pattern away so as to be able to produce
                ! a decent error message if this turns out to be the best we ever manage,
                ! and in the mean time give up on this line

                ! However, if the superfluous text begins with a comma or "then" then
                ! take that to be the start of another instruction

                if (wn <= num_words) {
                    l = NextWord();
                    if (l == THEN1__WD or THEN2__WD or THEN3__WD or comma_word) {
                        held_back_mode = 1; hb_wn = wn-1;
                    }
                    else {
                        for (m=0 : m<32 : m++) pattern2-->m = pattern-->m;
                        pcount2 = pcount;
                        etype = UPTO_PE;
                        break;
                    }
                }

                ! Now, we may need to revise the multiple object because of the single one
                ! we now know (but didn't when the list was drawn up).

                if (parameters >= 1) {
                	if (parser_results-->INP1_PRES == 0) {
                	    l = ReviseMulti(parser_results-->INP2_PRES);
                	    if (l ~= 0) { etype = l; parser_results-->ACTION_PRES = action_to_be; break; }
                	}
                }
                if (parameters >= 2) {
                	if (parser_results-->INP2_PRES == 0) {
            	        l = ReviseMulti(parser_results-->INP1_PRES);
                	    if (l ~= 0) { etype = l; break; }
                	} else {
                		k = parser_results-->INP1_PRES; l = parser_results-->INP2_PRES;
                		if (k && l) {
	                 		if ((multi_context==MULTIEXCEPT_TOKEN && k == l) ||
	                			((multi_context==MULTIINSIDE_TOKEN && k notin l && l notin k))) {
                				best_etype = NOTHING_PE;
                				parser_results-->ACTION_PRES = action_to_be; jump GiveError;
                			}
                		}
                	}
                }

                ! To trap the case of "take all" inferring only "yourself" when absolutely
                ! nothing else is in the vicinity...

                if (take_all_rule == 2 && parser_results-->INP1_PRES == actor) {
                    best_etype = NOTHING_PE;
                    jump GiveError;
                }

                #Ifdef DEBUG;
                if (parser_trace >= 1) print "[Line successfully parsed]^";
                #Endif; ! DEBUG

                ! The line has successfully matched the text.  Declare the input error-free...

                oops_from = 0;

                ! ...explain any inferences made (using the pattern)...

                if (inferfrom ~= 0) {
                	PrintInferredCommand(inferfrom);
                    ClearParagraphing(20);
                }

                ! ...copy the action number, and the number of parameters...

                parser_results-->ACTION_PRES = action_to_be;
                parser_results-->NO_INPS_PRES = parameters;

                ! ...reverse first and second parameters if need be...

                if (action_reversed && parameters == 2) {
                    i = parser_results-->INP1_PRES;
                    parser_results-->INP1_PRES = parser_results-->INP2_PRES;
                    parser_results-->INP2_PRES = i;
                    if (nsns == 2) {
                        i = special_number1; special_number1 = special_number2;
                        special_number2 = i;
                    }
                }

                ! ...and to reset "it"-style objects to the first of these parameters, if
                ! there is one (and it really is an object)...

                if (parameters > 0 && parser_results-->INP1_PRES >= 2)
                    PronounNotice(parser_results-->INP1_PRES);

                ! ...and return from the parser altogether, having successfully matched
                ! a line.

                if (held_back_mode == 1) {
                    wn=hb_wn;
                    jump LookForMore;
                }
                rtrue;

            } ! end of if(token ~= ENDIT_TOKEN) else
        } ! end of for(pcount++)

        .LineFailed;
        ! The line has failed to match.
        ! We continue the outer "for" loop, trying the next line in the grammar.

        if (etype > best_etype) best_etype = etype;
        if (etype ~= ASKSCOPE_PE && etype > nextbest_etype) nextbest_etype = etype;

        ! ...unless the line was something like "take all" which failed because
        ! nothing matched the "all", in which case we stop and give an error now.

        if (take_all_rule == 2 && etype==NOTHING_PE) break;

    } ! end of for(line++)

    ! The grammar is exhausted: every line has failed to match.


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Parser Letter H
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

  .GiveError;

    etype = best_etype;
    if (actor ~= player) {
        if (usual_grammar_after ~= 0) {
            verb_wordnum = usual_grammar_after;
            jump AlmostReParse;
        }
        wn = verb_wordnum;
        special_word = NextWord();
        if (special_word == comma_word) {
            special_word = NextWord();
            verb_wordnum++;
        }
        parser_results-->ACTION_PRES = ##Answer;
        parser_results-->NO_INPS_PRES = 2;
        parser_results-->INP1_PRES = actor;
        parser_results-->INP2_PRES = 1; special_number1 = special_word;
        actor = player;
        consult_from = verb_wordnum; consult_words = num_words-consult_from+1;
        rtrue;
    }


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Parser Letter I
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

    ! If the player was the actor (eg, in "take dfghh") the error must be printed,
    ! and fresh input called for.  In three cases the oops word must be jiggled.

    if ((etype ofclass Routine) || (etype ofclass String)) {
        if (ParserError(etype) ~= 0) jump ReType;
    } else {
		if (verb_wordnum == 0 && etype == CANTSEE_PE) etype = VERB_PE;
		players_command = 100 + WordCount(); ! The snippet variable "player's command"
        BeginActivity(PRINTING_A_PARSER_ERROR_ACT);
        if (ForActivity(PRINTING_A_PARSER_ERROR_ACT)) jump SkipParserError;
    }
    pronoun_word = pronoun__word; pronoun_obj = pronoun__obj;

    if (etype == STUCK_PE) {    PARSER_ERROR_INTERNAL_RM('A'); new_line; oops_from = 1; }
    if (etype == UPTO_PE) {
    	if (inferred_go) PARSER_ERROR_INTERNAL_RM('C');
    	else PARSER_ERROR_INTERNAL_RM('B');
        for (m=0 : m<32 : m++) pattern-->m = pattern2-->m;
        pcount = pcount2; PrintCommand(0);
        print ".^";
    }
    if (etype == NUMBER_PE) {   PARSER_ERROR_INTERNAL_RM('D'); new_line; }
    if (etype == CANTSEE_PE) {  PARSER_ERROR_INTERNAL_RM('E'); new_line; oops_from=saved_oops; }
    if (etype == TOOLIT_PE) {   PARSER_ERROR_INTERNAL_RM('F'); new_line; }
    if (etype == NOTHELD_PE) {  PARSER_ERROR_INTERNAL_RM('G'); new_line; oops_from=saved_oops; }
    if (etype == MULTI_PE) {    PARSER_ERROR_INTERNAL_RM('H'); new_line; }
    if (etype == MMULTI_PE) {   PARSER_ERROR_INTERNAL_RM('I'); new_line; }
    if (etype == VAGUE_PE) {    PARSER_ERROR_INTERNAL_RM('J'); new_line; }
    if (etype == ITGONE_PE) {
        if (pronoun_obj == NULL) { PARSER_ERROR_INTERNAL_RM('J'); new_line; }
        else { PARSER_ERROR_INTERNAL_RM('K', noun); new_line; }
    }
    if (etype == EXCEPT_PE) {   PARSER_ERROR_INTERNAL_RM('L'); new_line; }
    if (etype == ANIMA_PE) {    PARSER_ERROR_INTERNAL_RM('M'); new_line; }
    if (etype == VERB_PE) {     PARSER_ERROR_INTERNAL_RM('N'); new_line; }
    if (etype == SCENERY_PE) {  PARSER_ERROR_INTERNAL_RM('O'); new_line; }
    if (etype == JUNKAFTER_PE) {  PARSER_ERROR_INTERNAL_RM('P'); new_line; }
    if (etype == TOOFEW_PE) {  PARSER_ERROR_INTERNAL_RM('Q', multi_had); new_line; }
    if (etype == NOTHING_PE) {
    	if (parser_results-->ACTION_PRES == ##Remove &&
        	parser_results-->INP2_PRES ofclass Object) {
        	noun = parser_results-->INP2_PRES; ! ensure valid for messages
            if (noun has animate) { PARSER_N_ERROR_INTERNAL_RM('C', noun); new_line; }
            else if (noun hasnt container or supporter) { PARSER_N_ERROR_INTERNAL_RM('D', noun); new_line; }
            else if (noun has container && noun hasnt open)  { PARSER_N_ERROR_INTERNAL_RM('E', noun); new_line; }
            else if (children(noun)==0) { PARSER_N_ERROR_INTERNAL_RM('F', noun); new_line; }
            else parser_results-->ACTION_PRES = 0;
        }
        if (parser_results-->ACTION_PRES ~= ##Remove) {
            if (multi_wanted==100) { PARSER_N_ERROR_INTERNAL_RM('A'); new_line; }
            else                  {  PARSER_N_ERROR_INTERNAL_RM('B'); new_line; }
        }
    }
    if (etype == NOTINCONTEXT_PE) { PARSER_ERROR_INTERNAL_RM('R'); new_line; }
    if (etype == ANIMAAGAIN_PE) { PARSER_ERROR_INTERNAL_RM('S'); new_line; }
    if (etype == COMMABEGIN_PE) { PARSER_ERROR_INTERNAL_RM('T'); new_line; }
    if (etype == MISSINGPERSON_PE) { PARSER_ERROR_INTERNAL_RM('U'); new_line; }
    if (etype == ANIMALISTEN_PE) { PARSER_ERROR_INTERNAL_RM('V', noun); new_line; }
    if (etype == TOTALK_PE) { PARSER_ERROR_INTERNAL_RM('W'); new_line; }
    if (etype == ASKSCOPE_PE) {
        scope_stage = 3;
        if (indirect(scope_error) == -1) {
            best_etype = nextbest_etype;
            if (~~((etype ofclass Routine) || (etype ofclass String)))
            	EndActivity(PRINTING_A_PARSER_ERROR_ACT);
            jump GiveError;
        }
    }

    .SkipParserError;
    if ((etype ofclass Routine) || (etype ofclass String)) jump ReType;
    say__p = 1;
    EndActivity(PRINTING_A_PARSER_ERROR_ACT);


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Parser Letter J
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

    ! And go (almost) right back to square one...

    jump ReType;

    ! ...being careful not to go all the way back, to avoid infinite repetition
    ! of a deferred command causing an error.


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Parser Letter K
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

    ! At this point, the return value is all prepared, and we are only looking
    ! to see if there is a "then" followed by subsequent instruction(s).

  .LookForMore;

    if (wn > num_words) rtrue;

    i = NextWord();
    if (i == THEN1__WD or THEN2__WD or THEN3__WD or comma_word) {
        if (wn > num_words) {
           held_back_mode = false;
           return;
        }
        if (verb_wordnum > 0) i = WordAddress(verb_wordnum); else i = WordAddress(1);
        j = WordAddress(wn);
        if (i<=j) for (: i<j : i++) i->0 = ' ';
        i = NextWord();
        if (i == AGAIN1__WD or AGAIN2__WD or AGAIN3__WD) {
            ! Delete the words "then again" from the again buffer,
            ! in which we have just realised that it must occur:
            ! prevents an infinite loop on "i. again"

            i = WordAddress(wn-2)-buffer;
            if (wn > num_words) j = INPUT_BUFFER_LEN-1;
            else j = WordAddress(wn)-buffer;
            for (: i<j : i++) buffer3->i = ' ';
        }
        VM_Tokenise(buffer,parse);
        held_back_mode = true;
        return;
    }
    best_etype = UPTO_PE;
    jump GiveError;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: End of Parser Proper
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

]; ! end of Parser__parse


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Internal Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PARSER_ERROR_INTERNAL_R; ];
[ PARSER_N_ERROR_INTERNAL_R; ];
[ PARSER_COMMAND_INTERNAL_R; ];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Parse Token
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ParseTokenStopped x y;
	if (wn>WordCount()) return GPR_FAIL;
	return ParseToken(x,y);
];

Global parsetoken_nesting = 0;
[ ParseToken given_ttype given_tdata token_n token  i t rv;
	if (parsetoken_nesting > 0) {
		! save match globals
		@push match_from; @push token_filter; @push match_length;
		@push number_of_classes; @push oops_from;
		for (i=0: i<number_matched: i++) {
			t = match_list-->i; @push t;
			t = match_classes-->i; @push t;
			t = match_scores-->i; @push t;
		}
		@push number_matched;
	 }

	parsetoken_nesting++;
	rv = ParseToken__(given_ttype, given_tdata, token_n, token);
	parsetoken_nesting--;

	if (parsetoken_nesting > 0) {
		! restore match globals
		@pull number_matched;
		for (i=number_matched-1: i>=0: i--) {
 			@pull t; match_scores-->i = t;
			@pull t; match_classes-->i = t;
			@pull t; match_list-->i = t;
   		}
		@pull oops_from; @pull number_of_classes;
		@pull match_length; @pull token_filter; @pull match_from;
	}
	return rv;
];

[ ParseToken__ given_ttype given_tdata token_n token
	l o i j k and_parity single_object desc_wn many_flag
	token_allows_multiple prev_indef_wanted;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Parse Token Letter A
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

    token_filter = 0;
    parser_inflection = name;

    switch (given_ttype) {
      ELEMENTARY_TT:
        switch (given_tdata) {
          SPECIAL_TOKEN:
            l = TryNumber(wn);
            special_word = NextWord();
            #Ifdef DEBUG;
            if (l ~= -1000)
                if (parser_trace >= 3) print "  [Read special as the number ", l, "]^";
            #Endif; ! DEBUG
            if (l == -1000) {
                #Ifdef DEBUG;
                if (parser_trace >= 3) print "  [Read special word at word number ", wn, "]^";
                #Endif; ! DEBUG
                l = special_word;
            }
            parsed_number = l;
            return GPR_NUMBER;

          NUMBER_TOKEN:
            l=TryNumber(wn++);
            if (l == -1000) {
                etype = NUMBER_PE;
                return GPR_FAIL;
            }
            #Ifdef DEBUG;
            if (parser_trace>=3) print "  [Read number as ", l, "]^";
            #Endif; ! DEBUG
            parsed_number = l;
            return GPR_NUMBER;

          CREATURE_TOKEN:
            if (action_to_be == ##Answer or ##Ask or ##AskFor or ##Tell)
                scope_reason = TALKING_REASON;

          TOPIC_TOKEN:
            consult_from = wn;
            if ((line_ttype-->(token_n+1) ~= PREPOSITION_TT) &&
               (line_token-->(token_n+1) ~= ENDIT_TOKEN)) {
               	RunTimeProblem(RTP_TEXTTOKENTOOHARD);
               	return GPR_PREPOSITION;
        	}
            do o = NextWordStopped();
            until (o == -1 || PrepositionChain(o, token_n+1) ~= -1);
            wn--;
            consult_words = wn-consult_from;
            if (consult_words == 0) return GPR_FAIL;
            if (action_to_be == ##Ask or ##Answer or ##Tell) {
                o = wn; wn = consult_from; parsed_number = NextWord();
                wn = o; return 1;
            }
            if (o==-1 && (line_ttype-->(token_n+1) == PREPOSITION_TT))
                return GPR_FAIL;    ! don't infer if required preposition is absent
            return GPR_PREPOSITION;
        }

      PREPOSITION_TT:
        ! Is it an unnecessary alternative preposition, when a previous choice
        ! has already been matched?
        if ((token->0) & $10) return GPR_PREPOSITION;

        ! If we've run out of the player's input, but still have parameters to
        ! specify, we go into "infer" mode, remembering where we are and the
        ! preposition we are inferring...

        if (wn > num_words) {
            if (inferfrom==0 && parameters<params_wanted) {
                inferfrom = pcount; inferword = token;
                pattern-->pcount = REPARSE_CODE + VM_DictionaryAddressToNumber(given_tdata);
            }

            ! If we are not inferring, then the line is wrong...

            if (inferfrom == 0) return -1;

            ! If not, then the line is right but we mark in the preposition...

            pattern-->pcount = REPARSE_CODE + VM_DictionaryAddressToNumber(given_tdata);
            return GPR_PREPOSITION;
        }

        o = NextWord();

        pattern-->pcount = REPARSE_CODE + VM_DictionaryAddressToNumber(o);

        ! Whereas, if the player has typed something here, see if it is the
        ! required preposition... if it's wrong, the line must be wrong,
        ! but if it's right, the token is passed (jump to finish this token).

        if (o == given_tdata) return GPR_PREPOSITION;
        if (PrepositionChain(o, token_n) ~= -1) return GPR_PREPOSITION;
        return -1;

      GPR_TT:
        l = indirect(given_tdata);
        #Ifdef DEBUG;
        if (parser_trace >= 3) print "  [Outside parsing routine returned ", l, "]^";
        #Endif; ! DEBUG
        return l;

      SCOPE_TT:
        scope_token = given_tdata;
        scope_stage = 1;
        #Ifdef DEBUG;
        if (parser_trace >= 3) print "  [Scope routine called at stage 1]^";
        #Endif; ! DEBUG
        l = indirect(scope_token);
        #Ifdef DEBUG;
        if (parser_trace >= 3) print "  [Scope routine returned multiple-flag of ", l, "]^";
        #Endif; ! DEBUG
        if (l == 1) given_tdata = MULTI_TOKEN; else given_tdata = NOUN_TOKEN;

      ATTR_FILTER_TT:
        token_filter = 1 + given_tdata;
        given_tdata = NOUN_TOKEN;

      ROUTINE_FILTER_TT:
        token_filter = given_tdata;
        given_tdata = NOUN_TOKEN;

    } ! end of switch(given_ttype)

    token = given_tdata;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Parse Token Letter B
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

    ! There are now three possible ways we can be here:
    !     parsing an elementary token other than "special" or "number";
    !     parsing a scope token;
    !     parsing a noun-filter token (either by routine or attribute).
    !
    ! In each case, token holds the type of elementary parse to
    ! perform in matching one or more objects, and
    ! token_filter is 0 (default), an attribute + 1 for an attribute filter
    ! or a routine address for a routine filter.

    token_allows_multiple = false;
    if (token == MULTI_TOKEN or MULTIHELD_TOKEN or MULTIEXCEPT_TOKEN or MULTIINSIDE_TOKEN)
        token_allows_multiple = true;

    many_flag = false; and_parity = true; dont_infer = false;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Parse Token Letter C
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

    ! We expect to find a list of objects next in what the player's typed.

  .ObjectList;

    #Ifdef DEBUG;
    if (parser_trace >= 3) print "  [Object list from word ", wn, "]^";
    #Endif; ! DEBUG

    ! Take an advance look at the next word: if it's "it" or "them", and these
    ! are unset, set the appropriate error number and give up on the line
    ! (if not, these are still parsed in the usual way - it is not assumed
    ! that they still refer to something in scope)

    o = NextWord(); wn--;

    pronoun_word = NULL; pronoun_obj = NULL;
    l = PronounValue(o);
    if (l ~= 0) {
        pronoun_word = o; pronoun_obj = l;
        if (l == NULL) {
            ! Don't assume this is a use of an unset pronoun until the
            ! descriptors have been checked, because it might be an
            ! article (or some such) instead

            for (l=1 : l<=LanguageDescriptors-->0 : l=l+4)
                if (o == LanguageDescriptors-->l) jump AssumeDescriptor;
            pronoun__word = pronoun_word; pronoun__obj = pronoun_obj;
            etype = VAGUE_PE;
            if (parser_trace >= 3) print "  [Stop: unset pronoun]^";
            return GPR_FAIL;
        }
    }

  .AssumeDescriptor;

    if (o == ME1__WD or ME2__WD or ME3__WD) { pronoun_word = o; pronoun_obj = player; }

    allow_plurals = true; desc_wn = wn;

  .TryAgain;

    ! First, we parse any descriptive words (like "the", "five" or "every"):
    l = Descriptors(token_allows_multiple);
    if (l ~= 0) { etype = l; return 0; }

  .TryAgain2;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Parse Token Letter D
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

    ! This is an actual specified object, and is therefore where a typing error
    ! is most likely to occur, so we set:

    oops_from = wn;

    ! So, two cases.  Case 1: token not equal to "held" (so, no implicit takes)
    ! but we may well be dealing with multiple objects

    ! In either case below we use NounDomain, giving it the token number as
    ! context, and two places to look: among the actor's possessions, and in the
    ! present location.  (Note that the order depends on which is likeliest.)

    if (token ~= HELD_TOKEN) {
        i = multiple_object-->0;
        #Ifdef DEBUG;
        if (parser_trace >= 3) print "  [Calling NounDomain on location and actor]^";
        #Endif; ! DEBUG
        l = NounDomain(actors_location, actor, token);
        if (l == REPARSE_CODE) return l;                  ! Reparse after Q&A
        if (indef_wanted == INDEF_ALL_WANTED && l == 0 && number_matched == 0)
            l = 1;  ! ReviseMulti if TAKE ALL FROM empty container

        if (token_allows_multiple && ~~multiflag) {
            if (best_etype==MULTI_PE) best_etype=STUCK_PE;
            multiflag = true;
        }
        if (l == 0) {
            if (indef_possambig) {
                ResetDescriptors();
                wn = desc_wn;
                jump TryAgain2;
            }
            if (etype == MULTI_PE or TOOFEW_PE && multiflag) etype = STUCK_PE;
            etype=CantSee();
            jump FailToken;
        } ! Choose best error

        #Ifdef DEBUG;
        if (parser_trace >= 3) {
            if (l > 1) print "  [ND returned ", (the) l, "]^";
            else {
                print "  [ND appended to the multiple object list:^";
                k = multiple_object-->0;
                for (j=i+1 : j<=k : j++)
                    print "  Entry ", j, ": ", (The) multiple_object-->j,
                          " (", multiple_object-->j, ")^";
                print "  List now has size ", k, "]^";
            }
        }
        #Endif; ! DEBUG

        if (l == 1) {
            if (~~many_flag) many_flag = true;
            else {                                ! Merge with earlier ones
                k = multiple_object-->0;            ! (with either parity)
                multiple_object-->0 = i;
                for (j=i+1 : j<=k : j++) {
                    if (and_parity) MultiAdd(multiple_object-->j);
                    else            MultiSub(multiple_object-->j);
                }
                #Ifdef DEBUG;
                if (parser_trace >= 3)
                	print "  [Merging ", k-i, " new objects to the ", i, " old ones]^";
                #Endif; ! DEBUG
            }
        }
        else {
            ! A single object was indeed found

            if (match_length == 0 && indef_possambig) {
                ! So the answer had to be inferred from no textual data,
                ! and we know that there was an ambiguity in the descriptor
                ! stage (such as a word which could be a pronoun being
                ! parsed as an article or possessive).  It's worth having
                ! another go.

                ResetDescriptors();
                wn = desc_wn;
                jump TryAgain2;
            }

            if ((token == CREATURE_TOKEN) && (CreatureTest(l) == 0)) {
                etype = ANIMA_PE;
                jump FailToken;
            } !  Animation is required

            if (~~many_flag) single_object = l;
            else {
                if (and_parity) MultiAdd(l); else MultiSub(l);
                #Ifdef DEBUG;
                if (parser_trace >= 3) print "  [Combining ", (the) l, " with list]^";
                #Endif; ! DEBUG
            }
        }
    }

    else {

    ! Case 2: token is "held" (which fortunately can't take multiple objects)
    ! and may generate an implicit take

        l = NounDomain(actor,actors_location,token);       ! Same as above...
        if (l == REPARSE_CODE) return l;
        if (l == 0) {
            if (indef_possambig) {
                ResetDescriptors();
                wn = desc_wn;
                jump TryAgain2;
            }
            etype = CantSee(); jump FailToken;            ! Choose best error
        }

        ! ...until it produces something not held by the actor.  Then an implicit
        ! take must be tried.  If this is already happening anyway, things are too
        ! confused and we have to give up (but saving the oops marker so as to get
        ! it on the right word afterwards).
        ! The point of this last rule is that a sequence like
        !
        !     > read newspaper
        !     (taking the newspaper first)
        !     The dwarf unexpectedly prevents you from taking the newspaper!
        !
        ! should not be allowed to go into an infinite repeat - read becomes
        ! take then read, but take has no effect, so read becomes take then read...
        ! Anyway for now all we do is record the number of the object to take.

        o = parent(l);
        if (o ~= actor) {
            #Ifdef DEBUG;
            if (parser_trace >= 3) print "  [Allowing object ", (the) l, " for now]^";
            #Endif; ! DEBUG
        }
        single_object = l;
    } ! end of if (token ~= HELD_TOKEN) else

    ! The following moves the word marker to just past the named object...
	
!	if (match_from ~= oops_from) print match_from, " vs ", oops_from, "^";

!    wn = oops_from + match_length;
    wn = match_from + match_length;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Parse Token Letter E
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

    ! Object(s) specified now: is that the end of the list, or have we reached
    ! "and", "but" and so on?  If so, create a multiple-object list if we
    ! haven't already (and are allowed to).

  .NextInList;

    o = NextWord();

    if (o == AND1__WD or AND2__WD or AND3__WD or BUT1__WD or BUT2__WD or BUT3__WD or comma_word) {

        #Ifdef DEBUG;
        if (parser_trace >= 3) print "  [Read connective '", (address) o, "']^";
        #Endif; ! DEBUG

        if (~~token_allows_multiple) {
            if (multiflag) jump PassToken; ! give UPTO_PE error
            etype=MULTI_PE;
            jump FailToken;
        }

        if (o == BUT1__WD or BUT2__WD or BUT3__WD) and_parity = 1-and_parity;

        if (~~many_flag) {
            multiple_object-->0 = 1;
            multiple_object-->1 = single_object;
            many_flag = true;
            #Ifdef DEBUG;
            if (parser_trace >= 3) print "  [Making new list from ", (the) single_object, "]^";
            #Endif; ! DEBUG
        }
        dont_infer = true; inferfrom=0;           ! Don't print (inferences)
        jump ObjectList;                          ! And back around
    }

    wn--;   ! Word marker back to first not-understood word


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Parse Token Letter F
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

    ! Happy or unhappy endings:

  .PassToken;
    if (many_flag) {
        single_object = GPR_MULTIPLE;
        multi_context = token;
    }
    else {
        if (indef_mode == 1 && indef_type & PLURAL_BIT ~= 0) {
		  	if (token == MULTIEXCEPT_TOKEN or MULTIINSIDE_TOKEN) multi_context = token;
            if (indef_wanted < INDEF_ALL_WANTED && indef_wanted > 1) {
                multi_had = 1; multi_wanted = indef_wanted;
                etype = TOOFEW_PE;
                jump FailToken;
            }
        }
    }
    return single_object;

  .FailToken;

    ! If we were only guessing about it being a plural, try again but only
    ! allowing singulars (so that words like "six" are not swallowed up as
    ! Descriptors)

    if (allow_plurals && indef_guess_p == 1) {
        #Ifdef DEBUG;
        if (parser_trace >= 4) print "   [Retrying singulars after failure ", etype, "]^";
        #Endif;
        prev_indef_wanted = indef_wanted;
        allow_plurals = false;
        wn = desc_wn;
        jump TryAgain;
    }

    if ((indef_wanted > 0 || prev_indef_wanted > 0) && (~~multiflag)) etype = MULTI_PE;

    return GPR_FAIL;

]; ! end of ParseToken__


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Descriptors
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant OTHER_BIT  =   1;     !  These will be used in Adjudicate()
Constant MY_BIT     =   2;     !  to disambiguate choices
Constant THAT_BIT   =   4;
Constant PLURAL_BIT =   8;
Constant LIT_BIT    =  16;
Constant UNLIT_BIT  =  32;

[ ResetDescriptors;
    indef_mode = 0; indef_type = 0; indef_wanted = 0; indef_guess_p = 0;
    indef_possambig = false;
    indef_owner = nothing;
    indef_cases = $$111111111111;
    indef_nspec_at = 0;
];

[ ArticleDescriptors  o x flag cto type n;
    if (wn > num_words) return 0;

    for (flag=true : flag :) {
        o = NextWordStopped(); flag = false;

       for (x=1 : x<=LanguageDescriptors-->0 : x=x+4)
            if (o == LanguageDescriptors-->x) {
                type = LanguageDescriptors-->(x+2);
                if (type == DEFART_PK or INDEFART_PK) flag = true;
            }
    }
    wn--;
    return 0;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Parsing Descriptors
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ Descriptors  o x flag cto type n;
    ResetDescriptors();
    if (wn > num_words) return 0;

    for (flag=true : flag :) {
        o = NextWordStopped(); flag = false;

       for (x=1 : x<=LanguageDescriptors-->0 : x=x+4)
            if (o == LanguageDescriptors-->x) {
                flag = true;
                type = LanguageDescriptors-->(x+2);
                if (type ~= DEFART_PK) indef_mode = true;
                indef_possambig = true;
                indef_cases = indef_cases & (LanguageDescriptors-->(x+1));

                if (type == POSSESS_PK) {
                    cto = LanguageDescriptors-->(x+3);
                    switch (cto) {
                      0: indef_type = indef_type | MY_BIT;
                      1: indef_type = indef_type | THAT_BIT;
                      default:
                        indef_owner = PronounValue(cto);
                        if (indef_owner == NULL) indef_owner = InformParser;
                    }
                }

                if (type == light)  indef_type = indef_type | LIT_BIT;
                if (type == -light) indef_type = indef_type | UNLIT_BIT;
            }

        if (o == OTHER1__WD or OTHER2__WD or OTHER3__WD) {
            indef_mode = 1; flag = 1;
            indef_type = indef_type | OTHER_BIT;
        }
        if (o == ALL1__WD or ALL2__WD or ALL3__WD or ALL4__WD or ALL5__WD) {
            indef_mode = 1; flag = 1; indef_wanted = INDEF_ALL_WANTED;
            if (take_all_rule == 1) take_all_rule = 2;
            indef_type = indef_type | PLURAL_BIT;
        }
        if (allow_plurals) {
        	if (NextWordStopped() ~= -1 or THEN1__WD) { wn--; n = TryNumber(wn-1); } else { n=0; wn--; }
            if (n == 1) { indef_mode = 1; flag = 1; }
            if (n > 1) {
                indef_guess_p = 1;
                indef_mode = 1; flag = 1; indef_wanted = n;
                indef_nspec_at = wn-1;
                indef_type = indef_type | PLURAL_BIT;
            }
        }
        if (flag == 1 && NextWordStopped() ~= OF1__WD or OF2__WD or OF3__WD or OF4__WD)
            wn--;  ! Skip 'of' after these
    }
    wn--;
    return 0;
];

[ SafeSkipDescriptors;
	@push indef_mode; @push indef_type; @push indef_wanted;
	@push indef_guess_p; @push indef_possambig; @push indef_owner;
	@push indef_cases; @push indef_nspec_at;
	
	Descriptors();
	
	@pull indef_nspec_at; @pull indef_cases;
	@pull indef_owner; @pull indef_possambig; @pull indef_guess_p;
	@pull indef_wanted; @pull indef_type; @pull indef_mode;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Preposition Chain
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PrepositionChain wd index;
    if (line_tdata-->index == wd) return wd;
    if ((line_token-->index)->0 & $20 == 0) return -1;
    do {
        if (line_tdata-->index == wd) return wd;
        index++;
    } until ((line_token-->index == ENDIT_TOKEN) || (((line_token-->index)->0 & $10) == 0));
    return -1;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Creature
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ CreatureTest obj;
    if (obj has animate) rtrue;
    if (obj hasnt talkable) rfalse;
    if (action_to_be == ##Ask or ##Answer or ##Tell or ##AskFor) rtrue;
    rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Noun Domain
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ NounDomain domain1 domain2 context dont_ask
	first_word i j k l answer_words marker;
    #Ifdef DEBUG;
    if (parser_trace >= 4) {
        print "   [NounDomain called at word ", wn, "^";
        print "   ";
        if (indef_mode) {
            print "seeking indefinite object: ";
            if (indef_type & OTHER_BIT)  print "other ";
            if (indef_type & MY_BIT)     print "my ";
            if (indef_type & THAT_BIT)   print "that ";
            if (indef_type & PLURAL_BIT) print "plural ";
            if (indef_type & LIT_BIT)    print "lit ";
            if (indef_type & UNLIT_BIT)  print "unlit ";
            if (indef_owner ~= 0) print "owner:", (name) indef_owner;
            new_line;
            print "   number wanted: ";
            if (indef_wanted == INDEF_ALL_WANTED) print "all"; else print indef_wanted;
            new_line;
            print "   most likely GNAs of names: ", indef_cases, "^";
        }
        else print "seeking definite object^";
    }
    #Endif; ! DEBUG

    match_length = 0; number_matched = 0; match_from = wn;

    SearchScope(domain1, domain2, context);

    #Ifdef DEBUG;
    if (parser_trace >= 4) print "   [ND made ", number_matched, " matches]^";
    #Endif; ! DEBUG

    wn = match_from+match_length;

    ! If nothing worked at all, leave with the word marker skipped past the
    ! first unmatched word...

    if (number_matched == 0) { wn++; rfalse; }

    ! Suppose that there really were some words being parsed (i.e., we did
    ! not just infer).  If so, and if there was only one match, it must be
    ! right and we return it...

    if (match_from <= num_words) {
        if (number_matched == 1) {
            i=match_list-->0;
            return i;
        }

        ! ...now suppose that there was more typing to come, i.e. suppose that
        ! the user entered something beyond this noun.  If nothing ought to follow,
        ! then there must be a mistake, (unless what does follow is just a full
        ! stop, and or comma)

        if (wn <= num_words) {
            i = NextWord(); wn--;
            if (i ~=  AND1__WD or AND2__WD or AND3__WD or comma_word
                   or THEN1__WD or THEN2__WD or THEN3__WD
                   or BUT1__WD or BUT2__WD or BUT3__WD) {
                if (lookahead == ENDIT_TOKEN) rfalse;
            }
        }
    }

    ! Now look for a good choice, if there's more than one choice...

    number_of_classes = 0;

    if (number_matched == 1) {
    	i = match_list-->0;
		if (indef_mode == 1 && indef_type & PLURAL_BIT ~= 0) {
			if (context == MULTI_TOKEN or MULTIHELD_TOKEN or
				MULTIEXCEPT_TOKEN or MULTIINSIDE_TOKEN or
				NOUN_TOKEN or HELD_TOKEN or CREATURE_TOKEN) {
				BeginActivity(DECIDING_WHETHER_ALL_INC_ACT, i);
				if ((ForActivity(DECIDING_WHETHER_ALL_INC_ACT, i)) &&
					(RulebookFailed())) rfalse;
				EndActivity(DECIDING_WHETHER_ALL_INC_ACT, i);
			}
		}
    }
    if (number_matched > 1) {
		i = true;
	    if (number_matched > 1)
	    	for (j=0 : j<number_matched-1 : j++)
				if (Identical(match_list-->j, match_list-->(j+1)) == false)
					i = false;
		if (i) dont_infer = true;
        i = Adjudicate(context);
        if (i == -1) rfalse;
        if (i == 1) rtrue;       !  Adjudicate has made a multiple
                             !  object, and we pass it on
    }

    ! If i is non-zero here, one of two things is happening: either
    ! (a) an inference has been successfully made that object i is
    !     the intended one from the user's specification, or
    ! (b) the user finished typing some time ago, but we've decided
    !     on i because it's the only possible choice.
    ! In either case we have to keep the pattern up to date,
    ! note that an inference has been made and return.
    ! (Except, we don't note which of a pile of identical objects.)

    if (i ~= 0) {
    	if (dont_infer) return i;
        if (inferfrom == 0) inferfrom=pcount;
        pattern-->pcount = i;
        return i;
    }

	if (dont_ask) return match_list-->0;

    ! If we get here, there was no obvious choice of object to make.  If in
    ! fact we've already gone past the end of the player's typing (which
    ! means the match list must contain every object in scope, regardless
    ! of its name), then it's foolish to give an enormous list to choose
    ! from - instead we go and ask a more suitable question...

    if (match_from > num_words) jump Incomplete;

    ! Now we print up the question, using the equivalence classes as worked
    ! out by Adjudicate() so as not to repeat ourselves on plural objects...

	BeginActivity(ASKING_WHICH_DO_YOU_MEAN_ACT);
	if (ForActivity(ASKING_WHICH_DO_YOU_MEAN_ACT)) jump SkipWhichQuestion;
	j = 1; marker = 0;
	for (i=1 : i<=number_of_classes : i++) {
		while (((match_classes-->marker) ~= i) && ((match_classes-->marker) ~= -i))
			marker++;
		if (match_list-->marker hasnt animate) j = 0;
	}
	if (j) PARSER_CLARIF_INTERNAL_RM('A');
	else PARSER_CLARIF_INTERNAL_RM('B');

    j = number_of_classes; marker = 0;
    for (i=1 : i<=number_of_classes : i++) {
        while (((match_classes-->marker) ~= i) && ((match_classes-->marker) ~= -i)) marker++;
        k = match_list-->marker;

        if (match_classes-->marker > 0) print (the) k; else print (a) k;

        if (i < j-1)  print ", ";
        if (i == j-1) {
			#Ifdef SERIAL_COMMA;
			if (j ~= 2) print ",";
        	#Endif; ! SERIAL_COMMA
        	PARSER_CLARIF_INTERNAL_RM('H');
        }
    }
    print "?^";

	.SkipWhichQuestion; EndActivity(ASKING_WHICH_DO_YOU_MEAN_ACT);

    ! ...and get an answer:

  .WhichOne;
    #Ifdef TARGET_ZCODE;
    for (i=2 : i<INPUT_BUFFER_LEN : i++) buffer2->i = ' ';
    #Endif; ! TARGET_ZCODE
    answer_words=Keyboard(buffer2, parse2);

    ! Conveniently, parse2-->1 is the first word in both ZCODE and GLULX.
    first_word = (parse2-->1);

    ! Take care of "all", because that does something too clever here to do
    ! later on:

    if (first_word == ALL1__WD or ALL2__WD or ALL3__WD or ALL4__WD or ALL5__WD) {
        if (context == MULTI_TOKEN or MULTIHELD_TOKEN or MULTIEXCEPT_TOKEN or MULTIINSIDE_TOKEN) {
            l = multiple_object-->0;
            for (i=0 : i<number_matched && l+i<MATCH_LIST_WORDS : i++) {
                k = match_list-->i;
                multiple_object-->(i+1+l) = k;
            }
            multiple_object-->0 = i+l;
            rtrue;
        }
        PARSER_CLARIF_INTERNAL_RM('C');
        jump WhichOne;
    }

	! Look for a comma, and interpret this as a fresh conversation command
	! if so:

	for (i=1 : i<=answer_words : i++)
		if (WordFrom(i, parse2) == comma_word) {
            VM_CopyBuffer(buffer, buffer2);
            jump RECONSTRUCT_INPUT;		
		}

    ! If the first word of the reply can be interpreted as a verb, then
    ! assume that the player has ignored the question and given a new
    ! command altogether.
    ! (This is one time when it's convenient that the directions are
    ! not themselves verbs - thus, "north" as a reply to "Which, the north
    ! or south door" is not treated as a fresh command but as an answer.)

    #Ifdef LanguageIsVerb;
    if (first_word == 0) {
        j = wn; first_word = LanguageIsVerb(buffer2, parse2, 1); wn = j;
    }
    #Endif; ! LanguageIsVerb
    if (first_word ~= 0) {
        j = first_word->#dict_par1;
        if ((0 ~= j&1) && ~~LanguageVerbMayBeName(first_word)) {
            VM_CopyBuffer(buffer, buffer2);
            jump RECONSTRUCT_INPUT;
        }
    }

    ! Now we insert the answer into the original typed command, as
    ! words additionally describing the same object
    ! (eg, > take red button
    !      Which one, ...
    !      > music
    ! becomes "take music red button".  The parser will thus have three
    ! words to work from next time, not two.)

    #Ifdef TARGET_ZCODE;
    k = WordAddress(match_from) - buffer; l=buffer2->1+1;
    for (j=buffer + buffer->0 - 1 : j>=buffer+k+l : j--) j->0 = 0->(j-l);
    for (i=0 : i<l : i++) buffer->(k+i) = buffer2->(2+i);
    buffer->(k+l-1) = ' ';
    buffer->1 = buffer->1 + l;
    if (buffer->1 >= (buffer->0 - 1)) buffer->1 = buffer->0;
    #Ifnot; ! TARGET_GLULX
    k = WordAddress(match_from) - buffer;
    l = (buffer2-->0) + 1;
    for (j=buffer+INPUT_BUFFER_LEN-1 : j>=buffer+k+l : j--) j->0 = j->(-l);
    for (i=0 : i<l : i++) buffer->(k+i) = buffer2->(WORDSIZE+i);
    buffer->(k+l-1) = ' ';
    buffer-->0 = buffer-->0 + l;
    if (buffer-->0 > (INPUT_BUFFER_LEN-WORDSIZE)) buffer-->0 = (INPUT_BUFFER_LEN-WORDSIZE);
    #Endif; ! TARGET_

    ! Having reconstructed the input, we warn the parser accordingly
    ! and get out.

	.RECONSTRUCT_INPUT;

	num_words = WordCount(); players_command = 100 + num_words;
    wn = 1;
    #Ifdef LanguageToInformese;
    LanguageToInformese();
    ! Re-tokenise:
    VM_Tokenise(buffer,parse);
    #Endif; ! LanguageToInformese
	num_words = WordCount(); players_command = 100 + num_words;
    actors_location = ScopeCeiling(player);
	FollowRulebook(Activity_after_rulebooks-->READING_A_COMMAND_ACT);

    return REPARSE_CODE;

    ! Now we come to the question asked when the input has run out
    ! and can't easily be guessed (eg, the player typed "take" and there
    ! were plenty of things which might have been meant).

  .Incomplete;

    if (context == CREATURE_TOKEN) PARSER_CLARIF_INTERNAL_RM('D', actor);
    else                           PARSER_CLARIF_INTERNAL_RM('E', actor);
    new_line;

    #Ifdef TARGET_ZCODE;
    for (i=2 : i<INPUT_BUFFER_LEN : i++) buffer2->i=' ';
    #Endif; ! TARGET_ZCODE
    answer_words = Keyboard(buffer2, parse2);

	! Look for a comma, and interpret this as a fresh conversation command
	! if so:

	for (i=1 : i<=answer_words : i++)
		if (WordFrom(i, parse2) == comma_word) {
			VM_CopyBuffer(buffer, buffer2);
			return REPARSE_CODE;
		}

    first_word=(parse2-->1);
    #Ifdef LanguageIsVerb;
    if (first_word==0) {
        j = wn; first_word=LanguageIsVerb(buffer2, parse2, 1); wn = j;
    }
    #Endif; ! LanguageIsVerb

    ! Once again, if the reply looks like a command, give it to the
    ! parser to get on with and forget about the question...

    if (first_word ~= 0) {
        j = first_word->#dict_par1;
        if ((0 ~= j&1) && ~~LanguageVerbMayBeName(first_word)) {
            VM_CopyBuffer(buffer, buffer2);
            return REPARSE_CODE;
        }
    }

    ! ...but if we have a genuine answer, then:
    !
    ! (1) we must glue in text suitable for anything that's been inferred.

    if (inferfrom ~= 0) {
        for (j=inferfrom : j<pcount : j++) {
            if (pattern-->j == PATTERN_NULL) continue;
            #Ifdef TARGET_ZCODE;
            i = 2+buffer->1; (buffer->1)++; buffer->(i++) = ' ';
            #Ifnot; ! TARGET_GLULX
            i = WORDSIZE + buffer-->0;
            (buffer-->0)++; buffer->(i++) = ' ';
            #Endif; ! TARGET_

            #Ifdef DEBUG;
            if (parser_trace >= 5)
            	print "[Gluing in inference with pattern code ", pattern-->j, "]^";
            #Endif; ! DEBUG

            ! Conveniently, parse2-->1 is the first word in both ZCODE and GLULX.

            parse2-->1 = 0;

            ! An inferred object.  Best we can do is glue in a pronoun.
            ! (This is imperfect, but it's very seldom needed anyway.)

            if (pattern-->j >= 2 && pattern-->j < REPARSE_CODE) {
                PronounNotice(pattern-->j);
                for (k=1 : k<=LanguagePronouns-->0 : k=k+3)
                    if (pattern-->j == LanguagePronouns-->(k+2)) {
                        parse2-->1 = LanguagePronouns-->k;
                        #Ifdef DEBUG;
                        if (parser_trace >= 5)
                        	print "[Using pronoun '", (address) parse2-->1, "']^";
                        #Endif; ! DEBUG
                        break;
                    }
            }
            else {
                ! An inferred preposition.
                parse2-->1 = VM_NumberToDictionaryAddress(pattern-->j - REPARSE_CODE);
                #Ifdef DEBUG;
                if (parser_trace >= 5)
                	print "[Using preposition '", (address) parse2-->1, "']^";
                #Endif; ! DEBUG
            }

            ! parse2-->1 now holds the dictionary address of the word to glue in.

            if (parse2-->1 ~= 0) {
                k = buffer + i;
                #Ifdef TARGET_ZCODE;
                @output_stream 3 k;
                 print (address) parse2-->1;
                @output_stream -3;
                k = k-->0;
                for (l=i : l<i+k : l++) buffer->l = buffer->(l+2);
                i = i + k; buffer->1 = i-2;
                #Ifnot; ! TARGET_GLULX
                k = Glulx_PrintAnyToArray(buffer+i, INPUT_BUFFER_LEN-i, parse2-->1);
                i = i + k; buffer-->0 = i - WORDSIZE;
                #Endif; ! TARGET_
            }
        }
    }

    ! (2) we must glue the newly-typed text onto the end.

    #Ifdef TARGET_ZCODE;
    i = 2+buffer->1; (buffer->1)++; buffer->(i++) = ' ';
    for (j=0 : j<buffer2->1 : i++,j++) {
        buffer->i = buffer2->(j+2);
        (buffer->1)++;
        if (buffer->1 == INPUT_BUFFER_LEN) break;
    }
    #Ifnot; ! TARGET_GLULX
    i = WORDSIZE + buffer-->0;
    (buffer-->0)++; buffer->(i++) = ' ';
    for (j=0 : j<buffer2-->0 : i++,j++) {
        buffer->i = buffer2->(j+WORDSIZE);
        (buffer-->0)++;
        if (buffer-->0 == INPUT_BUFFER_LEN) break;
    }
    #Endif; ! TARGET_

    ! (3) we fill up the buffer with spaces, which is unnecessary, but may
    !     help incorrectly-written interpreters to cope.

    #Ifdef TARGET_ZCODE;
    for (: i<INPUT_BUFFER_LEN : i++) buffer->i = ' ';
    #Endif; ! TARGET_ZCODE

    return REPARSE_CODE;

]; ! end of NounDomain

[ PARSER_CLARIF_INTERNAL_R; ];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Adjudicate
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ Adjudicate context i j k good_ones last n ultimate flag offset;
    #Ifdef DEBUG;
    if (parser_trace >= 4) {
        print "   [Adjudicating match list of size ", number_matched,
        	" in context ", context, "^";
        print "   ";
        if (indef_mode) {
            print "indefinite type: ";
            if (indef_type & OTHER_BIT)  print "other ";
            if (indef_type & MY_BIT)     print "my ";
            if (indef_type & THAT_BIT)   print "that ";
            if (indef_type & PLURAL_BIT) print "plural ";
            if (indef_type & LIT_BIT)    print "lit ";
            if (indef_type & UNLIT_BIT)  print "unlit ";
            if (indef_owner ~= 0) print "owner:", (name) indef_owner;
            new_line;
            print "   number wanted: ";
            if (indef_wanted == INDEF_ALL_WANTED) print "all"; else print indef_wanted;
            new_line;
            print "   most likely GNAs of names: ", indef_cases, "^";
        }
        else print "definite object^";
    }
    #Endif; ! DEBUG

    j = number_matched-1; good_ones = 0; last = match_list-->0;
    for (i=0 : i<=j : i++) {
        n = match_list-->i;
        match_scores-->i = good_ones;
        ultimate = ScopeCeiling(n);

        if (context==HELD_TOKEN && parent(n)==actor)
        {   good_ones++; last=n; }
        if (context==MULTI_TOKEN && ultimate==ScopeCeiling(actor)
            && n~=actor && n hasnt concealed && n hasnt scenery) 
        {   good_ones++; last=n; }
        if (context==MULTIHELD_TOKEN && parent(n)==actor)
        {   good_ones++; last=n; }

        if (context==MULTIEXCEPT_TOKEN or MULTIINSIDE_TOKEN)
        {   if (advance_warning==-1)
            {   if (context==MULTIEXCEPT_TOKEN)
                {   good_ones++; last=n;
                 }
                if (context==MULTIINSIDE_TOKEN)
                {   if (parent(n)~=actor) { good_ones++; last=n; }
                 }
            }
            else
            {   if (context==MULTIEXCEPT_TOKEN && n~=advance_warning)
                {   good_ones++; last=n; }
                if (context==MULTIINSIDE_TOKEN && n in advance_warning)
                {   good_ones++; last=n; }
            }
         }
        if (context==CREATURE_TOKEN && CreatureTest(n)==1)
        {   good_ones++; last=n; }
        
        match_scores-->i = 1000*(good_ones - match_scores-->i);
    }
    if (good_ones == 1) {
		if (indef_mode == 1 && indef_type & PLURAL_BIT ~= 0 &&
			context == MULTI_TOKEN or MULTIHELD_TOKEN or
				MULTIEXCEPT_TOKEN or MULTIINSIDE_TOKEN) {
	        BeginActivity(DECIDING_WHETHER_ALL_INC_ACT, last);
            if ((ForActivity(DECIDING_WHETHER_ALL_INC_ACT, last)) &&
            	(RulebookFailed())) good_ones = 0;
	        EndActivity(DECIDING_WHETHER_ALL_INC_ACT, last);
			if (good_ones == 1) return last;
		} else {
			return last;
		}
    }

    ! If there is ambiguity about what was typed, but it definitely wasn't
    ! animate as required, then return anything; higher up in the parser
    ! a suitable error will be given.  (This prevents a question being asked.)

    if (context == CREATURE_TOKEN && good_ones == 0) return match_list-->0;

    if (indef_mode == 0) indef_type=0;

    ScoreMatchL(context);
    if (number_matched == 0) return -1;

    if (indef_mode == 0) {
        !  Is there now a single highest-scoring object?
        i = SingleBestGuess();
        if (i >= 0) {

            #Ifdef DEBUG;
            if (parser_trace >= 4) print "   Single best-scoring object returned.]^";
            #Endif; ! DEBUG
            return i;
        }
    }

    if (indef_mode == 1 && indef_type & PLURAL_BIT ~= 0) {
        if (context ~= MULTI_TOKEN or MULTIHELD_TOKEN or MULTIEXCEPT_TOKEN
                     or MULTIINSIDE_TOKEN) {
            etype = MULTI_PE;
            return -1;
        }
        i = 0; offset = multiple_object-->0;
        for (j=BestGuess(): j~=-1 && i<indef_wanted && i+offset<MATCH_LIST_WORDS-1:
        	j=BestGuess()) {
            flag = 0;
            BeginActivity(DECIDING_WHETHER_ALL_INC_ACT, j);
            if ((ForActivity(DECIDING_WHETHER_ALL_INC_ACT, j)) == 0) {

                if (j hasnt concealed && j hasnt worn) flag = 1;
            
                if (context == MULTIHELD_TOKEN or MULTIEXCEPT_TOKEN && parent(j) ~= actor)
                    flag = 0;

                if (action_to_be == ##Take or ##Remove && parent(j) == actor)
                    flag = 0;

                k = ChooseObjects(j, flag);

                if (k == 1)
                    flag = 1;
                else {
                    if (k == 2) flag = 0;
                }
            } else {
                flag = 0; if (RulebookSucceeded()) flag = 1;
            }
            EndActivity(DECIDING_WHETHER_ALL_INC_ACT, j);
            if (flag == 1) {
                i++; multiple_object-->(i+offset) = j;
                #Ifdef DEBUG;
                if (parser_trace >= 4) print "   Accepting it^";
                #Endif; ! DEBUG
            }
            else {
                i = i;
                #Ifdef DEBUG;
                if (parser_trace >= 4) print "   Rejecting it^";
                #Endif; ! DEBUG
            }
        }
        if (i < indef_wanted && indef_wanted < INDEF_ALL_WANTED) {
            etype = TOOFEW_PE; multi_wanted = indef_wanted;
            multi_had=i;
            return -1;
        }
        multiple_object-->0 = i+offset;
        multi_context = context;
        #Ifdef DEBUG;
        if (parser_trace >= 4)
            print "   Made multiple object of size ", i, "]^";
        #Endif; ! DEBUG
        return 1;
    }

    for (i=0 : i<number_matched : i++) match_classes-->i = 0;

    n = 1;
    for (i=0 : i<number_matched : i++)
        if (match_classes-->i == 0) {
            match_classes-->i = n++; flag = 0;
            for (j=i+1 : j<number_matched : j++)
                if (match_classes-->j == 0 && Identical(match_list-->i, match_list-->j) == 1) {
                    flag=1;
                    match_classes-->j = match_classes-->i;
                }
            if (flag == 1) match_classes-->i = 1-n;
        }
     n--; number_of_classes = n;

    #Ifdef DEBUG;
    if (parser_trace >= 4) {
        print "   Grouped into ", n, " possibilities by name:^";
        for (i=0 : i<number_matched : i++)
            if (match_classes-->i > 0)
                print "   ", (The) match_list-->i, " (", match_list-->i, ")  ---  group ",
                  match_classes-->i, "^";
    }
    #Endif; ! DEBUG

    if (indef_mode == 0) {
        if (n > 1) {
            k = -1;
            for (i=0 : i<number_matched : i++) {
                if (match_scores-->i > k) {
                    k = match_scores-->i;
                    j = match_classes-->i; j = j*j;
                    flag = 0;
                }
                else
                    if (match_scores-->i == k) {
                        if ((match_classes-->i) * (match_classes-->i) ~= j)
                            flag = 1;
                    }
            }

        if (flag) {
            #Ifdef DEBUG;
            if (parser_trace >= 4) print "   Unable to choose best group, so ask player.]^";
            #Endif; ! DEBUG
            return 0;
        }
        #Ifdef DEBUG;
        if (parser_trace >= 4) print "   Best choices are all from the same group.^";
        #Endif; ! DEBUG
        }
    }

    !  When the player is really vague, or there's a single collection of
    !  indistinguishable objects to choose from, choose the one the player
    !  most recently acquired, or if the player has none of them, then
    !  the one most recently put where it is.

    if (n == 1) dont_infer = true;
    return BestGuess();

]; ! Adjudicate


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: ReviseMulti
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ReviseMulti second_p  i low;
    #Ifdef DEBUG;
    if (parser_trace >= 4)
    	print "   Revising multiple object list of size ", multiple_object-->0,
     	" with 2nd ", (name) second_p, "^";
    #Endif; ! DEBUG

    if (multi_context == MULTIEXCEPT_TOKEN or MULTIINSIDE_TOKEN) {
        for (i=1,low=0 : i<=multiple_object-->0 : i++) {
            if ( (multi_context==MULTIEXCEPT_TOKEN && multiple_object-->i ~= second_p) ||
                 (multi_context==MULTIINSIDE_TOKEN && multiple_object-->i in second_p)) {
                low++;
                multiple_object-->low = multiple_object-->i;
            }
        }
        multiple_object-->0 = low;
    }

    if (multi_context == MULTI_TOKEN && action_to_be == ##Take) {
        #Ifdef DEBUG;
        if (parser_trace >= 4) print "   Token 2 plural case: number with actor ", low, "^";
        #Endif; ! DEBUG
        if (take_all_rule == 2) {
            for (i=1,low=0 : i<=multiple_object-->0 : i++) {
                if (ScopeCeiling(multiple_object-->i) == ScopeCeiling(actor)) {
                    low++;
                    multiple_object-->low = multiple_object-->i;
                }
            }
            multiple_object-->0 = low;
        }
    }

    i = multiple_object-->0;
    #Ifdef DEBUG;
    if (parser_trace >= 4) print "   Done: new size ", i, "^";
    #Endif; ! DEBUG
    if (i == 0) return NOTHING_PE;
    return 0;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Match List
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ MakeMatch obj quality i;
    #Ifdef DEBUG;
    if (parser_trace >= 6) print "    Match with quality ",quality,"^";
    #Endif; ! DEBUG
    if (token_filter ~= 0 && ConsultNounFilterToken(obj) == 0) {
        #Ifdef DEBUG;
        if (parser_trace >= 6) print "    Match filtered out: token filter ", token_filter, "^";
        #Endif; ! DEBUG
        rtrue;
    }
    if (quality < match_length) rtrue;
    if (quality > match_length) { match_length = quality; number_matched = 0; }
    else {
        if (number_matched >= MATCH_LIST_WORDS) rtrue;
        for (i=0 : i<number_matched : i++)
            if (match_list-->i == obj) rtrue;
    }
    match_list-->number_matched++ = obj;
    #Ifdef DEBUG;
    if (parser_trace >= 6) print "    Match added to list^";
    #Endif; ! DEBUG
];

[ ConsultNounFilterToken obj sn rv;
    if (token_filter ofclass Routine) {
    	sn = noun;
	    noun = obj;
    	rv = indirect(token_filter);
    	noun = sn;
    	return rv;
    }
    if (obj has (token_filter-1)) rtrue;
    rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: ScoreMatchL
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant SCORE__CHOOSEOBJ = 1000;
Constant SCORE__IFGOOD = 500;
Constant SCORE__UNCONCEALED = 100;
Constant SCORE__BESTLOC = 60;
Constant SCORE__NEXTBESTLOC = 40;
Constant SCORE__NOTCOMPASS = 20;
Constant SCORE__NOTSCENERY = 10;
Constant SCORE__NOTACTOR = 5;
Constant SCORE__GNA = 1;
Constant SCORE__DIVISOR = 20;

Constant PREFER_HELD;
[ ScoreMatchL context its_owner its_score obj i j threshold met a_s l_s;
!   if (indef_type & OTHER_BIT ~= 0) threshold++;
    if (indef_type & MY_BIT ~= 0)    threshold++;
    if (indef_type & THAT_BIT ~= 0)  threshold++;
    if (indef_type & LIT_BIT ~= 0)   threshold++;
    if (indef_type & UNLIT_BIT ~= 0) threshold++;
    if (indef_owner ~= nothing)      threshold++;

    #Ifdef DEBUG;
    if (parser_trace >= 4) print "   Scoring match list: indef mode ", indef_mode, " type ",
      indef_type, ", satisfying ", threshold, " requirements:^";
    #Endif; ! DEBUG

    #ifdef PREFER_HELD;
    a_s = SCORE__BESTLOC; l_s = SCORE__NEXTBESTLOC;
    if (action_to_be == ##Take or ##Remove) {
        a_s = SCORE__NEXTBESTLOC; l_s = SCORE__BESTLOC;
    }
    context = context;  ! silence warning
    #ifnot;
    a_s = SCORE__NEXTBESTLOC; l_s = SCORE__BESTLOC;
    if (context == HELD_TOKEN or MULTIHELD_TOKEN or MULTIEXCEPT_TOKEN) {
        a_s = SCORE__BESTLOC; l_s = SCORE__NEXTBESTLOC;
    }
    #endif; ! PREFER_HELD

    for (i=0 : i<number_matched : i++) {
        obj = match_list-->i; its_owner = parent(obj); its_score=0; met=0;

        !      if (indef_type & OTHER_BIT ~= 0
        !          &&  obj ~= itobj or himobj or herobj) met++;
        if (indef_type & MY_BIT ~= 0 && its_owner == actor) met++;
        if (indef_type & THAT_BIT ~= 0 && its_owner == actors_location) met++;
        if (indef_type & LIT_BIT ~= 0 && obj has light) met++;
        if (indef_type & UNLIT_BIT ~= 0 && obj hasnt light) met++;
        if (indef_owner ~= 0 && its_owner == indef_owner) met++;

        if (met < threshold) {
            #Ifdef DEBUG;
            if (parser_trace >= 4)
            	print "   ", (The) match_list-->i, " (", match_list-->i, ") in ",
            	    (the) its_owner, " is rejected (doesn't match descriptors)^";
            #Endif; ! DEBUG
            match_list-->i = -1;
        }
        else {
            its_score = 0;
            if (obj hasnt concealed) its_score = SCORE__UNCONCEALED;

            if (its_owner == actor) its_score = its_score + a_s;
            else
                if (its_owner == actors_location) its_score = its_score + l_s;
                else
                    if (its_owner ~= compass) its_score = its_score + SCORE__NOTCOMPASS;

            its_score = its_score + SCORE__CHOOSEOBJ * ChooseObjects(obj, 2);

            if (obj hasnt scenery) its_score = its_score + SCORE__NOTSCENERY;
            if (obj ~= actor) its_score = its_score + SCORE__NOTACTOR;

            !   A small bonus for having the correct GNA,
            !   for sorting out ambiguous articles and the like.

            if (indef_cases & (PowersOfTwo_TB-->(GetGNAOfObject(obj))))
                its_score = its_score + SCORE__GNA;

            match_scores-->i = match_scores-->i + its_score;
            #Ifdef DEBUG;
            if (parser_trace >= 4) print "     ", (The) match_list-->i, " (", match_list-->i,
              ") in ", (the) its_owner, " : ", match_scores-->i, " points^";
            #Endif; ! DEBUG
        }
     }

    for (i=0 : i<number_matched : i++) {
        while (match_list-->i == -1) {
            if (i == number_matched-1) { number_matched--; break; }
            for (j=i : j<number_matched-1 : j++) {
                match_list-->j = match_list-->(j+1);
                match_scores-->j = match_scores-->(j+1);
            }
            number_matched--;
        }
    }
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: BestGuess
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BestGuess  earliest its_score best i;
    earliest = 0; best = -1;
    for (i=0 : i<number_matched : i++) {
        if (match_list-->i >= 0) {
            its_score = match_scores-->i;
            if (its_score > best) { best = its_score; earliest = i; }
        }
    }
    #Ifdef DEBUG;
    if (parser_trace >= 4)
      if (best < 0) print "   Best guess ran out of choices^";
      else print "   Best guess ", (the) match_list-->earliest,
      	" (", match_list-->earliest, ")^";
    #Endif; ! DEBUG
    if (best < 0) return -1;
    i = match_list-->earliest;
    match_list-->earliest = -1;
    return i;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: SingleBestGuess
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SingleBestGuess  earliest its_score best i;
    earliest = -1; best = -1000;
    for (i=0 : i<number_matched : i++) {
        its_score = match_scores-->i;
        if (its_score == best) earliest = -1;
        if (its_score > best) { best = its_score; earliest = match_list-->i; }
    }
    return earliest;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Identical
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ Identical o1 o2 p1 p2 n1 n2 i j flag;
    if (o1 == o2) rtrue;  ! This should never happen, but to be on the safe side
    if (o1 == 0 || o2 == 0) rfalse;  ! Similarly
    if (o1 ofclass K3_direction || o2 ofclass K3_direction) rfalse; ! Saves time

    !  What complicates things is that o1 or o2 might have a parsing routine,
    !  so the parser can't know from here whether they are or aren't the same.
    !  If they have different parsing routines, we simply assume they're
    !  different.  If they have the same routine (which they probably got from
    !  a class definition) then the decision process is as follows:
    !
    !     the routine is called (with self being o1, not that it matters)
    !       with noun and second being set to o1 and o2, and action being set
    !       to the fake action TheSame.  If it returns -1, they are found
    !       identical; if -2, different; and if >=0, then the usual method
    !       is used instead.

    if (o1.parse_name ~= 0 || o2.parse_name ~= 0) {
      if (o1.parse_name ~= o2.parse_name) rfalse;
      parser_action = ##TheSame; parser_one = o1; parser_two = o2;
      j = wn; i = RunRoutines(o1,parse_name); wn = j;
      if (i == -1) rtrue;
      if (i == -2) rfalse;
    }

    !  This is the default algorithm: do they have the same words in their
    !  "name" (i.e. property no. 1) properties.  (Note that the following allows
    !  for repeated words and words in different orders.)

    p1 = o1.&1; n1 = (o1.#1)/WORDSIZE;
    p2 = o2.&1; n2 = (o2.#1)/WORDSIZE;

    !  for (i=0 : i<n1 : i++) { print (address) p1-->i, " "; } new_line;
    !  for (i=0 : i<n2 : i++) { print (address) p2-->i, " "; } new_line;

    for (i=0 : i<n1 : i++) {
        flag = 0;
        for (j=0 : j<n2 : j++)
            if (p1-->i == p2-->j) flag = 1;
        if (flag == 0) rfalse;
    }

    for (j=0 : j<n2 : j++) {
        flag = 0;
        for (i=0 : i<n1 : i++)
            if (p1-->i == p2-->j) flag = 1;
        if (flag == 0) rfalse;
    }

    !  print "Which are identical!^";
    rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Print Command
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PrintInferredCommand from singleton_noun;
	singleton_noun = FALSE;
	if ((from ~= 0) && (from == pcount-1) &&
		(pattern-->from > 1) && (pattern-->from < REPARSE_CODE))
			singleton_noun = TRUE;

	if (singleton_noun) {
		BeginActivity(CLARIFYING_PARSERS_CHOICE_ACT, pattern-->from);
		if (ForActivity(CLARIFYING_PARSERS_CHOICE_ACT, pattern-->from) == 0) {
			print "("; PrintCommand(from); print ")^";
		}
		EndActivity(CLARIFYING_PARSERS_CHOICE_ACT, pattern-->from);
	} else {
		print "("; PrintCommand(from); print ")^";
	}
];

[ PrintCommand from i k spacing_flag;
    if (from == 0) {
        i = verb_word;
        if (LanguageVerb(i) == 0)
            if (PrintVerb(i) == 0) print (address) i;
        from++; spacing_flag = true;
    }
    for (k=from : k<pcount : k++) {
        i = pattern-->k;
        if (i == PATTERN_NULL) continue;
        if (spacing_flag) print (char) ' ';
        if (i == 0) { PARSER_CLARIF_INTERNAL_RM('F'); jump TokenPrinted; }
        if (i == 1) { PARSER_CLARIF_INTERNAL_RM('G'); jump TokenPrinted; }
        if (i >= REPARSE_CODE)
            print (address) VM_NumberToDictionaryAddress(i-REPARSE_CODE);
        else
            if (i ofclass K3_direction)
                print (LanguageDirection) i; ! the direction name as adverb
            else
                print (the) i;
      .TokenPrinted;
        spacing_flag = true;
    }
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: CantSee
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ CantSee  i w e;
    saved_oops=oops_from;

    if (scope_token ~= 0) {
        scope_error = scope_token; return ASKSCOPE_PE;
    }

    wn--; w = NextWord();
    e = CANTSEE_PE;
    if (w == pronoun_word) {
		w = NextWordStopped(); wn--;
		if ((w == -1) || (line_token-->(pcount) ~= ENDIT_TOKEN)) {
			if (pcount > 0) AnalyseToken(line_token-->(pcount-1));
			if ((pcount > 0) && (found_ttype == ROUTINE_FILTER_TT or ATTR_FILTER_TT))
				e = NOTINCONTEXT_PE;
			else {
				pronoun__word = pronoun_word; pronoun__obj = pronoun_obj;
				e = ITGONE_PE;
			}
		}
    }
    
    if (etype > e) return etype;
    return e;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Multiple Object List
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ MultiAdd o i j;
    i = multiple_object-->0;
    if (i == MATCH_LIST_WORDS-1) { toomany_flag = 1; rtrue; }
    for (j=1 : j<=i : j++)
        if (o == multiple_object-->j) rtrue;
    i++;
    multiple_object-->i = o;
    multiple_object-->0 = i;
];

[ MultiSub o i j k;
    i = multiple_object-->0;
    for (j=1 : j<=i : j++)
        if (o == multiple_object-->j) {
            for (k=j : k<=i : k++) multiple_object-->k = multiple_object-->(k+1);
            multiple_object-->0 = --i;
            return 0;
        }
    return VAGUE_PE;
];

[ MultiFilter attr  i j o;
	.MFiltl;
    i = multiple_object-->0;
    for (j=1 : j<=i : j++) {
        o = multiple_object-->j;
        if (o hasnt attr) { MultiSub(o); jump Mfiltl; }
    }
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Scope
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PlaceInScope O opts ws; ! If opts is set, do not place contents in scope
	ws = wn; wn = match_from;
	if (opts == false) DoScopeActionAndRecurse(O);
	else DoScopeAction(O);
	wn = ws; return;
];

[ AddToScope obj;
    if (ats_flag >= 2) DoScopeActionAndRecurse(obj, 0, ats_flag-2);
    if (ats_flag == 1) { if (HasLightSource(obj)==1) ats_hls = 1; }
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Scope Level 0
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TestScope obj act a al sr x y;
    x = parser_one; y = parser_two;
    parser_one = obj; parser_two = 0; a = actor; al = actors_location;
    sr = scope_reason; scope_reason = TESTSCOPE_REASON;
    if (act == 0) actor = player; else actor = act;
    actors_location = ScopeCeiling(actor);
    SearchScope(actors_location, actor, 0); scope_reason = sr; actor = a;
    actors_location = al; parser_one = x; x = parser_two; parser_two = y;
    return x;
];

[ LoopOverScope routine act x y a al;
    x = parser_one; y = scope_reason; a = actor; al = actors_location;
    parser_one = routine;
    if (act == 0) actor = player; else actor = act;
    actors_location = ScopeCeiling(actor);
    scope_reason = LOOPOVERSCOPE_REASON;
    SearchScope(actors_location, actor, 0);
    parser_one = x; scope_reason = y; actor = a; actors_location = al;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: SearchScope
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SearchScope domain1 domain2 context i;
	if (domain1 == 0) return;
	! (a)
    if (scope_token) {
        scope_stage = 2;
        #Ifdef DEBUG;
        if (parser_trace >= 3) print "  [Scope routine called at stage 2]^";
        #Endif;
        if (indirect(scope_token) ~= 0) rtrue;
    }
	! (b)
    BeginActivity(DECIDING_SCOPE_ACT, actor);
    if (ForActivity(DECIDING_SCOPE_ACT, actor) == false) {
		! (c.1)
		if ((scope_reason == PARSING_REASON) && (context == MULTIINSIDE_TOKEN) &&
			(advance_warning ~= -1)) {
			if (IsSeeThrough(advance_warning) == 1)
			    ScopeWithin(advance_warning, 0, context);
		} else {
			! (c.2)
			if ((scope_reason == PARSING_REASON) && (context ~= CREATURE_TOKEN) &&
				(indef_mode == 0) && (domain1 == actors_location))
					ScopeWithin(compass);
			! (c.3)
			if (domain1 has supporter or container) DoScopeAction(domain1);
			ScopeWithin(domain1, domain2, context);
			! (c.4)
			if (domain2) {
				if (domain2 has supporter or container) DoScopeAction(domain2);
				ScopeWithin(domain2, 0, context);
			}
		}
		! (c.5)
		if (thedark == domain1 or domain2) {
			DoScopeActionAndRecurse(actor, actor, context);
			if (parent(actor) has supporter or container)
				DoScopeActionAndRecurse(parent(actor), parent(actor), context);
		}
    }
    EndActivity(DECIDING_SCOPE_ACT, actor);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: ScopeWithin
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ScopeWithin domain nosearch context obj next_obj;
    if (domain == 0) rtrue;

    ! Look through the objects in the domain, avoiding "objectloop" in case
    ! movements occur.
    obj = child(domain);
    while (obj) {
        next_obj = sibling(obj);
        if ((domain == actor) || (TestConcealment(domain, obj) == false))
            DoScopeActionAndRecurse(obj, nosearch, context);
        obj = next_obj;
    }
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: DoScopeActionAndRecurse
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ DoScopeActionAndRecurse domain nosearch context i ad n obj next_obj;
	DoScopeAction(domain);

 	! (a)
    if ((domain ~= nosearch) &&
        ((domain ofclass K1_room or K8_person) || (IsSeeThrough(domain) == 1))) {
		obj = child(domain);
		while (obj) {
			next_obj = sibling(obj);
			if ((domain == actor) || (TestConcealment(domain, obj) == false))
				DoScopeActionAndRecurse(obj, nosearch, context);
			obj = next_obj;
		}
	}

	! (b)
	if (domain provides component_child) {
		obj = domain.component_child;
		while (obj) {
			next_obj = obj.component_sibling;
			if ((domain == actor) || (TestConcealment(domain, obj) == false))
				DoScopeActionAndRecurse(obj, 0, context);
			obj = next_obj;
		}
	}

    ! (c)
    ad = domain.&add_to_scope;
    if (ad ~= 0) {
        ! Test if the property value is not an object.
        #Ifdef TARGET_ZCODE;
        i = (UnsignedCompare(ad-->0, top_object) > 0);
        #Ifnot; ! TARGET_GLULX
        i = (((ad-->0)->0) ~= $70);
        #Endif; ! TARGET_

        if (i) {
            ats_flag = 2+context;
            RunRoutines(domain, add_to_scope);
            ats_flag = 0;
        }
        else {
            n = domain.#add_to_scope;
            for (i=0 : (WORDSIZE*i)<n : i++)
                if (ad-->i)
                    DoScopeActionAndRecurse(ad-->i, 0, context);
        }
    }
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: DoScopeAction
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ DoScopeAction item;

    #Ifdef DEBUG;
    if (parser_trace >= 6)
        print "[DSA on ", (the) item, " with reason = ", scope_reason,
            " p1 = ", parser_one, " p2 = ", parser_two, "]^";
    #Endif; ! DEBUG

    @push parser_one; @push scope_reason;

	switch(scope_reason) {
		TESTSCOPE_REASON: if (item == parser_one) parser_two = 1;
		LOOPOVERSCOPE_REASON: if (parser_one ofclass Routine) indirect(parser_one, item);
		PARSING_REASON, TALKING_REASON: MatchTextAgainstObject(item);
    }

    @pull scope_reason; @pull parser_one;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Parsing Object Names
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ MatchTextAgainstObject item i;
    if (token_filter ~= 0 && ConsultNounFilterToken(item) == 0) return;

	if (match_from <= num_words) { ! If there's any text to match, that is
		wn = match_from;
		i = NounWord();
		if ((i == 1) && (player == item)) MakeMatch(item, 1); ! "me"
		if ((i >= 2) && (i < 128) && (LanguagePronouns-->i == item)) MakeMatch(item, 1);
	}

	! Construing the current word as the start of a noun, can it refer to the
	! object?

	wn = match_from;
	if (TryGivenObject(item) > 0)
		if (indef_nspec_at > 0 && match_from ~= indef_nspec_at) {
			! This case arises if the player has typed a number in
			! which is hypothetically an indefinite descriptor:
			! e.g. "take two clubs".  We have just checked the object
			! against the word "clubs", in the hope of eventually finding
			! two such objects.  But we also backtrack and check it
			! against the words "two clubs", in case it turns out to
			! be the 2 of Clubs from a pack of cards, say.  If it does
			! match against "two clubs", we tear up our original
			! assumption about the meaning of "two" and lapse back into
			! definite mode.

			wn = indef_nspec_at;
			if (TryGivenObject(item) > 0) {
				match_from = indef_nspec_at;
				ResetDescriptors();
			}
			wn = match_from;
		}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: TryGivenObject
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TryGivenObject obj nomatch threshold k w j;
    #Ifdef DEBUG;
    if (parser_trace >= 5) print "    Trying ", (the) obj, " (", obj, ") at word ", wn, "^";
    #Endif; ! DEBUG

	if (nomatch && obj == 0) return 0;

! if (nomatch) print "*** TryGivenObject *** on ", (the) obj, " at wn = ", wn, "^";

    dict_flags_of_noun = 0;

!  If input has run out then always match, with only quality 0 (this saves
!  time).

    if (wn > num_words) {
    	if (nomatch) return 0;
        if (indef_mode ~= 0)
            dict_flags_of_noun = $$01110000;  ! Reject "plural" bit
        MakeMatch(obj,0);
        #Ifdef DEBUG;
        if (parser_trace >= 5) print "    Matched (0)^";
        #Endif; ! DEBUG
        return 1;
    }

!  Ask the object to parse itself if necessary, sitting up and taking notice
!  if it says the plural was used:

    if (obj.parse_name~=0) {
        parser_action = NULL; j=wn;
        k = RunRoutines(obj,parse_name);
        if (k > 0) {
            wn=j+k;

          .MMbyPN;

            if (parser_action == ##PluralFound)
                dict_flags_of_noun = dict_flags_of_noun | 4;

            if (dict_flags_of_noun & 4) {
                if (~~allow_plurals) k = 0;
                else {
                    if (indef_mode == 0) {
                        indef_mode = 1; indef_type = 0; indef_wanted = 0;
                    }
                    indef_type = indef_type | PLURAL_BIT;
                    if (indef_wanted == 0) indef_wanted = INDEF_ALL_WANTED;
                }
            }

            #Ifdef DEBUG;
            if (parser_trace >= 5) print "    Matched (", k, ")^";
            #Endif; ! DEBUG
            if (nomatch == false) MakeMatch(obj,k);
            return k;
        }
        if (k == 0) jump NoWordsMatch;
    }

    ! The default algorithm is simply to count up how many words pass the
    ! Refers test:

    parser_action = NULL;

    w = NounWord();

    if (w == 1 && player == obj) { k=1; jump MMbyPN; }

    if (w >= 2 && w < 128 && (LanguagePronouns-->w == obj)) { k = 1; jump MMbyPN; }

    if (Refers(obj, wn-1) == 0) {
        .NoWordsMatch;
        if (indef_mode ~= 0) { k = 0; parser_action = NULL; jump MMbyPN; }
        rfalse;
    }

	threshold = 1;
	dict_flags_of_noun = (w->#dict_par1) & $$01110100;
	w = NextWord();
	while (Refers(obj, wn-1)) {
		threshold++;
		if (w)
		   dict_flags_of_noun = dict_flags_of_noun | ((w->#dict_par1) & $$01110100);
		w = NextWord();
	}

    k = threshold;
    jump MMbyPN;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Refers
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ Refers obj wnum   wd k l m;
    if (obj == 0) rfalse;

    #Ifdef LanguageRefers;
    k = LanguageRefers(obj,wnum); if (k >= 0) return k;
    #Endif; ! LanguageRefers

    k = wn; wn = wnum; wd = NextWordStopped(); wn = k;

    if (parser_inflection >= 256) {
        k = indirect(parser_inflection, obj, wd);
        if (k >= 0) return k;
        m = -k;
    }
    else
        m = parser_inflection;
    k = obj.&m; l = (obj.#m)/WORDSIZE-1;
    for (m=0 : m<=l : m++)
        if (wd == k-->m) rtrue;
    rfalse;
];

[ WordInProperty wd obj prop k l m;
    k = obj.&prop; l = (obj.#prop)/WORDSIZE-1;
    for (m=0 : m<=l : m++)
        if (wd == k-->m) rtrue;
    rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: NounWord
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ NounWord i j s;
    i = NextWord();
    if (i == 0) rfalse;
    if (i == ME1__WD or ME2__WD or ME3__WD) return 1;
    s = LanguagePronouns-->0;
    for (j=1 : j<=s : j=j+3)
        if (i == LanguagePronouns-->j)
            return j+2;
    if ((i->#dict_par1)&128 == 0) rfalse;
    return i;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: TryNumber
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TryNumber wordnum   i j c num len mul tot d digit;
    i = wn; wn = wordnum; j = NextWord(); wn = i;
    j = NumberWord(j); ! Test for verbal forms ONE to THIRTY
    if (j >= 1) return j;

    #Ifdef TARGET_ZCODE;
    i = wordnum*4+1; j = parse->i; num = j+buffer; len = parse->(i-1);
    #Ifnot; ! TARGET_GLULX
    i = wordnum*3; j = parse-->i; num = j+buffer; len = parse-->(i-1);
    #Endif; ! TARGET_

    if (len >= 4) mul=1000;
    if (len == 3) mul=100;
    if (len == 2) mul=10;
    if (len == 1) mul=1;

    tot = 0; c = 0; len = len-1;

    for (c=0 : c<=len : c++) {
        digit=num->c;
        if (digit == '0') { d = 0; jump digok; }
        if (digit == '1') { d = 1; jump digok; }
        if (digit == '2') { d = 2; jump digok; }
        if (digit == '3') { d = 3; jump digok; }
        if (digit == '4') { d = 4; jump digok; }
        if (digit == '5') { d = 5; jump digok; }
        if (digit == '6') { d = 6; jump digok; }
        if (digit == '7') { d = 7; jump digok; }
        if (digit == '8') { d = 8; jump digok; }
        if (digit == '9') { d = 9; jump digok; }
        return -1000;
     .digok;
        tot = tot+mul*d; mul = mul/10;
    }
    if (len > 3) tot=10000;
    return tot;
];

 
[ GetGNAOfObject obj case gender;
   if (obj hasnt animate) case = 6;

   if (obj has male) gender = male; 
   if (obj has neuter) gender = neuter; 
   if (obj has female) gender = female; 

   if (gender == 0) {
!       if (case == 0) 
!         gender = LanguageAnimateGender;
!       else 
         gender = LanguageInanimateGender;
   }

   if (gender == female) case = case + 1; 
   if (gender == neuter) case = case + 2; 
   if (obj has pluralname) case = case + 3;

   return case;

]; 

[ GetSecondaryGNAOfObject obj case gender;
   if (obj hasnt animate) case = 6;

   if (obj has female) gender = female; 
   if (obj has neuter) gender = neuter; 
   if (obj has male) gender = male; 

   if (gender == 0) {
!       if (case == 0) 
!         gender = LanguageAnimateGender;
!       else 
         gender = LanguageInanimateGender;
   }

   if (gender == female) case = case + 1; 
   if (gender == neuter) case = case + 2; 
   if (obj has pluralname) case = case + 3;

   return case;

]; 

! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Gender (skipping)
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Noticing Plurals
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ DetectPluralWord at n i w swn outcome;
	swn = wn; wn = at;
	for (i=0:i<n:i++) {
		w = NextWordStopped();
		if (w == 0 or THEN1__WD or COMMA_WORD or -1) break;
		if ((w->#dict_par1) & $$00000100) {
			parser_action = ##PluralFound;
			outcome = true;
		}
	}
	wn = swn;
	return outcome;
];

 
[ SetPronoun dword value x;
    for (x=1 : x<=LanguagePronouns-->0 : x=x+3)
        if (LanguagePronouns-->x == dword) {
            LanguagePronouns-->(x+2) = value; return;
        }
    RunTimeError(14);
];

[ PronounValue dword x;
    for (x=1 : x<=LanguagePronouns-->0 : x=x+3)
        if (LanguagePronouns-->x == dword)
            return LanguagePronouns-->(x+2);
    return 0;
];

[ ResetVagueWords obj; PronounNotice(obj); ];

[ PronounNotice obj x bm;
   if (obj == player) return;

   bm = PowersOfTwo_TB-->(GetGNAOfObject(obj));
! [unicode 167]#[unicode 167] Added one line, to allow for an object to have two genders
   bm = bm | (PowersOfTwo_TB-->(GetSecondaryGNAOfObject(obj)));

   for (x = 1 : x <= LanguagePronouns-->0: x = x+3)
       if (bm & (LanguagePronouns-->(x+1)) ~= 0)
           LanguagePronouns-->(x+2) = obj;
];

[ PronounNoticeHeldObjects x;
#IFNDEF MANUAL_PRONOUNS;
   objectloop(x in player) PronounNotice(x);
#ENDIF;
   x = 0; ! To prevent a "not used" error
   rfalse;
]; 

! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Pronoun Handling (skipping)
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Yes/No Questions
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ YesOrNo i j;
    for (::) {
        #Ifdef TARGET_ZCODE;
        if (location == nothing || parent(player) == nothing) read buffer parse;
        else read buffer parse DrawStatusLine;
        j = parse->1;
        #Ifnot; ! TARGET_GLULX;
        if (location ~= nothing && parent(player) ~= nothing) DrawStatusLine();
        KeyboardPrimitive(buffer, parse);
        j = parse-->0;
        #Endif; ! TARGET_
        if (j) { ! at least one word entered
            i = parse-->1;
            if (i == YES1__WD or YES2__WD or YES3__WD) rtrue;
            if (i == NO1__WD or NO2__WD or NO3__WD) rfalse;
        }
        YES_OR_NO_QUESTION_INTERNAL_RM('A'); print "> ";
    }
];

[ YES_OR_NO_QUESTION_INTERNAL_R; ];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Number Words
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ NumberWord o i n;
    n = LanguageNumbers-->0;
    for (i=1 : i<=n : i=i+2)
        if (o == LanguageNumbers-->i) return LanguageNumbers-->(i+1);
    return 0;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Choose Objects
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

!Constant COBJ_DEBUG;

! the highest value returned by CheckDPMR (see the Standard Rules)
Constant HIGHEST_DPMR_SCORE = 4;

Array alt_match_list --> (MATCH_LIST_WORDS+1);

#ifdef TARGET_GLULX;
[ COBJ__Copy words from to  i;
	for (i=0: i<words: i++)
		to-->i = from-->i;
];
#ifnot;
[ COBJ__Copy words from to  bytes;
	bytes = words * 2;
	@copy_table from to bytes;
];
#endif;

! swap alt_match_list with match_list/number_matched
[ COBJ__SwapMatches i x;
	! swap the counts
	x = number_matched;
	number_matched = alt_match_list-->0;
	alt_match_list-->0 = x;
	! swap the values
	if (x < number_matched) x = number_matched;
	for (i=x: i>0: i--) {
		x = match_list-->(i-1);
		match_list-->(i-1) = alt_match_list-->i;
		alt_match_list-->i = x;
	}
];

[ ChooseObjects obj code  l i swn spcount;
	if (code<2) rfalse;

	if (cobj_flag == 1) {
		.CodeOne;
		if (parameters > 0) {
			#ifdef COBJ_DEBUG;
			print "[scoring ", (the) obj, " (second)]^";
			#endif;
			return ScoreDabCombo(parser_results-->INP1_PRES, obj);
		} else {
			#ifdef COBJ_DEBUG;
			print "[scoring ", (the) obj, " (first) in ",
				alt_match_list-->0, " combinations]^";
			#endif;
			l = 0;
			for (i=1: i<=alt_match_list-->0: i++) {
				spcount = ScoreDabCombo(obj, alt_match_list-->i);
				if (spcount == HIGHEST_DPMR_SCORE) {
					#ifdef COBJ_DEBUG;
					print "[scored ", spcount, " - best possible]^";
					#endif;
					return spcount;
				}
				if (spcount>l) l = spcount;
			}
			return l;
		}
	}
	if (cobj_flag == 2) {
		.CodeTwo;
		#ifdef COBJ_DEBUG;
		print "[scoring ", (the) obj, " (simple); parameters = ", parameters,
			" aw = ", advance_warning, "]^";
		#endif;
		@push action_to_be;
		if (parameters==0) {
			if (advance_warning > 0)
				l = ScoreDabCombo(obj, advance_warning);
			else
				l = ScoreDabCombo(obj, 0);
		} else {
			l = ScoreDabCombo(parser_results-->INP1_PRES, obj);
		}
		@pull action_to_be;
		return l;
	}

	#ifdef COBJ_DEBUG;
	print "[choosing a cobj strategy: ";
	#endif;
	swn = wn;
	spcount = pcount;
	while (line_ttype-->pcount == PREPOSITION_TT) pcount++;
	if (line_ttype-->pcount == ELEMENTARY_TT) {
		if (line_tdata-->pcount == TOPIC_TOKEN) {
			pcount = spcount;
			jump CodeTwo;
		}
		while (wn <= num_words) {
			l = NextWordStopped(); wn--;
			if (l == THEN1__WD) break;
			if ( (l ~= -1 or 0) && (l->#dict_par1) &8 ) { wn++; continue; }	! if preposition
			if (l == ALL1__WD or ALL2__WD or ALL3__WD or ALL4__WD or ALL5__WD) { wn++; continue; }
			SafeSkipDescriptors();
			! save the current match state
			@push match_length; @push token_filter; @push match_from;
			alt_match_list-->0 = number_matched;
			COBJ__Copy(number_matched, match_list, alt_match_list+WORDSIZE);
			! now get all the matches for the second noun
			match_length = 0; number_matched = 0; match_from = wn;
			token_filter = 0;
			SearchScope(actor, actors_location, line_tdata-->pcount);
			#ifdef COBJ_DEBUG;
			print number_matched, " possible second nouns]^";
			#endif;
			wn = swn;
			cobj_flag = 1;
			! restore match variables
			COBJ__SwapMatches();
			@pull match_from; @pull token_filter; @pull match_length;
			pcount = spcount;
			jump CodeOne;
		}
	}
	pcount = spcount;
	wn = swn;	
	
	#ifdef COBJ_DEBUG;
	print "nothing interesting]^";
	#endif;
	cobj_flag = 2;
	jump CodeTwo;
];

[ ScoreDabCombo a b  result;
	@push action; @push act_requester; @push noun; @push second;
	action = action_to_be;
	act_requester = player;
	if (action_reversed) { noun = b; second = a; }
	else { noun = a; second = b; }
	result = CheckDPMR();
	@pull second; @pull noun; @pull act_requester; @pull action;
	#ifdef COBJ_DEBUG;
	print "[", (the) a, " / ", (the) b, " => ", result, "]^";
	#endif;
	return result;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Default Topic
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ DefaultTopic; return GPR_FAIL; ];



[ ParserError error_type;
	if (error_type) PrintSingleParagraph(error_type);
	rfalse;
];

Object InformLibrary "(Inform Library)" has proper;

Array Protect_I7_Arrays --> 16339 12345;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Order of Play
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Main
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Global EarlyInTurnSequence;
Global IterationsOfTurnSequence;

[ Main;
	#ifdef TARGET_ZCODE; max_z_object = #largest_object - 255; #endif;
	ClearRTP();
	FollowRulebook(STARTUP_RB);
	#ifdef DEBUG; InternalTestCases(); #endif;
	while (true) {
		while (deadflag == false) {
			EarlyInTurnSequence = true;
			action = ##Wait; meta = false; noun = nothing; second = nothing;
			actor = player;
			FollowRulebook(TURN_SEQUENCE_RB);
			IterationsOfTurnSequence++;
		}
		if (FollowRulebook(SHUTDOWN_RB) == false) return;
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Virtual Machine Startup Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VIRTUAL_MACHINE_STARTUP_R;
	CarryOutActivity(STARTING_VIRTUAL_MACHINE_ACT);
	VM_Initialise();
	print "^^^";
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Initial Situation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant PLAYER_OBJECT_INIS = 0;
Constant START_OBJECT_INIS = 1;
Constant START_ROOM_INIS = 2;
Constant START_TIME_INIS = 3;
Constant DONE_INIS = 4;

Array InitialSituation --> selfobj nothing I126_create_your_character 540 0;




! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Initialise Memory Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ INITIALISE_MEMORY_R;
	#ifdef TARGET_GLULX; VM_PreInitialise(); #Endif;
	#Ifdef LanguageInitialise; LanguageInitialise(); #Endif;

	not_yet_in_play = true;
	#ifdef I7_LOOKMODE; lookmode = I7_LOOKMODE; #endif;
	player = InitialSituation-->PLAYER_OBJECT_INIS;
	the_time = InitialSituation-->START_TIME_INIS;
	real_location = nothing;
	location = nothing;

	CreatePropertyOffsets();
	HeapInitialise(); ! Create a completely unused memory allocation heap
	StackFramingInitialise(); ! Create an empty stack
	CreateDynamicRelations(); ! Create relation structures on the heap

	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Seed Random Number Generator Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SEED_RANDOM_NUMBER_GENERATOR_R i;
	if (0) VM_Seed_RNG(0);
	for (i=1: i<=100: i++) random(i);
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Position Player In Model World Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ POSITION_PLAYER_IN_MODEL_R player_to_be;

	player = selfobj;
	player_to_be = InitialSituation-->PLAYER_OBJECT_INIS;
	
	location = LocationOf(player_to_be);
	if (location == 0) {
		location = InitialSituation-->START_ROOM_INIS;
		if (InitialSituation-->START_OBJECT_INIS)
			move player_to_be to InitialSituation-->START_OBJECT_INIS;
		else move player_to_be to location;
	}

	if (player_to_be ~= player) { remove selfobj; ChangePlayer(player_to_be); }
	else { real_location = location; SilentlyConsiderLight(); }

	NOTE_OBJECT_ACQUISITIONS_R(); MoveFloatingObjects();
	
	actor = player; act_requester = nothing; actors_location = real_location; action = ##Wait;

	InitialSituation-->DONE_INIS = true;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Parse Command Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant ACTION_PRES = 0;
Constant NO_INPS_PRES = 1;
Constant INP1_PRES = 2;
Constant INP2_PRES = 3; ! Parser.i6t code assumes this is INP1_PRES + 1

[ PARSE_COMMAND_R;
	if (EarlyInTurnSequence == false) rfalse; ! Prevent use outside top level
	not_yet_in_play = false;

	Parser__parse();
	TreatParserResults();
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Treat Parser Results
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TreatParserResults;
	if (parser_results-->ACTION_PRES == ##MistakeAction) meta = true;

	if (parser_results-->ACTION_PRES == ##Tell &&
		parser_results-->INP1_PRES == player && actor ~= player) {
		parser_results-->ACTION_PRES = ##Ask;
		parser_results-->INP1_PRES = actor; actor = player;
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Generate Action Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ GENERATE_ACTION_R i j k l;
	if (EarlyInTurnSequence == false) rfalse; ! Prevent use outside top level
	EarlyInTurnSequence = false;

	action = parser_results-->ACTION_PRES;
	act_requester = nothing; if (actor ~= player) act_requester = player;

	inp1 = 0; inp2 = 0; multiflag = false;
	if (parser_results-->NO_INPS_PRES >= 1) {
		inp1 = parser_results-->INP1_PRES; if (inp1 == 0) multiflag = true;
	}
	if (parser_results-->NO_INPS_PRES >= 2) {
		inp2 = parser_results-->INP2_PRES; if (inp2 == 0) multiflag = true;
	}

	if (inp1 == 1) {
		noun = nothing; ! noun = special_number1;
	} else noun = inp1;
	if (inp2 == 1) {
		second = nothing;
		! if (inp1 == 1) second = special_number2; else second = special_number1;
	} else second = inp2;

	if (multiflag) {
		if (multiple_object-->0 == 0) {
			if (actor == player) { GENERATE_ACTION_RM('B'); new_line; }
			return;
		}
		if (toomany_flag) {
			toomany_flag = false;
			if (actor == player) { GENERATE_ACTION_RM('A'); }
		}
		GenerateMultipleActions();
		multiflag = false;
	} else BeginAction(action, noun, second);

	if ((actor ~= player) || (act_requester)) action = ##Wait;
	actor = player; act_requester = 0;

	if (meta) { RulebookSucceeds(); rtrue; }
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Generate Multiple Actions
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ GenerateMultipleActions initial_location k item;
	initial_location = location;
	for (k=1: k<=multiple_object-->0: k++) {
		item = multiple_object-->k;
		RunParagraphOn();
		if (inp1 == 0) { inp1 = item; BeginAction(action, item, second, item); inp1 = 0; }
		else { inp2 = item; BeginAction(action, noun, item, item); inp2 = 0; }
		if (deadflag) return;
		if (location ~= initial_location) {
			if (player == actor) { ACTION_PROCESSING_INTERNAL_RM('J'); new_line; }
			return;
		}
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Timed Events Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TIMED_EVENTS_R i event_timer fire rule;
	for (i=1: i<=(TimedEventsTable-->0): i++)
		if ((rule=TimedEventsTable-->i) ~= 0) {
			event_timer = TimedEventTimesTable-->i; fire = false;
			if (event_timer<0) {
				(TimedEventTimesTable-->i)++;
				if (TimedEventTimesTable-->i == 0) fire = true;
			} else {
				if ((the_time >= event_timer) && (the_time < event_timer+30)) fire = true;
			}
			if (fire) {
				TimedEventsTable-->i = 0;
				FollowRulebook(rule);
			}
		}
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Setting Timed Events
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SetTimedEvent rule event_time absolute_time i b;
	for (i=1: i<=(TimedEventsTable-->0): i++) {
		if (rule == TimedEventsTable-->i) { b=i; break; }
		if ((b==0) && (TimedEventsTable-->i == 0)) b=i;
	}
	if (b==0) return RunTimeProblem(RTP_TOOMANYEVENTS);
	TimedEventsTable-->b = rule;
	if (absolute_time) TimedEventTimesTable-->b = event_time;
	else TimedEventTimesTable-->b = -event_time;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Setting Time Of Day
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Global time_step;

[ SetTime t s;
    the_time = t; time_rate = s; time_step = 0;
    if (s < 0) time_step = 0-s;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Advance Time Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ADVANCE_TIME_R;
    turns++;
    if (the_time ~= NULL) {
        if (time_rate >= 0) the_time = the_time+time_rate;
        else {
            time_step--;
            if (time_step == 0) {
                the_time++;
                time_step = -time_rate;
            }
        }
        the_time = the_time % TWENTY_FOUR_HOURS;
    }
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Note Object Acquisitions Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ NOTE_OBJECT_ACQUISITIONS_R obj;
    objectloop (obj in player) give obj moved;
    objectloop (obj has concealed)
    	if (IndirectlyContains(player, obj)) give obj ~concealed;
    #Ifdef RUCKSACK_CLASS;
	objectloop (obj in player)
		if (obj ofclass RUCKSACK_CLASS)
			SACK_OBJECT = obj;
	objectloop (obj ofclass RUCKSACK_CLASS && obj provides component_parent
		&& obj.component_parent == player)
		SACK_OBJECT = obj;
	#Endif;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Resurrect Player If Asked Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ RESURRECT_PLAYER_IF_ASKED_R;
	if (resurrect_please) {
		RulebookSucceeds(); resurrect_please = false;
		deadflag = 0; story_complete = false; rtrue;
	}
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Ask The Final Question Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ASK_FINAL_QUESTION_R;
	print "^";
	while (true) {
		CarryOutActivity(DEALING_WITH_FINAL_QUESTION_ACT);
		DivideParagraphPoint();
		if (resurrect_please) rtrue;
    }
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Read The Final Answer Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ READ_FINAL_ANSWER_R;
	DrawStatusLine();
	KeyboardPrimitive(buffer, parse);
	players_command = 100 + WordCount();
	num_words = WordCount();
	wn = 1;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Immediately Restart VM Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ IMMEDIATELY_RESTART_VM_R; @restart; ];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Immediately Restore Saved Game Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ IMMEDIATELY_RESTORE_SAVED_R; actor = player; RESTORE_THE_GAME_R(); ];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Immediately Quit Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ IMMEDIATELY_QUIT_R; @quit; ];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Immediately Undo Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ IMMEDIATELY_UNDO_R; Perform_Undo(); ];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Print Obituary Headline Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PRINT_OBITUARY_HEADLINE_R;
    print "^^    ";
    VM_Style(ALERT_VMSTY);
    print "***";
    if (deadflag == 1) PRINT_OBITUARY_HEADLINE_RM('A');
    if (deadflag == 2) PRINT_OBITUARY_HEADLINE_RM('B');
    if (deadflag == 3) PRINT_OBITUARY_HEADLINE_RM('C');
    if (deadflag ~= 0 or 1 or 2 or 3)  {
        print " ";
        TEXT_TY_Say(deadflag);
        print " ";
    }
    print "***";
    VM_Style(NORMAL_VMSTY);
    print "^^"; #Ifndef NO_SCORING; print "^"; #Endif;
    rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Print Final Score Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PRINT_FINAL_SCORE_R;
	#Iftrue USE_SCORING ~= 0; ANNOUNCE_SCORE_R(); #Endif;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Display Final Status Line Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ DISPLAY_FINAL_STATUS_LINE_R;
	sline1 = score; sline2 = turns;
	rfalse;
];



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Properties
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant p3_list_grouping_key = list_together;
Constant p4_printed_name = short_name;
Constant p5_printed_plural_name = plural;
Constant p6_indefinite_article = article;
Constant p7_description = description;
Constant p8_map_region = map_region;
Constant p9_initial_appearance = initial;
Constant p11_other_side = door_to;
Constant p12_carrying_capacity = capacity;
Constant p13_matching_key = with_key;
Constant p16_plural_named = pluralname;
Constant p18_proper_named = proper;
Constant p20_ambiguously_plural = ambigpluralname;
Constant p21_privately_named = privately_named;
Constant p23_lighted = light;
Constant p25_visited = visited;
Constant p27_lit = light;
Constant p29_edible = edible;
Constant p31_fixed_in_place = static;
Constant p33_scenery = scenery;
Constant p34_wearable = clothing;
Constant p35_pushable_between_rooms = pushable;
Constant p36_handled = moved;
Constant p38_undescribed = concealed;
Constant p39_marked_for_listing = workflag;
Constant p41_mentioned = mentioned;
Constant p43_enterable = enterable;
Constant p45_transparent = transparent;
Constant p46_open = open;
Constant p48_openable = openable;
Constant p50_lockable = lockable;
Constant p51_locked = locked;
Constant p53_female = female;
Constant p54_male = male;
Constant p55_neuter = neuter;
Constant p56_switched_on = on;
Constant p71 = worn;
Constant p72 = vector;
Constant p73 = room_index;
Constant p74 = door_dir;
Constant p75 = door_to;
Constant p76 = found_in;
Constant p77 = absent;
Constant p78 = cap_short_name;
Constant p79 = mark_as_room;
Constant p80 = mark_as_thing;
Constant p81 = component_parent;
Constant p82 = component_child;
Constant p83 = component_sibling;
Constant p84 = regional_found_in;
Constant p85 = IK1_Count;
Constant p86 = IK1_Link;
Constant p87 = IK2_Count;
Constant p88 = IK2_Link;
Constant p89 = IK3_Count;
Constant p90 = IK3_Link;
Constant p91 = IK4_Count;
Constant p92 = IK4_Link;
Constant p93 = IK5_Count;
Constant p94 = IK5_Link;
Constant p95 = IK6_Count;
Constant p96 = IK6_Link;
Constant p97 = IK7_Count;
Constant p98 = IK7_Link;
Constant p99 = IK8_Count;
Constant p100 = IK8_Link;
Constant p101 = IK9_Count;
Constant p102 = IK9_Link;
Constant p103 = IK10_Count;
Constant p104 = IK10_Link;
Constant p105 = IK11_Count;
Constant p106 = IK11_Link;
Constant p107 = IK12_Count;
Constant p108 = IK12_Link;
Constant p109 = IK13_Count;
Constant p110 = IK13_Link;
Constant p111 = IK14_Count;
Constant p112 = IK14_Link;
Constant p113 = IK15_Count;
Constant p114 = IK15_Link;
Constant p115 = IK16_Count;
Constant p116 = IK16_Link;
Constant p117 = IK17_Count;
Constant p118 = IK17_Link;
Constant p119 = IK18_Count;
Constant p120 = IK18_Link;
Constant p121 = IK19_Count;
Constant p122 = IK19_Link;
Constant p123 = IK20_Count;
Constant p124 = IK20_Link;
Constant p125 = IK21_Count;
Constant p126 = IK21_Link;
Constant p127 = IK22_Count;
Constant p128 = IK22_Link;
Constant p129 = IK23_Count;
Constant p130 = IK23_Link;
Constant p131 = KD_Count;
Constant p132 = name;
Constant p133 = parse_name;
Constant p134 = action_bitmap;

Attribute p63_distant;
Attribute p65_cursed;
Attribute p67_indoors;
Attribute p69_explored;
Constant FBNA_PROP_NUMBER = p58_recurring;
Object property_numberspace_forcer
    with p58_recurring false
;

Array property_metadata -->
    ! offset 0: property p0_specification
    "specification" NULL
    ! offset 2: property p1_indefinite_appearance_tex
    "indefinite appearance text" NULL
    ! offset 4: property p2_variable_initial_value
    "variable initial value" K1_room K2_thing K3_direction K9_region NULL
    ! offset 10: property list_together
    "list grouping key" K1_room K2_thing K3_direction K9_region NULL
    ! offset 16: property short_name
    "printed name" K1_room K2_thing K3_direction K9_region NULL
    ! offset 22: property plural
    "printed plural name" K1_room K2_thing K3_direction K9_region NULL
    ! offset 28: property article
    "indefinite article" K1_room K2_thing K3_direction K9_region NULL
    ! offset 34: property description
    "description" K1_room K2_thing NULL
    ! offset 38: property map_region
    "map region" K1_room NULL
    ! offset 41: property initial
    "initial appearance" K2_thing NULL
    ! offset 44: property p10_opposite
    "opposite" K3_direction NULL
    ! offset 47: property door_to
    "other side" K4_door NULL
    ! offset 50: property capacity
    "carrying capacity" K5_container K6_supporter K8_person NULL
    ! offset 55: property with_key
    "matching key" K2_thing K4_door K5_container NULL
    ! offset 60: property p14_adaptive_text_viewpoint
    "adaptive text viewpoint" NULL
    ! offset 62: property p15_reading_material
    "reading-material" K2_thing NULL
    ! offset 65: property pluralname
    "plural-named" K1_room K2_thing K3_direction K9_region NULL
    ! offset 71: property proper
    "proper-named" K1_room K2_thing K3_direction K9_region NULL
    ! offset 77: property ambigpluralname
    "ambiguously plural" K2_thing K1_room K2_thing K3_direction K9_region NULL
    ! offset 84: property privately_named
    "privately-named" K1_room K2_thing K3_direction K9_region NULL
    ! offset 90: property light
    "lighted" K1_room K2_thing NULL
    ! offset 94: property visited
    "visited" K1_room NULL
    ! offset 97: property light
    "lit" K1_room K2_thing NULL
    ! offset 101: property edible
    "edible" K2_thing NULL
    ! offset 104: property static
    "fixed in place" K2_thing NULL
    ! offset 107: property scenery
    "scenery" K2_thing NULL
    ! offset 110: property clothing
    "wearable" K2_thing NULL
    ! offset 113: property pushable
    "pushable between rooms" K2_thing NULL
    ! offset 116: property moved
    "handled" K2_thing NULL
    ! offset 119: property concealed
    "undescribed" K2_thing NULL
    ! offset 122: property workflag
    "marked for listing" K2_thing K3_direction NULL
    ! offset 126: property mentioned
    "mentioned" K2_thing NULL
    ! offset 129: property enterable
    "enterable" K5_container K6_supporter NULL
    ! offset 133: property transparent
    "transparent" K5_container NULL
    ! offset 136: property open
    "open" K4_door K5_container NULL
    ! offset 140: property openable
    "openable" K4_door K5_container NULL
    ! offset 144: property lockable
    "lockable" K4_door K5_container NULL
    ! offset 148: property locked
    "locked" K4_door K5_container NULL
    ! offset 152: property female
    "female" K2_thing NULL
    ! offset 155: property male
    "male" K2_thing NULL
    ! offset 158: property neuter
    "neuter" K2_thing NULL
    ! offset 161: property on
    "switched on" K13_device NULL
    ! offset 164: property p58_recurring
    "recurring" NULL
    ! offset 166: property p60_unbolting
    "unbolting" K2_thing NULL
    ! offset 169: property p62_gender
    "gender" K8_person NULL
    ! offset 172: property p63_distant
    "distant" K2_thing NULL
    ! offset 175: property p65_cursed
    "cursed" K1_room NULL
    ! offset 178: property p67_indoors
    "indoors" K1_room NULL
    ! offset 181: property p69_explored
    "explored" K23_drawer NULL
    ! offset 184: property worn
    "<nameless>" NULL
    ! offset 186: property vector
    "<nameless>" NULL
    ! offset 188: property room_index
    "<nameless>" NULL
    ! offset 190: property door_dir
    "<nameless>" NULL
    ! offset 192: property door_to
    "<nameless>" K4_door NULL
    ! offset 195: property found_in
    "<nameless>" NULL
    ! offset 197: property absent
    "<nameless>" NULL
    ! offset 199: property cap_short_name
    "<nameless>" NULL
    ! offset 201: property mark_as_room
    "<nameless>" NULL
    ! offset 203: property mark_as_thing
    "<nameless>" NULL
    ! offset 205: property component_parent
    "<nameless>" NULL
    ! offset 207: property component_child
    "<nameless>" NULL
    ! offset 209: property component_sibling
    "<nameless>" NULL
    ! offset 211: property regional_found_in
    "<nameless>" NULL
    ! offset 213: property IK1_Count
    "<nameless>" NULL
    ! offset 215: property IK1_Link
    "<nameless>" NULL
    ! offset 217: property IK2_Count
    "<nameless>" NULL
    ! offset 219: property IK2_Link
    "<nameless>" NULL
    ! offset 221: property IK3_Count
    "<nameless>" NULL
    ! offset 223: property IK3_Link
    "<nameless>" NULL
    ! offset 225: property IK4_Count
    "<nameless>" NULL
    ! offset 227: property IK4_Link
    "<nameless>" NULL
    ! offset 229: property IK5_Count
    "<nameless>" NULL
    ! offset 231: property IK5_Link
    "<nameless>" NULL
    ! offset 233: property IK6_Count
    "<nameless>" NULL
    ! offset 235: property IK6_Link
    "<nameless>" NULL
    ! offset 237: property IK7_Count
    "<nameless>" NULL
    ! offset 239: property IK7_Link
    "<nameless>" NULL
    ! offset 241: property IK8_Count
    "<nameless>" NULL
    ! offset 243: property IK8_Link
    "<nameless>" NULL
    ! offset 245: property IK9_Count
    "<nameless>" NULL
    ! offset 247: property IK9_Link
    "<nameless>" NULL
    ! offset 249: property IK10_Count
    "<nameless>" NULL
    ! offset 251: property IK10_Link
    "<nameless>" NULL
    ! offset 253: property IK11_Count
    "<nameless>" NULL
    ! offset 255: property IK11_Link
    "<nameless>" NULL
    ! offset 257: property IK12_Count
    "<nameless>" NULL
    ! offset 259: property IK12_Link
    "<nameless>" NULL
    ! offset 261: property IK13_Count
    "<nameless>" NULL
    ! offset 263: property IK13_Link
    "<nameless>" NULL
    ! offset 265: property IK14_Count
    "<nameless>" NULL
    ! offset 267: property IK14_Link
    "<nameless>" NULL
    ! offset 269: property IK15_Count
    "<nameless>" NULL
    ! offset 271: property IK15_Link
    "<nameless>" NULL
    ! offset 273: property IK16_Count
    "<nameless>" NULL
    ! offset 275: property IK16_Link
    "<nameless>" NULL
    ! offset 277: property IK17_Count
    "<nameless>" NULL
    ! offset 279: property IK17_Link
    "<nameless>" NULL
    ! offset 281: property IK18_Count
    "<nameless>" NULL
    ! offset 283: property IK18_Link
    "<nameless>" NULL
    ! offset 285: property IK19_Count
    "<nameless>" NULL
    ! offset 287: property IK19_Link
    "<nameless>" NULL
    ! offset 289: property IK20_Count
    "<nameless>" NULL
    ! offset 291: property IK20_Link
    "<nameless>" NULL
    ! offset 293: property IK21_Count
    "<nameless>" NULL
    ! offset 295: property IK21_Link
    "<nameless>" NULL
    ! offset 297: property IK22_Count
    "<nameless>" NULL
    ! offset 299: property IK22_Link
    "<nameless>" NULL
    ! offset 301: property IK23_Count
    "<nameless>" NULL
    ! offset 303: property IK23_Link
    "<nameless>" NULL
    ! offset 305: property KD_Count
    "<nameless>" NULL
    ! offset 307: property name
    "<nameless>" NULL
    ! offset 309: property parse_name
    "<nameless>" NULL
    ! offset 311: property action_bitmap
    "<nameless>" NULL
;

Constant attributed_property_offsets_SIZE 48;
Array attributed_property_offsets --> attributed_property_offsets_SIZE;
Constant valued_property_offsets_SIZE (100 + 135 + INDIV_PROP_START-48);
Array valued_property_offsets --> valued_property_offsets_SIZE;

[ CreatePropertyOffsets 
    i ! loop counter
    ;
    for (i=0: i<attributed_property_offsets_SIZE: i++)attributed_property_offsets-->i = -1;
    for (i=0: i<valued_property_offsets_SIZE: i++)valued_property_offsets-->i = -1;
    valued_property_offsets-->p0_specification = 0;
    valued_property_offsets-->p1_indefinite_appearance_tex = 2;
    valued_property_offsets-->p2_variable_initial_value = 4;
    valued_property_offsets-->list_together = 10;
    valued_property_offsets-->short_name = 16;
    valued_property_offsets-->plural = 22;
    valued_property_offsets-->article = 28;
    valued_property_offsets-->description = 34;
    valued_property_offsets-->map_region = 38;
    valued_property_offsets-->initial = 41;
    valued_property_offsets-->p10_opposite = 44;
    valued_property_offsets-->door_to = 47;
    valued_property_offsets-->capacity = 50;
    valued_property_offsets-->with_key = 55;
    valued_property_offsets-->p14_adaptive_text_viewpoint = 60;
    valued_property_offsets-->p15_reading_material = 62;
    attributed_property_offsets-->pluralname = 65;
    attributed_property_offsets-->proper = 71;
    attributed_property_offsets-->ambigpluralname = 77;
    attributed_property_offsets-->privately_named = 84;
    attributed_property_offsets-->light = 90;
    attributed_property_offsets-->visited = 94;
    attributed_property_offsets-->light = 97;
    attributed_property_offsets-->edible = 101;
    attributed_property_offsets-->static = 104;
    attributed_property_offsets-->scenery = 107;
    attributed_property_offsets-->clothing = 110;
    attributed_property_offsets-->pushable = 113;
    attributed_property_offsets-->moved = 116;
    attributed_property_offsets-->concealed = 119;
    attributed_property_offsets-->workflag = 122;
    attributed_property_offsets-->mentioned = 126;
    attributed_property_offsets-->enterable = 129;
    attributed_property_offsets-->transparent = 133;
    attributed_property_offsets-->open = 136;
    attributed_property_offsets-->openable = 140;
    attributed_property_offsets-->lockable = 144;
    attributed_property_offsets-->locked = 148;
    attributed_property_offsets-->female = 152;
    attributed_property_offsets-->male = 155;
    attributed_property_offsets-->neuter = 158;
    attributed_property_offsets-->on = 161;
    valued_property_offsets-->p58_recurring = 164;
    valued_property_offsets-->p60_unbolting = 166;
    valued_property_offsets-->p62_gender = 169;
    attributed_property_offsets-->p63_distant = 172;
    attributed_property_offsets-->p65_cursed = 175;
    attributed_property_offsets-->p67_indoors = 178;
    attributed_property_offsets-->p69_explored = 181;
    attributed_property_offsets-->worn = 184;
    valued_property_offsets-->vector = 186;
    valued_property_offsets-->room_index = 188;
    valued_property_offsets-->door_dir = 190;
    valued_property_offsets-->door_to = 192;
    valued_property_offsets-->found_in = 195;
    attributed_property_offsets-->absent = 197;
    valued_property_offsets-->cap_short_name = 199;
    attributed_property_offsets-->mark_as_room = 201;
    attributed_property_offsets-->mark_as_thing = 203;
    valued_property_offsets-->component_parent = 205;
    valued_property_offsets-->component_child = 207;
    valued_property_offsets-->component_sibling = 209;
    valued_property_offsets-->regional_found_in = 211;
    valued_property_offsets-->IK1_Count = 213;
    valued_property_offsets-->IK1_Link = 215;
    valued_property_offsets-->IK2_Count = 217;
    valued_property_offsets-->IK2_Link = 219;
    valued_property_offsets-->IK3_Count = 221;
    valued_property_offsets-->IK3_Link = 223;
    valued_property_offsets-->IK4_Count = 225;
    valued_property_offsets-->IK4_Link = 227;
    valued_property_offsets-->IK5_Count = 229;
    valued_property_offsets-->IK5_Link = 231;
    valued_property_offsets-->IK6_Count = 233;
    valued_property_offsets-->IK6_Link = 235;
    valued_property_offsets-->IK7_Count = 237;
    valued_property_offsets-->IK7_Link = 239;
    valued_property_offsets-->IK8_Count = 241;
    valued_property_offsets-->IK8_Link = 243;
    valued_property_offsets-->IK9_Count = 245;
    valued_property_offsets-->IK9_Link = 247;
    valued_property_offsets-->IK10_Count = 249;
    valued_property_offsets-->IK10_Link = 251;
    valued_property_offsets-->IK11_Count = 253;
    valued_property_offsets-->IK11_Link = 255;
    valued_property_offsets-->IK12_Count = 257;
    valued_property_offsets-->IK12_Link = 259;
    valued_property_offsets-->IK13_Count = 261;
    valued_property_offsets-->IK13_Link = 263;
    valued_property_offsets-->IK14_Count = 265;
    valued_property_offsets-->IK14_Link = 267;
    valued_property_offsets-->IK15_Count = 269;
    valued_property_offsets-->IK15_Link = 271;
    valued_property_offsets-->IK16_Count = 273;
    valued_property_offsets-->IK16_Link = 275;
    valued_property_offsets-->IK17_Count = 277;
    valued_property_offsets-->IK17_Link = 279;
    valued_property_offsets-->IK18_Count = 281;
    valued_property_offsets-->IK18_Link = 283;
    valued_property_offsets-->IK19_Count = 285;
    valued_property_offsets-->IK19_Link = 287;
    valued_property_offsets-->IK20_Count = 289;
    valued_property_offsets-->IK20_Link = 291;
    valued_property_offsets-->IK21_Count = 293;
    valued_property_offsets-->IK21_Link = 295;
    valued_property_offsets-->IK22_Count = 297;
    valued_property_offsets-->IK22_Link = 299;
    valued_property_offsets-->IK23_Count = 301;
    valued_property_offsets-->IK23_Link = 303;
    valued_property_offsets-->KD_Count = 305;
    valued_property_offsets-->name = 307;
    valued_property_offsets-->parse_name = 309;
    valued_property_offsets-->action_bitmap = 311;
];



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Activities
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant NUMBER_RULEBOOKS_CREATED = 407;
Constant V0_printing_the_name = 0;
Constant V1_printing_the_plural_name = 1;
Constant V2_printing_a_number = 2;
Constant V3_printing_room_description = 3;
Constant V4_printing_inventory_detail = 4;
Constant V5_listing_contents = 5;
Constant V6_grouping_together = 6;
Constant V7_writing_a_paragraph_about = 7;
Constant V8_listing_nondescript_items = 8;
Constant V9_printing_the_name_of_a_da = 9;
Constant V10_printing_the_description = 10;
Constant V11_printing_the_announcemen = 11;
Constant V12_printing_the_announcemen = 12;
Constant V13_printing_a_refusal_to_ac = 13;
Constant V14_constructing_the_status_ = 14;
Constant V15_printing_the_banner_text = 15;
Constant V16_reading_a_command = 16;
Constant V17_deciding_the_scope = 17;
Constant V18_deciding_the_concealed_p = 18;
Constant V19_deciding_whether_all_inc = 19;
Constant V20_clarifying_the_parser_s_ = 20;
Constant V21_asking_which_do_you_mean = 21;
Constant V22_printing_a_parser_error = 22;
Constant V23_supplying_a_missing_noun = 23;
Constant V24_supplying_a_missing_seco = 24;
Constant V25_implicitly_taking = 25;
Constant V26_starting_the_virtual_mac = 26;
Constant V27_amusing_a_victorious_pla = 27;
Constant V28_printing_the_player_s_ob = 28;
Constant V29_handling_the_final_quest = 29;
Constant V30_printing_the_locale_desc = 30;
Constant V31_choosing_notable_locale_ = 31;
Constant V32_printing_a_locale_paragr = 32;
Constant V33_issuing_the_response_tex = 33;
Constant V34_refusing_keys = 34;
Constant V35_displaying = 35;
Constant V36_pausing_the_game = 36;

Array Activity_before_rulebooks --> 28 31 34 37 40 43 46 49 52 55 58 61 64 67 70 73 76 79 82 85 88 91 94 97 100 103 106 109 112 115 118 121 124 127 361 370 373 NULL;

Array Activity_for_rulebooks --> 29 32 35 38 41 44 47 50 53 56 59 62 65 68 71 74 77 80 83 86 89 92 95 98 101 104 107 110 113 116 119 122 125 128 362 371 374 NULL;

Array Activity_after_rulebooks --> 30 33 36 39 42 45 48 51 54 57 60 63 66 69 72 75 78 81 84 87 90 93 96 99 102 105 108 111 114 117 120 123 126 129 363 372 375 NULL;

Array Activity_atb_rulebooks -> 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ff;



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Relations
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant RELS_SYMMETRIC $8000;
Constant RELS_EQUIVALENCE $4000;
Constant RELS_X_UNIQUE $2000;
Constant RELS_Y_UNIQUE $1000;
Constant RELS_TEST $0800;
Constant RELS_ASSERT_TRUE $0400;
Constant RELS_ASSERT_FALSE $0200;
Constant RELS_SHOW $0100;
Constant RELS_ROUTE_FIND $0080;
Constant RELS_ROUTE_FIND_COUNT $0040;
Constant RELS_LOOKUP_ANY $0008;
Constant RELS_LOOKUP_ALL_X $0004;
Constant RELS_LOOKUP_ALL_Y $0002;
Constant RELS_LIST $0001;
#Iftrue (WORDSIZE == 2);
Constant REL_BLOCK_HEADER ($100*5 + $$1101);
#Ifnot;
Constant REL_BLOCK_HEADER ($100*6 + $$1101)*$10000;
#Endif;



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Printing Routines
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PrintSceneName 
    value ! Implied call parameter
    ;
    switch(value) {
        I77_entire_game: print "Entire Game";
        I156_chooseyourdestiny: print "chooseYourDestiny";
        I179_gazelletransformation: print "gazelleTransformation";
        I219_gagglebecomesherd: print "gaggleBecomesHerd";
        I229_newscast: print "newsCast";
        I290_joining_the_zoo: print "Joining The Zoo";
        I341_genieinabottle: print "genieInABottle";
        I365_exploring_your_office: print "Exploring Your Office";
        I371_jerked: print "Jerked";
        I400_supplyshopevent: print "supplyShopEvent";
        I418_here_girl: print "Here Girl";
        I419_sizeincrease: print "SizeIncrease";
        I420_dontcroak: print "dontCroak";
        I421_maretf: print "MareTf";
        I422_swineoption: print "SwineOption";
        default: print "<illegal scene>";
    }
];
[ A_PrintSceneName 
    value ! Implied call parameter
    ;
    return (value % 15)+1;
];
[ B_PrintSceneName 
    value ! Implied call parameter
    ;
    return ((value+13) % 15)+1;
];
[ R_PrintSceneName 
    a ! Implied call parameter
    b ! Implied call parameter
    ;
    if (a == 0 && b == 0) return (random(15));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ PrintFigureName 
    value ! Implied call parameter
    ;
    switch(value) {
        I76_figure_of_cover: print "Figure of cover";
        default: print "<illegal figure name>";
    }
];
[ A_PrintFigureName 
    value ! Implied call parameter
    ;
    return (value % 1)+1;
];
[ B_PrintFigureName 
    value ! Implied call parameter
    ;
    return ((value+-1) % 1)+1;
];
[ R_PrintFigureName 
    a ! Implied call parameter
    b ! Implied call parameter
    ;
    if (a == 0 && b == 0) return (random(1));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ PrintSoundName 
    value ! Implied call parameter
    ;
    switch(value) {
        default: print "<illegal sound name>";
    }
];
[ A_PrintSoundName 
    value ! Implied call parameter
    ;
    return (value % 0)+1;
];
[ B_PrintSoundName 
    value ! Implied call parameter
    ;
    return ((value+-2) % 0)+1;
];
[ R_PrintSoundName 
    a ! Implied call parameter
    b ! Implied call parameter
    ;
    if (a == 0 && b == 0) return (random(0));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ PrintExternalFileName 
    value ! Implied call parameter
    ;
    switch(value) {
        default: print "<illegal external file>";
    }
];
[ A_PrintExternalFileName 
    value ! Implied call parameter
    ;
    return (value % 0)+1;
];
[ B_PrintExternalFileName 
    value ! Implied call parameter
    ;
    return ((value+-2) % 0)+1;
];
[ R_PrintExternalFileName 
    a ! Implied call parameter
    b ! Implied call parameter
    ;
    if (a == 0 && b == 0) return (random(0));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ T60 
    value ! Implied call parameter
    ;
    switch(value) {
        I70_english_language: print "English language";
        I71_french_language: print "French language";
        I72_german_language: print "German language";
        I73_italian_language: print "Italian language";
        I74_spanish_language: print "Spanish language";
        I75_swedish_language: print "Swedish language";
        default: print "<illegal natural language>";
    }
];
[ A_T60 
    value ! Implied call parameter
    ;
    return (value % 6)+1;
];
[ B_T60 
    value ! Implied call parameter
    ;
    return ((value+4) % 6)+1;
];
[ R_T60 
    a ! Implied call parameter
    b ! Implied call parameter
    ;
    if (a == 0 && b == 0) return (random(6));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ T61 
    value ! Implied call parameter
    ;
    switch(value) {
        I79_didn_t_understand_error: print "didn't understand error";
        I80_only_understood_as_far_a: print "only understood as far as error";
        I81_didn_t_understand_that_n: print "didn't understand that number error";
        I82_can_only_do_that_to_some: print "can only do that to something animate error";
        I83_can_t_see_any_such_thing: print "can't see any such thing error";
        I84_said_too_little_error: print "said too little error";
        I85_aren_t_holding_that_erro: print "aren't holding that error";
        I86_can_t_use_multiple_objec: print "can't use multiple objects error";
        I87_can_only_use_multiple_ob: print "can only use multiple objects error";
        I88_not_sure_what_it_refers_: print "not sure what it refers to error";
        I89_excepted_something_not_i: print "excepted something not included error";
        I90_not_a_verb_i_recognise_e: print "not a verb I recognise error";
        I91_not_something_you_need_t: print "not something you need to refer to error";
        I92_can_t_see_it_at_the_mome: print "can't see it at the moment error";
        I93_didn_t_understand_the_wa: print "didn't understand the way that finished error";
        I94_not_enough_of_those_avai: print "not enough of those available error";
        I95_nothing_to_do_error: print "nothing to do error";
        I96_noun_did_not_make_sense_: print "noun did not make sense in that context error";
        I97_referred_to_a_determinat: print "referred to a determination of scope error";
        I98_i_beg_your_pardon_error: print "I beg your pardon error";
        I99_can_t_again_the_addresse: print "can't again the addressee error";
        I100_comma_can_t_begin_error: print "comma can't begin error";
        I101_can_t_see_whom_to_talk_: print "can't see whom to talk to error";
        I102_can_t_talk_to_inanimate: print "can't talk to inanimate things error";
        I103_didn_t_understand_addre: print "didn't understand addressee's last name error";
        default: print "<illegal command parser error>";
    }
];
[ A_T61 
    value ! Implied call parameter
    ;
    return (value % 25)+1;
];
[ B_T61 
    value ! Implied call parameter
    ;
    return ((value+23) % 25)+1;
];
[ R_T61 
    a ! Implied call parameter
    b ! Implied call parameter
    ;
    if (a == 0 && b == 0) return (random(25));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ T62 
    value ! Implied call parameter
    ;
    switch(value) {
        I105_present_tense: print "present tense";
        I106_past_tense: print "past tense";
        I107_perfect_tense: print "perfect tense";
        I108_past_perfect_tense: print "past perfect tense";
        I109_future_tense: print "future tense";
        default: print "<illegal grammatical tense>";
    }
];
[ A_T62 
    value ! Implied call parameter
    ;
    return (value % 5)+1;
];
[ B_T62 
    value ! Implied call parameter
    ;
    return ((value+3) % 5)+1;
];
[ R_T62 
    a ! Implied call parameter
    b ! Implied call parameter
    ;
    if (a == 0 && b == 0) return (random(5));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ T63 
    value ! Implied call parameter
    ;
    switch(value) {
        I111_first_person_singular: print "first person singular";
        I112_second_person_singular: print "second person singular";
        I113_third_person_singular: print "third person singular";
        I114_first_person_plural: print "first person plural";
        I115_second_person_plural: print "second person plural";
        I116_third_person_plural: print "third person plural";
        default: print "<illegal narrative viewpoint>";
    }
];
[ A_T63 
    value ! Implied call parameter
    ;
    return (value % 6)+1;
];
[ B_T63 
    value ! Implied call parameter
    ;
    return ((value+4) % 6)+1;
];
[ R_T63 
    a ! Implied call parameter
    b ! Implied call parameter
    ;
    if (a == 0 && b == 0) return (random(6));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ T64 
    value ! Implied call parameter
    ;
    switch(value) {
        I118_nominative: print "nominative";
        I119_accusative: print "accusative";
        default: print "<illegal grammatical case>";
    }
];
[ A_T64 
    value ! Implied call parameter
    ;
    return (value % 2)+1;
];
[ B_T64 
    value ! Implied call parameter
    ;
    return ((value+0) % 2)+1;
];
[ R_T64 
    a ! Implied call parameter
    b ! Implied call parameter
    ;
    if (a == 0 && b == 0) return (random(2));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ T65 
    value ! Implied call parameter
    ;
    switch(value) {
        I121_neuter_gender: print "neuter gender";
        I122_masculine_gender: print "masculine gender";
        I123_feminine_gender: print "feminine gender";
        default: print "<illegal grammatical gender>";
    }
];
[ A_T65 
    value ! Implied call parameter
    ;
    return (value % 3)+1;
];
[ B_T65 
    value ! Implied call parameter
    ;
    return ((value+1) % 3)+1;
];
[ R_T65 
    a ! Implied call parameter
    b ! Implied call parameter
    ;
    if (a == 0 && b == 0) return (random(3));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ T68 
    value ! Implied call parameter
    ;
    switch(value) {
        I128_masculine: print "masculine";
        I129_feminine: print "feminine";
        I130_unknown: print "unknown";
        default: print "<illegal gender>";
    }
];
[ A_T68 
    value ! Implied call parameter
    ;
    return (value % 3)+1;
];
[ B_T68 
    value ! Implied call parameter
    ;
    return ((value+1) % 3)+1;
];
[ R_T68 
    a ! Implied call parameter
    b ! Implied call parameter
    ;
    if (a == 0 && b == 0) return (random(3));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ PrintKindValuePair 
    k ! Implied call parameter
    v ! Implied call parameter
    ;
    k = KindAtomic(k);
      switch(k) {
        2: print (DA_Number) v;
        3: print (DA_Number) v;
        4: print (DA_Number) v;
        5: print (DA_Number) v;
        6: print (DA_Number) v;
        7: print (DA_Number) v;
        8: print (DA_Number) v;
        9: print (DA_Number) v;
        10: print (PrintShortName) v;
        11: print (DecimalNumber) v;
        12: print (REAL_NUMBER_TY_Say) v;
        13: print (DA_TruthState) v;
        14: print (TEXT_TY_Say) v;
        15: print (DecimalNumber) v;
        16: print (PrintUseOption) v;
        17: print (PrintResponse) v;
        18: print (PrintVerbAsValue) v;
        19: print (PrintSnippet) v;
        20: print (PrintTableName) v;
        21: print (DA_Number) v;
        22: print (RulebookOutcomePrintingRule) v;
        23: print (DecimalNumber) v;
        25: print (DecimalNumber) v;
        27: print (SayPhraseName) v;
        28: print (DecimalNumber) v;
        29: print (RELATION_TY_Say) v;
        30: print (RulePrintingRule) v;
        31: print (RulePrintingRule) v;
        32: print (DecimalNumber) v;
        33: print (LIST_OF_TY_Say) v;
        34: print (DecimalNumber) v;
        35: print (PROPERTY_TY_Say) v;
        36: print (DecimalNumber) v;
        37: print (COMBINATION_TY_Say) v;
        38: print (DecimalNumber) v;
        39: print (STORED_ACTION_TY_Say) v;
        40: print (SayActionName) v;
        41: print (PrintTimeOfDay) v;
        42: print (PrintSceneName) v;
        43: print (PrintFigureName) v;
        44: print (PrintSoundName) v;
        45: print (PrintExternalFileName) v;
        46: print (T60) v;
        47: print (T61) v;
        48: print (T62) v;
        49: print (T63) v;
        50: print (T64) v;
        51: print (T65) v;
        52: print (T68) v;
        default: print v;
    }
];
[ DefaultValueOfKOV 
    sk ! Implied call parameter
    k ! weak kind ID
    ;
    k = KindAtomic(sk);
    switch(k) {
        10: return nothing;
        11: return 0;
        12: return 0;
        13: return false;
        14: return BlkValueCreate(sk);
        15: return 32;
        16: return 0;
        17: return 0;
        18: return ConjugateVerb_0;
        19: return 101;
        20: return TheEmptyTable;
        21: return 0;
        22: return RBNO_0;
        23: return DefaultTopic;
        25: return ;
        33: return BlkValueCreate(sk);
        38: return ;
        39: return BlkValueCreate(sk);
        40: return ##Wait;
        41: return 540;
        42: return I77_entire_game;
        43: return I76_figure_of_cover;
        44: return ;
        45: return ;
        46: return I70_english_language;
        47: return I79_didn_t_understand_error;
        48: return I105_present_tense;
        49: return I111_first_person_singular;
        50: return I118_nominative;
        51: return I121_neuter_gender;
        52: return I128_masculine;
        default: return 0;
    }
];
[ KOVComparisonFunction 
    k ! Implied call parameter
    ;
    k = KindAtomic(k);
    switch(k) {
        10: return UnsignedCompare;
        12: return REAL_NUMBER_TY_Compare;
        13: return UnsignedCompare;
        14: return BlkValueCompare;
        15: return UnsignedCompare;
        16: return UnsignedCompare;
        17: return UnsignedCompare;
        18: return UnsignedCompare;
        19: return UnsignedCompare;
        20: return UnsignedCompare;
        21: return UnsignedCompare;
        22: return UnsignedCompare;
        23: return UnsignedCompare;
        25: return UnsignedCompare;
        33: return BlkValueCompare;
        38: return UnsignedCompare;
        39: return BlkValueCompare;
        40: return UnsignedCompare;
        42: return UnsignedCompare;
        43: return UnsignedCompare;
        44: return UnsignedCompare;
        45: return UnsignedCompare;
        default: return 0;
    }
];
[ KOVDomainSize 
    k ! Implied call parameter
    ;
    k = KindAtomic(k);
    switch(k) {
        42: return 15;
        43: return 1;
        44: return 0;
        45: return 0;
        46: return 6;
        47: return 25;
        48: return 5;
        49: return 6;
        50: return 2;
        51: return 3;
        52: return 3;
        default: return 0;
    }
];
[ KOVIsBlockValue 
    k ! Implied call parameter
    ;
    k = KindAtomic(k);
    if (k == 14 or 29 or 33 or 37 or 39) rtrue;
    rfalse;
];
[ KOVSupportFunction 
    k ! Implied call parameter
    fail ! Implied call parameter
    ;
    k = KindAtomic(k);
    switch(k) {
        14: return TEXT_TY_Support;
        29: return RELATION_TY_Support;
        33: return LIST_OF_TY_Support;
        37: return COMBINATION_TY_Support;
        39: return STORED_ACTION_TY_Support;
    }
    if (fail) BlkValueError(fail);
    rfalse;
];

[ I7_Kind_Name 
    k ! Implied call parameter
    ;
    if (k == K1_room) print "room";
    if (k == K2_thing) print "thing";
    if (k == K3_direction) print "direction";
    if (k == K4_door) print "door";
    if (k == K5_container) print "container";
    if (k == K6_supporter) print "supporter";
    if (k == K7_backdrop) print "backdrop";
    if (k == K8_person) print "person";
    if (k == K9_region) print "region";
    if (k == K10_man) print "man";
    if (k == K11_woman) print "woman";
    if (k == K12_animal) print "animal";
    if (k == K13_device) print "device";
    if (k == K14_vehicle) print "vehicle";
    if (k == K15_player_s_holdall) print "player's holdall";
    if (k == K16_passkey) print "passkey";
    if (k == K17_keychain) print "keychain";
    if (k == K18_streetlights) print "streetlights";
    if (k == K19_trees) print "trees";
    if (k == K20_bushes) print "bushes";
    if (k == K21_bench) print "bench";
    if (k == K22_train_platform) print "Train Platform";
    if (k == K23_drawer) print "drawer";
];

Constant RBNO_0 = "allow access";
Constant RBNO_1 = "deny access";
Constant RBNO_2 = "there is sufficient light";
Constant RBNO_3 = "there is insufficient light";
Constant RBNO_4 = "persuasion succeeds";
Constant RBNO_5 = "persuasion fails";
Constant RBNO_6 = "it is very likely";
Constant RBNO_7 = "it is likely";
Constant RBNO_8 = "it is possible";
Constant RBNO_9 = "it is unlikely";
Constant RBNO_10 = "it is very unlikely";
Constant RBNO_11 = "it does not";
Constant RBNO_12 = "it does";
[ RulebookOutcomePrintingRule 
    rbno ! Implied call parameter
    ;
    if (rbno == 0) print "(no outcome)";
    else print (string) rbno; rfalse;
];



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Object Tree
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


Array KindHierarchy --> K0_kind (0) K1_room (0) K2_thing (0) K3_direction (0) K4_door (2) K5_container (2) K6_supporter (2) K7_backdrop (2) K8_person (2) K9_region (0) K10_man (8) K11_woman (8) K12_animal (8) K13_device (2) K14_vehicle (5) K15_player_s_holdall (5) K16_passkey (2) K17_keychain (6) K18_streetlights (2) K19_trees (2) K20_bushes (2) K21_bench (6) K22_train_platform (6) K23_drawer (5) ;
Constant IK1_First = I126_create_your_character;
Constant IK2_First = selfobj;
Constant IK3_First = I50_north;
Constant IK4_First = I155_fulfill_your_destiny;
Constant IK5_First = I138_small_gold_box;
Constant IK6_First = I307_bull_statue;
Constant IK7_First = I337_large_hill;
Constant IK8_First = selfobj;
Constant IK9_First = I139_southside_district;
Constant IK10_First = I198_elephant_statue;
Constant IK11_First = I157_witch;
Constant IK12_First = I355_unseen_birds;
Constant IK13_First = I160_streetlight;
Constant IK14_First = I282_old_truck;
Constant IK15_First = nothing;
Constant IK16_First = nothing;
Constant IK17_First = nothing;
Constant IK18_First = nothing;
Constant IK19_First = nothing;
Constant IK20_First = nothing;
Constant IK21_First = X174;
Constant IK22_First = X177;
Constant IK23_First = I186_top_drawer;
Constant No_Directions = 12;
! Table of direction object alias constants:
Constant DirectionObject_0 = I50_north;
Constant DirectionObject_1 = I51_northeast;
Constant DirectionObject_2 = I52_northwest;
Constant DirectionObject_3 = I53_south;
Constant DirectionObject_4 = I54_southeast;
Constant DirectionObject_5 = I55_southwest;
Constant DirectionObject_6 = I56_east;
Constant DirectionObject_7 = I57_west;
Constant DirectionObject_8 = I58_up;
Constant DirectionObject_9 = I59_down;
Constant DirectionObject_10 = in_obj;
Constant DirectionObject_11 = out_obj;
Array Map_Storage -->
 0 0 0 0 0 0 0 0 0 0 0 0 ! Exits from: I126_create_your_character
 I149_whispering_cave 0 0 0 0 0 0 0 0 0 0 0 ! Exits from: I131_now_the_coven_of_the_el
 0 0 0 0 0 0 I269_headmistresses_chambers I267_farm_co 0 0 0 0 ! Exits from: I132_now_the_farm_coven
 0 0 0 0 0 0 0 0 0 0 0 0 ! Exits from: I137_temp
 0 0 0 0 0 0 I155_fulfill_your_destiny 0 0 0 0 0 ! Exits from: I140_city_park
 I142_15_rogers_road 0 0 0 0 0 0 I155_fulfill_your_destiny 0 0 0 0 ! Exits from: I141_park_entrance
 I145_lackluster_apartments 0 I144_atkin_train_station I141_park_entrance 0 0 I147_dead_end I143_junkyard 0 0 0 0 ! Exits from: I142_15_rogers_road
 0 0 0 0 0 0 I142_15_rogers_road I255_entrance_to_warehouse_r 0 0 0 0 ! Exits from: I143_junkyard
 0 0 0 0 I142_15_rogers_road 0 0 0 0 0 0 0 ! Exits from: I144_atkin_train_station
 I146_hk_research_group 0 0 I142_15_rogers_road 0 0 0 0 I183_apartment_1025 0 0 0 ! Exits from: I145_lackluster_apartments
 I152_commercial_intersection 0 0 I145_lackluster_apartments 0 0 I151_kelmers_road 0 0 0 0 0 ! Exits from: I146_hk_research_group
 0 0 0 0 I148_small_trail 0 0 I142_15_rogers_road 0 0 0 0 ! Exits from: I147_dead_end
 0 0 I147_dead_end 0 I149_whispering_cave 0 0 0 0 0 0 0 ! Exits from: I148_small_trail
 0 0 I148_small_trail I131_now_the_coven_of_the_el 0 0 0 0 0 0 0 0 ! Exits from: I149_whispering_cave
 0 I384_party_avenue 0 0 0 I152_commercial_intersection 0 0 0 0 0 0 ! Exits from: I150_haverton_bridge
 0 0 0 0 0 0 I311_110_main_street I146_hk_research_group 0 0 0 0 ! Exits from: I151_kelmers_road
 I208_mall_entrance I150_haverton_bridge 0 I146_hk_research_group 0 0 0 I153_hermes_station 0 0 0 0 ! Exits from: I152_commercial_intersection
 0 0 0 0 0 0 I152_commercial_intersection 0 0 0 0 0 ! Exits from: I153_hermes_station
 0 0 0 0 0 0 0 0 0 I145_lackluster_apartments 0 0 ! Exits from: I183_apartment_1025
 I209_jupiter_hall 0 0 I152_commercial_intersection 0 0 0 0 0 0 0 0 ! Exits from: I208_mall_entrance
 I211_food_court 0 0 I208_mall_entrance 0 0 0 I210_tv4u 0 0 0 0 ! Exits from: I209_jupiter_hall
 0 0 0 0 0 0 I209_jupiter_hall 0 0 0 0 0 ! Exits from: I210_tv4u
 0 0 0 I209_jupiter_hall 0 0 I215_birds_of_paradise I216_venus_hall 0 I212_hotspot 0 0 ! Exits from: I211_food_court
 0 0 0 0 0 0 0 0 I211_food_court 0 0 0 ! Exits from: I212_hotspot
 0 0 0 0 0 0 I216_venus_hall 0 0 0 0 0 ! Exits from: I213_statuesque
 0 0 0 I216_venus_hall 0 0 0 0 0 0 0 0 ! Exits from: I214_gellin_like_a_vellin
 0 0 0 0 0 0 0 I211_food_court 0 0 0 0 ! Exits from: I215_birds_of_paradise
 I214_gellin_like_a_vellin 0 0 I217_dpc 0 0 I211_food_court I213_statuesque 0 0 0 0 ! Exits from: I216_venus_hall
 I216_venus_hall 0 0 0 0 0 0 0 0 0 0 0 ! Exits from: I217_dpc
 0 0 0 I258_ajk_supply_entrance 0 0 I143_junkyard I256_ocean_path 0 0 0 0 ! Exits from: I255_entrance_to_warehouse_r
 0 0 I257_shed 0 0 0 I255_entrance_to_warehouse_r 0 0 0 0 0 ! Exits from: I256_ocean_path
 0 0 0 0 I256_ocean_path 0 0 0 0 0 0 0 ! Exits from: I257_shed
 I255_entrance_to_warehouse_r 0 0 I260_tinman_moving_entrance 0 0 0 I259_ajk_warehouse 0 0 0 0 ! Exits from: I258_ajk_supply_entrance
 0 0 0 0 0 0 I258_ajk_supply_entrance 0 0 0 0 0 ! Exits from: I259_ajk_warehouse
 I258_ajk_supply_entrance 0 0 0 0 I261_small_bridge I263_dark_culdesac I262_tinman_warehouse 0 0 0 0 ! Exits from: I260_tinman_moving_entrance
 0 I260_tinman_moving_entrance 0 0 0 I264_entrance_to_docks 0 0 0 0 0 0 ! Exits from: I261_small_bridge
 0 0 0 0 0 0 I260_tinman_moving_entrance 0 0 0 0 0 ! Exits from: I262_tinman_warehouse
 0 0 0 0 0 0 0 I260_tinman_moving_entrance 0 0 0 0 ! Exits from: I263_dark_culdesac
 0 I261_small_bridge 0 I267_farm_co 0 0 I266_security_checkpoint I265_boat_ramp_1 0 0 0 0 ! Exits from: I264_entrance_to_docks
 0 0 0 0 0 0 I264_entrance_to_docks 0 0 0 0 0 ! Exits from: I265_boat_ramp_1
 0 0 0 0 0 0 0 I264_entrance_to_docks 0 0 0 0 ! Exits from: I266_security_checkpoint
 I264_entrance_to_docks 0 0 0 0 0 I132_now_the_farm_coven I268_boat_ramp_2 0 0 0 0 ! Exits from: I267_farm_co
 0 0 0 0 0 0 I267_farm_co 0 0 0 0 0 ! Exits from: I268_boat_ramp_2
 0 0 0 0 0 0 0 I132_now_the_farm_coven 0 0 0 0 ! Exits from: I269_headmistresses_chambers
 0 I324_100_main_street 0 I312_120_main_street 0 0 I325_perlman_investments I151_kelmers_road 0 0 0 0 ! Exits from: I311_110_main_street
 I311_110_main_street 0 0 I315_130_main_street 0 0 I313_120_haven_street 0 0 0 0 0 ! Exits from: I312_120_main_street
 0 0 0 0 0 0 I318_the_pigsty_bar_n_grill I312_120_main_street 0 0 0 0 ! Exits from: I313_120_haven_street
 0 0 0 0 0 0 I316_import_inc I315_130_main_street 0 0 0 0 ! Exits from: I314_130_haven_street
 I312_120_main_street 0 0 0 0 0 I314_130_haven_street 0 0 0 0 0 ! Exits from: I315_130_main_street
 0 0 0 0 0 0 I317_back_room I314_130_haven_street 0 0 0 0 ! Exits from: I316_import_inc
 0 0 0 0 0 0 0 I316_import_inc 0 0 0 0 ! Exits from: I317_back_room
 0 0 0 0 0 0 I319_back_entrance I313_120_haven_street 0 0 0 0 ! Exits from: I318_the_pigsty_bar_n_grill
 I320_fence_out_of_town 0 0 0 0 0 0 I318_the_pigsty_bar_n_grill 0 0 0 0 ! Exits from: I319_back_entrance
 I321_eastern_woods 0 0 I319_back_entrance 0 0 0 0 0 0 0 0 ! Exits from: I320_fence_out_of_town
 I322_cross_road 0 0 I320_fence_out_of_town 0 0 0 0 0 0 0 0 ! Exits from: I321_eastern_woods
 I323_goddesses_chambers 0 0 I321_eastern_woods 0 0 0 0 0 0 0 0 ! Exits from: I322_cross_road
 0 0 0 I322_cross_road 0 0 0 0 0 0 0 0 ! Exits from: I323_goddesses_chambers
 I328_ross_avenue I327_grungy_alleyway 0 0 0 I311_110_main_street I326_sloppys_fast_food 0 0 0 0 0 ! Exits from: I324_100_main_street
 0 0 0 0 0 0 0 I311_110_main_street 0 0 0 0 ! Exits from: I325_perlman_investments
 0 0 0 0 0 0 0 I324_100_main_street 0 0 0 0 ! Exits from: I326_sloppys_fast_food
 0 0 0 0 0 I324_100_main_street 0 0 0 0 0 0 ! Exits from: I327_grungy_alleyway
 0 0 0 I324_100_main_street 0 0 I329_path_to_the_sewers 0 0 0 0 0 ! Exits from: I328_ross_avenue
 0 0 0 0 0 0 0 I328_ross_avenue 0 0 0 0 ! Exits from: I329_path_to_the_sewers
 I389_upper_class_arts 0 0 0 0 I150_haverton_bridge I385_illus_design_corp 0 0 0 0 0 ! Exits from: I384_party_avenue
 0 I386_walter_haven 0 0 0 0 0 I384_party_avenue 0 0 0 0 ! Exits from: I385_illus_design_corp
 I387_side_pass 0 0 0 0 I385_illus_design_corp I404_mysterious_door 0 0 0 0 0 ! Exits from: I386_walter_haven
 0 I393_palomino_bar_n_grill 0 I386_walter_haven 0 I388_country_club 0 0 0 0 0 0 ! Exits from: I387_side_pass
 0 I387_side_pass 0 0 0 0 0 0 0 0 0 0 ! Exits from: I388_country_club
 0 I390_the_long_john 0 I384_party_avenue 0 0 0 0 0 0 0 0 ! Exits from: I389_upper_class_arts
 I391_secluded_alley 0 0 0 0 I389_upper_class_arts 0 0 0 0 0 0 ! Exits from: I390_the_long_john
 0 0 0 I390_the_long_john 0 0 I392_season_365 0 0 0 0 0 ! Exits from: I391_secluded_alley
 0 0 0 0 0 0 I393_palomino_bar_n_grill I391_secluded_alley 0 0 0 0 ! Exits from: I392_season_365
 0 0 0 0 0 I387_side_pass 0 I392_season_365 0 0 0 0 ! Exits from: I393_palomino_bar_n_grill
 0 0 0 0 0 0 0 I404_mysterious_door 0 0 0 0 ! Exits from: I403_striped_coven
;

Class VPH_Class;
Array KOV_representatives --> 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ValuePropertyHolder_42 0 0 0 ValuePropertyHolder_46 0 0 0 0 0 0 ;
VPH_Class ValuePropertyHolder_42
    with value_range 15
    with p58_recurring KOVP_42_P58
    with description KOVP_42_P7
;
! Storage for property p58_recurring of kind SCENE_TY
Array KOVP_42_P58 table 0 0 (true) (false) (false) (false) (false) (false) (false) (false) (false) (false) (false) (false) (false) (false) (false) ;
! Storage for property description of kind SCENE_TY
Array KOVP_42_P7 table 0 0 (BC_3) (BC_4) (BC_5) (BC_6) (BC_7) (BC_8) (BC_9) (BC_10) (BC_11) (BC_12) (BC_13) (BC_14) (BC_15) (BC_16) (BC_17) ;
VPH_Class ValuePropertyHolder_46
    with value_range 6
    with p14_adaptive_text_viewpoint KOVP_46_P14
;
! Storage for property p14_adaptive_text_viewpoint of kind 
Array KOVP_46_P14 table 0 0 (I114_first_person_plural) (I111_first_person_singular) (I111_first_person_singular) (I111_first_person_singular) (I111_first_person_singular) (I111_first_person_singular) ;
Class K0_kind 
    has ~pluralname
    has ~proper
    with list_together BC_18
    with short_name BC_19
    with plural BC_20
    with article BC_21
    has ~ambigpluralname
;

Class K1_room 
    class K0_kind
    with description BC_22
    with map_region nothing
    has ~privately_named
    has light
    has ~visited
    has ~p65_cursed
    has ~p67_indoors
    with list_together BC_23
    with short_name BC_24
    with plural BC_25
    with article BC_26
;

Class K2_thing 
    class K0_kind
    with p15_reading_material BC_27
    has ~privately_named
    has ~light
    has ~edible
    has ~static
    has ~concealed
    has ~workflag
    has mentioned
    has ~female
    has ~male
    has neuter
    has ~ambigpluralname
    has ~p63_distant
    with component_parent nothing
    with component_child nothing
    with component_sibling nothing
    with action_bitmap 0 0 0 0 0 0 
    has ~scenery
    has ~clothing
    has ~pushable
    has ~moved
    with description BC_28
    with initial BC_29
    with with_key nothing
    with p60_unbolting nothing
    with list_together BC_30
    with short_name BC_31
    with plural BC_32
    with article BC_33
;

Class K6_supporter 
    class K2_thing

    	has transparent supporter

    with plural BC_34
    with capacity 100
    has static
    has ~enterable
    with description BC_35
    with initial BC_36
    with p15_reading_material BC_37
    with list_together BC_38
    with short_name BC_39
    with article BC_40
;

Class K17_keychain 
    class K6_supporter
    with plural BC_41
    has ~static
    with description BC_42
    with initial BC_43
    with p15_reading_material BC_44
    with list_together BC_45
    with short_name BC_46
    with article BC_47
;

Class K21_bench 
    class K6_supporter
    with plural BC_48
    with description BC_49
    with initial BC_50
    with p15_reading_material BC_51
    with list_together BC_52
    with short_name BC_53
    with article BC_54
;

Class K22_train_platform 
    class K6_supporter
    with plural BC_55
    with description BC_56
    with initial BC_57
    with p15_reading_material BC_58
    with list_together BC_59
    with short_name BC_60
    with article BC_61
;

Class K8_person 
    class K2_thing
     
        has transparent animate 
        with before NULL, 

    with plural BC_62
    with capacity 100
    with p62_gender I128_masculine
    with description BC_63
    with initial BC_64
    with p15_reading_material BC_65
    with list_together BC_66
    with short_name BC_67
    with article BC_68
;

Class K10_man 
    class K8_person
    with plural BC_69
    has male
    has ~neuter
    with description BC_70
    with initial BC_71
    with p15_reading_material BC_72
    with list_together BC_73
    with short_name BC_74
    with article BC_75
;

Class K11_woman 
    class K8_person
    with plural BC_76
    has female
    has ~neuter
    with description BC_77
    with initial BC_78
    with p15_reading_material BC_79
    with list_together BC_80
    with short_name BC_81
    with article BC_82
;

Class K12_animal 
    class K8_person
    with plural BC_83
    with description BC_84
    with initial BC_85
    with p15_reading_material BC_86
    with list_together BC_87
    with short_name BC_88
    with article BC_89
;

Class K4_door 
    class K2_thing
     has door, 
    with plural BC_90
    has static
    has ~pushable
    has ~open
    has openable
    has ~lockable
    has ~locked
    with door_to nothing
    with with_key nothing
    with description BC_91
    with initial BC_92
    with p15_reading_material BC_93
    with list_together BC_94
    with short_name BC_95
    with article BC_96
;

Class K5_container 
    class K2_thing
     has container, 
    with plural BC_97
    with capacity 100
    has ~transparent
    has open
    has ~openable
    has ~lockable
    has ~locked
    has ~enterable
    with with_key nothing
    with description BC_98
    with initial BC_99
    with p15_reading_material BC_100
    with list_together BC_101
    with short_name BC_102
    with article BC_103
;

Class K14_vehicle 
    class K5_container
    with plural BC_104
    has static
    has enterable
    with description BC_105
    with initial BC_106
    with p15_reading_material BC_107
    with list_together BC_108
    with short_name BC_109
    with article BC_110
;

Class K15_player_s_holdall 
    class K5_container
    with plural BC_111
    has ~static
    has openable
    with description BC_112
    with initial BC_113
    with p15_reading_material BC_114
    with list_together BC_115
    with short_name BC_116
    with article BC_117
;

Class K23_drawer 
    class K5_container
    with plural BC_118
    with description BC_119
    has ~open
    has openable
    has ~p69_explored
    with initial BC_120
    with p15_reading_material BC_121
    with list_together BC_122
    with short_name BC_123
    with article BC_124
;

Class K7_backdrop 
    class K2_thing
    with plural BC_125
    has static
    has scenery
    has ~pushable
    with description BC_126
    with initial BC_127
    with p15_reading_material BC_128
    with list_together BC_129
    with short_name BC_130
    with article BC_131
;

Class K13_device 
    class K2_thing
     has switchable, 
    with plural BC_132
    has ~on
    with description BC_133
    with initial BC_134
    with p15_reading_material BC_135
    with list_together BC_136
    with short_name BC_137
    with article BC_138
;

Class K16_passkey 
    class K2_thing
    with plural BC_139
    with description BC_140
    with initial BC_141
    with p15_reading_material BC_142
    with list_together BC_143
    with short_name BC_144
    with article BC_145
;

Class K18_streetlights 
    class K2_thing
    with plural BC_146
    with description BC_147
    with initial BC_148
    with p15_reading_material BC_149
    with list_together BC_150
    with short_name BC_151
    with article BC_152
;

Class K19_trees 
    class K2_thing
    with plural BC_153
    with description BC_154
    with parse_name Parse_Name_GV96
    with initial BC_155
    with p15_reading_material BC_156
    with list_together BC_157
    with short_name BC_158
    with article BC_159
;

Class K20_bushes 
    class K2_thing
    with plural BC_160
    with description BC_161
    with initial BC_162
    with p15_reading_material BC_163
    with list_together BC_164
    with short_name BC_165
    with article BC_166
;

Class K9_region 
    class K0_kind
    with plural BC_167
    has ~privately_named
    with list_together BC_168
    with short_name BC_169
    with article BC_170
;

Class K3_direction 
    class K0_kind

    	has scenery, ! class CompassDirection,

    with plural BC_171
    has ~privately_named
    has ~workflag
    with p10_opposite I50_north
    with list_together BC_172
    with short_name BC_173
    with article BC_174
;

Object I50_north "" Compass
    class K3_direction
    with short_name BC_175
    with article BC_176
    with p10_opposite I53_south
    with vector 0
    with IK3_Count 0
    with IK3_Link I51_northeast
    with KD_Count 3
    with name 'north' 'directions//p' 'n//' 
    with parse_name Parse_Name_GV1
    with action_bitmap 0 0 0 0 0 0 
    with list_together BC_177
    with plural BC_178
;

Object I51_northeast "" Compass
    class K3_direction
    with short_name BC_179
    with article BC_180
    with p10_opposite I55_southwest
    with vector 0
    with IK3_Count 1
    with IK3_Link I52_northwest
    with KD_Count 3
    with name 'northeast' 'directions//p' 'ne' 
    with parse_name Parse_Name_GV2
    with action_bitmap 0 0 0 0 0 0 
    with list_together BC_181
    with plural BC_182
;

Object I52_northwest "" Compass
    class K3_direction
    with short_name BC_183
    with article BC_184
    with p10_opposite I54_southeast
    with vector 0
    with IK3_Count 2
    with IK3_Link I53_south
    with KD_Count 3
    with name 'northwest' 'directions//p' 'nw' 
    with parse_name Parse_Name_GV3
    with action_bitmap 0 0 0 0 0 0 
    with list_together BC_185
    with plural BC_186
;

Object I53_south "" Compass
    class K3_direction
    with short_name BC_187
    with article BC_188
    with p10_opposite I50_north
    with vector 0
    with IK3_Count 3
    with IK3_Link I54_southeast
    with KD_Count 3
    with name 'south' 'directions//p' 's//' 
    with parse_name Parse_Name_GV4
    with action_bitmap 0 0 0 0 0 0 
    with list_together BC_189
    with plural BC_190
;

Object I54_southeast "" Compass
    class K3_direction
    with short_name BC_191
    with article BC_192
    with p10_opposite I52_northwest
    with vector 0
    with IK3_Count 4
    with IK3_Link I55_southwest
    with KD_Count 3
    with name 'southeast' 'directions//p' 'se' 
    with parse_name Parse_Name_GV5
    with action_bitmap 0 0 0 0 0 0 
    with list_together BC_193
    with plural BC_194
;

Object I55_southwest "" Compass
    class K3_direction
    with short_name BC_195
    with article BC_196
    with p10_opposite I51_northeast
    with vector 0
    with IK3_Count 5
    with IK3_Link I56_east
    with KD_Count 3
    with name 'southwest' 'directions//p' 'sw' 
    with parse_name Parse_Name_GV6
    with action_bitmap 0 0 0 0 0 0 
    with list_together BC_197
    with plural BC_198
;

Object I56_east "" Compass
    class K3_direction
    with short_name BC_199
    with article BC_200
    with p10_opposite I57_west
    with vector 0
    with IK3_Count 6
    with IK3_Link I57_west
    with KD_Count 3
    with name 'east' 'directions//p' 'e//' 
    with parse_name Parse_Name_GV7
    with action_bitmap 0 0 0 0 0 0 
    with list_together BC_201
    with plural BC_202
;

Object I57_west "" Compass
    class K3_direction
    with short_name BC_203
    with article BC_204
    with p10_opposite I56_east
    with vector 0
    with IK3_Count 7
    with IK3_Link I58_up
    with KD_Count 3
    with name 'west' 'directions//p' 'w//' 
    with parse_name Parse_Name_GV8
    with action_bitmap 0 0 0 0 0 0 
    with list_together BC_205
    with plural BC_206
;

Object I58_up "" Compass
    class K3_direction
    with short_name BC_207
    with article BC_208
    with p10_opposite I59_down
    with vector 0
    with IK3_Count 8
    with IK3_Link I59_down
    with KD_Count 3
    with name 'up' 'directions//p' 'u//' 
    with parse_name Parse_Name_GV9
    with action_bitmap 0 0 0 0 0 0 
    with list_together BC_209
    with plural BC_210
;

Object I59_down "" Compass
    class K3_direction
    with short_name BC_211
    with article BC_212
    with p10_opposite I58_up
    with vector 0
    with IK3_Count 9
    with IK3_Link in_obj
    with KD_Count 3
    with name 'down' 'directions//p' 'd//' 
    with parse_name Parse_Name_GV10
    with action_bitmap 0 0 0 0 0 0 
    with list_together BC_213
    with plural BC_214
;

Object in_obj "" Compass
    class K3_direction
    with short_name BC_215
    with article BC_216
    with p10_opposite out_obj
    with vector 0
    with IK3_Count 10
    with IK3_Link out_obj
    with KD_Count 3
    with name 'inside' 'directions//p' 'in' 
    with parse_name Parse_Name_GV11
    with action_bitmap 0 0 0 0 0 0 
    with list_together BC_217
    with plural BC_218
;

Object out_obj "" Compass
    class K3_direction
    with short_name BC_219
    with article BC_220
    with p10_opposite in_obj
    with vector 0
    with IK3_Count 11
    with IK3_Link nothing
    with KD_Count 3
    with name 'outside' 'directions//p' 'out' 
    with parse_name Parse_Name_GV12
    with action_bitmap 0 0 0 0 0 0 
    with list_together BC_221
    with plural BC_222
;

Object selfobj ""
    class K8_person
     
        with saved_short_name "yourself", 

    with short_name BC_223
    with description BC_224
    has proper
    has concealed
    with p62_gender I130_unknown
    with vector 0
    with cap_short_name BC_225
    has mark_as_thing
    with IK2_Count 0
    with IK2_Link I138_small_gold_box
    with IK8_Count 0
    with IK8_Link I198_elephant_statue
    with KD_Count 8
    with name 'yourself' 'people//p' 
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_226
    with p15_reading_material BC_227
    with list_together BC_228
    with plural BC_229
    with article BC_230
;

Object -> I138_small_gold_box ""
    class K5_container
    with short_name BC_231
    has ~static
    has openable
    with vector 0
    has mark_as_thing
    with IK2_Count 2
    with IK2_Link I195_elephant_treasure_chest
    with IK5_Count 0
    with IK5_Link I195_elephant_treasure_chest
    with KD_Count 5
    with name 'small' 'gold' 'box' 'containers//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_232
    with initial BC_233
    with p15_reading_material BC_234
    with list_together BC_235
    with plural BC_236
    with article BC_237
;

Object I126_create_your_character ""
    class K1_room
    with short_name BC_238
    with description BC_239
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_240
    has mark_as_room
    with IK1_Count 0
    with IK1_Link I131_now_the_coven_of_the_el
    with KD_Count 1
    with name 'create' 'my' 'character' 'rooms//p' 
    with list_together BC_241
    with plural BC_242
    with article BC_243
;

Object I131_now_the_coven_of_the_el ""
    class K1_room
    with short_name BC_244
    with description BC_245
    with map_region I139_southside_district
    has proper
    has p65_cursed
    with vector 0
    with room_index -1
    with cap_short_name BC_246
    has mark_as_room
    with IK1_Count 1
    with IK1_Link I132_now_the_farm_coven
    with KD_Count 1
    with name 'now' 'the' 'coven' 'of' 'the' 'elephant' 'rooms//p' 
    with list_together BC_247
    with plural BC_248
    with article BC_249
;

Object -> I195_elephant_treasure_chest ""
    class K5_container
    with short_name BC_250
    with with_key I138_small_gold_box
    has ~open
    has openable
    has lockable
    has locked
    with vector 0
    has mark_as_thing
    with IK2_Count 38
    with IK2_Link I196_wand_of_the_elephant
    with IK5_Count 5
    with IK5_Link I172_orange_container
    with KD_Count 5
    with name 'elephant' 'treasure' 'chest' 'containers//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_251
    with initial BC_252
    with p15_reading_material BC_253
    with list_together BC_254
    with plural BC_255
    with article BC_256
;

Object -> -> I196_wand_of_the_elephant ""
    class K2_thing
    with short_name BC_257
    has proper
    with vector 0
    with cap_short_name BC_258
    has mark_as_thing
    with IK2_Count 39
    with IK2_Link I197_note
    with KD_Count 2
    with name 'wand' 'of' 'the' 'elephant' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_259
    with initial BC_260
    with p15_reading_material BC_261
    with list_together BC_262
    with plural BC_263
    with article BC_264
;

Object -> I197_note ""
    class K2_thing
    with short_name BC_265
    with description BC_266
    with p15_reading_material BC_267
    with vector 0
    has mark_as_thing
    with IK2_Count 40
    with IK2_Link I198_elephant_statue
    with KD_Count 2
    with name 'note' 'things//p' 'underwitch' 
    with parse_name Parse_Name_GV98
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_268
    with list_together BC_269
    with plural BC_270
    with article BC_271
;

Object -> I198_elephant_statue ""
    class K10_man
    with short_name BC_272
    with description BC_273
    has proper
    with vector 0
    with cap_short_name BC_274
    has mark_as_thing
    with IK2_Count 41
    with IK2_Link I307_bull_statue
    with IK8_Count 3
    with IK8_Link I157_witch
    with IK10_Count 1
    with IK10_Link I178_crying_man
    with KD_Count 10
    with name 'elephant' 'statue' 'men//p' 
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_275
    with p15_reading_material BC_276
    with list_together BC_277
    with plural BC_278
    with article BC_279
;

Object I132_now_the_farm_coven ""
    class K1_room
    with short_name BC_280
    with description BC_281
    with map_region I254_warehouse_district
    has proper
    has p65_cursed
    with vector 0
    with room_index -1
    with cap_short_name BC_282
    has mark_as_room
    with IK1_Count 2
    with IK1_Link I137_temp
    with KD_Count 1
    with name 'now' 'the' 'farm' 'coven' 'rooms//p' 
    with list_together BC_283
    with plural BC_284
    with article BC_285
;

Object -> I307_bull_statue ""
    class K6_supporter
    with short_name BC_286
    with description BC_287
    has proper
    with vector 0
    with cap_short_name BC_288
    has mark_as_thing
    with IK2_Count 120
    with IK2_Link I133_group
    with IK6_Count 16
    with IK6_Link X174
    with KD_Count 6
    with name 'bull' 'statue' 'supporters//p' 
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_289
    with p15_reading_material BC_290
    with list_together BC_291
    with plural BC_292
    with article BC_293
;

Object I133_group ""
    class K2_thing
    with short_name BC_294
    with vector 0
    has mark_as_thing
    with IK2_Count 1
    with IK2_Link I154_wand
    with KD_Count 2
    with name 'group' 'things//p' 'crowd' 
    with parse_name Parse_Name_GV95
    with action_bitmap 0 0 0 0 0 0 
    with description BC_295
    with initial BC_296
    with p15_reading_material BC_297
    with list_together BC_298
    with plural BC_299
    with article BC_300
;

Object I137_temp ""
    class K1_room
    with short_name BC_301
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_302
    has mark_as_room
    with IK1_Count 3
    with IK1_Link I140_city_park
    with KD_Count 1
    with name 'temp' 'rooms//p' 
    with description BC_303
    with list_together BC_304
    with plural BC_305
    with article BC_306
;

Object I139_southside_district ""
    class K9_region
    with short_name BC_307
    has proper
    with vector 0
    with cap_short_name BC_308
    with regional_found_in [ ;
        if (TestRegionalContainment(location, I139_southside_district)) rtrue; rfalse;],
    with IK9_Count 0
    with IK9_Link I207_st_peters_mall
    with KD_Count 9
    with name 'southside' 'district' 'regions//p' 
    with action_bitmap 0 0 0 0 0 0 
    with list_together BC_309
    with plural BC_310
    with article BC_311
;

Object I140_city_park ""
    class K1_room
    with short_name BC_312
    with description BC_313
    with map_region I139_southside_district
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_314
    has mark_as_room
    with IK1_Count 4
    with IK1_Link I141_park_entrance
    with KD_Count 1
    with name 'city' 'park' 'rooms//p' 
    with list_together BC_315
    with plural BC_316
    with article BC_317
;

Object -> I154_wand ""
    class K2_thing
    with short_name BC_318
    with vector 0
    has mark_as_thing
    with IK2_Count 3
    with IK2_Link I158_tree
    with KD_Count 2
    with name 'wand' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_319
    with initial BC_320
    with p15_reading_material BC_321
    with list_together BC_322
    with plural BC_323
    with article BC_324
;

Object -> I158_tree ""
    class K2_thing
    with short_name BC_325
    with vector 0
    has mark_as_thing
    with IK2_Count 6
    with IK2_Link I159_few_bushes
    with KD_Count 2
    with name 'tree' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_326
    with initial BC_327
    with p15_reading_material BC_328
    with list_together BC_329
    with plural BC_330
    with article BC_331
;

Object -> I159_few_bushes ""
    class K2_thing
    with short_name BC_332
    with vector 0
    has mark_as_thing
    with IK2_Count 7
    with IK2_Link I160_streetlight
    with KD_Count 2
    with name 'few' 'bushes' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_333
    with initial BC_334
    with p15_reading_material BC_335
    with list_together BC_336
    with plural BC_337
    with article BC_338
;

Object -> I160_streetlight ""
    class K13_device
    with short_name BC_339
    has ~on
    with vector 0
    has mark_as_thing
    with IK2_Count 8
    with IK2_Link I157_witch
    with IK13_Count 0
    with IK13_Link I227_televisions
    with KD_Count 13
    with name 'streetlight' 'devices//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_340
    with initial BC_341
    with p15_reading_material BC_342
    with list_together BC_343
    with plural BC_344
    with article BC_345
;

Object I141_park_entrance ""
    class K1_room
    with short_name BC_346
    with description BC_347
    with map_region I139_southside_district
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_348
    has mark_as_room
    with IK1_Count 5
    with IK1_Link I142_15_rogers_road
    with KD_Count 1
    with name 'park' 'entrance' 'rooms//p' 
    with list_together BC_349
    with plural BC_350
    with article BC_351
;

Object -> I157_witch ""
    class K11_woman
    with short_name BC_352
    with description BC_353
    with initial BC_354
    with vector 0
    has mark_as_thing
    with IK2_Count 5
    with IK2_Link I161_long_robe
    with IK8_Count 1
    with IK8_Link I178_crying_man
    with IK11_Count 0
    with IK11_Link I238_grandmistress_witch
    with KD_Count 11
    with name 'witch' 'women//p' 
    with parse_name Parse_Name_GV97
    with action_bitmap 0 0 0 0 0 0 
    with p15_reading_material BC_355
    with list_together BC_356
    with plural BC_357
    with article BC_358
;

Object -> -> I161_long_robe ""
    class K2_thing
    with short_name BC_359
    has ~static
    has clothing
    has worn
    with vector 0
    has mark_as_thing
    with IK2_Count 9
    with IK2_Link I163_couple_bushes
    with KD_Count 2
    with name 'long' 'robe' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_360
    with initial BC_361
    with p15_reading_material BC_362
    with list_together BC_363
    with plural BC_364
    with article BC_365
;

Object -> I163_couple_bushes ""
    class K2_thing
    with short_name BC_366
    with vector 0
    has mark_as_thing
    with IK2_Count 11
    with IK2_Link I164_entrance_sign
    with KD_Count 2
    with name 'couple' 'bushes' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_367
    with initial BC_368
    with p15_reading_material BC_369
    with list_together BC_370
    with plural BC_371
    with article BC_372
;

Object -> I164_entrance_sign ""
    class K2_thing
    with short_name BC_373
    with vector 0
    has mark_as_thing
    with IK2_Count 12
    with IK2_Link I165_bent_fence
    with KD_Count 2
    with name 'entrance' 'sign' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_374
    with initial BC_375
    with p15_reading_material BC_376
    with list_together BC_377
    with plural BC_378
    with article BC_379
;

Object -> I165_bent_fence ""
    class K2_thing
    with short_name BC_380
    with vector 0
    has mark_as_thing
    with IK2_Count 13
    with IK2_Link I166_flickering_streetlight
    with KD_Count 2
    with name 'bent' 'fence' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_381
    with initial BC_382
    with p15_reading_material BC_383
    with list_together BC_384
    with plural BC_385
    with article BC_386
;

Object -> I166_flickering_streetlight ""
    class K2_thing
    with short_name BC_387
    with vector 0
    has mark_as_thing
    with IK2_Count 14
    with IK2_Link I167_pennies
    with KD_Count 2
    with name 'flickering' 'streetlight' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_388
    with initial BC_389
    with p15_reading_material BC_390
    with list_together BC_391
    with plural BC_392
    with article BC_393
;

Object I142_15_rogers_road ""
    class K1_room
    with short_name BC_394
    with description BC_395
    with map_region I139_southside_district
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_396
    has mark_as_room
    with IK1_Count 6
    with IK1_Link I143_junkyard
    with KD_Count 1
    with name '15' 'rogers' 'road' 'rooms//p' 
    with list_together BC_397
    with plural BC_398
    with article BC_399
;

Object -> I167_pennies ""
    class K2_thing
    with short_name BC_400
    has pluralname
    with vector 0
    has mark_as_thing
    with IK2_Count 15
    with IK2_Link I168_broken_cellphone
    with KD_Count 2
    with name 'pennies' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_401
    with initial BC_402
    with p15_reading_material BC_403
    with list_together BC_404
    with plural BC_405
    with article BC_406
;

Object -> I168_broken_cellphone ""
    class K2_thing
    with short_name BC_407
    with vector 0
    has mark_as_thing
    with IK2_Count 16
    with IK2_Link I169_squished_donut
    with KD_Count 2
    with name 'broken' 'cellphone' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_408
    with initial BC_409
    with p15_reading_material BC_410
    with list_together BC_411
    with plural BC_412
    with article BC_413
;

Object -> I169_squished_donut ""
    class K2_thing
    with short_name BC_414
    with vector 0
    has mark_as_thing
    with IK2_Count 17
    with IK2_Link I170_trash
    with KD_Count 2
    with name 'squished' 'donut' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_415
    with initial BC_416
    with p15_reading_material BC_417
    with list_together BC_418
    with plural BC_419
    with article BC_420
;

Object I143_junkyard ""
    class K1_room
    with short_name BC_421
    with description BC_422
    with map_region I139_southside_district
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_423
    has mark_as_room
    with IK1_Count 7
    with IK1_Link I144_atkin_train_station
    with KD_Count 1
    with name 'junkyard' 'rooms//p' 
    with list_together BC_424
    with plural BC_425
    with article BC_426
;

Object -> I170_trash ""
    class K2_thing
    with short_name BC_427
    has pluralname
    with vector 0
    has mark_as_thing
    with IK2_Count 18
    with IK2_Link I171_toolbox
    with KD_Count 2
    with name 'trash' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_428
    with initial BC_429
    with p15_reading_material BC_430
    with list_together BC_431
    with plural BC_432
    with article BC_433
;

Object -> I171_toolbox ""
    class K2_thing
    with short_name BC_434
    with vector 0
    has mark_as_thing
    with IK2_Count 19
    with IK2_Link I172_orange_container
    with KD_Count 2
    with name 'toolbox' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_435
    with initial BC_436
    with p15_reading_material BC_437
    with list_together BC_438
    with plural BC_439
    with article BC_440
;

Object -> I172_orange_container ""
    class K5_container
    with short_name BC_441
    has open
    with vector 0
    has mark_as_thing
    with IK2_Count 20
    with IK2_Link X174
    with IK5_Count 1
    with IK5_Link I186_top_drawer
    with KD_Count 5
    with name 'orange' 'container' 'containers//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_442
    with initial BC_443
    with p15_reading_material BC_444
    with list_together BC_445
    with plural BC_446
    with article BC_447
;

Object I144_atkin_train_station ""
    class K1_room
    with short_name BC_448
    with description BC_449
    with map_region I139_southside_district
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_450
    has mark_as_room
    with IK1_Count 8
    with IK1_Link I145_lackluster_apartments
    with KD_Count 1
    with name 'atkin' 'train' 'station' 'rooms//p' 
    with list_together BC_451
    with plural BC_452
    with article BC_453
;

Object -> X174 ""
    class K21_bench
    with short_name BC_454
    with vector 0
    has mark_as_thing
    with IK2_Count 21
    with IK2_Link X175
    with IK6_Count 0
    with IK6_Link X175
    with IK21_Count 0
    with IK21_Link X175
    with KD_Count 21
    with name 'bench' 'benches//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_455
    with initial BC_456
    with p15_reading_material BC_457
    with list_together BC_458
    with plural BC_459
    with article BC_460
;

Object -> X175 ""
    class K21_bench
    with short_name BC_461
    with vector 0
    has mark_as_thing
    with IK2_Count 22
    with IK2_Link X177
    with IK6_Count 1
    with IK6_Link X177
    with IK21_Count 1
    with IK21_Link nothing
    with KD_Count 21
    with name 'bench' 'benches//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_462
    with initial BC_463
    with p15_reading_material BC_464
    with list_together BC_465
    with plural BC_466
    with article BC_467
;

Object -> X177 ""
    class K22_train_platform
    with short_name BC_468
    with vector 0
    has mark_as_thing
    with IK2_Count 23
    with IK2_Link I178_crying_man
    with IK6_Count 2
    with IK6_Link I180_decoration_table
    with IK22_Count 0
    with IK22_Link nothing
    with KD_Count 22
    with name 'train' 'platform'  'platforms//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_469
    with initial BC_470
    with p15_reading_material BC_471
    with list_together BC_472
    with plural BC_473
    with article BC_474
;

Object -> I178_crying_man ""
    class K10_man
    with short_name BC_475
    with description BC_476
    has proper
    with vector 0
    with cap_short_name BC_477
    has mark_as_thing
    with IK2_Count 24
    with IK2_Link I180_decoration_table
    with IK8_Count 2
    with IK8_Link I199_suspicious_man
    with IK10_Count 0
    with IK10_Link nothing
    with KD_Count 10
    with name 'crying' 'man' 'men//p' 
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_478
    with p15_reading_material BC_479
    with list_together BC_480
    with plural BC_481
    with article BC_482
;

Object I145_lackluster_apartments ""
    class K1_room
    with short_name BC_483
    with description BC_484
    with map_region I139_southside_district
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_485
    has mark_as_room
    with IK1_Count 9
    with IK1_Link I146_hk_research_group
    with KD_Count 1
    with name 'lackluster' 'apartments' 'rooms//p' 
    with list_together BC_486
    with plural BC_487
    with article BC_488
;

Object -> I180_decoration_table ""
    class K6_supporter
    with short_name BC_489
    has proper
    with vector 0
    with cap_short_name BC_490
    has mark_as_thing
    with IK2_Count 25
    with IK2_Link I181_vase
    with IK6_Count 3
    with IK6_Link I191_old_sign
    with KD_Count 6
    with name 'decoration' 'table' 'supporters//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_491
    with initial BC_492
    with p15_reading_material BC_493
    with list_together BC_494
    with plural BC_495
    with article BC_496
;

Object -> -> I181_vase ""
    class K2_thing
    with short_name BC_497
    has proper
    with vector 0
    with cap_short_name BC_498
    has mark_as_thing
    with IK2_Count 26
    with IK2_Link I182_sunny_drenched_window
    with KD_Count 2
    with name 'vase' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_499
    with initial BC_500
    with p15_reading_material BC_501
    with list_together BC_502
    with plural BC_503
    with article BC_504
;

Object -> I182_sunny_drenched_window ""
    class K2_thing
    with short_name BC_505
    with description BC_506
    has proper
    with vector 0
    with cap_short_name BC_507
    has mark_as_thing
    with IK2_Count 27
    with IK2_Link I199_suspicious_man
    with KD_Count 2
    with name 'sunny-drenched' 'window' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_508
    with p15_reading_material BC_509
    with list_together BC_510
    with plural BC_511
    with article BC_512
;

Object I146_hk_research_group ""
    class K1_room
    with short_name BC_513
    with description BC_514
    with map_region I139_southside_district
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_515
    has mark_as_room
    with IK1_Count 10
    with IK1_Link I147_dead_end
    with KD_Count 1
    with name 'hk' 'research' 'group' 'rooms//p' 
    with list_together BC_516
    with plural BC_517
    with article BC_518
;

Object -> I199_suspicious_man ""
    class K8_person
    with short_name BC_519
    with description BC_520
    has proper
    with vector 0
    with cap_short_name BC_521
    has mark_as_thing
    with IK2_Count 42
    with IK2_Link I200_growing_bushes
    with IK8_Count 4
    with IK8_Link I252_drunk_girl
    with KD_Count 8
    with name 'suspicious' 'man' 'people//p' 
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_522
    with p15_reading_material BC_523
    with list_together BC_524
    with plural BC_525
    with article BC_526
;

Object -> I200_growing_bushes ""
    class K2_thing
    with short_name BC_527
    has pluralname
    with vector 0
    has mark_as_thing
    with IK2_Count 43
    with IK2_Link I201_crumbling_sign
    with KD_Count 2
    with name 'growing' 'bushes' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_528
    with initial BC_529
    with p15_reading_material BC_530
    with list_together BC_531
    with plural BC_532
    with article BC_533
;

Object -> I201_crumbling_sign ""
    class K2_thing
    with short_name BC_534
    with vector 0
    has mark_as_thing
    with IK2_Count 44
    with IK2_Link I202_electric_fence
    with KD_Count 2
    with name 'crumbling' 'sign' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_535
    with initial BC_536
    with p15_reading_material BC_537
    with list_together BC_538
    with plural BC_539
    with article BC_540
;

Object -> I202_electric_fence ""
    class K2_thing
    with short_name BC_541
    with vector 0
    has mark_as_thing
    with IK2_Count 45
    with IK2_Link I190_rusted_bench
    with KD_Count 2
    with name 'electric' 'fence' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_542
    with initial BC_543
    with p15_reading_material BC_544
    with list_together BC_545
    with plural BC_546
    with article BC_547
;

Object I147_dead_end ""
    class K1_room
    with short_name BC_548
    with description BC_549
    with map_region I139_southside_district
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_550
    has mark_as_room
    with IK1_Count 11
    with IK1_Link I148_small_trail
    with KD_Count 1
    with name 'dead' 'end' 'rooms//p' 
    with list_together BC_551
    with plural BC_552
    with article BC_553
;

Object -> I190_rusted_bench ""
    class K2_thing
    with short_name BC_554
    with vector 0
    has mark_as_thing
    with IK2_Count 33
    with IK2_Link I191_old_sign
    with KD_Count 2
    with name 'rusted' 'bench' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_555
    with initial BC_556
    with p15_reading_material BC_557
    with list_together BC_558
    with plural BC_559
    with article BC_560
;

Object -> I191_old_sign ""
    class K6_supporter
    with short_name BC_561
    with description BC_562
    has proper
    with vector 0
    with cap_short_name BC_563
    has mark_as_thing
    with IK2_Count 34
    with IK2_Link I192_silhouetted_trees
    with IK6_Count 4
    with IK6_Link I203_broken_down_car
    with KD_Count 6
    with name 'old' 'sign' 'supporters//p' 
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_564
    with p15_reading_material BC_565
    with list_together BC_566
    with plural BC_567
    with article BC_568
;

Object I148_small_trail ""
    class K1_room
    with short_name BC_569
    with description BC_570
    with map_region I139_southside_district
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_571
    has mark_as_room
    with IK1_Count 12
    with IK1_Link I149_whispering_cave
    with KD_Count 1
    with name 'small' 'trail' 'rooms//p' 
    with list_together BC_572
    with plural BC_573
    with article BC_574
;

Object -> I192_silhouetted_trees ""
    class K2_thing
    with short_name BC_575
    with description BC_576
    has proper
    has static
    has scenery
    with vector 0
    with cap_short_name BC_577
    has mark_as_thing
    with IK2_Count 35
    with IK2_Link I193_weird_rocks
    with KD_Count 2
    with name 'silhouetted' 'trees' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_578
    with p15_reading_material BC_579
    with list_together BC_580
    with plural BC_581
    with article BC_582
;

Object I149_whispering_cave ""
    class K1_room
    with short_name BC_583
    with description BC_584
    with map_region I139_southside_district
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_585
    has mark_as_room
    with IK1_Count 13
    with IK1_Link I150_haverton_bridge
    with KD_Count 1
    with name 'whispering' 'cave' 'rooms//p' 
    with list_together BC_586
    with plural BC_587
    with article BC_588
;

Object -> I193_weird_rocks ""
    class K2_thing
    with short_name BC_589
    has pluralname
    with vector 0
    has mark_as_thing
    with IK2_Count 36
    with IK2_Link I194_cobwebs
    with KD_Count 2
    with name 'weird' 'rocks' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_590
    with initial BC_591
    with p15_reading_material BC_592
    with list_together BC_593
    with plural BC_594
    with article BC_595
;

Object -> I194_cobwebs ""
    class K2_thing
    with short_name BC_596
    has proper
    with vector 0
    with cap_short_name BC_597
    has mark_as_thing
    with IK2_Count 37
    with IK2_Link I252_drunk_girl
    with KD_Count 2
    with name 'cobwebs' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_598
    with initial BC_599
    with p15_reading_material BC_600
    with list_together BC_601
    with plural BC_602
    with article BC_603
;

Object I150_haverton_bridge ""
    class K1_room
    with short_name BC_604
    with description BC_605
    with map_region I139_southside_district
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_606
    has mark_as_room
    with IK1_Count 14
    with IK1_Link I151_kelmers_road
    with KD_Count 1
    with name 'haverton' 'bridge' 'rooms//p' 
    with list_together BC_607
    with plural BC_608
    with article BC_609
;

Object -> I252_drunk_girl ""
    class K8_person
    with short_name BC_610
    has proper
    with vector 0
    with cap_short_name BC_611
    has mark_as_thing
    with IK2_Count 82
    with IK2_Link I253_drunk_man
    with IK8_Count 17
    with IK8_Link I253_drunk_man
    with KD_Count 8
    with name 'drunk' 'girl' 'people//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_612
    with initial BC_613
    with p15_reading_material BC_614
    with list_together BC_615
    with plural BC_616
    with article BC_617
;

Object -> I253_drunk_man ""
    class K8_person
    with short_name BC_618
    has proper
    with vector 0
    with cap_short_name BC_619
    has mark_as_thing
    with IK2_Count 83
    with IK2_Link I203_broken_down_car
    with IK8_Count 18
    with IK8_Link I204_young_woman
    with KD_Count 8
    with name 'drunk' 'man' 'people//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_620
    with initial BC_621
    with p15_reading_material BC_622
    with list_together BC_623
    with plural BC_624
    with article BC_625
;

Object I151_kelmers_road ""
    class K1_room
    with short_name BC_626
    with description BC_627
    with map_region I139_southside_district
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_628
    has mark_as_room
    with IK1_Count 15
    with IK1_Link I152_commercial_intersection
    with KD_Count 1
    with name 'kelmers' 'road' 'rooms//p' 
    with list_together BC_629
    with plural BC_630
    with article BC_631
;

Object -> I203_broken_down_car ""
    class K6_supporter
    with short_name BC_632
    with description BC_633
    has proper
    with vector 0
    with cap_short_name BC_634
    has mark_as_thing
    with IK2_Count 46
    with IK2_Link I204_young_woman
    with IK6_Count 5
    with IK6_Link I206_helpful_mans_car
    with KD_Count 6
    with name 'broken' 'down' 'car' 'supporters//p' 
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_635
    with p15_reading_material BC_636
    with list_together BC_637
    with plural BC_638
    with article BC_639
;

Object -> I204_young_woman ""
    class K8_person
    with short_name BC_640
    with description BC_641
    has proper
    with vector 0
    with cap_short_name BC_642
    has mark_as_thing
    with IK2_Count 47
    with IK2_Link I205_good_samaritan
    with IK8_Count 5
    with IK8_Link I205_good_samaritan
    with KD_Count 8
    with name 'young' 'woman' 'people//p' 
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_643
    with p15_reading_material BC_644
    with list_together BC_645
    with plural BC_646
    with article BC_647
;

Object -> I205_good_samaritan ""
    class K8_person
    with short_name BC_648
    with initial BC_649
    has proper
    with vector 0
    with cap_short_name BC_650
    has mark_as_thing
    with IK2_Count 48
    with IK2_Link I206_helpful_mans_car
    with IK8_Count 6
    with IK8_Link I222_ellen
    with KD_Count 8
    with name 'good' 'samaritan' 'people//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_651
    with p15_reading_material BC_652
    with list_together BC_653
    with plural BC_654
    with article BC_655
;

Object -> I206_helpful_mans_car ""
    class K6_supporter
    with short_name BC_656
    with initial BC_657
    has proper
    with vector 0
    with cap_short_name BC_658
    has mark_as_thing
    with IK2_Count 49
    with IK2_Link I218_gaggle_of_girls
    with IK6_Count 6
    with IK6_Link I251_three_empty_benches
    with KD_Count 6
    with name 'helpful' 'mans' 'car' 'supporters//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_659
    with p15_reading_material BC_660
    with list_together BC_661
    with plural BC_662
    with article BC_663
;

Object I152_commercial_intersection ""
    class K1_room
    with short_name BC_664
    with description BC_665
    with map_region I139_southside_district
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_666
    has mark_as_room
    with IK1_Count 16
    with IK1_Link I153_hermes_station
    with KD_Count 1
    with name 'commercial' 'intersection' 'rooms//p' 
    with list_together BC_667
    with plural BC_668
    with article BC_669
;

Object -> I218_gaggle_of_girls ""
    class K2_thing
    with short_name BC_670
    with description BC_671
    has proper
    with vector 0
    with cap_short_name BC_672
    has mark_as_thing
    with IK2_Count 50
    with IK2_Link I220_traveling_actors
    with KD_Count 2
    with name 'gaggle' 'of' 'girls' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_673
    with p15_reading_material BC_674
    with list_together BC_675
    with plural BC_676
    with article BC_677
;

Object -> I220_traveling_actors ""
    class K2_thing
    with short_name BC_678
    has proper
    with vector 0
    with cap_short_name BC_679
    has mark_as_thing
    with IK2_Count 51
    with IK2_Link I221_crowd
    with KD_Count 2
    with name 'traveling' 'actors' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_680
    with initial BC_681
    with p15_reading_material BC_682
    with list_together BC_683
    with plural BC_684
    with article BC_685
;

Object -> I221_crowd ""
    class K2_thing
    with short_name BC_686
    has proper
    with vector 0
    with cap_short_name BC_687
    has mark_as_thing
    with IK2_Count 52
    with IK2_Link I251_three_empty_benches
    with KD_Count 2
    with name 'crowd' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_688
    with initial BC_689
    with p15_reading_material BC_690
    with list_together BC_691
    with plural BC_692
    with article BC_693
;

Object I153_hermes_station ""
    class K1_room
    with short_name BC_694
    with description BC_695
    with map_region I139_southside_district
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_696
    has mark_as_room
    with IK1_Count 17
    with IK1_Link I183_apartment_1025
    with KD_Count 1
    with name 'hermes' 'station' 'rooms//p' 
    with list_together BC_697
    with plural BC_698
    with article BC_699
;

Object -> I251_three_empty_benches ""
    class K6_supporter
    with short_name BC_700
    has proper
    with vector 0
    with cap_short_name BC_701
    has mark_as_thing
    with IK2_Count 81
    with IK2_Link I155_fulfill_your_destiny
    with IK6_Count 7
    with IK6_Link I272_cage
    with KD_Count 6
    with name 'three' 'empty' 'benches' 'supporters//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_702
    with initial BC_703
    with p15_reading_material BC_704
    with list_together BC_705
    with plural BC_706
    with article BC_707
;

Object I155_fulfill_your_destiny ""
    class K4_door
    with short_name BC_708
    has proper
    has lockable
    has locked
    with vector 0
    with door_dir [ 
        loc ! room of actor
        ;
        loc = location;
        if (loc == thedark) loc = real_location;
        if (loc == I140_city_park) return I56_east; return I57_west;],
    with door_to [ 
        loc ! room of actor
        ;
        loc = location;
        if (loc == thedark) loc = real_location;
        if (loc == I140_city_park) return I141_park_entrance; return I140_city_park;],
    with found_in I140_city_park I141_park_entrance
    with cap_short_name BC_709
    has mark_as_thing
    with IK2_Count 4
    with IK2_Link I162_weird_logo
    with IK4_Count 0
    with IK4_Link I404_mysterious_door
    with KD_Count 4
    with name 'fulfill' 'my' 'destiny' 'doors//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_710
    with initial BC_711
    with p15_reading_material BC_712
    with list_together BC_713
    with plural BC_714
    with article BC_715
;

Object I162_weird_logo ""
    class K2_thing
    with short_name BC_716
    with description BC_717
    with vector 0
    has mark_as_thing
    with IK2_Count 10
    with IK2_Link I184_cherry_desk
    with KD_Count 2
    with name 'weird' 'logo' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_718
    with p15_reading_material BC_719
    with list_together BC_720
    with plural BC_721
    with article BC_722
;

Object I183_apartment_1025 ""
    class K1_room
    with short_name BC_723
    with description BC_724
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_725
    has mark_as_room
    with IK1_Count 18
    with IK1_Link I208_mall_entrance
    with KD_Count 1
    with name 'apartment' '1025' 'rooms//p' 
    with list_together BC_726
    with plural BC_727
    with article BC_728
;

Object -> I184_cherry_desk ""
    class K2_thing
    with short_name BC_729
    with description BC_730
    with vector 0
    has mark_as_thing
    with component_child I186_top_drawer
    with IK2_Count 28
    with IK2_Link I186_top_drawer
    with KD_Count 2
    with name 'cherry' 'desk' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_731
    with p15_reading_material BC_732
    with list_together BC_733
    with plural BC_734
    with article BC_735
;

Object I186_top_drawer ""
    class K23_drawer
    with short_name BC_736
    with vector 0
    has mark_as_thing
    with component_parent I184_cherry_desk
    with component_sibling I187_middle_drawer
    with IK2_Count 29
    with IK2_Link I187_middle_drawer
    with IK5_Count 2
    with IK5_Link I187_middle_drawer
    with IK23_Count 0
    with IK23_Link I187_middle_drawer
    with KD_Count 23
    with name 'top' 'drawer' 'drawers//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_737
    with initial BC_738
    with p15_reading_material BC_739
    with list_together BC_740
    with plural BC_741
    with article BC_742
;

Object I187_middle_drawer ""
    class K23_drawer
    with short_name BC_743
    with vector 0
    has mark_as_thing
    with component_parent I184_cherry_desk
    with component_sibling I188_bottom_drawer
    with IK2_Count 30
    with IK2_Link I188_bottom_drawer
    with IK5_Count 3
    with IK5_Link I188_bottom_drawer
    with IK23_Count 1
    with IK23_Link I188_bottom_drawer
    with KD_Count 23
    with name 'middle' 'drawer' 'drawers//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_744
    with initial BC_745
    with p15_reading_material BC_746
    with list_together BC_747
    with plural BC_748
    with article BC_749
;

Object I188_bottom_drawer ""
    class K23_drawer
    with short_name BC_750
    with vector 0
    has mark_as_thing
    with component_parent I184_cherry_desk
    with IK2_Count 31
    with IK2_Link I189_mysterious_passcode
    with IK5_Count 4
    with IK5_Link I230_cluckin_bell
    with IK23_Count 2
    with IK23_Link nothing
    with KD_Count 23
    with name 'bottom' 'drawer' 'drawers//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_751
    with initial BC_752
    with p15_reading_material BC_753
    with list_together BC_754
    with plural BC_755
    with article BC_756
;

Object I189_mysterious_passcode ""
    class K2_thing
    with short_name BC_757
    with description BC_758
    with p15_reading_material BC_759
    with vector 0
    has mark_as_thing
    with IK2_Count 32
    with IK2_Link I222_ellen
    with KD_Count 2
    with name 'mysterious' 'passcode' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_760
    with list_together BC_761
    with plural BC_762
    with article BC_763
;

Object I207_st_peters_mall ""
    class K9_region
    with short_name BC_764
    has proper
    with vector 0
    with cap_short_name BC_765
    with regional_found_in [ ;
        if (TestRegionalContainment(location, I207_st_peters_mall)) rtrue; rfalse;],
    with IK9_Count 1
    with IK9_Link I254_warehouse_district
    with KD_Count 9
    with name 'st' 'peters' 'mall' 'regions//p' 
    with action_bitmap 0 0 0 0 0 0 
    with list_together BC_766
    with plural BC_767
    with article BC_768
;

Object I208_mall_entrance ""
    class K1_room
    with short_name BC_769
    with description BC_770
    with map_region I207_st_peters_mall
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_771
    has mark_as_room
    with IK1_Count 19
    with IK1_Link I209_jupiter_hall
    with KD_Count 1
    with name 'mall' 'entrance' 'rooms//p' 
    with list_together BC_772
    with plural BC_773
    with article BC_774
;

Object -> I222_ellen ""
    class K8_person
    with short_name BC_775
    has proper
    with vector 0
    with cap_short_name BC_776
    has mark_as_thing
    with IK2_Count 53
    with IK2_Link I223_baek
    with IK8_Count 7
    with IK8_Link I223_baek
    with KD_Count 8
    with name 'ellen' 'people//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_777
    with initial BC_778
    with p15_reading_material BC_779
    with list_together BC_780
    with plural BC_781
    with article BC_782
;

Object -> I223_baek ""
    class K8_person
    with short_name BC_783
    has proper
    with vector 0
    with cap_short_name BC_784
    has mark_as_thing
    with IK2_Count 54
    with IK2_Link I224_mean_kid
    with IK8_Count 8
    with IK8_Link I224_mean_kid
    with KD_Count 8
    with name 'baek' 'people//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_785
    with initial BC_786
    with p15_reading_material BC_787
    with list_together BC_788
    with plural BC_789
    with article BC_790
;

Object I209_jupiter_hall ""
    class K1_room
    with short_name BC_791
    with description BC_792
    with map_region I207_st_peters_mall
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_793
    has mark_as_room
    with IK1_Count 20
    with IK1_Link I210_tv4u
    with KD_Count 1
    with name 'jupiter' 'hall' 'rooms//p' 
    with list_together BC_794
    with plural BC_795
    with article BC_796
;

Object -> I224_mean_kid ""
    class K8_person
    with short_name BC_797
    has proper
    with vector 0
    with cap_short_name BC_798
    has mark_as_thing
    with IK2_Count 55
    with IK2_Link I225_little_brother
    with IK8_Count 9
    with IK8_Link I225_little_brother
    with KD_Count 8
    with name 'mean' 'kid' 'people//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_799
    with initial BC_800
    with p15_reading_material BC_801
    with list_together BC_802
    with plural BC_803
    with article BC_804
;

Object -> I225_little_brother ""
    class K8_person
    with short_name BC_805
    has proper
    with vector 0
    with cap_short_name BC_806
    has mark_as_thing
    with IK2_Count 56
    with IK2_Link I226_janitor
    with IK8_Count 10
    with IK8_Link I226_janitor
    with KD_Count 8
    with name 'little' 'brother' 'people//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_807
    with initial BC_808
    with p15_reading_material BC_809
    with list_together BC_810
    with plural BC_811
    with article BC_812
;

Object -> I226_janitor ""
    class K8_person
    with short_name BC_813
    has proper
    with vector 0
    with cap_short_name BC_814
    has mark_as_thing
    with IK2_Count 57
    with IK2_Link I227_televisions
    with IK8_Count 11
    with IK8_Link I233_bored_employee
    with KD_Count 8
    with name 'janitor' 'people//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_815
    with initial BC_816
    with p15_reading_material BC_817
    with list_together BC_818
    with plural BC_819
    with article BC_820
;

Object I210_tv4u ""
    class K1_room
    with short_name BC_821
    with map_region I207_st_peters_mall
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_822
    has mark_as_room
    with IK1_Count 21
    with IK1_Link I211_food_court
    with KD_Count 1
    with name 'tv4u' 'rooms//p' 
    with description BC_823
    with list_together BC_824
    with plural BC_825
    with article BC_826
;

Object -> I227_televisions ""
    class K13_device
    with short_name BC_827
    with initial BC_828
    has pluralname
    has on
    with vector 0
    has mark_as_thing
    with IK2_Count 58
    with IK2_Link I228_tv_station
    with IK13_Count 1
    with IK13_Link nothing
    with KD_Count 13
    with name 'televisions' 'devices//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_829
    with p15_reading_material BC_830
    with list_together BC_831
    with plural BC_832
    with article BC_833
;

Object -> I228_tv_station ""
    class K2_thing
    with short_name BC_834
    with description BC_835
    has proper
    with vector 0
    with cap_short_name BC_836
    has mark_as_thing
    with IK2_Count 59
    with IK2_Link I230_cluckin_bell
    with KD_Count 2
    with name 'tv' 'station' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_837
    with p15_reading_material BC_838
    with list_together BC_839
    with plural BC_840
    with article BC_841
;

Object I211_food_court ""
    class K1_room
    with short_name BC_842
    with description BC_843
    with map_region I207_st_peters_mall
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_844
    has mark_as_room
    with IK1_Count 22
    with IK1_Link I212_hotspot
    with KD_Count 1
    with name 'food' 'court' 'rooms//p' 
    with list_together BC_845
    with plural BC_846
    with article BC_847
;

Object -> I230_cluckin_bell ""
    class K5_container
    with short_name BC_848
    has proper
    has enterable
    has open
    with vector 0
    with cap_short_name BC_849
    has mark_as_thing
    with IK2_Count 60
    with IK2_Link I233_bored_employee
    with IK5_Count 6
    with IK5_Link I231_doctor_food
    with KD_Count 5
    with name 'cluckin' 'bell' 'containers//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_850
    with initial BC_851
    with p15_reading_material BC_852
    with list_together BC_853
    with plural BC_854
    with article BC_855
;

Object -> -> I233_bored_employee ""
    class K8_person
    with short_name BC_856
    with description BC_857
    has proper
    with vector 0
    with cap_short_name BC_858
    has mark_as_thing
    with IK2_Count 63
    with IK2_Link I231_doctor_food
    with IK8_Count 12
    with IK8_Link I234_training_manager
    with KD_Count 8
    with name 'bored' 'employee' 'people//p' 
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_859
    with p15_reading_material BC_860
    with list_together BC_861
    with plural BC_862
    with article BC_863
;

Object -> I231_doctor_food ""
    class K5_container
    with short_name BC_864
    has proper
    has enterable
    has open
    with vector 0
    with cap_short_name BC_865
    has mark_as_thing
    with IK2_Count 61
    with IK2_Link I234_training_manager
    with IK5_Count 7
    with IK5_Link I232_aunt_bettys
    with KD_Count 5
    with name 'doctor' 'food' 'containers//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_866
    with initial BC_867
    with p15_reading_material BC_868
    with list_together BC_869
    with plural BC_870
    with article BC_871
;

Object -> -> I234_training_manager ""
    class K8_person
    with short_name BC_872
    with description BC_873
    has proper
    with vector 0
    with cap_short_name BC_874
    has mark_as_thing
    with IK2_Count 64
    with IK2_Link I235_new_employee
    with IK8_Count 13
    with IK8_Link I235_new_employee
    with KD_Count 8
    with name 'training' 'manager' 'people//p' 
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_875
    with p15_reading_material BC_876
    with list_together BC_877
    with plural BC_878
    with article BC_879
;

Object -> -> I235_new_employee ""
    class K8_person
    with short_name BC_880
    with description BC_881
    has proper
    with vector 0
    with cap_short_name BC_882
    has mark_as_thing
    with IK2_Count 65
    with IK2_Link I232_aunt_bettys
    with IK8_Count 14
    with IK8_Link I236_aunt_betty
    with KD_Count 8
    with name 'new' 'employee' 'people//p' 
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_883
    with p15_reading_material BC_884
    with list_together BC_885
    with plural BC_886
    with article BC_887
;

Object -> I232_aunt_bettys ""
    class K5_container
    with short_name BC_888
    has proper
    has enterable
    has open
    with vector 0
    with cap_short_name BC_889
    has mark_as_thing
    with IK2_Count 62
    with IK2_Link I236_aunt_betty
    with IK5_Count 8
    with IK5_Link I282_old_truck
    with KD_Count 5
    with name 'aunt' 'bettys' 'containers//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_890
    with initial BC_891
    with p15_reading_material BC_892
    with list_together BC_893
    with plural BC_894
    with article BC_895
;

Object -> -> I236_aunt_betty ""
    class K8_person
    with short_name BC_896
    with initial BC_897
    has proper
    with vector 0
    with cap_short_name BC_898
    has mark_as_thing
    with IK2_Count 66
    with IK2_Link I237_small_green_pastry
    with IK8_Count 15
    with IK8_Link I238_grandmistress_witch
    with KD_Count 8
    with name 'aunt' 'betty' 'people//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_899
    with p15_reading_material BC_900
    with list_together BC_901
    with plural BC_902
    with article BC_903
;

Object I212_hotspot ""
    class K1_room
    with short_name BC_904
    with description BC_905
    with map_region I207_st_peters_mall
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_906
    has mark_as_room
    with IK1_Count 23
    with IK1_Link I213_statuesque
    with KD_Count 1
    with name 'hotspot' 'rooms//p' 
    with list_together BC_907
    with plural BC_908
    with article BC_909
;

Object -> I237_small_green_pastry ""
    class K2_thing
    with short_name BC_910
    has proper
    with vector 0
    with cap_short_name BC_911
    has mark_as_thing
    with IK2_Count 67
    with IK2_Link I238_grandmistress_witch
    with KD_Count 2
    with name 'small' 'green' 'pastry' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_912
    with initial BC_913
    with p15_reading_material BC_914
    with list_together BC_915
    with plural BC_916
    with article BC_917
;

Object -> I238_grandmistress_witch ""
    class K11_woman
    with short_name BC_918
    with initial BC_919
    has proper
    with vector 0
    with cap_short_name BC_920
    has mark_as_thing
    with IK2_Count 68
    with IK2_Link I242_ivory_human_statues
    with IK8_Count 16
    with IK8_Link I270_equestrian_mistress
    with IK11_Count 1
    with IK11_Link I270_equestrian_mistress
    with KD_Count 11
    with name 'grandmistress' 'witch' 'women//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_921
    with p15_reading_material BC_922
    with list_together BC_923
    with plural BC_924
    with article BC_925
;

Object I213_statuesque ""
    class K1_room
    with short_name BC_926
    with description BC_927
    with map_region I207_st_peters_mall
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_928
    has mark_as_room
    with IK1_Count 24
    with IK1_Link I214_gellin_like_a_vellin
    with KD_Count 1
    with name 'statuesque' 'rooms//p' 
    with list_together BC_929
    with plural BC_930
    with article BC_931
;

Object -> I242_ivory_human_statues ""
    class K2_thing
    with short_name BC_932
    has pluralname
    with vector 0
    has mark_as_thing
    with IK2_Count 72
    with IK2_Link I243_abandoned_clothing
    with KD_Count 2
    with name 'ivory' 'human' 'statues' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_933
    with initial BC_934
    with p15_reading_material BC_935
    with list_together BC_936
    with plural BC_937
    with article BC_938
;

Object -> I243_abandoned_clothing ""
    class K2_thing
    with short_name BC_939
    has proper
    with vector 0
    with cap_short_name BC_940
    has mark_as_thing
    with IK2_Count 73
    with IK2_Link I244_hidden_book_of_notes
    with KD_Count 2
    with name 'abandoned' 'clothing' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_941
    with initial BC_942
    with p15_reading_material BC_943
    with list_together BC_944
    with plural BC_945
    with article BC_946
;

Object -> I244_hidden_book_of_notes ""
    class K2_thing
    with short_name BC_947
    has proper
    with vector 0
    with cap_short_name BC_948
    has mark_as_thing
    with IK2_Count 74
    with IK2_Link I245_bottles_of_slime
    with KD_Count 2
    with name 'hidden' 'book' 'of' 'notes' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_949
    with initial BC_950
    with p15_reading_material BC_951
    with list_together BC_952
    with plural BC_953
    with article BC_954
;

Object I214_gellin_like_a_vellin ""
    class K1_room
    with short_name BC_955
    with description BC_956
    with map_region I207_st_peters_mall
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_957
    has mark_as_room
    with IK1_Count 25
    with IK1_Link I215_birds_of_paradise
    with KD_Count 1
    with name 'gellin' 'like' 'a//' 'vellin' 'rooms//p' 
    with list_together BC_958
    with plural BC_959
    with article BC_960
;

Object -> I245_bottles_of_slime ""
    class K2_thing
    with short_name BC_961
    has pluralname
    with vector 0
    has mark_as_thing
    with IK2_Count 75
    with IK2_Link I246_stains_on_the_floor
    with KD_Count 2
    with name 'bottles' 'of' 'slime' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_962
    with initial BC_963
    with p15_reading_material BC_964
    with list_together BC_965
    with plural BC_966
    with article BC_967
;

Object -> I246_stains_on_the_floor ""
    class K2_thing
    with short_name BC_968
    has proper
    with vector 0
    with cap_short_name BC_969
    has mark_as_thing
    with IK2_Count 76
    with IK2_Link I247_message_in_slime
    with KD_Count 2
    with name 'stains' 'on' 'the' 'floor' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_970
    with initial BC_971
    with p15_reading_material BC_972
    with list_together BC_973
    with plural BC_974
    with article BC_975
;

Object -> I247_message_in_slime ""
    class K2_thing
    with short_name BC_976
    has proper
    with vector 0
    with cap_short_name BC_977
    has mark_as_thing
    with IK2_Count 77
    with IK2_Link I239_small_crowd_of_teenager
    with KD_Count 2
    with name 'message' 'in' 'slime' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_978
    with initial BC_979
    with p15_reading_material BC_980
    with list_together BC_981
    with plural BC_982
    with article BC_983
;

Object I215_birds_of_paradise ""
    class K1_room
    with short_name BC_984
    with description BC_985
    with map_region I207_st_peters_mall
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_986
    has mark_as_room
    with IK1_Count 26
    with IK1_Link I216_venus_hall
    with KD_Count 1
    with name 'birds' 'of' 'paradise' 'rooms//p' 
    with list_together BC_987
    with plural BC_988
    with article BC_989
;

Object I216_venus_hall ""
    class K1_room
    with short_name BC_990
    with description BC_991
    with map_region I207_st_peters_mall
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_992
    has mark_as_room
    with IK1_Count 27
    with IK1_Link I217_dpc
    with KD_Count 1
    with name 'venus' 'hall' 'rooms//p' 
    with list_together BC_993
    with plural BC_994
    with article BC_995
;

Object -> I239_small_crowd_of_teenager ""
    class K2_thing
    with short_name BC_996
    with description BC_997
    has proper
    with vector 0
    with cap_short_name BC_998
    has mark_as_thing
    with IK2_Count 69
    with IK2_Link I240_mall_plants
    with KD_Count 2
    with name 'small' 'crowd' 'of' 'teenagers' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_999
    with p15_reading_material BC_1000
    with list_together BC_1001
    with plural BC_1002
    with article BC_1003
;

Object -> I240_mall_plants ""
    class K2_thing
    with short_name BC_1004
    has pluralname
    with vector 0
    has mark_as_thing
    with IK2_Count 70
    with IK2_Link I241_mall_maps
    with KD_Count 2
    with name 'mall' 'plants' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1005
    with initial BC_1006
    with p15_reading_material BC_1007
    with list_together BC_1008
    with plural BC_1009
    with article BC_1010
;

Object -> I241_mall_maps ""
    class K2_thing
    with short_name BC_1011
    has proper
    with vector 0
    with cap_short_name BC_1012
    has mark_as_thing
    with IK2_Count 71
    with IK2_Link I248_old_school_records
    with KD_Count 2
    with name 'mall' 'maps' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1013
    with initial BC_1014
    with p15_reading_material BC_1015
    with list_together BC_1016
    with plural BC_1017
    with article BC_1018
;

Object I217_dpc ""
    class K1_room
    with short_name BC_1019
    with description BC_1020
    with map_region I207_st_peters_mall
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_1021
    has mark_as_room
    with IK1_Count 28
    with IK1_Link I255_entrance_to_warehouse_r
    with KD_Count 1
    with name 'dpc' 'rooms//p' 
    with list_together BC_1022
    with plural BC_1023
    with article BC_1024
;

Object -> I248_old_school_records ""
    class K2_thing
    with short_name BC_1025
    has pluralname
    with vector 0
    has mark_as_thing
    with IK2_Count 78
    with IK2_Link I249_badass_t_shirts
    with KD_Count 2
    with name 'old-school' 'records' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1026
    with initial BC_1027
    with p15_reading_material BC_1028
    with list_together BC_1029
    with plural BC_1030
    with article BC_1031
;

Object -> I249_badass_t_shirts ""
    class K2_thing
    with short_name BC_1032
    has proper
    with vector 0
    with cap_short_name BC_1033
    has mark_as_thing
    with IK2_Count 79
    with IK2_Link I250_nympho
    with KD_Count 2
    with name 'badass' 't-shirts' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1034
    with initial BC_1035
    with p15_reading_material BC_1036
    with list_together BC_1037
    with plural BC_1038
    with article BC_1039
;

Object -> I250_nympho ""
    class K2_thing
    with short_name BC_1040
    has proper
    with vector 0
    with cap_short_name BC_1041
    has mark_as_thing
    with IK2_Count 80
    with IK2_Link I270_equestrian_mistress
    with KD_Count 2
    with name 'nympho' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1042
    with initial BC_1043
    with p15_reading_material BC_1044
    with list_together BC_1045
    with plural BC_1046
    with article BC_1047
;

Object I254_warehouse_district ""
    class K9_region
    with short_name BC_1048
    has proper
    with vector 0
    with cap_short_name BC_1049
    with regional_found_in [ ;
        if (TestRegionalContainment(location, I254_warehouse_district)) rtrue; rfalse;],
    with IK9_Count 2
    with IK9_Link I310_business_district
    with KD_Count 9
    with name 'warehouse' 'district' 'regions//p' 
    with action_bitmap 0 0 0 0 0 0 
    with list_together BC_1050
    with plural BC_1051
    with article BC_1052
;

Object I255_entrance_to_warehouse_r ""
    class K1_room
    with short_name BC_1053
    with description BC_1054
    with map_region I254_warehouse_district
    with vector 0
    with room_index -1
    has mark_as_room
    with IK1_Count 29
    with IK1_Link I256_ocean_path
    with KD_Count 1
    with name 'entrance' 'to' 'warehouse' 'row' 'rooms//p' 
    with list_together BC_1055
    with plural BC_1056
    with article BC_1057
;

Object I256_ocean_path ""
    class K1_room
    with short_name BC_1058
    with description BC_1059
    with map_region I254_warehouse_district
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_1060
    has mark_as_room
    with IK1_Count 30
    with IK1_Link I257_shed
    with KD_Count 1
    with name 'ocean' 'path' 'rooms//p' 
    with list_together BC_1061
    with plural BC_1062
    with article BC_1063
;

Object I257_shed ""
    class K1_room
    with short_name BC_1064
    with description BC_1065
    with map_region I254_warehouse_district
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_1066
    has mark_as_room
    with IK1_Count 31
    with IK1_Link I258_ajk_supply_entrance
    with KD_Count 1
    with name 'shed' 'rooms//p' 
    with list_together BC_1067
    with plural BC_1068
    with article BC_1069
;

Object -> I270_equestrian_mistress ""
    class K11_woman
    with short_name BC_1070
    with description BC_1071
    has proper
    with vector 0
    with cap_short_name BC_1072
    has mark_as_thing
    with IK2_Count 84
    with IK2_Link I271_becky
    with IK8_Count 19
    with IK8_Link I271_becky
    with IK11_Count 2
    with IK11_Link I271_becky
    with KD_Count 11
    with name 'equestrian' 'mistress' 'women//p' 
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_1073
    with p15_reading_material BC_1074
    with list_together BC_1075
    with plural BC_1076
    with article BC_1077
;

Object -> I271_becky ""
    class K11_woman
    with short_name BC_1078
    with description BC_1079
    has proper
    with vector 0
    with cap_short_name BC_1080
    has mark_as_thing
    with IK2_Count 85
    with IK2_Link I272_cage
    with IK8_Count 20
    with IK8_Link I293_relaxed_woman
    with IK11_Count 3
    with IK11_Link I349_trixie
    with KD_Count 11
    with name 'becky' 'women//p' 
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_1081
    with p15_reading_material BC_1082
    with list_together BC_1083
    with plural BC_1084
    with article BC_1085
;

Object -> I272_cage ""
    class K6_supporter
    with short_name BC_1086
    with description BC_1087
    has proper
    with vector 0
    with cap_short_name BC_1088
    has mark_as_thing
    with IK2_Count 86
    with IK2_Link I273_two_wooden_chairs
    with IK6_Count 8
    with IK6_Link I273_two_wooden_chairs
    with KD_Count 6
    with name 'cage' 'supporters//p' 
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_1089
    with p15_reading_material BC_1090
    with list_together BC_1091
    with plural BC_1092
    with article BC_1093
;

Object -> I273_two_wooden_chairs ""
    class K6_supporter
    with short_name BC_1094
    with description BC_1095
    has proper
    with vector 0
    with cap_short_name BC_1096
    has mark_as_thing
    with IK2_Count 87
    with IK2_Link I274_mistresses_table
    with IK6_Count 9
    with IK6_Link I274_mistresses_table
    with KD_Count 6
    with name 'two' 'wooden' 'chairs' 'supporters//p' 
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_1097
    with p15_reading_material BC_1098
    with list_together BC_1099
    with plural BC_1100
    with article BC_1101
;

Object -> I274_mistresses_table ""
    class K6_supporter
    with short_name BC_1102
    with description BC_1103
    has proper
    with vector 0
    with cap_short_name BC_1104
    has mark_as_thing
    with IK2_Count 88
    with IK2_Link I275_horse_whip
    with IK6_Count 10
    with IK6_Link I284_knocked_over_trashcan
    with KD_Count 6
    with name 'mistresses' 'table' 'supporters//p' 
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_1105
    with p15_reading_material BC_1106
    with list_together BC_1107
    with plural BC_1108
    with article BC_1109
;

Object -> -> I275_horse_whip ""
    class K2_thing
    with short_name BC_1110
    with description BC_1111
    has proper
    with vector 0
    with cap_short_name BC_1112
    has mark_as_thing
    with IK2_Count 89
    with IK2_Link I276_soggy_cigarettes
    with KD_Count 2
    with name 'horse' 'whip' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_1113
    with p15_reading_material BC_1114
    with list_together BC_1115
    with plural BC_1116
    with article BC_1117
;

Object I258_ajk_supply_entrance ""
    class K1_room
    with short_name BC_1118
    with description BC_1119
    with map_region I254_warehouse_district
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_1120
    has mark_as_room
    with IK1_Count 32
    with IK1_Link I259_ajk_warehouse
    with KD_Count 1
    with name 'ajk' 'supply' 'entrance' 'rooms//p' 
    with list_together BC_1121
    with plural BC_1122
    with article BC_1123
;

Object -> I276_soggy_cigarettes ""
    class K2_thing
    with short_name BC_1124
    has pluralname
    with vector 0
    has mark_as_thing
    with IK2_Count 90
    with IK2_Link I277_sounds_of_barking
    with KD_Count 2
    with name 'soggy' 'cigarettes' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1125
    with initial BC_1126
    with p15_reading_material BC_1127
    with list_together BC_1128
    with plural BC_1129
    with article BC_1130
;

Object -> I277_sounds_of_barking ""
    class K2_thing
    with short_name BC_1131
    has proper
    with vector 0
    with cap_short_name BC_1132
    has mark_as_thing
    with IK2_Count 91
    with IK2_Link I278_weird_footprints
    with KD_Count 2
    with name 'sounds' 'of' 'barking' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1133
    with initial BC_1134
    with p15_reading_material BC_1135
    with list_together BC_1136
    with plural BC_1137
    with article BC_1138
;

Object -> I278_weird_footprints ""
    class K2_thing
    with short_name BC_1139
    has proper
    with vector 0
    with cap_short_name BC_1140
    has mark_as_thing
    with IK2_Count 92
    with IK2_Link I282_old_truck
    with KD_Count 2
    with name 'weird' 'footprints' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1141
    with initial BC_1142
    with p15_reading_material BC_1143
    with list_together BC_1144
    with plural BC_1145
    with article BC_1146
;

Object -> I282_old_truck ""
    class K14_vehicle
    with short_name BC_1147
    with description BC_1148
    has proper
    has ~open
    has openable
    has lockable
    has locked
    with vector 0
    with cap_short_name BC_1149
    has mark_as_thing
    with IK2_Count 96
    with IK2_Link I283_disgusting_pair_of_boot
    with IK5_Count 9
    with IK5_Link I287_old_office
    with IK14_Count 0
    with IK14_Link I376_two_cop_cars
    with KD_Count 14
    with name 'old' 'truck' 'vehicles//p' 
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_1150
    with p15_reading_material BC_1151
    with list_together BC_1152
    with plural BC_1153
    with article BC_1154
;

Object -> I283_disgusting_pair_of_boot ""
    class K2_thing
    with short_name BC_1155
    with description BC_1156
    with vector 0
    has mark_as_thing
    with IK2_Count 97
    with IK2_Link I284_knocked_over_trashcan
    with KD_Count 2
    with name 'disgusting' 'pair' 'of' 'boots' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_1157
    with p15_reading_material BC_1158
    with list_together BC_1159
    with plural BC_1160
    with article BC_1161
;

Object -> I284_knocked_over_trashcan ""
    class K6_supporter
    with short_name BC_1162
    with description BC_1163
    has proper
    with vector 0
    with cap_short_name BC_1164
    has mark_as_thing
    with IK2_Count 98
    with IK2_Link I279_cages
    with IK6_Count 11
    with IK6_Link I288_old_bed
    with KD_Count 6
    with name 'knocked' 'over' 'trashcan' 'supporters//p' 
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_1165
    with p15_reading_material BC_1166
    with list_together BC_1167
    with plural BC_1168
    with article BC_1169
;

Object I259_ajk_warehouse ""
    class K1_room
    with short_name BC_1170
    with description BC_1171
    with map_region I254_warehouse_district
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_1172
    has mark_as_room
    with IK1_Count 33
    with IK1_Link I260_tinman_moving_entrance
    with KD_Count 1
    with name 'ajk' 'warehouse' 'rooms//p' 
    with list_together BC_1173
    with plural BC_1174
    with article BC_1175
;

Object -> I279_cages ""
    class K2_thing
    with short_name BC_1176
    has pluralname
    with vector 0
    has mark_as_thing
    with IK2_Count 93
    with IK2_Link I280_barking_dogs
    with KD_Count 2
    with name 'cages' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1177
    with initial BC_1178
    with p15_reading_material BC_1179
    with list_together BC_1180
    with plural BC_1181
    with article BC_1182
;

Object -> I280_barking_dogs ""
    class K2_thing
    with short_name BC_1183
    has proper
    with vector 0
    with cap_short_name BC_1184
    has mark_as_thing
    with IK2_Count 94
    with IK2_Link I281_kinky_sex_items
    with KD_Count 2
    with name 'barking' 'dogs' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1185
    with initial BC_1186
    with p15_reading_material BC_1187
    with list_together BC_1188
    with plural BC_1189
    with article BC_1190
;

Object -> I281_kinky_sex_items ""
    class K2_thing
    with short_name BC_1191
    has proper
    with vector 0
    with cap_short_name BC_1192
    has mark_as_thing
    with IK2_Count 95
    with IK2_Link I285_giant_tinman_sign
    with KD_Count 2
    with name 'kinky' 'sex' 'items' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1193
    with initial BC_1194
    with p15_reading_material BC_1195
    with list_together BC_1196
    with plural BC_1197
    with article BC_1198
;

Object I260_tinman_moving_entrance ""
    class K1_room
    with short_name BC_1199
    with description BC_1200
    with map_region I254_warehouse_district
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_1201
    has mark_as_room
    with IK1_Count 34
    with IK1_Link I261_small_bridge
    with KD_Count 1
    with name 'tinman' 'moving' 'entrance' 'rooms//p' 
    with list_together BC_1202
    with plural BC_1203
    with article BC_1204
;

Object -> I285_giant_tinman_sign ""
    class K2_thing
    with short_name BC_1205
    with description BC_1206
    has proper
    has static
    has scenery
    with vector 0
    with cap_short_name BC_1207
    has mark_as_thing
    with IK2_Count 99
    with IK2_Link I286_picture_of_owner
    with KD_Count 2
    with name 'giant' 'tinman' 'sign' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_1208
    with p15_reading_material BC_1209
    with list_together BC_1210
    with plural BC_1211
    with article BC_1212
;

Object I261_small_bridge ""
    class K1_room
    with short_name BC_1213
    with description BC_1214
    with map_region I254_warehouse_district
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_1215
    has mark_as_room
    with IK1_Count 35
    with IK1_Link I262_tinman_warehouse
    with KD_Count 1
    with name 'small' 'bridge' 'rooms//p' 
    with list_together BC_1216
    with plural BC_1217
    with article BC_1218
;

Object I262_tinman_warehouse ""
    class K1_room
    with short_name BC_1219
    with description BC_1220
    with map_region I254_warehouse_district
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_1221
    has mark_as_room
    with IK1_Count 36
    with IK1_Link I263_dark_culdesac
    with KD_Count 1
    with name 'tinman' 'warehouse' 'rooms//p' 
    with list_together BC_1222
    with plural BC_1223
    with article BC_1224
;

Object -> I286_picture_of_owner ""
    class K2_thing
    with short_name BC_1225
    has proper
    with vector 0
    with cap_short_name BC_1226
    has mark_as_thing
    with IK2_Count 100
    with IK2_Link I287_old_office
    with KD_Count 2
    with name 'picture' 'of' 'owner' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1227
    with initial BC_1228
    with p15_reading_material BC_1229
    with list_together BC_1230
    with plural BC_1231
    with article BC_1232
;

Object -> I287_old_office ""
    class K5_container
    with short_name BC_1233
    has proper
    has enterable
    has open
    with vector 0
    with cap_short_name BC_1234
    has mark_as_thing
    with IK2_Count 101
    with IK2_Link I288_old_bed
    with IK5_Count 10
    with IK5_Link I291_portal
    with KD_Count 5
    with name 'old' 'office' 'containers//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1235
    with initial BC_1236
    with p15_reading_material BC_1237
    with list_together BC_1238
    with plural BC_1239
    with article BC_1240
;

Object -> -> I288_old_bed ""
    class K6_supporter
    with short_name BC_1241
    has proper
    with vector 0
    with cap_short_name BC_1242
    has mark_as_thing
    with IK2_Count 102
    with IK2_Link I289_metal_desk
    with IK6_Count 12
    with IK6_Link I289_metal_desk
    with KD_Count 6
    with name 'old' 'bed' 'supporters//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1243
    with initial BC_1244
    with p15_reading_material BC_1245
    with list_together BC_1246
    with plural BC_1247
    with article BC_1248
;

Object -> -> I289_metal_desk ""
    class K6_supporter
    with short_name BC_1249
    has proper
    with vector 0
    with cap_short_name BC_1250
    has mark_as_thing
    with IK2_Count 103
    with IK2_Link I291_portal
    with IK6_Count 13
    with IK6_Link I292_docks_sign
    with KD_Count 6
    with name 'metal' 'desk' 'supporters//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1251
    with initial BC_1252
    with p15_reading_material BC_1253
    with list_together BC_1254
    with plural BC_1255
    with article BC_1256
;

Object I263_dark_culdesac ""
    class K1_room
    with short_name BC_1257
    with description BC_1258
    with map_region I254_warehouse_district
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_1259
    has mark_as_room
    with IK1_Count 37
    with IK1_Link I264_entrance_to_docks
    with KD_Count 1
    with name 'dark' 'culdesac' 'rooms//p' 
    with list_together BC_1260
    with plural BC_1261
    with article BC_1262
;

Object -> I291_portal ""
    class K5_container
    with short_name BC_1263
    with description BC_1264
    has proper
    has enterable
    has open
    with vector 0
    with cap_short_name BC_1265
    has mark_as_thing
    with IK2_Count 104
    with IK2_Link I292_docks_sign
    with IK5_Count 11
    with IK5_Link I295_guard_house
    with KD_Count 5
    with name 'portal' 'containers//p' 
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_1266
    with p15_reading_material BC_1267
    with list_together BC_1268
    with plural BC_1269
    with article BC_1270
;

Object I264_entrance_to_docks ""
    class K1_room
    with short_name BC_1271
    with description BC_1272
    with map_region I254_warehouse_district
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_1273
    has mark_as_room
    with IK1_Count 38
    with IK1_Link I265_boat_ramp_1
    with KD_Count 1
    with name 'entrance' 'to' 'docks' 'rooms//p' 
    with list_together BC_1274
    with plural BC_1275
    with article BC_1276
;

Object -> I292_docks_sign ""
    class K6_supporter
    with short_name BC_1277
    with initial BC_1278
    has proper
    with vector 0
    with cap_short_name BC_1279
    has mark_as_thing
    with IK2_Count 105
    with IK2_Link I293_relaxed_woman
    with IK6_Count 14
    with IK6_Link I298_guard_desk
    with KD_Count 6
    with name 'docks' 'sign' 'supporters//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1280
    with p15_reading_material BC_1281
    with list_together BC_1282
    with plural BC_1283
    with article BC_1284
;

Object I265_boat_ramp_1 ""
    class K1_room
    with short_name BC_1285
    with description BC_1286
    with map_region I254_warehouse_district
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_1287
    has mark_as_room
    with IK1_Count 39
    with IK1_Link I266_security_checkpoint
    with KD_Count 1
    with name 'boat' 'ramp' '1//' 'rooms//p' 
    with list_together BC_1288
    with plural BC_1289
    with article BC_1290
;

Object -> I293_relaxed_woman ""
    class K8_person
    with short_name BC_1291
    with description BC_1292
    has proper
    with vector 0
    with cap_short_name BC_1293
    has mark_as_thing
    with IK2_Count 106
    with IK2_Link I294_splashing_woman
    with IK8_Count 21
    with IK8_Link I294_splashing_woman
    with KD_Count 8
    with name 'relaxed' 'woman' 'people//p' 
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_1294
    with p15_reading_material BC_1295
    with list_together BC_1296
    with plural BC_1297
    with article BC_1298
;

Object -> I294_splashing_woman ""
    class K8_person
    with short_name BC_1299
    with description BC_1300
    has proper
    with vector 0
    with cap_short_name BC_1301
    has mark_as_thing
    with IK2_Count 107
    with IK2_Link I295_guard_house
    with IK8_Count 22
    with IK8_Link I296_sleeping_guard
    with KD_Count 8
    with name 'splashing' 'woman' 'people//p' 
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_1302
    with p15_reading_material BC_1303
    with list_together BC_1304
    with plural BC_1305
    with article BC_1306
;

Object I266_security_checkpoint ""
    class K1_room
    with short_name BC_1307
    with description BC_1308
    with map_region I254_warehouse_district
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_1309
    has mark_as_room
    with IK1_Count 40
    with IK1_Link I267_farm_co
    with KD_Count 1
    with name 'security' 'checkpoint' 'rooms//p' 
    with list_together BC_1310
    with plural BC_1311
    with article BC_1312
;

Object -> I295_guard_house ""
    class K5_container
    with short_name BC_1313
    has proper
    has enterable
    has open
    with vector 0
    with cap_short_name BC_1314
    has mark_as_thing
    with IK2_Count 108
    with IK2_Link I296_sleeping_guard
    with IK5_Count 12
    with IK5_Link I332_fruit_storefront
    with KD_Count 5
    with name 'guard' 'house' 'containers//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1315
    with initial BC_1316
    with p15_reading_material BC_1317
    with list_together BC_1318
    with plural BC_1319
    with article BC_1320
;

Object -> -> I296_sleeping_guard ""
    class K8_person
    with short_name BC_1321
    with description BC_1322
    has proper
    with vector 0
    with cap_short_name BC_1323
    has mark_as_thing
    with IK2_Count 109
    with IK2_Link I297_taser
    with IK8_Count 23
    with IK8_Link I302_christine
    with KD_Count 8
    with name 'sleeping' 'guard' 'people//p' 
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_1324
    with p15_reading_material BC_1325
    with list_together BC_1326
    with plural BC_1327
    with article BC_1328
;

Object -> -> -> I297_taser ""
    class K2_thing
    with short_name BC_1329
    has ~static
    has clothing
    has worn
    with vector 0
    has mark_as_thing
    with IK2_Count 110
    with IK2_Link I298_guard_desk
    with KD_Count 2
    with name 'taser' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1330
    with initial BC_1331
    with p15_reading_material BC_1332
    with list_together BC_1333
    with plural BC_1334
    with article BC_1335
;

Object -> -> I298_guard_desk ""
    class K6_supporter
    with short_name BC_1336
    has proper
    with vector 0
    with cap_short_name BC_1337
    has mark_as_thing
    with IK2_Count 111
    with IK2_Link I299_porno_mag
    with IK6_Count 15
    with IK6_Link I330_few_parked_cars
    with KD_Count 6
    with name 'guard' 'desk' 'supporters//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1338
    with initial BC_1339
    with p15_reading_material BC_1340
    with list_together BC_1341
    with plural BC_1342
    with article BC_1343
;

Object -> -> -> I299_porno_mag ""
    class K2_thing
    with short_name BC_1344
    with description BC_1345
    has proper
    with vector 0
    with cap_short_name BC_1346
    has mark_as_thing
    with IK2_Count 112
    with IK2_Link I300_mug
    with KD_Count 2
    with name 'porno' 'mag' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_1347
    with p15_reading_material BC_1348
    with list_together BC_1349
    with plural BC_1350
    with article BC_1351
;

Object -> -> -> I300_mug ""
    class K2_thing
    with short_name BC_1352
    with description BC_1353
    has proper
    with vector 0
    with cap_short_name BC_1354
    has mark_as_thing
    with IK2_Count 113
    with IK2_Link I301_racks_of_hose_machines
    with KD_Count 2
    with name 'mug' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_1355
    with p15_reading_material BC_1356
    with list_together BC_1357
    with plural BC_1358
    with article BC_1359
;

Object I267_farm_co ""
    class K1_room
    with short_name BC_1360
    with description BC_1361
    with map_region I254_warehouse_district
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_1362
    has mark_as_room
    with IK1_Count 41
    with IK1_Link I268_boat_ramp_2
    with KD_Count 1
    with name 'farm' 'co' 'rooms//p' 
    with list_together BC_1363
    with plural BC_1364
    with article BC_1365
;

Object -> I301_racks_of_hose_machines ""
    class K2_thing
    with short_name BC_1366
    has proper
    with vector 0
    with cap_short_name BC_1367
    has mark_as_thing
    with IK2_Count 114
    with IK2_Link I302_christine
    with KD_Count 2
    with name 'racks' 'of' 'hose' 'machines' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1368
    with initial BC_1369
    with p15_reading_material BC_1370
    with list_together BC_1371
    with plural BC_1372
    with article BC_1373
;

Object -> I302_christine ""
    class K8_person
    with short_name BC_1374
    with description BC_1375
    has proper
    with vector 0
    with cap_short_name BC_1376
    has mark_as_thing
    with IK2_Count 115
    with IK2_Link I303_chains
    with IK8_Count 24
    with IK8_Link I333_fruit_salesman
    with KD_Count 8
    with name 'christine' 'people//p' 
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_1377
    with p15_reading_material BC_1378
    with list_together BC_1379
    with plural BC_1380
    with article BC_1381
;

Object -> I303_chains ""
    class K2_thing
    with short_name BC_1382
    with description BC_1383
    has proper
    with vector 0
    with cap_short_name BC_1384
    has mark_as_thing
    with IK2_Count 116
    with IK2_Link I304_fishing_nets
    with KD_Count 2
    with name 'chains' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_1385
    with p15_reading_material BC_1386
    with list_together BC_1387
    with plural BC_1388
    with article BC_1389
;

Object I268_boat_ramp_2 ""
    class K1_room
    with short_name BC_1390
    with description BC_1391
    with map_region I254_warehouse_district
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_1392
    has mark_as_room
    with IK1_Count 42
    with IK1_Link I269_headmistresses_chambers
    with KD_Count 1
    with name 'boat' 'ramp' '2//' 'rooms//p' 
    with list_together BC_1393
    with plural BC_1394
    with article BC_1395
;

Object -> I304_fishing_nets ""
    class K2_thing
    with short_name BC_1396
    has pluralname
    with vector 0
    has mark_as_thing
    with IK2_Count 117
    with IK2_Link I305_moldy_hair_brushes
    with KD_Count 2
    with name 'fishing' 'nets' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1397
    with initial BC_1398
    with p15_reading_material BC_1399
    with list_together BC_1400
    with plural BC_1401
    with article BC_1402
;

Object -> I305_moldy_hair_brushes ""
    class K2_thing
    with short_name BC_1403
    has proper
    with vector 0
    with cap_short_name BC_1404
    has mark_as_thing
    with IK2_Count 118
    with IK2_Link I306_lost_keys
    with KD_Count 2
    with name 'moldy' 'hair' 'brushes' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1405
    with initial BC_1406
    with p15_reading_material BC_1407
    with list_together BC_1408
    with plural BC_1409
    with article BC_1410
;

Object -> I306_lost_keys ""
    class K2_thing
    with short_name BC_1411
    has proper
    with vector 0
    with cap_short_name BC_1412
    has mark_as_thing
    with IK2_Count 119
    with IK2_Link I308_bull_horn
    with KD_Count 2
    with name 'lost' 'keys' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1413
    with initial BC_1414
    with p15_reading_material BC_1415
    with list_together BC_1416
    with plural BC_1417
    with article BC_1418
;

Object I269_headmistresses_chambers ""
    class K1_room
    with short_name BC_1419
    with description BC_1420
    with map_region I254_warehouse_district
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_1421
    has mark_as_room
    with IK1_Count 43
    with IK1_Link I311_110_main_street
    with KD_Count 1
    with name 'headmistresses' 'chambers' 'rooms//p' 
    with list_together BC_1422
    with plural BC_1423
    with article BC_1424
;

Object -> I308_bull_horn ""
    class K2_thing
    with short_name BC_1425
    with description BC_1426
    has proper
    with vector 0
    with cap_short_name BC_1427
    has mark_as_thing
    with IK2_Count 121
    with IK2_Link I309_wand_of_the_cow
    with KD_Count 2
    with name 'bull' 'horn' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_1428
    with p15_reading_material BC_1429
    with list_together BC_1430
    with plural BC_1431
    with article BC_1432
;

Object -> I309_wand_of_the_cow ""
    class K2_thing
    with short_name BC_1433
    with description BC_1434
    has proper
    with vector 0
    with cap_short_name BC_1435
    has mark_as_thing
    with IK2_Count 122
    with IK2_Link I330_few_parked_cars
    with KD_Count 2
    with name 'wand' 'of' 'the' 'cow' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_1436
    with p15_reading_material BC_1437
    with list_together BC_1438
    with plural BC_1439
    with article BC_1440
;

Object I310_business_district ""
    class K9_region
    with short_name BC_1441
    has proper
    with vector 0
    with cap_short_name BC_1442
    with regional_found_in [ ;
        if (TestRegionalContainment(location, I310_business_district)) rtrue; rfalse;],
    with IK9_Count 3
    with IK9_Link I383_uptown_district
    with KD_Count 9
    with name 'business' 'district' 'regions//p' 
    with action_bitmap 0 0 0 0 0 0 
    with list_together BC_1443
    with plural BC_1444
    with article BC_1445
;

Object I311_110_main_street ""
    class K1_room
    with short_name BC_1446
    with description BC_1447
    with map_region I310_business_district
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_1448
    has mark_as_room
    with IK1_Count 44
    with IK1_Link I312_120_main_street
    with KD_Count 1
    with name '110' 'main' 'street' 'rooms//p' 
    with list_together BC_1449
    with plural BC_1450
    with article BC_1451
;

Object -> I330_few_parked_cars ""
    class K6_supporter
    with short_name BC_1452
    with vector 0
    has mark_as_thing
    with IK2_Count 123
    with IK2_Link I331_public_mail_box
    with IK6_Count 17
    with IK6_Link I331_public_mail_box
    with KD_Count 6
    with name 'few' 'parked' 'cars' 'supporters//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1453
    with initial BC_1454
    with p15_reading_material BC_1455
    with list_together BC_1456
    with plural BC_1457
    with article BC_1458
;

Object I312_120_main_street ""
    class K1_room
    with short_name BC_1459
    with description BC_1460
    with map_region I310_business_district
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_1461
    has mark_as_room
    with IK1_Count 45
    with IK1_Link I313_120_haven_street
    with KD_Count 1
    with name '120' 'main' 'street' 'rooms//p' 
    with list_together BC_1462
    with plural BC_1463
    with article BC_1464
;

Object -> I331_public_mail_box ""
    class K6_supporter
    with short_name BC_1465
    has proper
    with vector 0
    with cap_short_name BC_1466
    has mark_as_thing
    with IK2_Count 124
    with IK2_Link I332_fruit_storefront
    with IK6_Count 18
    with IK6_Link I342_sweeping_garden
    with KD_Count 6
    with name 'public' 'mail' 'box' 'supporters//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1467
    with initial BC_1468
    with p15_reading_material BC_1469
    with list_together BC_1470
    with plural BC_1471
    with article BC_1472
;

Object -> I332_fruit_storefront ""
    class K5_container
    with short_name BC_1473
    has proper
    has enterable
    has open
    with vector 0
    with cap_short_name BC_1474
    has mark_as_thing
    with IK2_Count 125
    with IK2_Link I333_fruit_salesman
    with IK5_Count 13
    with IK5_Link I343_patio
    with KD_Count 5
    with name 'fruit' 'storefront' 'containers//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1475
    with initial BC_1476
    with p15_reading_material BC_1477
    with list_together BC_1478
    with plural BC_1479
    with article BC_1480
;

Object -> -> I333_fruit_salesman ""
    class K8_person
    with short_name BC_1481
    has proper
    with vector 0
    with cap_short_name BC_1482
    has mark_as_thing
    with IK2_Count 126
    with IK2_Link I334_lindsay
    with IK8_Count 25
    with IK8_Link I334_lindsay
    with KD_Count 8
    with name 'fruit' 'salesman' 'people//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1483
    with initial BC_1484
    with p15_reading_material BC_1485
    with list_together BC_1486
    with plural BC_1487
    with article BC_1488
;

Object -> -> I334_lindsay ""
    class K8_person
    with short_name BC_1489
    has proper
    with vector 0
    with cap_short_name BC_1490
    has mark_as_thing
    with IK2_Count 127
    with IK2_Link I342_sweeping_garden
    with IK8_Count 26
    with IK8_Link I349_trixie
    with KD_Count 8
    with name 'lindsay' 'people//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1491
    with initial BC_1492
    with p15_reading_material BC_1493
    with list_together BC_1494
    with plural BC_1495
    with article BC_1496
;

Object I313_120_haven_street ""
    class K1_room
    with short_name BC_1497
    with description BC_1498
    with map_region I310_business_district
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_1499
    has mark_as_room
    with IK1_Count 46
    with IK1_Link I314_130_haven_street
    with KD_Count 1
    with name '120' 'haven' 'street' 'rooms//p' 
    with list_together BC_1500
    with plural BC_1501
    with article BC_1502
;

Object -> I342_sweeping_garden ""
    class K6_supporter
    with short_name BC_1503
    has proper
    with vector 0
    with cap_short_name BC_1504
    has mark_as_thing
    with IK2_Count 134
    with IK2_Link I343_patio
    with IK6_Count 20
    with IK6_Link I344_white_plastic_chairs
    with KD_Count 6
    with name 'sweeping' 'garden' 'supporters//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1505
    with initial BC_1506
    with p15_reading_material BC_1507
    with list_together BC_1508
    with plural BC_1509
    with article BC_1510
;

Object -> I343_patio ""
    class K5_container
    with short_name BC_1511
    has proper
    has enterable
    has open
    with vector 0
    with cap_short_name BC_1512
    has mark_as_thing
    with IK2_Count 135
    with IK2_Link I344_white_plastic_chairs
    with IK5_Count 14
    with IK5_Link I345_drink_bar
    with KD_Count 5
    with name 'patio' 'containers//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1513
    with initial BC_1514
    with p15_reading_material BC_1515
    with list_together BC_1516
    with plural BC_1517
    with article BC_1518
;

Object -> -> I344_white_plastic_chairs ""
    class K6_supporter
    with short_name BC_1519
    has proper
    with vector 0
    with cap_short_name BC_1520
    has mark_as_thing
    with IK2_Count 136
    with IK2_Link I338_construction_workers
    with IK6_Count 21
    with IK6_Link I340_wall_of_artifacts
    with KD_Count 6
    with name 'white' 'plastic' 'chairs' 'supporters//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1521
    with initial BC_1522
    with p15_reading_material BC_1523
    with list_together BC_1524
    with plural BC_1525
    with article BC_1526
;

Object I314_130_haven_street ""
    class K1_room
    with short_name BC_1527
    with description BC_1528
    with map_region I310_business_district
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_1529
    has mark_as_room
    with IK1_Count 47
    with IK1_Link I315_130_main_street
    with KD_Count 1
    with name '130' 'haven' 'street' 'rooms//p' 
    with list_together BC_1530
    with plural BC_1531
    with article BC_1532
;

Object -> I338_construction_workers ""
    class K2_thing
    with short_name BC_1533
    has pluralname
    with vector 0
    has mark_as_thing
    with IK2_Count 131
    with IK2_Link I339_large_machinery
    with KD_Count 2
    with name 'construction' 'workers' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1534
    with initial BC_1535
    with p15_reading_material BC_1536
    with list_together BC_1537
    with plural BC_1538
    with article BC_1539
;

Object -> I339_large_machinery ""
    class K2_thing
    with short_name BC_1540
    has proper
    with vector 0
    with cap_short_name BC_1541
    has mark_as_thing
    with IK2_Count 132
    with IK2_Link I335_crowd_of_people
    with KD_Count 2
    with name 'large' 'machinery' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1542
    with initial BC_1543
    with p15_reading_material BC_1544
    with list_together BC_1545
    with plural BC_1546
    with article BC_1547
;

Object I315_130_main_street ""
    class K1_room
    with short_name BC_1548
    with description BC_1549
    with map_region I310_business_district
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_1550
    has mark_as_room
    with IK1_Count 48
    with IK1_Link I316_import_inc
    with KD_Count 1
    with name '130' 'main' 'street' 'rooms//p' 
    with list_together BC_1551
    with plural BC_1552
    with article BC_1553
;

Object -> I335_crowd_of_people ""
    class K2_thing
    with short_name BC_1554
    has proper
    with vector 0
    with cap_short_name BC_1555
    has mark_as_thing
    with IK2_Count 128
    with IK2_Link I336_potholes
    with KD_Count 2
    with name 'crowd' 'of' 'people' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1556
    with initial BC_1557
    with p15_reading_material BC_1558
    with list_together BC_1559
    with plural BC_1560
    with article BC_1561
;

Object -> I336_potholes ""
    class K2_thing
    with short_name BC_1562
    has proper
    has static
    has scenery
    with vector 0
    with cap_short_name BC_1563
    has mark_as_thing
    with IK2_Count 129
    with IK2_Link I340_wall_of_artifacts
    with KD_Count 2
    with name 'potholes' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1564
    with initial BC_1565
    with p15_reading_material BC_1566
    with list_together BC_1567
    with plural BC_1568
    with article BC_1569
;

Object I316_import_inc ""
    class K1_room
    with short_name BC_1570
    with description BC_1571
    with map_region I310_business_district
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_1572
    has mark_as_room
    with IK1_Count 49
    with IK1_Link I317_back_room
    with KD_Count 1
    with name 'import' 'inc' 'rooms//p' 
    with list_together BC_1573
    with plural BC_1574
    with article BC_1575
;

Object I317_back_room ""
    class K1_room
    with short_name BC_1576
    with description BC_1577
    with map_region I310_business_district
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_1578
    has mark_as_room
    with IK1_Count 50
    with IK1_Link I318_the_pigsty_bar_n_grill
    with KD_Count 1
    with name 'back' 'room' 'rooms//p' 
    with list_together BC_1579
    with plural BC_1580
    with article BC_1581
;

Object -> I340_wall_of_artifacts ""
    class K6_supporter
    with short_name BC_1582
    with initial BC_1583
    has proper
    with vector 0
    with cap_short_name BC_1584
    has mark_as_thing
    with IK2_Count 133
    with IK2_Link I345_drink_bar
    with IK6_Count 19
    with IK6_Link I350_trash_pile
    with KD_Count 6
    with name 'wall' 'of' 'artifacts' 'supporters//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1585
    with p15_reading_material BC_1586
    with list_together BC_1587
    with plural BC_1588
    with article BC_1589
;

Object I318_the_pigsty_bar_n_grill ""
    class K1_room
    with short_name BC_1590
    with description BC_1591
    with map_region I310_business_district
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_1592
    has mark_as_room
    with IK1_Count 51
    with IK1_Link I319_back_entrance
    with KD_Count 1
    with name 'the' 'pigsty' 'bar' 'n//' 'grill' 'rooms//p' 
    with list_together BC_1593
    with plural BC_1594
    with article BC_1595
;

Object -> I345_drink_bar ""
    class K5_container
    with short_name BC_1596
    has proper
    has enterable
    has ~open
    has openable
    has lockable
    has locked
    with vector 0
    with cap_short_name BC_1597
    has mark_as_thing
    with IK2_Count 137
    with IK2_Link I349_trixie
    with IK5_Count 15
    with IK5_Link I346_storage_room
    with KD_Count 5
    with name 'drink' 'bar' 'containers//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1598
    with initial BC_1599
    with p15_reading_material BC_1600
    with list_together BC_1601
    with plural BC_1602
    with article BC_1603
;

Object -> -> I349_trixie ""
    class K11_woman
    with short_name BC_1604
    with description BC_1605
    has proper
    with vector 0
    with cap_short_name BC_1606
    has mark_as_thing
    with IK2_Count 141
    with IK2_Link I346_storage_room
    with IK8_Count 29
    with IK8_Link I347_mistress_witch
    with IK11_Count 6
    with IK11_Link I347_mistress_witch
    with KD_Count 11
    with name 'trixie' 'women//p' 
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_1607
    with p15_reading_material BC_1608
    with list_together BC_1609
    with plural BC_1610
    with article BC_1611
;

Object -> I346_storage_room ""
    class K5_container
    with short_name BC_1612
    has proper
    has enterable
    has ~open
    with vector 0
    with cap_short_name BC_1613
    has mark_as_thing
    with IK2_Count 138
    with IK2_Link I347_mistress_witch
    with IK5_Count 16
    with IK5_Link I360_essence_socket
    with KD_Count 5
    with name 'storage' 'room' 'containers//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1614
    with initial BC_1615
    with p15_reading_material BC_1616
    with list_together BC_1617
    with plural BC_1618
    with article BC_1619
;

Object -> -> I347_mistress_witch ""
    class K11_woman
    with short_name BC_1620
    has proper
    with vector 0
    with cap_short_name BC_1621
    has mark_as_thing
    with IK2_Count 139
    with IK2_Link I348_kim
    with IK8_Count 27
    with IK8_Link I348_kim
    with IK11_Count 4
    with IK11_Link I348_kim
    with KD_Count 11
    with name 'mistress' 'witch' 'women//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1622
    with initial BC_1623
    with p15_reading_material BC_1624
    with list_together BC_1625
    with plural BC_1626
    with article BC_1627
;

Object -> -> I348_kim ""
    class K11_woman
    with short_name BC_1628
    has proper
    with vector 0
    with cap_short_name BC_1629
    has mark_as_thing
    with IK2_Count 140
    with IK2_Link I350_trash_pile
    with IK8_Count 28
    with IK8_Link I351_drunk_hobo
    with IK11_Count 5
    with IK11_Link nothing
    with KD_Count 11
    with name 'kim' 'women//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1630
    with initial BC_1631
    with p15_reading_material BC_1632
    with list_together BC_1633
    with plural BC_1634
    with article BC_1635
;

Object I319_back_entrance ""
    class K1_room
    with short_name BC_1636
    with description BC_1637
    with map_region I310_business_district
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_1638
    has mark_as_room
    with IK1_Count 52
    with IK1_Link I320_fence_out_of_town
    with KD_Count 1
    with name 'back' 'entrance' 'rooms//p' 
    with list_together BC_1639
    with plural BC_1640
    with article BC_1641
;

Object -> I350_trash_pile ""
    class K6_supporter
    with short_name BC_1642
    has proper
    with vector 0
    with cap_short_name BC_1643
    has mark_as_thing
    with IK2_Count 142
    with IK2_Link I351_drunk_hobo
    with IK6_Count 22
    with IK6_Link I352_wire_fence
    with KD_Count 6
    with name 'trash' 'pile' 'supporters//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1644
    with initial BC_1645
    with p15_reading_material BC_1646
    with list_together BC_1647
    with plural BC_1648
    with article BC_1649
;

Object -> I351_drunk_hobo ""
    class K8_person
    with short_name BC_1650
    has proper
    with vector 0
    with cap_short_name BC_1651
    has mark_as_thing
    with IK2_Count 143
    with IK2_Link I352_wire_fence
    with IK8_Count 30
    with IK8_Link I355_unseen_birds
    with KD_Count 8
    with name 'drunk' 'hobo' 'people//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1652
    with initial BC_1653
    with p15_reading_material BC_1654
    with list_together BC_1655
    with plural BC_1656
    with article BC_1657
;

Object I320_fence_out_of_town ""
    class K1_room
    with short_name BC_1658
    with description BC_1659
    with map_region I310_business_district
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_1660
    has mark_as_room
    with IK1_Count 53
    with IK1_Link I321_eastern_woods
    with KD_Count 1
    with name 'fence' 'out' 'of' 'town' 'rooms//p' 
    with list_together BC_1661
    with plural BC_1662
    with article BC_1663
;

Object -> I352_wire_fence ""
    class K6_supporter
    with short_name BC_1664
    has proper
    with vector 0
    with cap_short_name BC_1665
    has mark_as_thing
    with IK2_Count 144
    with IK2_Link I353_large_bushes
    with IK6_Count 23
    with IK6_Link I353_large_bushes
    with KD_Count 6
    with name 'wire' 'fence' 'supporters//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1666
    with initial BC_1667
    with p15_reading_material BC_1668
    with list_together BC_1669
    with plural BC_1670
    with article BC_1671
;

Object -> I353_large_bushes ""
    class K6_supporter
    with short_name BC_1672
    has proper
    with vector 0
    with cap_short_name BC_1673
    has mark_as_thing
    with IK2_Count 145
    with IK2_Link I354_mammoth_trees
    with IK6_Count 24
    with IK6_Link I354_mammoth_trees
    with KD_Count 6
    with name 'large' 'bushes' 'supporters//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1674
    with initial BC_1675
    with p15_reading_material BC_1676
    with list_together BC_1677
    with plural BC_1678
    with article BC_1679
;

Object I321_eastern_woods ""
    class K1_room
    with short_name BC_1680
    with description BC_1681
    with map_region I310_business_district
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_1682
    has mark_as_room
    with IK1_Count 54
    with IK1_Link I322_cross_road
    with KD_Count 1
    with name 'eastern' 'woods' 'rooms//p' 
    with list_together BC_1683
    with plural BC_1684
    with article BC_1685
;

Object -> I354_mammoth_trees ""
    class K6_supporter
    with short_name BC_1686
    has proper
    with vector 0
    with cap_short_name BC_1687
    has mark_as_thing
    with IK2_Count 146
    with IK2_Link I355_unseen_birds
    with IK6_Count 25
    with IK6_Link I356_scattered_leaves
    with KD_Count 6
    with name 'mammoth' 'trees' 'supporters//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1688
    with initial BC_1689
    with p15_reading_material BC_1690
    with list_together BC_1691
    with plural BC_1692
    with article BC_1693
;

Object -> -> I355_unseen_birds ""
    class K12_animal
    with short_name BC_1694
    has proper
    with vector 0
    with cap_short_name BC_1695
    has mark_as_thing
    with IK2_Count 147
    with IK2_Link I356_scattered_leaves
    with IK8_Count 31
    with IK8_Link I357_doe
    with IK12_Count 0
    with IK12_Link I357_doe
    with KD_Count 12
    with name 'unseen' 'birds' 'animals//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1696
    with initial BC_1697
    with p15_reading_material BC_1698
    with list_together BC_1699
    with plural BC_1700
    with article BC_1701
;

Object I322_cross_road ""
    class K1_room
    with short_name BC_1702
    with description BC_1703
    with map_region I310_business_district
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_1704
    has mark_as_room
    with IK1_Count 55
    with IK1_Link I323_goddesses_chambers
    with KD_Count 1
    with name 'cross' 'road' 'rooms//p' 
    with list_together BC_1705
    with plural BC_1706
    with article BC_1707
;

Object -> I356_scattered_leaves ""
    class K6_supporter
    with short_name BC_1708
    has proper
    with vector 0
    with cap_short_name BC_1709
    has mark_as_thing
    with IK2_Count 148
    with IK2_Link I357_doe
    with IK6_Count 26
    with IK6_Link I366_stop_sign
    with KD_Count 6
    with name 'scattered' 'leaves' 'supporters//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1710
    with initial BC_1711
    with p15_reading_material BC_1712
    with list_together BC_1713
    with plural BC_1714
    with article BC_1715
;

Object -> I357_doe ""
    class K12_animal
    with short_name BC_1716
    has proper
    with vector 0
    with cap_short_name BC_1717
    has mark_as_thing
    with IK2_Count 149
    with IK2_Link I358_fawn
    with IK8_Count 32
    with IK8_Link I358_fawn
    with IK12_Count 1
    with IK12_Link I358_fawn
    with KD_Count 12
    with name 'doe' 'animals//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1718
    with initial BC_1719
    with p15_reading_material BC_1720
    with list_together BC_1721
    with plural BC_1722
    with article BC_1723
;

Object -> I358_fawn ""
    class K12_animal
    with short_name BC_1724
    has proper
    with vector 0
    with cap_short_name BC_1725
    has mark_as_thing
    with IK2_Count 150
    with IK2_Link I359_archaic_writing_tablets
    with IK8_Count 33
    with IK8_Link I369_riley
    with IK12_Count 2
    with IK12_Link nothing
    with KD_Count 12
    with name 'fawn' 'animals//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1726
    with initial BC_1727
    with p15_reading_material BC_1728
    with list_together BC_1729
    with plural BC_1730
    with article BC_1731
;

Object I323_goddesses_chambers ""
    class K1_room
    with short_name BC_1732
    with description BC_1733
    with map_region I310_business_district
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_1734
    has mark_as_room
    with IK1_Count 56
    with IK1_Link I324_100_main_street
    with KD_Count 1
    with name 'goddesses' 'chambers' 'rooms//p' 
    with list_together BC_1735
    with plural BC_1736
    with article BC_1737
;

Object -> I359_archaic_writing_tablets ""
    class K2_thing
    with short_name BC_1738
    has pluralname
    with vector 0
    has mark_as_thing
    with IK2_Count 151
    with IK2_Link I360_essence_socket
    with KD_Count 2
    with name 'archaic' 'writing' 'tablets' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1739
    with initial BC_1740
    with p15_reading_material BC_1741
    with list_together BC_1742
    with plural BC_1743
    with article BC_1744
;

Object -> I360_essence_socket ""
    class K5_container
    with short_name BC_1745
    has proper
    has open
    with vector 0
    with cap_short_name BC_1746
    has mark_as_thing
    with IK2_Count 152
    with IK2_Link I366_stop_sign
    with IK5_Count 17
    with IK5_Link I364_stairs_to_your_office
    with KD_Count 5
    with name 'essence' 'socket' 'containers//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1747
    with initial BC_1748
    with p15_reading_material BC_1749
    with list_together BC_1750
    with plural BC_1751
    with article BC_1752
;

Object I324_100_main_street ""
    class K1_room
    with short_name BC_1753
    with description BC_1754
    with map_region I310_business_district
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_1755
    has mark_as_room
    with IK1_Count 57
    with IK1_Link I325_perlman_investments
    with KD_Count 1
    with name '100' 'main' 'street' 'rooms//p' 
    with list_together BC_1756
    with plural BC_1757
    with article BC_1758
;

Object -> I366_stop_sign ""
    class K6_supporter
    with short_name BC_1759
    has proper
    with vector 0
    with cap_short_name BC_1760
    has mark_as_thing
    with IK2_Count 157
    with IK2_Link I367_blowing_trash
    with IK6_Count 27
    with IK6_Link I375_roadblock
    with KD_Count 6
    with name 'stop' 'sign' 'supporters//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1761
    with initial BC_1762
    with p15_reading_material BC_1763
    with list_together BC_1764
    with plural BC_1765
    with article BC_1766
;

Object -> I367_blowing_trash ""
    class K2_thing
    with short_name BC_1767
    has pluralname
    with vector 0
    has mark_as_thing
    with IK2_Count 158
    with IK2_Link I368_smelly_sewer_gates
    with KD_Count 2
    with name 'blowing' 'trash' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1768
    with initial BC_1769
    with p15_reading_material BC_1770
    with list_together BC_1771
    with plural BC_1772
    with article BC_1773
;

Object -> I368_smelly_sewer_gates ""
    class K2_thing
    with short_name BC_1774
    has proper
    with vector 0
    with cap_short_name BC_1775
    has mark_as_thing
    with IK2_Count 159
    with IK2_Link I361_lobby_plants
    with KD_Count 2
    with name 'smelly' 'sewer' 'gates' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1776
    with initial BC_1777
    with p15_reading_material BC_1778
    with list_together BC_1779
    with plural BC_1780
    with article BC_1781
;

Object I325_perlman_investments ""
    class K1_room
    with short_name BC_1782
    with description BC_1783
    with map_region I310_business_district
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_1784
    has mark_as_room
    with IK1_Count 58
    with IK1_Link I326_sloppys_fast_food
    with KD_Count 1
    with name 'perlman' 'investments' 'rooms//p' 
    with list_together BC_1785
    with plural BC_1786
    with article BC_1787
;

Object -> I361_lobby_plants ""
    class K2_thing
    with short_name BC_1788
    has pluralname
    with vector 0
    has mark_as_thing
    with IK2_Count 153
    with IK2_Link I362_marble_columns
    with KD_Count 2
    with name 'lobby' 'plants' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1789
    with initial BC_1790
    with p15_reading_material BC_1791
    with list_together BC_1792
    with plural BC_1793
    with article BC_1794
;

Object -> I362_marble_columns ""
    class K2_thing
    with short_name BC_1795
    has proper
    with vector 0
    with cap_short_name BC_1796
    has mark_as_thing
    with IK2_Count 154
    with IK2_Link I363_waiting_room_pictures
    with KD_Count 2
    with name 'marble' 'columns' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1797
    with initial BC_1798
    with p15_reading_material BC_1799
    with list_together BC_1800
    with plural BC_1801
    with article BC_1802
;

Object -> I363_waiting_room_pictures ""
    class K2_thing
    with short_name BC_1803
    has proper
    with vector 0
    with cap_short_name BC_1804
    has mark_as_thing
    with IK2_Count 155
    with IK2_Link I364_stairs_to_your_office
    with KD_Count 2
    with name 'waiting' 'room' 'pictures' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1805
    with initial BC_1806
    with p15_reading_material BC_1807
    with list_together BC_1808
    with plural BC_1809
    with article BC_1810
;

Object -> I364_stairs_to_your_office ""
    class K5_container
    with short_name BC_1811
    has proper
    has enterable
    has open
    with vector 0
    with cap_short_name BC_1812
    has mark_as_thing
    with IK2_Count 156
    with IK2_Link I369_riley
    with IK5_Count 18
    with IK5_Link I372_smelly_trashcan
    with KD_Count 5
    with name 'stairs' 'to' 'my' 'office' 'containers//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1813
    with initial BC_1814
    with p15_reading_material BC_1815
    with list_together BC_1816
    with plural BC_1817
    with article BC_1818
;

Object I326_sloppys_fast_food ""
    class K1_room
    with short_name BC_1819
    with description BC_1820
    with map_region I310_business_district
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_1821
    has mark_as_room
    with IK1_Count 59
    with IK1_Link I327_grungy_alleyway
    with KD_Count 1
    with name 'sloppys' 'fast' 'food' 'rooms//p' 
    with list_together BC_1822
    with plural BC_1823
    with article BC_1824
;

Object -> I369_riley ""
    class K8_person
    with short_name BC_1825
    has proper
    with vector 0
    with cap_short_name BC_1826
    has mark_as_thing
    with IK2_Count 160
    with IK2_Link I370_amazing_meal
    with IK8_Count 34
    with IK8_Link I377_intimidating_soldier
    with KD_Count 8
    with name 'riley' 'people//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1827
    with initial BC_1828
    with p15_reading_material BC_1829
    with list_together BC_1830
    with plural BC_1831
    with article BC_1832
;

Object -> I370_amazing_meal ""
    class K2_thing
    with short_name BC_1833
    has proper
    with vector 0
    with cap_short_name BC_1834
    has mark_as_thing
    with IK2_Count 161
    with IK2_Link I372_smelly_trashcan
    with KD_Count 2
    with name 'amazing' 'meal' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1835
    with initial BC_1836
    with p15_reading_material BC_1837
    with list_together BC_1838
    with plural BC_1839
    with article BC_1840
;

Object I327_grungy_alleyway ""
    class K1_room
    with short_name BC_1841
    with description BC_1842
    with map_region I310_business_district
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_1843
    has mark_as_room
    with IK1_Count 60
    with IK1_Link I328_ross_avenue
    with KD_Count 1
    with name 'grungy' 'alleyway' 'rooms//p' 
    with list_together BC_1844
    with plural BC_1845
    with article BC_1846
;

Object -> I372_smelly_trashcan ""
    class K5_container
    with short_name BC_1847
    has proper
    with vector 0
    with cap_short_name BC_1848
    has mark_as_thing
    with IK2_Count 162
    with IK2_Link I373_old_clothes
    with IK5_Count 19
    with IK5_Link I376_two_cop_cars
    with KD_Count 5
    with name 'smelly' 'trashcan' 'containers//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1849
    with initial BC_1850
    with p15_reading_material BC_1851
    with list_together BC_1852
    with plural BC_1853
    with article BC_1854
;

Object -> -> I373_old_clothes ""
    class K2_thing
    with short_name BC_1855
    has proper
    with vector 0
    with cap_short_name BC_1856
    has mark_as_thing
    with IK2_Count 163
    with IK2_Link I374_stinking_trashpile
    with KD_Count 2
    with name 'old' 'clothes' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1857
    with initial BC_1858
    with p15_reading_material BC_1859
    with list_together BC_1860
    with plural BC_1861
    with article BC_1862
;

Object -> -> I374_stinking_trashpile ""
    class K2_thing
    with short_name BC_1863
    has proper
    with vector 0
    with cap_short_name BC_1864
    has mark_as_thing
    with IK2_Count 164
    with IK2_Link I375_roadblock
    with KD_Count 2
    with name 'stinking' 'trashpile' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1865
    with initial BC_1866
    with p15_reading_material BC_1867
    with list_together BC_1868
    with plural BC_1869
    with article BC_1870
;

Object I328_ross_avenue ""
    class K1_room
    with short_name BC_1871
    with description BC_1872
    with map_region I310_business_district
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_1873
    has mark_as_room
    with IK1_Count 61
    with IK1_Link I329_path_to_the_sewers
    with KD_Count 1
    with name 'ross' 'avenue' 'rooms//p' 
    with list_together BC_1874
    with plural BC_1875
    with article BC_1876
;

Object -> I375_roadblock ""
    class K6_supporter
    with short_name BC_1877
    has proper
    with vector 0
    with cap_short_name BC_1878
    has mark_as_thing
    with IK2_Count 165
    with IK2_Link I376_two_cop_cars
    with IK6_Count 28
    with IK6_Link I401_sculpted_trees
    with KD_Count 6
    with name 'roadblock' 'supporters//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1879
    with initial BC_1880
    with p15_reading_material BC_1881
    with list_together BC_1882
    with plural BC_1883
    with article BC_1884
;

Object -> I376_two_cop_cars ""
    class K14_vehicle
    with short_name BC_1885
    has proper
    with vector 0
    with cap_short_name BC_1886
    has mark_as_thing
    with IK2_Count 166
    with IK2_Link I377_intimidating_soldier
    with IK5_Count 20
    with IK5_Link I379_tunnels
    with IK14_Count 1
    with IK14_Link nothing
    with KD_Count 14
    with name 'two' 'cop' 'cars' 'vehicles//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1887
    with initial BC_1888
    with p15_reading_material BC_1889
    with list_together BC_1890
    with plural BC_1891
    with article BC_1892
;

Object -> I377_intimidating_soldier ""
    class K8_person
    with short_name BC_1893
    has proper
    with vector 0
    with cap_short_name BC_1894
    has mark_as_thing
    with IK2_Count 167
    with IK2_Link I378_several_cops
    with IK8_Count 35
    with IK8_Link I378_several_cops
    with KD_Count 8
    with name 'intimidating' 'soldier' 'people//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1895
    with initial BC_1896
    with p15_reading_material BC_1897
    with list_together BC_1898
    with plural BC_1899
    with article BC_1900
;

Object -> I378_several_cops ""
    class K8_person
    with short_name BC_1901
    has proper
    with vector 0
    with cap_short_name BC_1902
    has mark_as_thing
    with IK2_Count 168
    with IK2_Link I379_tunnels
    with IK8_Count 36
    with IK8_Link nothing
    with KD_Count 8
    with name 'several' 'cops' 'people//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1903
    with initial BC_1904
    with p15_reading_material BC_1905
    with list_together BC_1906
    with plural BC_1907
    with article BC_1908
;

Object I329_path_to_the_sewers ""
    class K1_room
    with short_name BC_1909
    with description BC_1910
    with map_region I310_business_district
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_1911
    has mark_as_room
    with IK1_Count 62
    with IK1_Link I384_party_avenue
    with KD_Count 1
    with name 'path' 'to' 'the' 'sewers' 'rooms//p' 
    with list_together BC_1912
    with plural BC_1913
    with article BC_1914
;

Object -> I379_tunnels ""
    class K5_container
    with short_name BC_1915
    has proper
    has enterable
    has open
    with vector 0
    with cap_short_name BC_1916
    has mark_as_thing
    with IK2_Count 169
    with IK2_Link I380_weird_smelling_lumps
    with IK5_Count 21
    with IK5_Link I397_supply_shop
    with KD_Count 5
    with name 'tunnels' 'containers//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1917
    with initial BC_1918
    with p15_reading_material BC_1919
    with list_together BC_1920
    with plural BC_1921
    with article BC_1922
;

Object -> I380_weird_smelling_lumps ""
    class K2_thing
    with short_name BC_1923
    has pluralname
    with vector 0
    has mark_as_thing
    with IK2_Count 170
    with IK2_Link I381_dripping_pipes
    with KD_Count 2
    with name 'weird' 'smelling' 'lumps' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1924
    with initial BC_1925
    with p15_reading_material BC_1926
    with list_together BC_1927
    with plural BC_1928
    with article BC_1929
;

Object -> I381_dripping_pipes ""
    class K2_thing
    with short_name BC_1930
    has proper
    with vector 0
    with cap_short_name BC_1931
    has mark_as_thing
    with IK2_Count 171
    with IK2_Link I382_disgusting_puddles
    with KD_Count 2
    with name 'dripping' 'pipes' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1932
    with initial BC_1933
    with p15_reading_material BC_1934
    with list_together BC_1935
    with plural BC_1936
    with article BC_1937
;

Object -> I382_disgusting_puddles ""
    class K2_thing
    with short_name BC_1938
    has proper
    with vector 0
    with cap_short_name BC_1939
    has mark_as_thing
    with IK2_Count 172
    with IK2_Link I337_large_hill
    with KD_Count 2
    with name 'disgusting' 'puddles' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1940
    with initial BC_1941
    with p15_reading_material BC_1942
    with list_together BC_1943
    with plural BC_1944
    with article BC_1945
;

Object I337_large_hill ""
    class K7_backdrop
    with short_name BC_1946
    has proper
    with vector 0
    with found_in I315_130_main_street 
    with cap_short_name BC_1947
    has mark_as_thing
    with IK2_Count 130
    with IK2_Link I394_chugging_college_girls
    with IK7_Count 0
    with IK7_Link nothing
    with KD_Count 7
    with name 'large' 'hill' 'backdrops//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1948
    with initial BC_1949
    with p15_reading_material BC_1950
    with list_together BC_1951
    with plural BC_1952
    with article BC_1953
;

Object I383_uptown_district ""
    class K9_region
    with short_name BC_1954
    has proper
    with vector 0
    with cap_short_name BC_1955
    with regional_found_in [ ;
        if (TestRegionalContainment(location, I383_uptown_district)) rtrue; rfalse;],
    with IK9_Count 4
    with IK9_Link nothing
    with KD_Count 9
    with name 'uptown' 'district' 'regions//p' 
    with action_bitmap 0 0 0 0 0 0 
    with list_together BC_1956
    with plural BC_1957
    with article BC_1958
;

Object I384_party_avenue ""
    class K1_room
    with short_name BC_1959
    with description BC_1960
    with map_region I383_uptown_district
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_1961
    has mark_as_room
    with IK1_Count 63
    with IK1_Link I385_illus_design_corp
    with KD_Count 1
    with name 'party' 'avenue' 'rooms//p' 
    with list_together BC_1962
    with plural BC_1963
    with article BC_1964
;

Object -> I394_chugging_college_girls ""
    class K2_thing
    with short_name BC_1965
    has pluralname
    with vector 0
    has mark_as_thing
    with IK2_Count 173
    with IK2_Link I395_dumb_frat_boys
    with KD_Count 2
    with name 'chugging' 'college' 'girls' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1966
    with initial BC_1967
    with p15_reading_material BC_1968
    with list_together BC_1969
    with plural BC_1970
    with article BC_1971
;

Object -> I395_dumb_frat_boys ""
    class K2_thing
    with short_name BC_1972
    has proper
    with vector 0
    with cap_short_name BC_1973
    has mark_as_thing
    with IK2_Count 174
    with IK2_Link I396_pile_of_beer_cans
    with KD_Count 2
    with name 'dumb' 'frat' 'boys' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1974
    with initial BC_1975
    with p15_reading_material BC_1976
    with list_together BC_1977
    with plural BC_1978
    with article BC_1979
;

Object -> I396_pile_of_beer_cans ""
    class K2_thing
    with short_name BC_1980
    has proper
    with vector 0
    with cap_short_name BC_1981
    has mark_as_thing
    with IK2_Count 175
    with IK2_Link I397_supply_shop
    with KD_Count 2
    with name 'pile' 'of' 'beer' 'cans' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1982
    with initial BC_1983
    with p15_reading_material BC_1984
    with list_together BC_1985
    with plural BC_1986
    with article BC_1987
;

Object I385_illus_design_corp ""
    class K1_room
    with short_name BC_1988
    with description BC_1989
    with map_region I383_uptown_district
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_1990
    has mark_as_room
    with IK1_Count 64
    with IK1_Link I386_walter_haven
    with KD_Count 1
    with name 'illus' 'design' 'corp' 'rooms//p' 
    with list_together BC_1991
    with plural BC_1992
    with article BC_1993
;

Object -> I397_supply_shop ""
    class K5_container
    with short_name BC_1994
    has proper
    has enterable
    with vector 0
    with cap_short_name BC_1995
    has mark_as_thing
    with IK2_Count 176
    with IK2_Link I398_possible_trip_wire
    with IK5_Count 22
    with IK5_Link nothing
    with KD_Count 5
    with name 'supply' 'shop' 'containers//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_1996
    with initial BC_1997
    with p15_reading_material BC_1998
    with list_together BC_1999
    with plural BC_2000
    with article BC_2001
;

Object -> -> I398_possible_trip_wire ""
    class K2_thing
    with short_name BC_2002
    has proper
    with vector 0
    with cap_short_name BC_2003
    has mark_as_thing
    with IK2_Count 177
    with IK2_Link I399_surrounding_bushes
    with KD_Count 2
    with name 'possible' 'trip' 'wire' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_2004
    with initial BC_2005
    with p15_reading_material BC_2006
    with list_together BC_2007
    with plural BC_2008
    with article BC_2009
;

Object -> I399_surrounding_bushes ""
    class K2_thing
    with short_name BC_2010
    has pluralname
    with vector 0
    has mark_as_thing
    with IK2_Count 178
    with IK2_Link I401_sculpted_trees
    with KD_Count 2
    with name 'surrounding' 'bushes' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_2011
    with initial BC_2012
    with p15_reading_material BC_2013
    with list_together BC_2014
    with plural BC_2015
    with article BC_2016
;

Object I386_walter_haven ""
    class K1_room
    with short_name BC_2017
    with description BC_2018
    with map_region I383_uptown_district
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_2019
    has mark_as_room
    with IK1_Count 65
    with IK1_Link I387_side_pass
    with KD_Count 1
    with name 'walter' 'haven' 'rooms//p' 
    with list_together BC_2020
    with plural BC_2021
    with article BC_2022
;

Object -> I401_sculpted_trees ""
    class K6_supporter
    with short_name BC_2023
    has proper
    with vector 0
    with cap_short_name BC_2024
    has mark_as_thing
    with IK2_Count 179
    with IK2_Link I402_spiraling_fountains
    with IK6_Count 29
    with IK6_Link I402_spiraling_fountains
    with KD_Count 6
    with name 'sculpted' 'trees' 'supporters//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_2025
    with initial BC_2026
    with p15_reading_material BC_2027
    with list_together BC_2028
    with plural BC_2029
    with article BC_2030
;

Object -> I402_spiraling_fountains ""
    class K6_supporter
    with short_name BC_2031
    has proper
    with vector 0
    with cap_short_name BC_2032
    has mark_as_thing
    with IK2_Count 180
    with IK2_Link I405_telephone_wires
    with IK6_Count 30
    with IK6_Link nothing
    with KD_Count 6
    with name 'spiraling' 'fountains' 'supporters//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_2033
    with initial BC_2034
    with p15_reading_material BC_2035
    with list_together BC_2036
    with plural BC_2037
    with article BC_2038
;

Object I387_side_pass ""
    class K1_room
    with short_name BC_2039
    with description BC_2040
    with map_region I383_uptown_district
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_2041
    has mark_as_room
    with IK1_Count 66
    with IK1_Link I388_country_club
    with KD_Count 1
    with name 'side' 'pass' 'rooms//p' 
    with list_together BC_2042
    with plural BC_2043
    with article BC_2044
;

Object -> I405_telephone_wires ""
    class K2_thing
    with short_name BC_2045
    has pluralname
    with vector 0
    has mark_as_thing
    with IK2_Count 182
    with IK2_Link I406_expensive_cars
    with KD_Count 2
    with name 'telephone' 'wires' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_2046
    with initial BC_2047
    with p15_reading_material BC_2048
    with list_together BC_2049
    with plural BC_2050
    with article BC_2051
;

Object I388_country_club ""
    class K1_room
    with short_name BC_2052
    with description BC_2053
    with map_region I383_uptown_district
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_2054
    has mark_as_room
    with IK1_Count 67
    with IK1_Link I389_upper_class_arts
    with KD_Count 1
    with name 'country' 'club' 'rooms//p' 
    with list_together BC_2055
    with plural BC_2056
    with article BC_2057
;

Object -> I406_expensive_cars ""
    class K2_thing
    with short_name BC_2058
    has pluralname
    with vector 0
    has mark_as_thing
    with IK2_Count 183
    with IK2_Link I407_rich_executives
    with KD_Count 2
    with name 'expensive' 'cars' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_2059
    with initial BC_2060
    with p15_reading_material BC_2061
    with list_together BC_2062
    with plural BC_2063
    with article BC_2064
;

Object -> I407_rich_executives ""
    class K2_thing
    with short_name BC_2065
    has proper
    with vector 0
    with cap_short_name BC_2066
    has mark_as_thing
    with IK2_Count 184
    with IK2_Link I408_spare_golf_clubs
    with KD_Count 2
    with name 'rich' 'executives' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_2067
    with initial BC_2068
    with p15_reading_material BC_2069
    with list_together BC_2070
    with plural BC_2071
    with article BC_2072
;

Object -> I408_spare_golf_clubs ""
    class K2_thing
    with short_name BC_2073
    has proper
    with vector 0
    with cap_short_name BC_2074
    has mark_as_thing
    with IK2_Count 185
    with IK2_Link I409_crappy_paintings
    with KD_Count 2
    with name 'spare' 'golf' 'clubs' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_2075
    with initial BC_2076
    with p15_reading_material BC_2077
    with list_together BC_2078
    with plural BC_2079
    with article BC_2080
;

Object I389_upper_class_arts ""
    class K1_room
    with short_name BC_2081
    with description BC_2082
    with map_region I383_uptown_district
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_2083
    has mark_as_room
    with IK1_Count 68
    with IK1_Link I390_the_long_john
    with KD_Count 1
    with name 'upper' 'class' 'arts' 'rooms//p' 
    with list_together BC_2084
    with plural BC_2085
    with article BC_2086
;

Object -> I409_crappy_paintings ""
    class K2_thing
    with short_name BC_2087
    has pluralname
    with vector 0
    has mark_as_thing
    with IK2_Count 186
    with IK2_Link I410_broken_wine_bottles
    with KD_Count 2
    with name 'crappy' 'paintings' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_2088
    with initial BC_2089
    with p15_reading_material BC_2090
    with list_together BC_2091
    with plural BC_2092
    with article BC_2093
;

Object -> I410_broken_wine_bottles ""
    class K2_thing
    with short_name BC_2094
    has proper
    with vector 0
    with cap_short_name BC_2095
    has mark_as_thing
    with IK2_Count 187
    with IK2_Link I411_waiters
    with KD_Count 2
    with name 'broken' 'wine' 'bottles' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_2096
    with initial BC_2097
    with p15_reading_material BC_2098
    with list_together BC_2099
    with plural BC_2100
    with article BC_2101
;

Object I390_the_long_john ""
    class K1_room
    with short_name BC_2102
    with description BC_2103
    with map_region I383_uptown_district
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_2104
    has mark_as_room
    with IK1_Count 69
    with IK1_Link I391_secluded_alley
    with KD_Count 1
    with name 'the' 'long' 'john' 'rooms//p' 
    with list_together BC_2105
    with plural BC_2106
    with article BC_2107
;

Object I391_secluded_alley ""
    class K1_room
    with short_name BC_2108
    with description BC_2109
    with map_region I383_uptown_district
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_2110
    has mark_as_room
    with IK1_Count 70
    with IK1_Link I392_season_365
    with KD_Count 1
    with name 'secluded' 'alley' 'rooms//p' 
    with list_together BC_2111
    with plural BC_2112
    with article BC_2113
;

Object I392_season_365 ""
    class K1_room
    with short_name BC_2114
    with description BC_2115
    with map_region I383_uptown_district
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_2116
    has mark_as_room
    with IK1_Count 71
    with IK1_Link I393_palomino_bar_n_grill
    with KD_Count 1
    with name 'season' '365' 'rooms//p' 
    with list_together BC_2117
    with plural BC_2118
    with article BC_2119
;

Object -> I411_waiters ""
    class K2_thing
    with short_name BC_2120
    has pluralname
    with vector 0
    has mark_as_thing
    with IK2_Count 188
    with IK2_Link I412_waitresses
    with KD_Count 2
    with name 'waiters' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_2121
    with initial BC_2122
    with p15_reading_material BC_2123
    with list_together BC_2124
    with plural BC_2125
    with article BC_2126
;

Object -> I412_waitresses ""
    class K2_thing
    with short_name BC_2127
    has proper
    with vector 0
    with cap_short_name BC_2128
    has mark_as_thing
    with IK2_Count 189
    with IK2_Link I413_well_kept_tables
    with KD_Count 2
    with name 'waitresses' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_2129
    with initial BC_2130
    with p15_reading_material BC_2131
    with list_together BC_2132
    with plural BC_2133
    with article BC_2134
;

Object -> I413_well_kept_tables ""
    class K2_thing
    with short_name BC_2135
    has proper
    with vector 0
    with cap_short_name BC_2136
    has mark_as_thing
    with IK2_Count 190
    with IK2_Link I414_white_tablecloth
    with KD_Count 2
    with name 'well-kept' 'tables' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_2137
    with initial BC_2138
    with p15_reading_material BC_2139
    with list_together BC_2140
    with plural BC_2141
    with article BC_2142
;

Object -> I414_white_tablecloth ""
    class K2_thing
    with short_name BC_2143
    has proper
    with vector 0
    with cap_short_name BC_2144
    has mark_as_thing
    with IK2_Count 191
    with IK2_Link I415_cigarette_butts
    with KD_Count 2
    with name 'white' 'tablecloth' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_2145
    with initial BC_2146
    with p15_reading_material BC_2147
    with list_together BC_2148
    with plural BC_2149
    with article BC_2150
;

Object I393_palomino_bar_n_grill ""
    class K1_room
    with short_name BC_2151
    with description BC_2152
    with map_region I383_uptown_district
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_2153
    has mark_as_room
    with IK1_Count 72
    with IK1_Link I403_striped_coven
    with KD_Count 1
    with name 'palomino' 'bar' 'n//' 'grill' 'rooms//p' 
    with list_together BC_2154
    with plural BC_2155
    with article BC_2156
;

Object -> I415_cigarette_butts ""
    class K2_thing
    with short_name BC_2157
    has pluralname
    with vector 0
    has mark_as_thing
    with IK2_Count 192
    with IK2_Link I416_half_drunk_beers
    with KD_Count 2
    with name 'cigarette' 'butts' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_2158
    with initial BC_2159
    with p15_reading_material BC_2160
    with list_together BC_2161
    with plural BC_2162
    with article BC_2163
;

Object -> I416_half_drunk_beers ""
    class K2_thing
    with short_name BC_2164
    has proper
    with vector 0
    with cap_short_name BC_2165
    has mark_as_thing
    with IK2_Count 193
    with IK2_Link I417_courtney
    with KD_Count 2
    with name 'half' 'drunk' 'beers' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_2166
    with initial BC_2167
    with p15_reading_material BC_2168
    with list_together BC_2169
    with plural BC_2170
    with article BC_2171
;

Object -> I417_courtney ""
    class K2_thing
    with short_name BC_2172
    with initial BC_2173
    has proper
    has female
    with vector 0
    with cap_short_name BC_2174
    has mark_as_thing
    with IK2_Count 194
    with IK2_Link I404_mysterious_door
    with KD_Count 2
    with name 'courtney' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_2175
    with p15_reading_material BC_2176
    with list_together BC_2177
    with plural BC_2178
    with article BC_2179
;

Object I403_striped_coven ""
    class K1_room
    with short_name BC_2180
    with description BC_2181
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_2182
    has mark_as_room
    with IK1_Count 73
    with IK1_Link nothing
    with KD_Count 1
    with name 'striped' 'coven' 'rooms//p' 
    with list_together BC_2183
    with plural BC_2184
    with article BC_2185
;

Object I404_mysterious_door ""
    class K4_door
    with short_name BC_2186
    with description BC_2187
    has proper
    has lockable
    has locked
    with vector 0
    with door_dir [ 
        loc ! room of actor
        ;
        loc = location;
        if (loc == thedark) loc = real_location;
        if (loc == I403_striped_coven) return I57_west; return I56_east;],
    with door_to [ 
        loc ! room of actor
        ;
        loc = location;
        if (loc == thedark) loc = real_location;
        if (loc == I403_striped_coven) return I386_walter_haven; return I403_striped_coven;],
    with found_in I403_striped_coven I386_walter_haven
    with cap_short_name BC_2188
    has mark_as_thing
    with IK2_Count 181
    with IK2_Link nothing
    with IK4_Count 1
    with IK4_Link nothing
    with KD_Count 4
    with name 'mysterious' 'door' 'doors//p' 
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_2189
    with p15_reading_material BC_2190
    with list_together BC_2191
    with plural BC_2192
    with article BC_2193
;

Constant I70_english_language = 1;
Constant I71_french_language = 2;
Constant I72_german_language = 3;
Constant I73_italian_language = 4;
Constant I74_spanish_language = 5;
Constant I75_swedish_language = 6;
Constant I76_figure_of_cover = 1;
Constant I77_entire_game = 1;
Constant I79_didn_t_understand_error = 1;
Constant I80_only_understood_as_far_a = 2;
Constant I81_didn_t_understand_that_n = 3;
Constant I82_can_only_do_that_to_some = 4;
Constant I83_can_t_see_any_such_thing = 5;
Constant I84_said_too_little_error = 6;
Constant I85_aren_t_holding_that_erro = 7;
Constant I86_can_t_use_multiple_objec = 8;
Constant I87_can_only_use_multiple_ob = 9;
Constant I88_not_sure_what_it_refers_ = 10;
Constant I89_excepted_something_not_i = 11;
Constant I90_not_a_verb_i_recognise_e = 12;
Constant I91_not_something_you_need_t = 13;
Constant I92_can_t_see_it_at_the_mome = 14;
Constant I93_didn_t_understand_the_wa = 15;
Constant I94_not_enough_of_those_avai = 16;
Constant I95_nothing_to_do_error = 17;
Constant I96_noun_did_not_make_sense_ = 18;
Constant I97_referred_to_a_determinat = 19;
Constant I98_i_beg_your_pardon_error = 20;
Constant I99_can_t_again_the_addresse = 21;
Constant I100_comma_can_t_begin_error = 22;
Constant I101_can_t_see_whom_to_talk_ = 23;
Constant I102_can_t_talk_to_inanimate = 24;
Constant I103_didn_t_understand_addre = 25;
Constant I105_present_tense = 1;
Constant I106_past_tense = 2;
Constant I107_perfect_tense = 3;
Constant I108_past_perfect_tense = 4;
Constant I109_future_tense = 5;
Constant I111_first_person_singular = 1;
Constant I112_second_person_singular = 2;
Constant I113_third_person_singular = 3;
Constant I114_first_person_plural = 4;
Constant I115_second_person_plural = 5;
Constant I116_third_person_plural = 6;
Constant I118_nominative = 1;
Constant I119_accusative = 2;
Constant I121_neuter_gender = 1;
Constant I122_masculine_gender = 2;
Constant I123_feminine_gender = 3;
Constant I128_masculine = 1;
Constant I129_feminine = 2;
Constant I130_unknown = 3;
Constant I156_chooseyourdestiny = 2;
Constant I179_gazelletransformation = 3;
Constant I219_gagglebecomesherd = 4;
Constant I229_newscast = 5;
Constant I290_joining_the_zoo = 6;
Constant I341_genieinabottle = 7;
Constant I365_exploring_your_office = 8;
Constant I371_jerked = 9;
Constant I400_supplyshopevent = 10;
Constant I418_here_girl = 11;
Constant I419_sizeincrease = 12;
Constant I420_dontcroak = 13;
Constant I421_maretf = 14;
Constant I422_swineoption = 15;
Array Global_Vars -->
  (false) ! 7 darkness witnessed
  (BC_2194) ! 25 command prompt
  (I70_english_language) ! 29 language of play
  (BC_2195) ! 32 story author
  (BC_2196) ! 33 story headline
  (BC_2197) ! 34 story genre
  (BC_2198) ! 35 story description
  (1) ! 36 release number
  (0) ! 37 story creation year
  (0) ! 45 locale paragraph count
  (0) ! 60 amount
  (0) ! 61 num
  (BC_2199) ! 62 exitsmessage
  (BC_2200) ! 63 exitsandtext
  (BC_2201) ! 64 exitstotext
  (selfobj) ! 67 prior named noun
  (0) ! 68 menu depth
  (0) ! 69 endnode flag
  (BC_2202) ! 70 current menu title
  (T2_sample_options) ! 71 current menu
  (1) ! 72 current menu selection
  (T8_ordinary_status) ! 73 status bar table
  (14) ! 74 right alignment depth
  (BC_2203) ! 75 percentage_suffix
  (2) ! 76 percentage_precision
;



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Tables
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====



Array T0_final_question_options table  tab_0_0 tab_0_1 tab_0_2 tab_0_3 tab_0_4;
Array tab_0_0 table $0664 0 (BC_2204) (BC_2205) (BC_2206) (BC_2207) (BC_2208) ;
Array tab_0_1 table $0465 1 (0) (0) (1) (0) (0) ;
Array tab_0_2 table $2066 2 (Consult_Grammar_99) (Consult_Grammar_100) (Consult_Grammar_101) (Consult_Grammar_102) (Consult_Grammar_103) ;
Array tab_0_3 table $0067 3 (IMMEDIATELY_RESTART_VM_R) (IMMEDIATELY_RESTORE_SAVED_R) ( TABLE_NOVALUE) (IMMEDIATELY_QUIT_R) (IMMEDIATELY_UNDO_R) ;
Array tab_0_4 table $0068 4 ( TABLE_NOVALUE) ( TABLE_NOVALUE) (V27_amusing_a_victorious_pla) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ;
Array T1_locale_priorities table  tab_1_0 tab_1_1;
Array tab_1_0 table $0869 NULL ( TABLE_NOVALUE)  TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE;
Array tab_1_1 table $446a 5 ( TABLE_NOVALUE)  TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE;
Array T2_sample_options table  tab_2_0 tab_2_1 tab_2_2 tab_2_3;
Array tab_2_0 table $066b 30 (BC_2209) ;
Array tab_2_1 table $006c 31 ( TABLE_NOVALUE) ;
Array tab_2_2 table $066d 32 (BC_2210) ;
Array tab_2_3 table $006e 33 ( TABLE_NOVALUE) ;
Array T3_menu_commands table  tab_3_0 tab_3_1;
Array tab_3_0 table $446f 34 (78) (110) (80) (112) (81) (113) (13) (32) (130) (129) (27) (-8) (-6) (-5) (-4) ;
Array tab_3_1 table $0070 36 (R_893) (R_893) (R_894) (R_894) (R_892) (R_892) (R_895) (R_895) (R_893) (R_894) (R_892) (R_892) (R_895) (R_893) (R_894) ;
Array T4_shallow_menu_status table  tab_4_0 tab_4_1 tab_4_2;
Array tab_4_0 table $0671 38 (BC_2211) ;
Array tab_4_1 table $0672 39 (BC_2212) ;
Array tab_4_2 table $0673 40 (BC_2213) ;
Array T5_deep_menu_status table  tab_5_0 tab_5_1 tab_5_2;
Array tab_5_0 table $0671 41 (BC_2214) (BC_2215) (BC_2216) (BC_2217) ;
Array tab_5_1 table $0672 42 (BC_2218) (BC_2219) (BC_2220) (BC_2221) ;
Array tab_5_2 table $0673 43 (BC_2222) (BC_2223) (BC_2224) (BC_2225) ;
Array T6_sample_hints table  tab_6_0 tab_6_1;
Array tab_6_0 table $0674 44 (BC_2226) ;
Array tab_6_1 table $4475 45 ( TABLE_NOVALUE) ;
Array T8_ordinary_status table  tab_8_0 tab_8_1 tab_8_2;
Array tab_8_0 table $0671 46 (BC_2227) ;
Array tab_8_1 table $0672 47 (BC_2228) ;
Array tab_8_2 table $0673 48 (BC_2229) ;
Array T9_example_equal_rankings --> 1 tab_9_0;
Array tab_9_0 table $0676 49 (BC_2230) (BC_2231) (BC_2232) (BC_2233) (BC_2234) ;
Array T10_example_ranged_rankings table  tab_10_0 tab_10_1;
Array tab_10_0 table $4477 50 (10) (25) (75) (100) ;
Array tab_10_1 table $0676 51 (BC_2235) (BC_2236) (BC_2237) (BC_2238) ;
Array TB_Blanks -> 
  ! For table T0_final_question_options
  $00  ! Column 0
  $00  ! Column 1
  $00  ! Column 2
  $04  ! Column 3
  $1b  ! Column 4
  
  ! For table T1_locale_priorities
  $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $0f  ! Column 1
  
  ! For table T2_sample_options
  $00  ! Column 0
  $01  ! Column 1
  $00  ! Column 2
  $01  ! Column 3
  
  ! For table T3_menu_commands
  $00 $00  ! Column 0
  $00 $00  ! Column 1
  
  ! For table T4_shallow_menu_status
  $00  ! Column 0
  $00  ! Column 1
  $00  ! Column 2
  
  ! For table T5_deep_menu_status
  $00  ! Column 0
  $00  ! Column 1
  $00  ! Column 2
  
  ! For table T6_sample_hints
  $00  ! Column 0
  $01  ! Column 1
  
  ! For table T8_ordinary_status
  $00  ! Column 0
  $00  ! Column 1
  $00  ! Column 2
  
  ! For table T9_example_equal_rankings
  $00  ! Column 0
  
  ! For table T10_example_ranged_rankings
  $00  ! Column 0
  $00  ! Column 1
  
  ! End of table
  NULL NULL;
Array TableOfTables --> TheEmptyTable T0_final_question_options  T1_locale_priorities  T2_sample_options  T3_menu_commands  T4_shallow_menu_status  T5_deep_menu_status  T6_sample_hints  T8_ordinary_status  T9_example_equal_rankings  T10_example_ranged_rankings  0 0;
[ TC_KOV 
    tc ! Implied call parameter
    ;
    switch (tc) {
        100: return TEXT_TY; ! final question wording: text
        101: return TRUTH_STATE_TY; ! only if victorious: truth state
        102: return UNDERSTANDING_TY; ! topic: topic
        103: return KD0_rule; ! final response rule: rule
        104: return KD1_activity; ! final response activity: activity
        105: return OBJECT_TY; ! notable-object: object
        106: return NUMBER_TY; ! locale description priority: number
        107: return TEXT_TY; ! title: text
        108: return TABLE_TY; ! subtable: table name
        109: return TEXT_TY; ! description: text
        110: return KD0_rule; ! toggle: rule
        111: return NUMBER_TY; ! number: number
        112: return KD0_rule; ! effect: rule
        113: return TEXT_TY; ! left: text
        114: return TEXT_TY; ! central: text
        115: return TEXT_TY; ! right: text
        116: return TEXT_TY; ! hint: text
        117: return NUMBER_TY; ! used: number
        118: return TEXT_TY; ! rank: text
        119: return NUMBER_TY; ! maxpercent: number
    }
    return UNKNOWN_TY;
];



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Equations
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====





! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Actions
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====




Array ActionData table
  ##Inv  $$00000000  OBJECT_TY OBJECT_TY  0 20000
  ##Take  $$00001001  OBJECT_TY OBJECT_TY  0 20001
  ##Remove  $$00011011  OBJECT_TY OBJECT_TY  0 20002
  ##Drop  $$00001001  OBJECT_TY OBJECT_TY  0 20003
  ##PutOn  $$00011011  OBJECT_TY OBJECT_TY  0 20004
  ##Insert  $$00011011  OBJECT_TY OBJECT_TY  0 20005
  ##Eat  $$00001001  OBJECT_TY OBJECT_TY  0 20006
  ##Go  $$00001000  OBJECT_TY OBJECT_TY  ANSTVC_7 20007
  ##Enter  $$00001001  OBJECT_TY OBJECT_TY  0 20008
  ##Exit  $$00000000  OBJECT_TY OBJECT_TY  ANSTVC_9 20009
  ##GetOff  $$00001001  OBJECT_TY OBJECT_TY  0 20010
  ##Look  $$00000000  OBJECT_TY OBJECT_TY  ANSTVC_11 20011
  ##Examine  $$00001100  OBJECT_TY OBJECT_TY  ANSTVC_12 20012
  ##LookUnder  $$00001100  OBJECT_TY OBJECT_TY  0 20013
  ##Search  $$00001101  OBJECT_TY OBJECT_TY  0 20014
  ##Consult  $$00011001  OBJECT_TY UNDERSTANDING_TY  0 20015
  ##Lock  $$10011011  OBJECT_TY OBJECT_TY  0 20016
  ##Unlock  $$10011011  OBJECT_TY OBJECT_TY  0 20017
  ##SwitchOn  $$00001001  OBJECT_TY OBJECT_TY  0 20018
  ##SwitchOff  $$00001001  OBJECT_TY OBJECT_TY  0 20019
  ##Open  $$00001001  OBJECT_TY OBJECT_TY  0 20020
  ##Close  $$00001001  OBJECT_TY OBJECT_TY  0 20021
  ##Wear  $$01001001  OBJECT_TY OBJECT_TY  0 20022
  ##Disrobe  $$00001001  OBJECT_TY OBJECT_TY  0 20023
  ##Give  $$01011011  OBJECT_TY OBJECT_TY  0 20024
  ##Show  $$01011001  OBJECT_TY OBJECT_TY  0 20025
  ##WakeOther  $$00001001  OBJECT_TY OBJECT_TY  0 20026
  ##ThrowAt  $$01011001  OBJECT_TY OBJECT_TY  0 20027
  ##Attack  $$00001001  OBJECT_TY OBJECT_TY  0 20028
  ##Kiss  $$00001001  OBJECT_TY OBJECT_TY  0 20029
  ##Answer  $$00011001  OBJECT_TY UNDERSTANDING_TY  0 20030
  ##Tell  $$00011001  OBJECT_TY UNDERSTANDING_TY  0 20031
  ##Ask  $$00011001  OBJECT_TY UNDERSTANDING_TY  0 20032
  ##AskFor  $$00011011  OBJECT_TY OBJECT_TY  0 20033
  ##Wait  $$00000000  OBJECT_TY OBJECT_TY  0 20034
  ##Touch  $$00001001  OBJECT_TY OBJECT_TY  0 20035
  ##Wave  $$00001001  OBJECT_TY OBJECT_TY  0 20036
  ##Pull  $$00001001  OBJECT_TY OBJECT_TY  0 20037
  ##Push  $$00001001  OBJECT_TY OBJECT_TY  0 20038
  ##Turn  $$00001001  OBJECT_TY OBJECT_TY  0 20039
  ##PushDir  $$00011001  OBJECT_TY OBJECT_TY  0 20040
  ##Squeeze  $$00001001  OBJECT_TY OBJECT_TY  0 20041
  ##Yes  $$00000000  OBJECT_TY OBJECT_TY  0 20042
  ##No  $$00000000  OBJECT_TY OBJECT_TY  0 20043
  ##Burn  $$00001001  OBJECT_TY OBJECT_TY  0 20044
  ##Wake  $$00000000  OBJECT_TY OBJECT_TY  0 20045
  ##Think  $$00000000  OBJECT_TY OBJECT_TY  0 20046
  ##Smell  $$00001001  OBJECT_TY OBJECT_TY  0 20047
  ##Listen  $$00001001  OBJECT_TY OBJECT_TY  0 20048
  ##Taste  $$00001001  OBJECT_TY OBJECT_TY  0 20049
  ##Cut  $$00001001  OBJECT_TY OBJECT_TY  0 20050
  ##Jump  $$00000000  OBJECT_TY OBJECT_TY  0 20051
  ##Tie  $$00011011  OBJECT_TY OBJECT_TY  0 20052
  ##Drink  $$00001001  OBJECT_TY OBJECT_TY  0 20053
  ##Sorry  $$00000000  OBJECT_TY OBJECT_TY  0 20054
  ##Swing  $$00001001  OBJECT_TY OBJECT_TY  0 20055
  ##Rub  $$00001001  OBJECT_TY OBJECT_TY  0 20056
  ##SetTo  $$00011001  OBJECT_TY UNDERSTANDING_TY  0 20057
  ##WaveHands  $$00000000  OBJECT_TY OBJECT_TY  0 20058
  ##Buy  $$00001001  OBJECT_TY OBJECT_TY  0 20059
  ##Climb  $$00001001  OBJECT_TY OBJECT_TY  0 20060
  ##Sleep  $$00000000  OBJECT_TY OBJECT_TY  0 20061
  ##Quit  $$00100000  OBJECT_TY OBJECT_TY  0 20062
  ##Save  $$00100000  OBJECT_TY OBJECT_TY  0 20063
  ##Restore  $$00100000  OBJECT_TY OBJECT_TY  0 20064
  ##Restart  $$00100000  OBJECT_TY OBJECT_TY  0 20065
  ##Verify  $$00100000  OBJECT_TY OBJECT_TY  0 20066
  ##ScriptOn  $$00100000  OBJECT_TY OBJECT_TY  0 20067
  ##ScriptOff  $$00100000  OBJECT_TY OBJECT_TY  0 20068
  ##Version  $$00100000  OBJECT_TY OBJECT_TY  0 20069
  ##Score  $$00100000  OBJECT_TY OBJECT_TY  0 20070
  ##LMode3  $$00100000  OBJECT_TY OBJECT_TY  0 20071
  ##LMode2  $$00100000  OBJECT_TY OBJECT_TY  0 20072
  ##LMode1  $$00100000  OBJECT_TY OBJECT_TY  0 20073
  ##NotifyOn  $$00100000  OBJECT_TY OBJECT_TY  0 20074
  ##NotifyOff  $$00100000  OBJECT_TY OBJECT_TY  0 20075
  ##Pronouns  $$00100000  OBJECT_TY OBJECT_TY  0 20076
  ##A77_unlocking_keylessly  $$00001001  OBJECT_TY OBJECT_TY  ANSTVC_77 20077
  ##A78_locking_keylessly  $$00001001  OBJECT_TY OBJECT_TY  ANSTVC_78 20078
  ##A79_reading  $$00001101  OBJECT_TY OBJECT_TY  0 20079
;
Constant AD_RECORDS = 80;
[ ANSTVC_7 
    pos ! Implied call parameter
    state ! Implied call parameter
    ;
    if (state == 1) {
        MStack-->pos = I126_create_your_character; pos++;
        MStack-->pos = nothing; pos++;
        MStack-->pos = nothing; pos++;
        MStack-->pos = nothing; pos++;
        MStack-->pos = nothing; pos++;
    } else {
        pos++;
        pos++;
        pos++;
        pos++;
        pos++;
    }
    return 5;
];
[ ANSTVC_9 
    pos ! Implied call parameter
    state ! Implied call parameter
    ;
    if (state == 1) {
        MStack-->pos = nothing; pos++;
    } else {
        pos++;
    }
    return 1;
];
[ ANSTVC_11 
    pos ! Implied call parameter
    state ! Implied call parameter
    ;
    if (state == 1) {
        MStack-->pos = ##Wait; pos++;
        MStack-->pos = false; pos++;
        MStack-->pos = 0; pos++;
        MStack-->pos = nothing; pos++;
    } else {
        pos++;
        pos++;
        pos++;
        pos++;
    }
    return 4;
];
[ ANSTVC_12 
    pos ! Implied call parameter
    state ! Implied call parameter
    ;
    if (state == 1) {
        MStack-->pos = false; pos++;
    } else {
        pos++;
    }
    return 1;
];
[ ANSTVC_77 
    pos ! Implied call parameter
    state ! Implied call parameter
    ;
    if (state == 1) {
        MStack-->pos = nothing; pos++;
    } else {
        pos++;
    }
    return 1;
];
[ ANSTVC_78 
    pos ! Implied call parameter
    state ! Implied call parameter
    ;
    if (state == 1) {
        MStack-->pos = nothing; pos++;
    } else {
        pos++;
    }
    return 1;
];
[ DB_Action_Details 
    act ! Implied call parameter
    n ! Implied call parameter
    s ! Implied call parameter
    for_say ! Implied call parameter
    ;
    switch (act) {
        ##Inv: print "taking inventory"; 
        ##Take: print "taking"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Remove: print "removing"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "from"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##Drop: print "dropping"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##PutOn: print "putting"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "on"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##Insert: print "inserting"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "into"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##Eat: print "eating"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Go: print "going"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Enter: print "entering"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Exit: print "exiting"; 
        ##GetOff: print "getting off"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Look: print "looking"; 
        ##Examine: print "examining"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##LookUnder: print "looking under"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Search: print "searching"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Consult: print "consulting"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "about"; if (for_say ~= 2) { print " "; DA_Topic(parsed_number); }
        ##Lock: print "locking"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "with"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##Unlock: print "unlocking"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "with"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##SwitchOn: print "switching on"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##SwitchOff: print "switching off"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Open: print "opening"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Close: print "closing"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Wear: print "wearing"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Disrobe: print "taking off"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Give: print "giving"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "to"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##Show: print "showing"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "to"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##WakeOther: print "waking"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##ThrowAt: print "throwing"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "at"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##Attack: print "attacking"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Kiss: print "kissing"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Answer: print "answering"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "that"; if (for_say ~= 2) { print " "; DA_Topic(parsed_number); }
        ##Tell: print "telling"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "about"; if (for_say ~= 2) { print " "; DA_Topic(parsed_number); }
        ##Ask: print "asking"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "about"; if (for_say ~= 2) { print " "; DA_Topic(parsed_number); }
        ##AskFor: print "asking"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "for"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##Wait: print "waiting"; 
        ##Touch: print "touching"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Wave: print "waving"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Pull: print "pulling"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Push: print "pushing"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Turn: print "turning"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##PushDir: print "pushing"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "to"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##Squeeze: print "squeezing"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Yes: print "saying yes"; 
        ##No: print "saying no"; 
        ##Burn: print "burning"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Wake: print "waking up"; 
        ##Think: print "thinking"; 
        ##Smell: print "smelling"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Listen: print "listening to"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Taste: print "tasting"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Cut: print "cutting"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Jump: print "jumping"; 
        ##Tie: print "tying"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "to"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##Drink: print "drinking"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Sorry: print "saying sorry"; 
        ##Swing: print "swinging"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Rub: print "rubbing"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##SetTo: print "setting"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "to"; if (for_say ~= 2) { print " "; DA_Topic(parsed_number); }
        ##WaveHands: print "waving hands"; 
        ##Buy: print "buying"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Climb: print "climbing"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Sleep: print "sleeping"; 
        ##Quit: print "quitting the game"; 
        ##Save: print "saving the game"; 
        ##Restore: print "restoring the game"; 
        ##Restart: print "restarting the game"; 
        ##Verify: print "verifying the story file"; 
        ##ScriptOn: print "switching the story transcript on"; 
        ##ScriptOff: print "switching the story transcript off"; 
        ##Version: print "requesting the story file version"; 
        ##Score: print "requesting the score"; 
        ##LMode3: print "preferring abbreviated room descriptions"; 
        ##LMode2: print "preferring unabbreviated room descriptions"; 
        ##LMode1: print "preferring sometimes abbreviated room descriptions"; 
        ##NotifyOn: print "switching score notification on"; 
        ##NotifyOff: print "switching score notification off"; 
        ##Pronouns: print "requesting the pronoun meanings"; 
        ##A77_unlocking_keylessly: print "unlocking keylessly"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A78_locking_keylessly: print "locking keylessly"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A79_reading: print "reading"; if (for_say ~= 2) { print " "; DA_Name(n); }
    }
];

Array ActionCoding -->
    ##Inv ##Take ##Remove ##Drop ##PutOn ##Insert ##Eat ##Go
    ##Enter ##Exit ##GetOff ##Look ##Examine ##LookUnder ##Search ##Consult
    ##Lock ##Unlock ##SwitchOn ##SwitchOff ##Open ##Close ##Wear ##Disrobe
    ##Give ##Show ##WakeOther ##ThrowAt ##Attack ##Kiss ##Answer ##Tell
    ##Ask ##AskFor ##Wait ##Touch ##Wave ##Pull ##Push ##Turn
    ##PushDir ##Squeeze ##Yes ##No ##Burn ##Wake ##Think ##Smell
    ##Listen ##Taste ##Cut ##Jump ##Tie ##Drink ##Sorry ##Swing
    ##Rub ##SetTo ##WaveHands ##Buy ##Climb ##Sleep ##Quit ##Save
    ##Restore ##Restart ##Verify ##ScriptOn ##ScriptOff ##Version ##Score ##LMode3
    ##LMode2 ##LMode1 ##NotifyOn ##NotifyOff ##Pronouns ##A77_unlocking_keylessly ##A78_locking_keylessly ##A79_reading;


Array ActionHappened --> 0 0 0 0 0 0;


[ InvSub ;
    return GenericVerbSub(130,131,132);
];
[ TakeSub ;
    return GenericVerbSub(133,134,135);
];
[ RemoveSub ;
    return GenericVerbSub(136,137,138);
];
[ DropSub ;
    return GenericVerbSub(139,140,141);
];
[ PutOnSub ;
    return GenericVerbSub(142,143,144);
];
[ InsertSub ;
    return GenericVerbSub(145,146,147);
];
[ EatSub ;
    return GenericVerbSub(148,149,150);
];
[ GoSub ;
    return GenericVerbSub(151,152,153);
];
[ EnterSub ;
    return GenericVerbSub(154,155,156);
];
[ ExitSub ;
    return GenericVerbSub(157,158,159);
];
[ GetOffSub ;
    return GenericVerbSub(160,161,162);
];
[ LookSub ;
    return GenericVerbSub(163,164,165);
];
[ ExamineSub ;
    return GenericVerbSub(166,167,168);
];
[ LookUnderSub ;
    return GenericVerbSub(169,170,171);
];
[ SearchSub ;
    return GenericVerbSub(172,173,174);
];
[ ConsultSub ;
    return GenericVerbSub(175,176,177);
];
[ LockSub ;
    return GenericVerbSub(178,179,180);
];
[ UnlockSub ;
    return GenericVerbSub(181,182,183);
];
[ SwitchOnSub ;
    return GenericVerbSub(184,185,186);
];
[ SwitchOffSub ;
    return GenericVerbSub(187,188,189);
];
[ OpenSub ;
    return GenericVerbSub(190,191,192);
];
[ CloseSub ;
    return GenericVerbSub(193,194,195);
];
[ WearSub ;
    return GenericVerbSub(196,197,198);
];
[ DisrobeSub ;
    return GenericVerbSub(199,200,201);
];
[ GiveSub ;
    return GenericVerbSub(202,203,204);
];
[ ShowSub ;
    return GenericVerbSub(205,206,207);
];
[ WakeOtherSub ;
    return GenericVerbSub(208,209,210);
];
[ ThrowAtSub ;
    return GenericVerbSub(211,212,213);
];
[ AttackSub ;
    return GenericVerbSub(214,215,216);
];
[ KissSub ;
    return GenericVerbSub(217,218,219);
];
[ AnswerSub ;
    return GenericVerbSub(220,221,222);
];
[ TellSub ;
    return GenericVerbSub(223,224,225);
];
[ AskSub ;
    return GenericVerbSub(226,227,228);
];
[ AskForSub ;
    return GenericVerbSub(229,230,231);
];
[ WaitSub ;
    return GenericVerbSub(232,233,234);
];
[ TouchSub ;
    return GenericVerbSub(235,236,237);
];
[ WaveSub ;
    return GenericVerbSub(238,239,240);
];
[ PullSub ;
    return GenericVerbSub(241,242,243);
];
[ PushSub ;
    return GenericVerbSub(244,245,246);
];
[ TurnSub ;
    return GenericVerbSub(247,248,249);
];
[ PushDirSub ;
    return GenericVerbSub(250,251,252);
];
[ SqueezeSub ;
    return GenericVerbSub(253,254,255);
];
[ YesSub ;
    return GenericVerbSub(256,257,258);
];
[ NoSub ;
    return GenericVerbSub(259,260,261);
];
[ BurnSub ;
    return GenericVerbSub(262,263,264);
];
[ WakeSub ;
    return GenericVerbSub(265,266,267);
];
[ ThinkSub ;
    return GenericVerbSub(268,269,270);
];
[ SmellSub ;
    return GenericVerbSub(271,272,273);
];
[ ListenSub ;
    return GenericVerbSub(274,275,276);
];
[ TasteSub ;
    return GenericVerbSub(277,278,279);
];
[ CutSub ;
    return GenericVerbSub(280,281,282);
];
[ JumpSub ;
    return GenericVerbSub(283,284,285);
];
[ TieSub ;
    return GenericVerbSub(286,287,288);
];
[ DrinkSub ;
    return GenericVerbSub(289,290,291);
];
[ SorrySub ;
    return GenericVerbSub(292,293,294);
];
[ SwingSub ;
    return GenericVerbSub(295,296,297);
];
[ RubSub ;
    return GenericVerbSub(298,299,300);
];
[ SetToSub ;
    return GenericVerbSub(301,302,303);
];
[ WaveHandsSub ;
    return GenericVerbSub(304,305,306);
];
[ BuySub ;
    return GenericVerbSub(307,308,309);
];
[ ClimbSub ;
    return GenericVerbSub(310,311,312);
];
[ SleepSub ;
    return GenericVerbSub(313,314,315);
];
[ QuitSub ;
    return GenericVerbSub(316,317,318);
];
[ SaveSub ;
    return GenericVerbSub(319,320,321);
];
[ RestoreSub ;
    return GenericVerbSub(322,323,324);
];
[ RestartSub ;
    return GenericVerbSub(325,326,327);
];
[ VerifySub ;
    return GenericVerbSub(328,329,330);
];
[ ScriptOnSub ;
    return GenericVerbSub(331,332,333);
];
[ ScriptOffSub ;
    return GenericVerbSub(334,335,336);
];
[ VersionSub ;
    return GenericVerbSub(337,338,339);
];
[ ScoreSub ;
    return GenericVerbSub(340,341,342);
];
[ LMode3Sub ;
    return GenericVerbSub(343,344,345);
];
[ LMode2Sub ;
    return GenericVerbSub(346,347,348);
];
[ LMode1Sub ;
    return GenericVerbSub(349,350,351);
];
[ NotifyOnSub ;
    return GenericVerbSub(352,353,354);
];
[ NotifyOffSub ;
    return GenericVerbSub(355,356,357);
];
[ PronounsSub ;
    return GenericVerbSub(358,359,360);
];
[ A77_unlocking_keylesslySub ;
    return GenericVerbSub(364,365,366);
];
[ A78_locking_keylesslySub ;
    return GenericVerbSub(367,368,369);
];
[ A79_readingSub ;
    return GenericVerbSub(376,377,378);
];

[ MistakeActionSub ;
    switch(understand_as_mistake_number) {
        default: "I didn't understand that sentence.";
    }
    say__p = 1;
];



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Phrases
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


! Definitions of rules in rulebooks


! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Startup (B0_startup)
! ----------------------------------------------------------------------------------------------------
! Rule 1/11: INITIALISE_MEMORY_R
!   === equally specific with ===
! Rule 2/11: VIRTUAL_MACHINE_STARTUP_R
!   === equally specific with ===
! Rule 3/11: SEED_RANDOM_NUMBER_GENERATOR_R
!   === equally specific with ===
! Rule 4/11: UPDATE_CHRONOLOGICAL_RECORDS_R
!   === equally specific with ===
! Rule 5/11 ! This is the declare everything initially unmentioned rule:
!   === equally specific with ===
! Rule 6/11: POSITION_PLAYER_IN_MODEL_R
!   === equally specific with ===
! Rule 7/11 ! This is the start in the correct scenes rule:
! --- now the mid-placed rules ---
! Rule 8/11 ! This is the when play begins stage rule:
!   === equally specific with ===
! Rule 9/11 ! This is the fix baseline scoring rule:
!   === equally specific with ===
! Rule 10/11 ! This is the display banner rule:
!   === equally specific with ===
! Rule 11/11 ! This is the initial room description rule:
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! This is the declare everything initially unmentioned rule:
[ R_9 
    tmp_0 ! Let/loop value, e.g., '?-1,-1?'(deallocated by end of phrase)
    tmp_1 ! Let/loop value, e.g., '?-1,-1?'(deallocated by end of phrase)
    ;
    if (debug_rules) DB_Rule(R_9, 9);
    ! [1: repeat with item running through things begin]
    for (tmp_0=Prop_0(0), tmp_1=Prop_0(tmp_0): tmp_0: tmp_0=tmp_1, tmp_1=Prop_0(tmp_1)){
        ! [2: now the item is not mentioned]
        (Adj_69_t3_v10(tmp_0));
        ! [3: end repeat]
        }

        rfalse;
];
! From the Standard Rules
! No specific request
! This is the start in the correct scenes rule:
[ R_10 ;
    if (debug_rules) DB_Rule(R_10, 10);
    ! [1: follow the scene changing rules]
    FollowRulebook(RULEBOOK_TY_to_RULE_TY(3));
    rfalse;
];
! From the Standard Rules
! No specific request
! This is the when play begins stage rule:
[ R_11 ;
    if (debug_rules) DB_Rule(R_11, 11);
    ! [1: follow the when play begins rulebook]
    FollowRulebook(RULEBOOK_TY_to_RULE_TY(4));
    rfalse;
];
! From the Standard Rules
! No specific request
! This is the fix baseline scoring rule:
[ R_12 ;
    if (debug_rules) DB_Rule(R_12, 12);
    ! [1: now the last notified score is the score]
    last_score = score;
    rfalse;
];
! From the Standard Rules
! No specific request
! This is the display banner rule:
[ R_13 ;
    if (debug_rules) DB_Rule(R_13, 13);
    ! [1: say ~[banner text]~]
    say__p=1;ParaContent(); Banner(); .L_Say0; .L_SayX0;
    rfalse;
];
! From the Standard Rules
! No specific request
! This is the initial room description rule:
[ R_14 ;
    if (debug_rules) DB_Rule(R_14, 14);
    ! [1: try looking]
    TryAction(0, player, ##Look, 0, 0);;
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Turn sequence (B1_turn_sequence)
! ----------------------------------------------------------------------------------------------------
! Rule 1/12: PARSE_COMMAND_R
!   === equally specific with ===
! Rule 2/12 ! This is the declare everything initially unmentioned rule:
!   === equally specific with ===
! Rule 3/12: GENERATE_ACTION_R
!   === equally specific with ===
! Rule 4/12 ! A first turn sequence rule:
!   === equally specific with ===
! Rule 5/12 ! A first turn sequence rule ( this is the every turn stage rule ):
! --- now the mid-placed rules ---
! Rule 6/12: TIMED_EVENTS_R
!   === equally specific with ===
! Rule 7/12: ADVANCE_TIME_R
!   === equally specific with ===
! Rule 8/12: UPDATE_CHRONOLOGICAL_RECORDS_R
! --- now the last-placed rules ---
! Rule 9/12 ! A last turn sequence rule:
!   === equally specific with ===
! Rule 10/12: ADJUST_LIGHT_R
!   === equally specific with ===
! Rule 11/12: NOTE_OBJECT_ACQUISITIONS_R
!   === equally specific with ===
! Rule 12/12 ! This is the notify score changes rule:
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! A first turn sequence rule:
[ R_16 ;
    if (debug_rules) DB_Rule(R_16, 16);
    ! [1: follow the scene changing rules]
    FollowRulebook(RULEBOOK_TY_to_RULE_TY(3));
    rfalse;
];
! From the Standard Rules
! No specific request
! A first turn sequence rule ( this is the every turn stage rule ):
[ R_15 ;
    if (debug_rules) DB_Rule(R_15, 15);
    ! [1: follow the every turn rules]
    FollowRulebook(RULEBOOK_TY_to_RULE_TY(8));
    rfalse;
];
! From the Standard Rules
! No specific request
! A last turn sequence rule:
[ R_17 ;
    if (debug_rules) DB_Rule(R_17, 17);
    ! [1: follow the scene changing rules]
    FollowRulebook(RULEBOOK_TY_to_RULE_TY(3));
    rfalse;
];
! From the Standard Rules
! No specific request
! This is the notify score changes rule:
[ R_18 ;
    if (debug_rules) DB_Rule(R_18, 18);
    ! [1: if the score is not the last notified score begin]
    if (((~~((score == last_score))))){
        ! [2: issue score notification message]
        NotifyTheScore();
        ! [3: now the last notified score is the score]
        last_score = score;
        ! [4: end if]
        }

        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Shutdown (B2_shutdown)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! This is the when play ends stage rule:
! --- now the last-placed rules ---
! Rule 2/4: RESURRECT_PLAYER_IF_ASKED_R
!   === equally specific with ===
! Rule 3/4 ! This is the print player's obituary rule:
!   === equally specific with ===
! Rule 4/4: ASK_FINAL_QUESTION_R
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! This is the when play ends stage rule:
[ R_19 ;
    if (debug_rules) DB_Rule(R_19, 19);
    ! [1: follow the when play ends rulebook]
    FollowRulebook(RULEBOOK_TY_to_RULE_TY(5));
    rfalse;
];
! From the Standard Rules
! No specific request
! This is the print player's obituary rule:
[ R_20 ;
    if (debug_rules) DB_Rule(R_20, 20);
    ! [1: carry out the printing the player's obituary activity]
    CarryOutActivity(V28_printing_the_player_s_ob);
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: When play begins (B4_when_play_begins)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! When play begins:
! ----------------------------------------------------------------------------------------------------
! No specific request
! When play begins:
[ R_935 ;
    if (debug_rules) DB_Rule(R_935, 935);
    ! [1: now the command prompt is ~Please choose a gender for your character.^^>~]
    BlkValueCopy((Global_Vars-->1), TX_L_438);
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: When scene begins (B6_when_scene_begins)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! When a scene ( called the event ) begins ( this is the scene description text rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! When a scene ( called the event ) begins ( this is the scene description text rule ):
[ R_65 
    tmp_0 ! Let/loop value, e.g., 'event': scene
    ;
    if ((((tmp_0 = parameter_value, (((tmp_0=(parameter_value), true) && (true))))) || (tmp_0 = I77_entire_game,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_65, 65);
    ! [1: if the description of the event is not ~~ , say ~[description of the event][paragraph break]~]
    if (((~~(( BlkValueCompare(GProperty(SCENE_TY, tmp_0,description), EMPTY_TEXT_VALUE) == 0))))) { @push self; say__p=1;ParaContent(); print (TEXT_TY_Say) GProperty(SCENE_TY, self=tmp_0,description);@pull self; ParaContent(); DivideParagraphPoint(); new_line; .L_Say1; .L_SayX1; }
    } else if (debug_rules > 1) DB_Rule(R_65, 65, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Every turn (B8_every_turn)
! ----------------------------------------------------------------------------------------------------
! Rule 1/7 ! Every turn when the player is in a cursed room:
!   >>> III - When/while requirement >>>
! Rule 2/7 ! Every turn when the player is in Lackluster Apartments:
!   === equally specific with ===
! Rule 3/7 ! Every turn when the player is in Birds of Paradise:
!   === equally specific with ===
! Rule 4/7 ! Every turn when the player is in the Business District:
!   === equally specific with ===
! Rule 5/7 ! Every turn when the player is in The Long John:
!   === equally specific with ===
! Rule 6/7 ! Every turn when the player is in Palomino Bar n Grill:
!   >>> I - Number of aspects constrained >>>
! Rule 7/7 ! Every turn:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Every turn when the player is in a cursed room:
[ R_939 ;
    if ((((((ContainerOf(player) ofclass K1_room) && ((Adj_94_t1_v10(ContainerOf(player))))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_939, 939);
    ! [1: say ~[italic type] You sense a strange magic in the air.~]
    say__p=1;ParaContent(); style underline;ParaContent(); print " You sense a strange magic in the air."; new_line; .L_Say2; .L_SayX2;
    } else if (debug_rules > 1) DB_Rule(R_939, 939, 'context');
    rfalse;
];
! No specific request
! Every turn when the player is in Lackluster Apartments:
[ R_959 ;
    if ((((((I145_lackluster_apartments == ContainerOf(player))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_959, 959);
    ! [1: if a random chance of 1 in 2 succeeds , say walkingthedog]
    if (((GenerateRandomNumber(1, 2) <= 1))) { say__p=1;ParaContent(); (PHR_982_r0 ()); .L_Say3; .L_SayX3; }
    ! [2: otherwise say ~Maybe if you wait around you'll see something interesting....~]
    else { say__p=1;ParaContent(); print "Maybe if you wait around you'll see something interesting...."; new_line; .L_Say4; .L_SayX4; }
    } else if (debug_rules > 1) DB_Rule(R_959, 959, 'context');
    rfalse;
];
! No specific request
! Every turn when the player is in Birds of Paradise:
[ R_962 ;
    if ((((((I215_birds_of_paradise == ContainerOf(player))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_962, 962);
    ! [1: if a random chance of 1 in 2 succeeds , say egglayer]
    if (((GenerateRandomNumber(1, 2) <= 1))) { say__p=1;ParaContent(); (PHR_981_r1 ()); .L_Say5; .L_SayX5; }
    ! [2: otherwise say ~Hmmm... you just had the feeling something was going to happen.~]
    else { say__p=1;ParaContent(); print "Hmmm... you just had the feeling something was going to happen."; new_line; .L_Say6; .L_SayX6; }
    } else if (debug_rules > 1) DB_Rule(R_962, 962, 'context');
    rfalse;
];
! No specific request
! Every turn when the player is in the Business District:
[ R_965 ;
    if ((((((TestRegionalContainment(player,I310_business_district))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_965, 965);
    ! [1: if a random chance of 1 in 20 succeeds , say becomefemalegoat]
    if (((GenerateRandomNumber(1, 20) <= 1))) { say__p=1;ParaContent(); (PHR_1003_r2 ()); .L_Say7; .L_SayX7; }
    } else if (debug_rules > 1) DB_Rule(R_965, 965, 'context');
    rfalse;
];
! No specific request
! Every turn when the player is in The Long John:
[ R_976 ;
    if ((((((I390_the_long_john == ContainerOf(player))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_976, 976);
    ! [1: if a random chance of 1 in 2 succeeds , say captured]
    if (((GenerateRandomNumber(1, 2) <= 1))) { say__p=1;ParaContent(); (PHR_977_r3 ()); .L_Say8; .L_SayX8; }
    ! [2: otherwise say ~They haven't noticed you yet.~]
    else { say__p=1;ParaContent(); print "They haven't noticed you yet."; new_line; .L_Say9; .L_SayX9; }
    } else if (debug_rules > 1) DB_Rule(R_976, 976, 'context');
    rfalse;
];
! No specific request
! Every turn when the player is in Palomino Bar n Grill:
[ R_978 ;
    if ((((((I393_palomino_bar_n_grill == ContainerOf(player))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_978, 978);
    ! [1: if a random chance of 1 in 2 succeeds , say courtneysrevenge]
    if (((GenerateRandomNumber(1, 2) <= 1))) { say__p=1;ParaContent(); (PHR_979_r4 ()); .L_Say10; .L_SayX10; }
    ! [2: otherwise say ~Thank god... she hasn't noticed you yet.~]
    else { say__p=1;ParaContent(); print "Thank god... she hasn't noticed you yet."; new_line; .L_Say11; .L_SayX11; }
    } else if (debug_rules > 1) DB_Rule(R_978, 978, 'context');
    rfalse;
];
! From "Plurality" by Emily Short
! No specific request
! Every turn:
[ R_887 ;
    if (debug_rules) DB_Rule(R_887, 887);
    ! [1: if the noun is a thing and the noun is ambiguously plural , notice the plurality of the noun]
    if ((((noun ofclass K2_thing))) && ((((Adj_48_t1_v10(noun)))))) { PlugPlural(noun); }
    ! [2: if the second noun is a thing and the second noun is ambiguously plural , notice the plurality of the second noun]
    if ((((second ofclass K2_thing))) && ((((Adj_48_t1_v10(second)))))) { PlugPlural(second); }
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Action-processing (B9_action_processing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/11 ! This is the announce items from multiple object lists rule:
!   === equally specific with ===
! Rule 2/11 ! This is the set pronouns from items from multiple object lists rule:
!   === equally specific with ===
! Rule 3/11 ! This is the before stage rule:
! --- now the mid-placed rules ---
! Rule 4/11: BASIC_VISIBILITY_R
!   === equally specific with ===
! Rule 5/11: BASIC_ACCESSIBILITY_R
!   <<< IV - Action requirement <<<
! Rule 6/11 ! This is the keychain-aware carrying requirements rule:
! --- now the last-placed rules ---
! Rule 7/11 ! This is the instead stage rule:
!   === equally specific with ===
! Rule 8/11: REQUESTED_ACTIONS_REQUIRE_R
!   === equally specific with ===
! Rule 9/11: CARRY_OUT_REQUESTED_ACTIONS_R
!   === equally specific with ===
! Rule 10/11: DESCEND_TO_SPECIFIC_ACTION_R
!   === equally specific with ===
! Rule 11/11 ! This is the end action-processing in success rule:
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! This is the announce items from multiple object lists rule:
[ R_22 ;
    if (debug_rules) DB_Rule(R_22, 22);
    ! [1: if the current item from the multiple object list is not nothing , say ~[current item from the multiple object list]: [run paragraph on]~]
    if (((~~((multiple_object_item == nothing))))) { say__p=1;ParaContent(); print (PrintShortName) multiple_object_item;ParaContent(); print ": ";ParaContent(); RunParagraphOn(); .L_Say12; .L_SayX12; }
    rfalse;
];
! From the Standard Rules
! No specific request
! This is the set pronouns from items from multiple object lists rule:
[ R_21 ;
    if (debug_rules) DB_Rule(R_21, 21);
    ! [1: if the current item from the multiple object list is not nothing , set pronouns from the current item from the multiple object list]
    if (((~~((multiple_object_item == nothing))))) { PronounNotice(multiple_object_item); }
    rfalse;
];
! From the Standard Rules
! No specific request
! This is the before stage rule:
[ R_23 ;
    if (debug_rules) DB_Rule(R_23, 23);
    ! [1: abide by the before rules]
    if (FollowRulebook(RULEBOOK_TY_to_RULE_TY(19))) rtrue;
    rfalse;
];
! From "Locksmith" by Emily Short
! No specific request
! This is the keychain-aware carrying requirements rule:
[ R_838 ;
    if (debug_rules) DB_Rule(R_838, 838);
    ! [1: if locking or unlocking something with something which is on a keychain which is carried by the actor begin]
    if (((((action ==##Lock) &&  (actor==player)))) || ((((action ==##Unlock) &&  (actor==player) && ((noun ofclass K2_thing)) && ((second ofclass K2_thing) && (SupporterOf(second) ofclass K17_keychain) && (actor == CarrierOf(SupporterOf(second)))))))){
        ! [2: continue the action]
        rfalse;
        ! [3: end if]
        }

    ! [4: abide by the carrying requirements rule]
    if (FollowRulebook(CARRYING_REQUIREMENTS_R)) rtrue;
    rfalse;
];
! From the Standard Rules
! No specific request
! This is the instead stage rule:
[ R_24 ;
    if (debug_rules) DB_Rule(R_24, 24);
    ! [1: abide by the instead rules]
    if (FollowRulebook(RULEBOOK_TY_to_RULE_TY(20))) rtrue;
    rfalse;
];
! From the Standard Rules
! No specific request
! This is the end action-processing in success rule:
[ R_25 ;
    if (debug_rules) DB_Rule(R_25, 25);
    ! [1: rule succeeds]
    RulebookSucceeds(); rtrue;
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Setting action variables (B10_setting_action_variables)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Rule for setting action variables for going ( this is the standard set going variables rule ):
!   === equally specific with ===
! Rule 2/3 ! Setting action variables for exiting:
!   === equally specific with ===
! Rule 3/3 ! Setting action variables for looking ( this is the determine visibility ceiling rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Rule for setting action variables for going ( this is the standard set going variables rule ):
[ R_149 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    @push formal_par1;
    I7RBLK = KERNEL_0();
    @pull formal_par1;
    @pull formal_par0;
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_0 
    tmp_0 ! Let/loop value, e.g., 'carriage': vehicle
    tmp_1 ! Let/loop value, e.g., 'target': object
    tmp_2 ! Let/loop value, e.g., '?-1,-1?'(deallocated by end of phrase)
    ;
    if ((((action ==##Go)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_149, 149);
    ! [1: now the thing gone with is the item-pushed-between-rooms]
    (MStack-->MstVO(20007,4)) = move_pushing;
    ! [2: now the room gone from is the location of the actor]
    (MStack-->MstVO(20007,0)) = LocationOf(actor);
    ! [3: if the actor is in an enterable vehicle ( called the carriage ) , now the vehicle gone by is the carriage]
    if (((ContainerOf(actor) ofclass K14_vehicle) && (tmp_0=(ContainerOf(actor)), true) && ((Adj_71_t1_v10(ContainerOf(actor)))))) { (MStack-->MstVO(20007,3)) = tmp_0; }
    ! [4: let the target be nothing]

    		tmp_1 = nothing;
    ! [5: if the noun is a direction begin]
    if (((noun ofclass K3_direction))){
        ! [6: let direction d be the noun]

        		tmp_2 = noun;
        ! [7: let the target be the room-or-door direction d from the room gone from]
        tmp_1 = 
        ! Resolution of run-time phrase ambiguity (deciding a value):
            (
                ! This value evaluates third (i.e., last)
                formal_rv
            +
                0*(
                    ! The following condition evaluates second
                    ((
                        ((((((formal_par0 ofclass K3_direction) && (formal_par0 ofclass K3_direction))))) && ((
                        formal_rv = RoomOrDoorFrom(formal_par1,formal_par0)) | 1)
                        )|| (ArgumentTypeFailed(2260, 1))

                    ))
                +
                    ! The following assignments evaluate first
                    ((formal_par1 = (MStack-->MstVO(20007,0))) +
                    (formal_par0 = tmp_2)
                    ))
            )

        ! Resolution complete
        ;
        ! [8: otherwise]
        } else {

        ! [9: if the noun is a door , let the target be the noun]
        if (((noun ofclass K4_door))) { tmp_1 = noun; }
        ! [10: end if]
        }

    ! [11: if the target is a door begin]
    if (((tmp_1 ofclass K4_door))){
        ! [12: now the door gone through is the target]
        (MStack-->MstVO(20007,2)) = tmp_1;
        ! [13: now the target is the other side of the target from the room gone from]
        tmp_1 = 
        ! Resolution of run-time phrase ambiguity (deciding a value):
            (
                ! This value evaluates third (i.e., last)
                formal_rv
            +
                0*(
                    ! The following condition evaluates second
                    ((
                        ((((((formal_par0 ofclass K4_door) && (formal_par0 ofclass K4_door))))) && ((
                        formal_rv = OtherSideOfDoor(formal_par0,formal_par1)) | 1)
                        )|| (ArgumentTypeFailed(2265, 1))

                    ))
                +
                    ! The following assignments evaluate first
                    ((formal_par1 = (MStack-->MstVO(20007,0))) +
                    (formal_par0 = tmp_1)
                    ))
            )

        ! Resolution complete
        ;
        ! [14: end if]
        }

    ! [15: now the room gone to is the target]
    (MStack-->MstVO(20007,1)) = tmp_1;
    } else if (debug_rules > 1) DB_Rule(R_149, 149, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Setting action variables for exiting:
[ R_172 ;
    if ((((action ==##Exit)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_172, 172);
    ! [1: now the container exited from is the holder of the actor]
    (MStack-->MstVO(20009,0)) = (HolderOf(actor));
    } else if (debug_rules > 1) DB_Rule(R_172, 172, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Setting action variables for looking ( this is the determine visibility ceiling rule ):
[ R_184 ;
    if ((((action ==##Look)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_184, 184);
    ! [1: if the actor is the player , calculate visibility ceiling at low level]
    if (((actor == player))) { FindVisibilityLevels(); }
    ! [2: now the visibility level count is the visibility ceiling count calculated]
    (MStack-->MstVO(20011,2)) = visibility_levels;
    ! [3: now the visibility ceiling is the visibility ceiling calculated]
    (MStack-->MstVO(20011,3)) = visibility_ceiling;
    ! [4: now the room-describing action is the looking action]
    (MStack-->MstVO(20011,0)) = ##Look;
    } else if (debug_rules > 1) DB_Rule(R_184, 184, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: specific action-processing (B11_specific_action_processi)
! ----------------------------------------------------------------------------------------------------
! Rule 1/8: WORK_OUT_DETAILS_OF_SPECIFIC_R
! --- now the mid-placed rules ---
! Rule 2/8 ! A specific action-processing rule ( this is the investigate player's awareness before action rule ):
!   === equally specific with ===
! Rule 3/8 ! A specific action-processing rule ( this is the check stage rule ):
!   === equally specific with ===
! Rule 4/8 ! A specific action-processing rule ( this is the carry out stage rule ):
!   === equally specific with ===
! Rule 5/8 ! A specific action-processing rule ( this is the after stage rule ):
!   === equally specific with ===
! Rule 6/8 ! A specific action-processing rule ( this is the investigate player's awareness after action rule ):
!   === equally specific with ===
! Rule 7/8 ! A specific action-processing rule ( this is the report stage rule ):
! --- now the last-placed rules ---
! Rule 8/8 ! The last specific action-processing rule:
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! A specific action-processing rule ( this is the investigate player's awareness before action rule ):
[ R_26 ;
    if (debug_rules) DB_Rule(R_26, 26);
    ! [1: follow the player's action awareness rules]
    FollowRulebook(RULEBOOK_TY_to_RULE_TY(12));
    ! [2: if rule succeeded , now within the player's sight is true]
    if (((RulebookSucceeded()))) { (MStack-->MstVO(11,5)) = 1; }
    ! [3: otherwise now within the player's sight is false]
    else { (MStack-->MstVO(11,5)) = 0; }
    rfalse;
];
! From the Standard Rules
! No specific request
! A specific action-processing rule ( this is the check stage rule ):
[ R_27 ;
    if (debug_rules) DB_Rule(R_27, 27);
    ! [1: anonymously abide by the specific check rulebook]
    if (temporary_value = FollowRulebook(RULEBOOK_TY_to_RULE_TY((MStack-->MstVO(11,2))))) {
    		if (RulebookSucceeded()) ActRulebookSucceeds(temporary_value);
    		else ActRulebookFails(temporary_value);
    		return 2;
    	}
    rfalse;
];
! From the Standard Rules
! No specific request
! A specific action-processing rule ( this is the carry out stage rule ):
[ R_28 ;
    if (debug_rules) DB_Rule(R_28, 28);
    ! [1: follow the specific carry out rulebook]
    FollowRulebook(RULEBOOK_TY_to_RULE_TY((MStack-->MstVO(11,3))));
    rfalse;
];
! From the Standard Rules
! No specific request
! A specific action-processing rule ( this is the after stage rule ):
[ R_29 ;
    if (debug_rules) DB_Rule(R_29, 29);
    ! [1: if action in world is true , abide by the after rules]
    if (((((MStack-->MstVO(11,0)) && true) == (1 && true)))) { if (FollowRulebook(RULEBOOK_TY_to_RULE_TY(23))) rtrue; }
    rfalse;
];
! From the Standard Rules
! No specific request
! A specific action-processing rule ( this is the investigate player's awareness after action rule ):
[ R_30 ;
    if (debug_rules) DB_Rule(R_30, 30);
    ! [1: if within the player's sight is false begin]
    if (((((MStack-->MstVO(11,5)) && true) == (0 && true)))){
        ! [2: follow the player's action awareness rules]
        FollowRulebook(RULEBOOK_TY_to_RULE_TY(12));
        ! [3: if rule succeeded , now within the player's sight is true]
        if (((RulebookSucceeded()))) { (MStack-->MstVO(11,5)) = 1; }
        ! [4: end if]
        }

        rfalse;
];
! From the Standard Rules
! No specific request
! A specific action-processing rule ( this is the report stage rule ):
[ R_31 ;
    if (debug_rules) DB_Rule(R_31, 31);
    ! [1: if within the player's sight is true and action keeping silent is false , follow the specific report rulebook]
    if ((((((MStack-->MstVO(11,5)) && true) == (1 && true)))) && (((((MStack-->MstVO(11,1)) && true) == (0 && true))))) { FollowRulebook(RULEBOOK_TY_to_RULE_TY((MStack-->MstVO(11,4)))); }
    rfalse;
];
! From the Standard Rules
! No specific request
! The last specific action-processing rule:
[ R_32 ;
    if (debug_rules) DB_Rule(R_32, 32);
    ! [1: rule succeeds]
    RulebookSucceeds(); rtrue;
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: player's action awareness (B12_player_s_action_awarenes)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! A player's action awareness rule ( this is the player aware of his own actions rule ):
!   === equally specific with ===
! Rule 2/4 ! A player's action awareness rule ( this is the player aware of actions by visible actors rule ):
!   === equally specific with ===
! Rule 3/4 ! A player's action awareness rule ( this is the player aware of actions on visible nouns rule ):
!   === equally specific with ===
! Rule 4/4 ! A player's action awareness rule ( this is the player aware of actions on visible second nouns rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! A player's action awareness rule ( this is the player aware of his own actions rule ):
[ R_33 ;
    if (debug_rules) DB_Rule(R_33, 33);
    ! [1: if the player is the actor , rule succeeds]
    if (((player == actor))) { RulebookSucceeds(); rtrue; }
    rfalse;
];
! From the Standard Rules
! No specific request
! A player's action awareness rule ( this is the player aware of actions by visible actors rule ):
[ R_34 ;
    if (debug_rules) DB_Rule(R_34, 34);
    ! [1: if the player is not the actor and the player can see the actor , rule succeeds]
    if ((((~~((player == actor))))) && (((TestVisibility(player,actor))))) { RulebookSucceeds(); rtrue; }
    rfalse;
];
! From the Standard Rules
! No specific request
! A player's action awareness rule ( this is the player aware of actions on visible nouns rule ):
[ R_35 ;
    if (debug_rules) DB_Rule(R_35, 35);
    ! [1: if the noun is a thing and the player can see the noun , rule succeeds]
    if ((((noun ofclass K2_thing))) && (((TestVisibility(player,noun))))) { RulebookSucceeds(); rtrue; }
    rfalse;
];
! From the Standard Rules
! No specific request
! A player's action awareness rule ( this is the player aware of actions on visible second nouns rule ):
[ R_36 ;
    if (debug_rules) DB_Rule(R_36, 36);
    ! [1: if the second noun is a thing and the player can see the second noun , rule succeeds]
    if ((((second ofclass K2_thing))) && (((TestVisibility(player,second))))) { RulebookSucceeds(); rtrue; }
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Visibility (B16_visibility)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! The last visibility rule ( this is the can't act in the dark rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! The last visibility rule ( this is the can't act in the dark rule ):
[ R_37 ;
    if (debug_rules) DB_Rule(R_37, 37);
    ! [1: if in darkness , rule succeeds]
    if (((location==thedark))) { RulebookSucceeds(); rtrue; }
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Before (B19_before)
! ----------------------------------------------------------------------------------------------------
! Rule 1/9 ! Before someone trying going through a closed door ( called the blocking door ) ( this is the intelligently opening doors rule ):
!   >>> III.2.1 - Action/Where/Going In Exotic Ways >>>
! Rule 2/9 ! Before opening an unexplored drawer when exactly two drawers are explored:
!   >>> I - Number of aspects constrained >>>
! Rule 3/9 ! Before going through a closed door ( called the blocking door ) ( this is the opening doors before entering rule ):
!   >>> III.2.1 - Action/Where/Going In Exotic Ways >>>
! Rule 4/9 ! Before someone trying locking an open thing ( called the door ajar ) with something ( this is the intelligently closing doors rule ):
!   >>> III.3.3 - Action/What/Actor Performing Action >>>
! Rule 5/9 ! Before locking an open thing ( called the door ajar ) with something ( this is the closing doors before locking rule ):
!   >>> III.3.1 - Action/What/Second Thing Acted On >>>
! Rule 6/9 ! Before someone trying locking keylessly an open thing ( called the door ajar ) ( this is the intelligently closing keyless doors rule ):
!   === equally specific with ===
! Rule 7/9 ! Before someone trying opening a locked thing ( called the sealed chest ) ( this is the intelligently opening containers rule ):
!   >>> III.3.3 - Action/What/Actor Performing Action >>>
! Rule 8/9 ! Before locking keylessly an open thing ( called the door ajar ) ( this is the closing doors before locking keylessly rule ):
!   === equally specific with ===
! Rule 9/9 ! Before opening a locked thing ( called the sealed chest ) ( this is the unlocking before opening rule ):
! ----------------------------------------------------------------------------------------------------
! From "Locksmith" by Emily Short
! No specific request
! Before someone trying going through a closed door ( called the blocking door ) ( this is the intelligently opening doors rule ):
[ R_815 
    tmp_0 ! Let/loop value, e.g., 'blocking door': door
    ;
    if ((((action ==##Go) &&  (actor~=player) && (act_requester==nothing) && ((actor ofclass K8_person)) && (tmp_0 = (MStack-->MstVON(20007,2)), (((tmp_0=((MStack-->MstVON(20007,2))), true) && ((MStack-->MstVON(20007,2)) ofclass K4_door) && ((Adj_75_t1_v10((MStack-->MstVON(20007,2)))))))) && ((MStack-->MstVON(20007,1)) ~= nothing)) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_815, 815);
    ! [1: try the person asked trying opening the blocking door]
    TryAction(0, actor, ##Open, tmp_0, 0);;
    ! [2: if the blocking door is closed , stop the action]
    if ((((Adj_75_t1_v10(tmp_0))))) { rtrue; }
    } else if (debug_rules > 1) DB_Rule(R_815, 815, 'action');
    rfalse;
];
! No specific request
! Before opening an unexplored drawer when exactly two drawers are explored:
[ R_953 ;
    if ((((action ==##Open) &&  (actor==player) && ((noun ofclass K23_drawer) && ((Adj_99_t1_v10(noun)))) && (self=actor,true) && ((((Prop_1()))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_953, 953);
    ! [1: move the mysterious passcode to the noun]
    MoveObject(I189_mysterious_passcode, noun, 0, false);
    ! [2: now the noun is explored]
    (Adj_98_t2_v10(noun));
    } else if (debug_rules > 1) DB_Rule(R_953, 953, 'action');
    rfalse;
];
! From "Locksmith" by Emily Short
! No specific request
! Before going through a closed door ( called the blocking door ) ( this is the opening doors before entering rule ):
[ R_811 
    tmp_0 ! Let/loop value, e.g., 'blocking door': door
    ;
    if ((((action ==##Go) &&  (actor==player) && (tmp_0 = (MStack-->MstVON(20007,2)), (((tmp_0=((MStack-->MstVON(20007,2))), true) && ((MStack-->MstVON(20007,2)) ofclass K4_door) && ((Adj_75_t1_v10((MStack-->MstVON(20007,2)))))))) && ((MStack-->MstVON(20007,1)) ~= nothing)) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_811, 811);
    ! [1: if sequential action option is active begin]
    if ((((Adj_25_t1_v16(28))))){
        ! [2: try opening the blocking door]
        TryAction(0, player, ##Open, tmp_0, 0);;
        ! [3: otherwise]
        } else {

        ! [4: say ~(first opening [the blocking door])[command clarification break]~ ( a )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),TX_R_132); .L_Say13; .L_SayX13;
        ! [5: silently try opening the blocking door]
        @push keep_silent; keep_silent=1; @push say__p; @push say__pc;
        		ClearParagraphing(1); TryAction(0, player, ##Open, tmp_0, 0);; DivideParagraphPoint();
        		@pull say__pc; @pull say__p; AdjustParagraphPoint(); @pull keep_silent;
        ! [6: end if]
        }

    ! [7: if the blocking door is closed , stop the action]
    if ((((Adj_75_t1_v10(tmp_0))))) { rtrue; }
    } else if (debug_rules > 1) DB_Rule(R_811, 811, 'action');
    rfalse;
];
! From "Locksmith" by Emily Short
! No specific request
! Before someone trying locking an open thing ( called the door ajar ) with something ( this is the intelligently closing doors rule ):
[ R_816 
    tmp_0 ! Let/loop value, e.g., 'door ajar': thing
    ;
    if ((((action ==##Lock) &&  (actor~=player) && (act_requester==nothing) && ((actor ofclass K8_person)) && (tmp_0 = noun, (((tmp_0=(noun), true) && (noun ofclass K2_thing) && ((Adj_74_t1_v10(noun)))))) && ((second ofclass K2_thing))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_816, 816);
    ! [1: try the person asked trying closing the door ajar]
    TryAction(0, actor, ##Close, tmp_0, 0);;
    ! [2: if the door ajar is open , stop the action]
    if ((((Adj_74_t1_v10(tmp_0))))) { rtrue; }
    } else if (debug_rules > 1) DB_Rule(R_816, 816, 'action');
    rfalse;
];
! From "Locksmith" by Emily Short
! No specific request
! Before locking an open thing ( called the door ajar ) with something ( this is the closing doors before locking rule ):
[ R_812 
    tmp_0 ! Let/loop value, e.g., 'door ajar': thing
    ;
    if ((((action ==##Lock) &&  (actor==player) && (tmp_0 = noun, (((tmp_0=(noun), true) && (noun ofclass K2_thing) && ((Adj_74_t1_v10(noun)))))) && ((second ofclass K2_thing))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_812, 812);
    ! [1: if sequential action option is active begin]
    if ((((Adj_25_t1_v16(28))))){
        ! [2: try closing the door ajar]
        TryAction(0, player, ##Close, tmp_0, 0);;
        ! [3: otherwise]
        } else {

        ! [4: say ~(first closing [the door ajar])[command clarification break]~ ( a )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),TX_R_133); .L_Say14; .L_SayX14;
        ! [5: silently try closing the door ajar]
        @push keep_silent; keep_silent=1; @push say__p; @push say__pc;
        		ClearParagraphing(1); TryAction(0, player, ##Close, tmp_0, 0);; DivideParagraphPoint();
        		@pull say__pc; @pull say__p; AdjustParagraphPoint(); @pull keep_silent;
        ! [6: end if]
        }

    ! [7: if the door ajar is open , stop the action]
    if ((((Adj_74_t1_v10(tmp_0))))) { rtrue; }
    } else if (debug_rules > 1) DB_Rule(R_812, 812, 'action');
    rfalse;
];
! From "Locksmith" by Emily Short
! No specific request
! Before someone trying locking keylessly an open thing ( called the door ajar ) ( this is the intelligently closing keyless doors rule ):
[ R_817 
    tmp_0 ! Let/loop value, e.g., 'door ajar': thing
    ;
    if ((((action ==##A78_locking_keylessly) &&  (actor~=player) && (act_requester==nothing) && ((actor ofclass K8_person)) && (tmp_0 = noun, (((tmp_0=(noun), true) && (noun ofclass K2_thing) && ((Adj_74_t1_v10(noun))))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_817, 817);
    ! [1: try the person asked trying closing the door ajar]
    TryAction(0, actor, ##Close, tmp_0, 0);;
    ! [2: if the door ajar is open , stop the action]
    if ((((Adj_74_t1_v10(tmp_0))))) { rtrue; }
    } else if (debug_rules > 1) DB_Rule(R_817, 817, 'action');
    rfalse;
];
! From "Locksmith" by Emily Short
! No specific request
! Before someone trying opening a locked thing ( called the sealed chest ) ( this is the intelligently opening containers rule ):
[ R_818 
    tmp_0 ! Let/loop value, e.g., 'sealed chest': thing
    ;
    if ((((action ==##Open) &&  (actor~=player) && (act_requester==nothing) && ((actor ofclass K8_person)) && (tmp_0 = noun, (((tmp_0=(noun), true) && (noun ofclass K2_thing) && ((Adj_79_t1_v10(noun))))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_818, 818);
    ! [1: try the person asked trying unlocking keylessly the sealed chest]
    TryAction(0, actor, ##A77_unlocking_keylessly, tmp_0, 0);;
    ! [2: if the sealed chest is locked , stop the action]
    if ((((Adj_79_t1_v10(tmp_0))))) { rtrue; }
    } else if (debug_rules > 1) DB_Rule(R_818, 818, 'action');
    rfalse;
];
! From "Locksmith" by Emily Short
! No specific request
! Before locking keylessly an open thing ( called the door ajar ) ( this is the closing doors before locking keylessly rule ):
[ R_813 
    tmp_0 ! Let/loop value, e.g., 'door ajar': thing
    ;
    if ((((action ==##A78_locking_keylessly) &&  (actor==player) && (tmp_0 = noun, (((tmp_0=(noun), true) && (noun ofclass K2_thing) && ((Adj_74_t1_v10(noun))))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_813, 813);
    ! [1: if sequential action option is active begin]
    if ((((Adj_25_t1_v16(28))))){
        ! [2: try closing the door ajar]
        TryAction(0, player, ##Close, tmp_0, 0);;
        ! [3: otherwise]
        } else {

        ! [4: say ~(first closing [the door ajar])[command clarification break]~ ( a )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),TX_R_134); .L_Say15; .L_SayX15;
        ! [5: silently try closing the door ajar]
        @push keep_silent; keep_silent=1; @push say__p; @push say__pc;
        		ClearParagraphing(1); TryAction(0, player, ##Close, tmp_0, 0);; DivideParagraphPoint();
        		@pull say__pc; @pull say__p; AdjustParagraphPoint(); @pull keep_silent;
        ! [6: end if]
        }

    ! [7: if the door ajar is open , stop the action]
    if ((((Adj_74_t1_v10(tmp_0))))) { rtrue; }
    } else if (debug_rules > 1) DB_Rule(R_813, 813, 'action');
    rfalse;
];
! From "Locksmith" by Emily Short
! No specific request
! Before opening a locked thing ( called the sealed chest ) ( this is the unlocking before opening rule ):
[ R_814 
    tmp_0 ! Let/loop value, e.g., 'sealed chest': thing
    ;
    if ((((action ==##Open) &&  (actor==player) && (tmp_0 = noun, (((tmp_0=(noun), true) && (noun ofclass K2_thing) && ((Adj_79_t1_v10(noun))))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_814, 814);
    ! [1: if sequential action option is active begin]
    if ((((Adj_25_t1_v16(28))))){
        ! [2: try unlocking keylessly the sealed chest]
        TryAction(0, player, ##A77_unlocking_keylessly, tmp_0, 0);;
        ! [3: otherwise]
        } else {

        ! [4: say ~(first unlocking [the sealed chest])[command clarification break]~ ( a )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),TX_R_135); .L_Say16; .L_SayX16;
        ! [5: silently try unlocking keylessly the sealed chest]
        @push keep_silent; keep_silent=1; @push say__p; @push say__pc;
        		ClearParagraphing(1); TryAction(0, player, ##A77_unlocking_keylessly, tmp_0, 0);; DivideParagraphPoint();
        		@pull say__pc; @pull say__p; AdjustParagraphPoint(); @pull keep_silent;
        ! [6: end if]
        }

    ! [7: if the sealed chest is locked , stop the action]
    if ((((Adj_79_t1_v10(tmp_0))))) { rtrue; }
    } else if (debug_rules > 1) DB_Rule(R_814, 814, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Instead (B20_instead)
! ----------------------------------------------------------------------------------------------------
! Rule 1/12 ! Instead of opening the desk when at least one drawer is unexplored:
!   === equally specific with ===
! Rule 2/12 ! Instead of looking under the desk when no drawers are explored:
!   === equally specific with ===
! Rule 3/12 ! Instead of looking under the desk when at least one drawer is unexplored:
!   === equally specific with ===
! Rule 4/12 ! Instead of looking under the desk when all drawers are explored:
!   === equally specific with ===
! Rule 5/12 ! Instead of searching the desk when at least one drawer is unexplored:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 6/12 ! Instead of examining the player when the player is female:
!   === equally specific with ===
! Rule 7/12 ! Instead of examining the player when the player is male:
!   >>> I - Number of aspects constrained >>>
! Rule 8/12 ! Instead of inserting something into the small gold box:
!   >>> III.3.1 - Action/What/Second Thing Acted On >>>
! Rule 9/12 ! Instead of putting something which is not a passkey on a keychain ( this is the limiting keychains rule ):
!   >>> III.3.1 - Action/What/Second Thing Acted On >>>
! Rule 10/12 ! instead of player taking Bull Horn:
!   === equally specific with ===
! Rule 11/12 ! instead of player entering Storage Room:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 12/12 ! Instead of searching a closed drawer:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Instead of opening the desk when at least one drawer is unexplored:
[ R_954 
    tmp_0 ! Let/loop value, e.g., 'next drawer': object
    ;
    if ((((action ==##Open) &&  (actor==player) && ((noun == I184_cherry_desk) && (true)) && (self=actor,true) && ((((Prop_2()))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_954, 954);
    ! [1: let the next drawer be a random unexplored drawer]

    		tmp_0 = (Prop_3());
    ! [2: say ~(starting with [the next drawer])[line break]~]
    say__p=1;ParaContent(); print "(starting with ";ParaContent(); print (the) tmp_0;ParaContent(); print ")";ParaContent(); new_line; .L_Say17; .L_SayX17;
    ! [3: try opening the next drawer]
    TryAction(0, player, ##Open, tmp_0, 0);;
    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_954, 954, 'action');
    rfalse;
];
! No specific request
! Instead of looking under the desk when no drawers are explored:
[ R_955 ;
    if ((((action ==##LookUnder) &&  (actor==player) && ((noun == I184_cherry_desk) && (true)) && (self=actor,true) && ((((Prop_4()))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_955, 955);
    ! [1: say ~You carefully survey the ground around the desk. There don't seem to be any hidden tripwires or traps to prevent you from having a look in the drawers.~]
    say__p=1;ParaContent(); print "You carefully survey the ground around the desk. There don't seem to be any hidden tripwires or traps to prevent you from having a look in the drawers."; new_line; .L_Say18; .L_SayX18;
    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_955, 955, 'action');
    rfalse;
];
! No specific request
! Instead of looking under the desk when at least one drawer is unexplored:
[ R_956 ;
    if ((((action ==##LookUnder) &&  (actor==player) && ((noun == I184_cherry_desk) && (true)) && (self=actor,true) && ((((Prop_5()))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_956, 956);
    ! [1: say ~Nothing there either. Thoroughness is a virtue with tedium as a side effect, as your mother used to say -- but they always counted her a trifle slapdash.~]
    say__p=1;ParaContent(); print "Nothing there either. Thoroughness is a virtue with tedium as a side effect, as your mother used to say -- but they always counted her a trifle slapdash."; new_line; .L_Say19; .L_SayX19;
    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_956, 956, 'action');
    rfalse;
];
! No specific request
! Instead of looking under the desk when all drawers are explored:
[ R_957 ;
    if ((((action ==##LookUnder) &&  (actor==player) && ((noun == I184_cherry_desk) && (true)) && (self=actor,true) && ((((Prop_6()))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_957, 957);
    ! [1: say ~There's nothing down there, but this doesn't come as a great surprise.~]
    say__p=1;ParaContent(); print "There's nothing down there, but this doesn't come as a great surprise."; new_line; .L_Say20; .L_SayX20;
    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_957, 957, 'action');
    rfalse;
];
! No specific request
! Instead of searching the desk when at least one drawer is unexplored:
[ R_958 ;
    if ((((action ==##Search) &&  (actor==player) && ((noun == I184_cherry_desk) && (true)) && (self=actor,true) && ((((Prop_7()))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_958, 958);
    ! [1: move the mysterious passcode to the player]
    MoveObject(I189_mysterious_passcode, player, 0, false);
    ! [2: say ~You perform a hasty, squeaky search of ~]
    say__p=1;ParaContent(); print "You perform a hasty, squeaky search of "; .L_Say21; .L_SayX21;
    ! [3: if no drawer is explored , say ~all three drawers, discovering nothing and nothing in rapid succession. But on the third drawer you ~]
    if ((((Prop_8())))) { say__p=1;ParaContent(); print "all three drawers, discovering nothing and nothing in rapid succession. But on the third drawer you "; .L_Say22; .L_SayX22; }
    ! [4: if exactly two drawers are unexplored , say ~the remaining two drawers. There's nothing in the second, but in the third you ~]
    if ((((Prop_9())))) { say__p=1;ParaContent(); print "the remaining two drawers. There's nothing in the second, but in the third you "; .L_Say23; .L_SayX23; }
    ! [5: if exactly one drawer is unexplored , say ~the last drawer. In it, you ~]
    if ((((Prop_10())))) { say__p=1;ParaContent(); print "the last drawer. In it, you "; .L_Say24; .L_SayX24; }
    ! [6: say ~turn up a promising hemispherical object.~]
    say__p=1;ParaContent(); print "turn up a promising hemispherical object."; new_line; .L_Say25; .L_SayX25;
    ! [7: now all the drawers are explored]
    Prop_11();
    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_958, 958, 'action');
    rfalse;
];
! No specific request
! Instead of examining the player when the player is female:
[ R_937 ;
    if ((((action ==##Examine) &&  (actor==player) && ((noun == player) && (true)) && (self=actor,true) && ((((Adj_81_t1_v10(player)))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_937, 937);
    ! [1: say ~Looking down at yourself, you can see your cute new blouse you just got with your tight jeans.  You sigh at your C cup breasts, wishing they were bigger.  Not that boobs are fun to lug around, but then maybe the boys you like would actually be interested in you as well.  You are wearing Converse for shoes, a blue striped bra, and yellow cotton panties.~]
    say__p=1;ParaContent(); print "Looking down at yourself, you can see your cute new blouse you just got with your tight jeans.  You sigh at your C cup breasts, wishing they were bigger.  Not that boobs are fun to lug around, but then maybe the boys you like would actually be interested in you as well.  You are wearing Converse for shoes, a blue striped bra, and yellow cotton panties."; new_line; .L_Say26; .L_SayX26;
    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_937, 937, 'action');
    rfalse;
];
! No specific request
! Instead of examining the player when the player is male:
[ R_938 ;
    if ((((action ==##Examine) &&  (actor==player) && ((noun == player) && (true)) && (self=actor,true) && ((((Adj_82_t1_v10(player)))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_938, 938);
    ! [1: say ~Looking down at yourself, you can see your cool Deathshead band shirt, still holding it together despite all these years.  You are wearing purposely torn jeans because you heard it was stylish as well.  You sigh at your boring regular sized dick making the slight outline in your jeans.  Maybe if you were more hung you could be fucking girls all the time. You are wearing Nike tennis shoes, a watch, and dark grey boxer briefs.~]
    say__p=1;ParaContent(); print "Looking down at yourself, you can see your cool Deathshead band shirt, still holding it together despite all these years.  You are wearing purposely torn jeans because you heard it was stylish as well.  You sigh at your boring regular sized dick making the slight outline in your jeans.  Maybe if you were more hung you could be fucking girls all the time. You are wearing Nike tennis shoes, a watch, and dark grey boxer briefs."; new_line; .L_Say27; .L_SayX27;
    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_938, 938, 'action');
    rfalse;
];
! No specific request
! Instead of inserting something into the small gold box:
[ R_943 ;
    if ((((action ==##Insert) &&  (actor==player) && ((noun ofclass K2_thing)) && ((second == I138_small_gold_box) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_943, 943);
    ! [1: if the box is closed begin]
    if ((((Adj_75_t1_v10(I138_small_gold_box))))){
        ! [2: say ~You'd need to open the box to do that.~]
        say__p=1;ParaContent(); print "You'd need to open the box to do that."; new_line; .L_Say28; .L_SayX28;
        ! [3: otherwise if the player does not carry the noun]
        } else if (((~~((player == CarrierOf(noun)))))) {
        ! [4: say ~You're not holding [the noun].~]
        say__p=1;ParaContent(); print "You're not holding ";ParaContent(); print (the) noun;ParaContent(); print "."; new_line; .L_Say29; .L_SayX29;
        ! [5: otherwise]
        } else {

        ! [6: say ~There's not room for [the noun] in the box.~]
        say__p=1;ParaContent(); print "There's not room for ";ParaContent(); print (the) noun;ParaContent(); print " in the box."; new_line; .L_Say30; .L_SayX30;
        ! [7: end if]
        }

        RulebookFails(); rtrue;
        } else if (debug_rules > 1) DB_Rule(R_943, 943, 'action');
        rfalse;
];
! From "Locksmith" by Emily Short
! No specific request
! Instead of putting something which is not a passkey on a keychain ( this is the limiting keychains rule ):
[ R_837 ;
    if ((((action ==##PutOn) &&  (actor==player) && ((noun ofclass K2_thing) && (~~((noun ofclass K16_passkey)))) && ((second ofclass K17_keychain))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_837, 837);
    ! [1: say ~[The noun] [are] not a key.~ ( a )]
    say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_136); new_line; .L_Say31; .L_SayX31;
    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_837, 837, 'action');
    rfalse;
];
! No specific request
! instead of player taking Bull Horn:
[ R_964 ;
    if ((((action ==##Take) &&  (actor==player) && ((noun == I308_bull_horn) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_964, 964);
    ! [1: say becomebull]
    say__p=1;ParaContent(); (PHR_985_r5 ()); .L_Say32; .L_SayX32;
    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_964, 964, 'action');
    rfalse;
];
! No specific request
! instead of player entering Storage Room:
[ R_967 ;
    if ((((action ==##Enter) &&  (actor==player) && ((noun == I346_storage_room) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_967, 967);
    ! [1: say ~Trixie turns to you and yells 'Hey, thats for employees only, you creep! What do you think you are doing?'~]
    say__p=1;ParaContent(); print "Trixie turns to you and yells ~Hey, thats for employees only, you creep! What do you think you are doing?~"; new_line; .L_Say33; .L_SayX33;
    ! [2: say storageroomchance]
    say__p=1;ParaContent(); (PHR_968_r6 ()); .L_Say34; .L_SayX34;
    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_967, 967, 'action');
    rfalse;
];
! No specific request
! Instead of searching a closed drawer:
[ R_949 ;
    if ((((action ==##Search) &&  (actor==player) && ((noun ofclass K23_drawer) && ((Adj_75_t1_v10(noun))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_949, 949);
    ! [1: try opening the noun]
    TryAction(0, player, ##Open, noun, 0);;
    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_949, 949, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: After (B23_after)
! ----------------------------------------------------------------------------------------------------
! Rule 1/7 ! After examining the desk for the first time:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 2/7 ! After opening an unexplored drawer when exactly one drawer is explored:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 3/7 ! After opening a drawer when no drawers are explored:
!   >>> I - Number of aspects constrained >>>
! Rule 4/7 ! After examining the Mysterious Door:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 5/7 ! After examining an identified passkey ( this is the passkey description rule ):
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 6/7 ! After closing a drawer:
!   >>> I - Number of aspects constrained >>>
! Rule 7/7 ! After looking ( this is the exit descriptions rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! After examining the desk for the first time:
[ R_948 ;
    if ((PAPR_0() && (((TimesActionHasHappened-->0) == 1) && (ActionCurrentlyHappeningFlag->0)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_948, 948);
    ! [1: say ~(You remember that weird object you put in one of the drawers, but you can't remember which one.)~]
    say__p=1;ParaContent(); print "(You remember that weird object you put in one of the drawers, but you can't remember which one.)"; new_line; .L_Say35; .L_SayX35;
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_948, 948, 'action');
    rfalse;
];
! No specific request
! After opening an unexplored drawer when exactly one drawer is explored:
[ R_951 ;
    if ((((action ==##Open) &&  (actor==player) && ((noun ofclass K23_drawer) && ((Adj_99_t1_v10(noun)))) && (self=actor,true) && ((((Prop_12()))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_951, 951);
    ! [1: now the noun is explored]
    (Adj_98_t2_v10(noun));
    ! [2: say ~You struggle to open this one a bit more quietly, conscious all the time of noise... but no, it's empty. Just stands to reason.~]
    say__p=1;ParaContent(); print "You struggle to open this one a bit more quietly, conscious all the time of noise... but no, it's empty. Just stands to reason."; new_line; .L_Say36; .L_SayX36;
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_951, 951, 'action');
    rfalse;
];
! No specific request
! After opening a drawer when no drawers are explored:
[ R_950 ;
    if ((((action ==##Open) &&  (actor==player) && ((noun ofclass K23_drawer)) && (self=actor,true) && ((((Prop_13()))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_950, 950);
    ! [1: now the noun is explored]
    (Adj_98_t2_v10(noun));
    ! [2: say ~There is a tremendous screech, but nothing whatsoever inside, not even dust.~]
    say__p=1;ParaContent(); print "There is a tremendous screech, but nothing whatsoever inside, not even dust."; new_line; .L_Say37; .L_SayX37;
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_950, 950, 'action');
    rfalse;
];
! No specific request
! After examining the Mysterious Door:
[ R_973 ;
    if ((((action ==##Examine) &&  (actor==player) && ((noun == I404_mysterious_door) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_973, 973);
    ! [1: now the command prompt is ~Please enter the password now. >~]
    BlkValueCopy((Global_Vars-->1), TX_L_439);
    ! [2: continue the action]
    rfalse;
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_973, 973, 'action');
    rfalse;
];
! From "Locksmith" by Emily Short
! No specific request
! After examining an identified passkey ( this is the passkey description rule ):
[ R_832 ;
    if ((((action ==##Examine) &&  (actor==player) && ((noun ofclass K16_passkey) && ((Adj_43_t1_v10(noun))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_832, 832);
    ! [1: say ~[The noun] [unlock] [the list of things unbolted by the noun].~ ( a )]
    say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_137); new_line; .L_Say38; .L_SayX38;
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_832, 832, 'action');
    rfalse;
];
! No specific request
! After closing a drawer:
[ R_952 ;
    if ((((action ==##Close) &&  (actor==player) && ((noun ofclass K23_drawer))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_952, 952);
    ! [1: say ~There is a racket of wood protesting against wood as you do so, which makes you wonder if you hadn't better just leave them open from now on. The unhappy owner is probably going to catch on soon enough anyway.~]
    say__p=1;ParaContent(); print "There is a racket of wood protesting against wood as you do so, which makes you wonder if you hadn't better just leave them open from now on. The unhappy owner is probably going to catch on soon enough anyway."; new_line; .L_Say39; .L_SayX39;
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_952, 952, 'action');
    rfalse;
];
! From "Exit Descriptions" by Matthew Fletcher
! No specific request
! After looking ( this is the exit descriptions rule ):
[ R_810 
    tmp_0 ! Let/loop value, e.g., '?-1,-1?'(deallocated by end of phrase)
    tmp_1 ! Let/loop value, e.g., '?-1,-1?'(deallocated by end of phrase)
    tmp_2 ! Let/loop value, e.g., '?-1,-1?'(deallocated by end of phrase)
    ;
    if ((((action ==##Look) &&  (actor==player)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_810, 810);
    ! [1: now the amount is the number of adjacent rooms]
    (Global_Vars-->10) = (Prop_14());
    ! [2: repeat with destination running through adjacent rooms begin]
    for (tmp_0=Prop_15(0), tmp_1=Prop_15(tmp_0): tmp_0: tmp_0=tmp_1, tmp_1=Prop_15(tmp_1)){
        ! [3: if the num is 0 , say ~[ExitsMessage]~]
        if ((((Global_Vars-->11) == 0))) { say__p=1;ParaContent(); print (TEXT_TY_Say) (Global_Vars-->12); .L_Say40; .L_SayX40; }
        ! [4: let the way be the best route from the location to the destination , using even locked doors]

        		tmp_2 = MapRouteTo(real_location,tmp_0,0,2);
        ! [5: if the way is a direction , say ~ [way]~]
        if (((tmp_2 ofclass K3_direction))) { say__p=1;ParaContent(); print " ";ParaContent(); print (PrintShortName) tmp_2; .L_Say41; .L_SayX41; }
        ! [6: if the destination is visited , say ~[ExitsToText] [the destination]~]
        if ((((Adj_53_t1_v10(tmp_0))))) { say__p=1;ParaContent(); print (TEXT_TY_Say) (Global_Vars-->14);ParaContent(); print " ";ParaContent(); print (the) tmp_0; .L_Say42; .L_SayX42; }
        ! [7: decrease the amount by 1]
        (Global_Vars-->10) = (Global_Vars-->10) - 1;;
        ! [8: increase the num by 1]
        (Global_Vars-->11) = (Global_Vars-->11) + 1;;
        ! [9: if the amount is 0 , say ~.~]
        if ((((Global_Vars-->10) == 0))) { say__p=1;ParaContent(); print "."; new_line; .L_Say43; .L_SayX43; }
        ! [10: if the amount is 1 , say ~[ExitsAndText]~]
        if ((((Global_Vars-->10) == 1))) { say__p=1;ParaContent(); print (TEXT_TY_Say) (Global_Vars-->13); .L_Say44; .L_SayX44; }
        ! [11: if the amount is greater than 1 , say ~,~]
        if ((((Global_Vars-->10) > 1))) { say__p=1;ParaContent(); print ","; .L_Say45; .L_SayX45; }
        ! [12: end repeat]
        }

    ! [13: now the amount is 0]
    (Global_Vars-->10) = 0;
    ! [14: now the num is 0]
    (Global_Vars-->11) = 0;
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_810, 810, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: does the player mean (B25_does_the_player_mean)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Does the player mean taking something which is carried by the player ( this is the very unlikely to mean taking what's already carried rule ):
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 2/2 ! Does the player mean taking off something worn:
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Does the player mean taking something which is carried by the player ( this is the very unlikely to mean taking what's already carried rule ):
[ R_38 ;
    if ((((action ==##Take) &&  (actor==player) && ((noun ofclass K2_thing) && (player == CarrierOf(noun)))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_38, 38);
    ! [1: it is very unlikely]
    RulebookSucceeds(22, RBNO_10); rtrue;

    } else if (debug_rules > 1) DB_Rule(R_38, 38, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Does the player mean taking off something worn:
[ R_240 ;
    if ((((action ==##Disrobe) &&  (actor==player) && ((noun ofclass K2_thing) && ((Adj_0_t1_v10(noun))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_240, 240);
    ! [1: it is very likely]
    RulebookSucceeds(22, RBNO_6); rtrue;

    } else if (debug_rules > 1) DB_Rule(R_240, 240, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: before Printing the name (B28_before_printing_the_name)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Before printing the name of a thing ( called the item being printed ) ( this is the make named things mentioned rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Before printing the name of a thing ( called the item being printed ) ( this is the make named things mentioned rule ):
[ R_66 
    tmp_0 ! Let/loop value, e.g., 'item being printed': thing
    ;
    if ((((tmp_0 = parameter_value, (((tmp_0=(parameter_value), true) && (parameter_value ofclass K2_thing))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_66, 66);
    ! [1: if expanding text for comparison purposes , continue the activity]
    if ((say__comp)) { rfalse; }
    ! [2: now the item being printed is mentioned]
    (Adj_69_t2_v10(tmp_0));
    } else if (debug_rules > 1) DB_Rule(R_66, 66, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: after Printing the name (B30_after_printing_the_name)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! After printing the name of an identified passkey ( called the item ) while taking inventory ( this is the identify passkeys in inventory rule ):
!   >>> I - Number of aspects constrained >>>
! Rule 2/3 ! After printing the name of an ambiguously plural thing ( called the suspect ):
!   >>> III.1 - Object To Which Rule Applies >>>
! Rule 3/3 ! After printing the name of something ( called the target ):
! ----------------------------------------------------------------------------------------------------
! From "Locksmith" by Emily Short
! No specific request
! After printing the name of an identified passkey ( called the item ) while taking inventory ( this is the identify passkeys in inventory rule ):
[ R_831 
    tmp_0 ! Let/loop value, e.g., 'item': passkey
    ;
    if ((((tmp_0 = parameter_value, (((tmp_0=(parameter_value), true) && (parameter_value ofclass K16_passkey) && ((Adj_43_t1_v10(parameter_value))))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (((((((action ==##Inv) &&  (actor==player))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_831, 831);
    ! [1: now the prior named object is the item]
    prior_named_noun = tmp_0;
    ! [2: say ~ (which [open] [the list of things unbolted by the item])~ ( a )]
    say__p=1;ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),TX_R_138); .L_Say46; .L_SayX46;
    } else if (debug_rules > 1) DB_Rule(R_831, 831, 'context');
    } else if (debug_rules > 1) DB_Rule(R_831, 831, 'action');
    rfalse;
];
! From "Plurality" by Emily Short
! No specific request
! After printing the name of an ambiguously plural thing ( called the suspect ):
[ R_888 
    tmp_0 ! Let/loop value, e.g., 'suspect': thing
    ;
    if ((((tmp_0 = parameter_value, (((tmp_0=(parameter_value), true) && (parameter_value ofclass K2_thing) && ((Adj_48_t1_v10(parameter_value))))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_888, 888);
    ! [1: if the manual pronouns option is active , do nothing]
    if ((((Adj_25_t1_v16(16))))) { ; }
    ! [2: otherwise notice the plurality of the suspect]
    else { PlugPlural(tmp_0); }
    } else if (debug_rules > 1) DB_Rule(R_888, 888, 'action');
    rfalse;
];
! From "Plurality" by Emily Short
! No specific request
! After printing the name of something ( called the target ):
[ R_846 
    tmp_0 ! Let/loop value, e.g., 'target': thing
    ;
    if ((((tmp_0 = parameter_value, (((tmp_0=(parameter_value), true) && (parameter_value ofclass K2_thing))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_846, 846);
    ! [1: mark target in output]
    (PHR_847_r7 (tmp_0));
    } else if (debug_rules > 1) DB_Rule(R_846, 846, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Printing the plural name (B32_for_printing_the_plural_)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Rule for printing the plural name of something ( called the item ) ( this is the standard printing the plural name rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Rule for printing the plural name of something ( called the item ) ( this is the standard printing the plural name rule ):
[ R_67 
    tmp_0 ! Let/loop value, e.g., 'item': thing
    ;
    if ((((tmp_0 = parameter_value, (((tmp_0=(parameter_value), true) && (parameter_value ofclass K2_thing))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_67, 67);
    ! [1: say the printed plural name of the item]
    @push self; say__p=1;ParaContent(); print (TEXT_TY_Say) GProperty(10, self=tmp_0,plural); .L_Say47; .L_SayX47;@pull self; 
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_67, 67, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Printing a number (B35_for_printing_a_number)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Rule for printing a number of something ( called the item ) ( this is the standard printing a number of something rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Rule for printing a number of something ( called the item ) ( this is the standard printing a number of something rule ):
[ R_68 
    tmp_0 ! Let/loop value, e.g., 'item': thing
    ;
    if ((((tmp_0 = parameter_value, (((tmp_0=(parameter_value), true) && (parameter_value ofclass K2_thing))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_68, 68);
    ! [1: say ~[listing group size in words] ~]
    say__p=1;ParaContent(); print (number) say__n=(listing_size);ParaContent(); print " "; .L_Say48; .L_SayX48;
    ! [2: carry out the printing the plural name activity with the item]
    CarryOutActivity(V1_printing_the_plural_name, tmp_0);
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_68, 68, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Printing the announcement of light (B65_for_printing_the_announc)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! This is the look around once light available rule:
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! This is the look around once light available rule:
[ R_69 ;
    if (debug_rules) DB_Rule(R_69, 69);
    ! [1: try looking]
    TryAction(0, player, ##Look, 0, 0);;
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Constructing the status line (B71_for_constructing_the_sta)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Rule for constructing the status line while displaying ( this is the constructing status line while displaying rule ):
! ----------------------------------------------------------------------------------------------------
! From "Menus" by Emily Short
! No specific request
! Rule for constructing the status line while displaying ( this is the constructing status line while displaying rule ):
[ R_900 ;
    if (((TestActivity(V35_displaying)))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_900, 900);
    ! [1: if the endnode flag is 0 , fill status bar with table of deep menu status]
    if ((((Global_Vars-->17) == 0))) { (PHR_921_r8 (T5_deep_menu_status)); }
    ! [2: otherwise fill status bar with table of shallow menu status]
    else { (PHR_921_r8 (T4_shallow_menu_status)); }
    ! [3: rule succeeds]
    RulebookSucceeds(); rtrue;
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_900, 900, 'context');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Printing the banner text (B74_for_printing_the_banner_)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Rule for printing the banner text:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Rule for printing the banner text:
[ R_942 ;
    if (debug_rules) DB_Rule(R_942, 942);
    ! [1: say ~[bold type]The End of the World: TF Series: Witches Coven, a prequel to the original End of the World Twine game. [paragraph break][italic type]by The Loveable Wendigo.[paragraph break][paragraph break][roman type]~]
    say__p=1;ParaContent(); style bold;ParaContent(); print "The End of the World: TF Series: Witches Coven, a prequel to the original End of the World Twine game. ";ParaContent(); DivideParagraphPoint(); new_line;ParaContent(); style underline;ParaContent(); print "by The Loveable Wendigo.";ParaContent(); DivideParagraphPoint(); new_line;ParaContent(); DivideParagraphPoint(); new_line;ParaContent(); style roman; .L_Say49; .L_SayX49;
    ! [2: say the story headline]
    say__p=1;ParaContent(); print (TEXT_TY_Say) TX_L_3; .L_Say50; .L_SayX50;
    RulebookSucceeds(); rtrue;
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: after Reading a command (B78_after_reading_a_command)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! After reading a command when the gender of the player is unknown:
!   === equally specific with ===
! Rule 2/3 ! After reading a command when the command prompt is ~Please enter the password now. >~:
!   === equally specific with ===
! Rule 3/3 ! After reading a command when the command prompt is ~Would you like to try again? (Yes or No) >~:
! ----------------------------------------------------------------------------------------------------
! No specific request
! After reading a command when the gender of the player is unknown:
[ R_936 ;
    if ((((((GProperty(10, player,p62_gender) == I130_unknown)))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_936, 936);
    ! [1: if the player's command includes ~[gender]~ begin]
    if (((matched_text=SnippetIncludes(Consult_Grammar_104,players_command)))){
        ! [2: now the gender of the player is the gender understood]
        WriteGProperty(10, player,p62_gender,parsed_number);
        ! [3: if the gender of the player is unknown begin]
        if (((GProperty(10, player,p62_gender) == I130_unknown))){
            ! [4: say ~This story requires a selection of male or female. [run paragraph on]~]
            say__p=1;ParaContent(); print "This story requires a selection of male or female. ";ParaContent(); RunParagraphOn(); .L_Say51; .L_SayX51;
            ! [5: reject the player's command]
            RulebookFails(); rtrue;
            ! [6: end if]
            }

        ! [7: if the gender of the player is masculine , now the player is male]
        if (((GProperty(10, player,p62_gender) == I128_masculine))) { (Adj_82_t2_v10(player)); }
        ! [8: if the gender of the player is feminine , now the player is female]
        if (((GProperty(10, player,p62_gender) == I129_feminine))) { (Adj_81_t2_v10(player)); }
        ! [9: say ~[line break]Thank you. We now begin...~]
        say__p=1;ParaContent(); new_line;ParaContent(); print "Thank you. We now begin..."; new_line; .L_Say52; .L_SayX52;
        ! [10: say ~[pause_clear]Ah well how to start.. well this is your head.  Yep, that's right, you.  And you've been living in this city for quite a while.  Of course, there's not much to say about you, as you already know, and are starting to wonder why you are saying all this to yourself in your head. [pause_clear]^^Welp, might as well give yourself a quick summary of the days events if you're gonna be crazy like this.  Hmmm lets think.. well nothing out of the ordinary happened, UNTIL like right now.  Because you chose to work out for once by jogging like a normal out of shape person through the city park, and got lost.  And then something decided to just shoot out of the sky, or appear out of nowhere or something else that makes someone whos still saying this in their head seem even crazier.[pause_clear]^^Anyways, the second that dropped out of the sky you could hear stranges noises and cries throughout the city. Which is never a good sign.  Coupled with the horrible uneasy feeling you have had in your stomach since, well... to look at it positively it may have been nice that you got lost in the city park.^^Okay, time to get some stuff done, like finding a way out so you can at least see what's happened.  You start at a determined pace again, weaving down the path you SWEAR you've been down before.  The bend up ahead is different though... something is casting flickering light against the nearby trees as you get closer and closer.[pause_clear]~]
        say__p=1;ParaContent(); (PHR_928_r9 ());ParaContent(); print "Ah well how to start.. well this is your head.  Yep, that's right, you.  And you've been living in this city for quite a while.  Of course, there's not much to say about you, as you already know, and are starting to wonder why you are saying all this to yourself in your head. ";ParaContent(); (PHR_928_r9 ());ParaContent(); print "^^Welp, might as well give yourself a quick summary of the days events if you're gonna be crazy like this.  Hmmm lets think.. well nothing out of the ordinary happened, UNTIL like right now.  Because you chose to work out for once by jogging like a normal out of shape person through the city park, and got lost.  And then something decided to just shoot out of the sky, or appear out of nowhere or something else that makes someone whos still saying this in their head seem even crazier."; new_line;ParaContent(); (PHR_928_r9 ());ParaContent(); print "^^Anyways, the second that dropped out of the sky you could hear stranges noises and cries throughout the city. Which is never a good sign.  Coupled with the horrible uneasy feeling you have had in your stomach since, well... to look at it positively it may have been nice that you got lost in the city park.^^Okay, time to get some stuff done, like finding a way out so you can at least see what's happened.  You start at a determined pace again, weaving down the path you SWEAR you've been down before.  The bend up ahead is different though... something is casting flickering light against the nearby trees as you get closer and closer."; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say53; .L_SayX53;
        ! [11: now the command prompt is ~>~]
        BlkValueCopy((Global_Vars-->1), TX_L_413);
        ! [12: move the player to city park]
        MoveObject(player, I140_city_park, 0, false);
        ! [13: reject the player's command]
        RulebookFails(); rtrue;
        ! [14: otherwise]
        } else {

        ! [15: say ~Sorry, we're not ready to go on yet. [run paragraph on]~]
        say__p=1;ParaContent(); print "Sorry, we're not ready to go on yet. ";ParaContent(); RunParagraphOn(); .L_Say54; .L_SayX54;
        ! [16: reject the player's command]
        RulebookFails(); rtrue;
        ! [17: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_936, 936, 'context');
        rfalse;
];
! No specific request
! After reading a command when the command prompt is ~Please enter the password now. >~:
[ R_974 ;
    if (((((( BlkValueCompare((Global_Vars-->1), TX_L_439) == 0)))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_974, 974);
    ! [1: increment the turn count]
    turns = turns + 1;;
    ! [2: if the player's command matches ~Change is the root of all creation~ begin]
    if (((SnippetMatches(players_command, Consult_Grammar_105)))){
        ! [3: now the mysterious door is unlocked]
        (Adj_80_t2_v10(I404_mysterious_door));
        ! [4: say ~*CRRRRRRRREEEEEERRRRR*  You can feel a trembling as if a massive stone was moving.^^You have unlocked the Mysterious Door.~]
        say__p=1;ParaContent(); print "*CRRRRRRRREEEEEERRRRR*  You can feel a trembling as if a massive stone was moving.^^You have unlocked the Mysterious Door."; new_line; .L_Say55; .L_SayX55;
        ! [5: now the command prompt is ~>~]
        BlkValueCopy((Global_Vars-->1), TX_L_413);
        ! [6: otherwise]
        } else {

        ! [7: say ~The Mysterious Door remains closed.~]
        say__p=1;ParaContent(); print "The Mysterious Door remains closed."; new_line; .L_Say56; .L_SayX56;
        ! [8: now the command prompt is ~Would you like to try again? (Yes or No) >~]
        BlkValueCopy((Global_Vars-->1), TX_L_440);
        ! [9: end if]
        }

    ! [10: reject the player's command]
    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_974, 974, 'context');
    rfalse;
];
! No specific request
! After reading a command when the command prompt is ~Would you like to try again? (Yes or No) >~:
[ R_975 ;
    if (((((( BlkValueCompare((Global_Vars-->1), TX_L_440) == 0)))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_975, 975);
    ! [1: if the player's command matches ~yes~ or the player's command matches ~y~ begin]
    if ((((SnippetMatches(players_command, Consult_Grammar_106)))) || (((SnippetMatches(players_command, Consult_Grammar_107))))){
        ! [2: now the command prompt is ~Please enter the password now. >~]
        BlkValueCopy((Global_Vars-->1), TX_L_439);
        ! [3: say line break]
        say__p=1;ParaContent(); new_line; .L_Say57; .L_SayX57;
        ! [4: say run paragraph on]
        say__p=1;ParaContent(); RunParagraphOn(); .L_Say58; .L_SayX58;
        ! [5: reject the player's command]
        RulebookFails(); rtrue;
        ! [6: end if]
        }

    ! [7: if the player's command matches ~no~ or the player's command matches ~n~ begin]
    if ((((SnippetMatches(players_command, Consult_Grammar_108)))) || (((SnippetMatches(players_command, Consult_Grammar_109))))){
        ! [8: now the command prompt is ~>~]
        BlkValueCopy((Global_Vars-->1), TX_L_413);
        ! [9: say line break]
        say__p=1;ParaContent(); new_line; .L_Say59; .L_SayX59;
        ! [10: say run paragraph on]
        say__p=1;ParaContent(); RunParagraphOn(); .L_Say60; .L_SayX60;
        ! [11: reject the player's command]
        RulebookFails(); rtrue;
        ! [12: otherwise]
        } else {

        ! [13: say line break]
        say__p=1;ParaContent(); new_line; .L_Say61; .L_SayX61;
        ! [14: say run paragraph on]
        say__p=1;ParaContent(); RunParagraphOn(); .L_Say62; .L_SayX62;
        ! [15: reject the player's command]
        RulebookFails(); rtrue;
        ! [16: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_975, 975, 'context');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Deciding whether all includes (B86_for_deciding_whether_all)
! ----------------------------------------------------------------------------------------------------
! Rule 1/5 ! Rule for deciding whether all includes a person while dropping or throwing or inserting or putting ( this is the exclude people from drop all rule ):
!   >>> III - When/while requirement >>>
! Rule 2/5 ! Rule for deciding whether all includes scenery while taking or taking off or removing ( this is the exclude scenery from take all rule ):
!   >>> III.1 - Object To Which Rule Applies >>>
! Rule 3/5 ! Rule for deciding whether all includes fixed in place things while taking or taking off or removing ( this is the exclude fixed in place things from take all rule ):
!   >>> III.1 - Object To Which Rule Applies >>>
! Rule 4/5 ! Rule for deciding whether all includes people while taking or taking off or removing ( this is the exclude people from take all rule ):
!   >>> I - Number of aspects constrained >>>
! Rule 5/5 ! Rule for deciding whether all includes passkeys which are on a keychain ( this is the don't strip keys rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Rule for deciding whether all includes a person while dropping or throwing or inserting or putting ( this is the exclude people from drop all rule ):
[ R_73 ;
    if (((((parameter_value ofclass K8_person))))) { ! Runs only when pattern matches
    if (((((((action ==##Drop) &&  (actor==player))))) || (((((action ==##ThrowAt) &&  (actor==player))))) || (((((action ==##Insert) &&  (actor==player))))) || (((((action ==##PutOn) &&  (actor==player))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_73, 73);
    ! [1: it does not]
    RulebookFails(22, RBNO_11); rtrue;

    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_73, 73, 'context');
    } else if (debug_rules > 1) DB_Rule(R_73, 73, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Rule for deciding whether all includes scenery while taking or taking off or removing ( this is the exclude scenery from take all rule ):
[ R_70 ;
    if ((((((Adj_61_t1_v10(parameter_value))) && (true))))) { ! Runs only when pattern matches
    if (((((((action ==##Take) &&  (actor==player))))) || (((((action ==##Disrobe) &&  (actor==player))))) || (((((action ==##Remove) &&  (actor==player))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_70, 70);
    ! [1: it does not]
    RulebookFails(22, RBNO_11); rtrue;

    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_70, 70, 'context');
    } else if (debug_rules > 1) DB_Rule(R_70, 70, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Rule for deciding whether all includes fixed in place things while taking or taking off or removing ( this is the exclude fixed in place things from take all rule ):
[ R_72 ;
    if (((((parameter_value ofclass K2_thing) && ((Adj_59_t1_v10(parameter_value))))))) { ! Runs only when pattern matches
    if (((((((action ==##Take) &&  (actor==player))))) || (((((action ==##Disrobe) &&  (actor==player))))) || (((((action ==##Remove) &&  (actor==player))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_72, 72);
    ! [1: it does not]
    RulebookFails(22, RBNO_11); rtrue;

    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_72, 72, 'context');
    } else if (debug_rules > 1) DB_Rule(R_72, 72, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Rule for deciding whether all includes people while taking or taking off or removing ( this is the exclude people from take all rule ):
[ R_71 ;
    if (((((parameter_value ofclass K8_person))))) { ! Runs only when pattern matches
    if (((((((action ==##Take) &&  (actor==player))))) || (((((action ==##Disrobe) &&  (actor==player))))) || (((((action ==##Remove) &&  (actor==player))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_71, 71);
    ! [1: it does not]
    RulebookFails(22, RBNO_11); rtrue;

    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_71, 71, 'context');
    } else if (debug_rules > 1) DB_Rule(R_71, 71, 'action');
    rfalse;
];
! From "Locksmith" by Emily Short
! No specific request
! Rule for deciding whether all includes passkeys which are on a keychain ( this is the don't strip keys rule ):
[ R_839 ;
    if (((((parameter_value ofclass K16_passkey) && (SupporterOf(parameter_value) ofclass K17_keychain))))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_839, 839);
    ! [1: if the second noun is not a keychain , it does not]
    if (((~~((second ofclass K17_keychain))))) { RulebookFails(22, RBNO_11); rtrue;
     }
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_839, 839, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Supplying a missing noun (B98_for_supplying_a_missing_)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! Rule for supplying a missing noun while an actor smelling ( this is the ambient odour rule ):
!   === equally specific with ===
! Rule 2/4 ! Rule for supplying a missing noun while an actor listening ( this is the ambient sound rule ):
!   === equally specific with ===
! Rule 3/4 ! Rule for supplying a missing noun while an actor going ( this is the block vaguely going rule ):
! --- now the last-placed rules ---
! Rule 4/4 ! Rule for supplying a missing noun while entering ( this is the find what to enter rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Rule for supplying a missing noun while an actor smelling ( this is the ambient odour rule ):
[ R_74 ;
    if (((((((action ==##Smell) && (act_requester==nothing))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_74, 74);
    ! [1: now the noun is the touchability ceiling of the player]
    noun = TouchabilityCeiling(player);
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_74, 74, 'context');
    rfalse;
];
! From the Standard Rules
! No specific request
! Rule for supplying a missing noun while an actor listening ( this is the ambient sound rule ):
[ R_75 ;
    if (((((((action ==##Listen) && (act_requester==nothing))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_75, 75);
    ! [1: now the noun is the touchability ceiling of the player]
    noun = TouchabilityCeiling(player);
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_75, 75, 'context');
    rfalse;
];
! From the Standard Rules
! No specific request
! Rule for supplying a missing noun while an actor going ( this is the block vaguely going rule ):
[ R_76 ;
    if (((((((action ==##Go) && (act_requester==nothing))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_76, 76);
    ! [1: say ~You'll have to say which compass direction to go in.~ ( a )]
    say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_139); new_line; .L_Say63; .L_SayX63;
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_76, 76, 'context');
    rfalse;
];
! From the Standard Rules
! No specific request
! Rule for supplying a missing noun while entering ( this is the find what to enter rule ):
[ R_160 
    tmp_0 ! Let/loop value, e.g., 'box': thing
    ;
    if (((((((action ==##Enter) &&  (actor==player))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_160, 160);
    ! [1: if something enterable ( called the box ) is in the location , now the noun is the box]
    if ((((Prop_16() && (tmp_0=deferred_calling_list-->0, true)) || (tmp_0 = 0,false)))) { noun = tmp_0; }
    ! [2: otherwise continue the activity]
    else { rfalse; }
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_160, 160, 'context');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: before Handling the final question (B115_before_handling_the_fin)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! This is the print the final question rule:
!   === equally specific with ===
! Rule 2/3 ! This is the print the final prompt rule:
! --- now the last-placed rules ---
! Rule 3/3: READ_FINAL_ANSWER_R
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! This is the print the final question rule:
[ R_78 
    tmp_0 ! Let/loop value, e.g., 'named options count': number
    tmp_1 ! Let/loop value, e.g., '?-1,-1?'(deallocated by end of phrase)
    tmp_2 ! Let/loop value, e.g., '?-1,-1?'(deallocated by end of phrase)
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    if (debug_rules) DB_Rule(R_78, 78);
    ! [1: let named options count be 0]

    		tmp_0 = 0;
    ! [2: repeat through the table of final question options begin]
    @push ct_0; @push ct_1;
    		for (tmp_1=T0_final_question_options, tmp_2=1, ct_0=tmp_1, ct_1=tmp_2:
    			tmp_2<=TableRows(tmp_1):
    			tmp_2++, ct_0=tmp_1, ct_1=tmp_2)
    			if (TableRowIsBlank(ct_0, ct_1)==false){
        ! [3: if the only if victorious entry is false or the story has ended finally begin]
        if (((((TableLookUpEntry(ct_0,101,ct_1) && true) == (0 && true)))) || (((story_complete)))){
            ! [4: if there is a final response rule entry or the final response activity entry is not empty begin]
            if ((((ExistsTableLookUpEntry(ct_0,103,ct_1)))) || (((~~(((Adj_17_t1_v32(TableLookUpEntry(ct_0,104,ct_1))))))))){
                ! [5: if there is a final question wording entry , increase named options count by 1]
                if (((ExistsTableLookUpEntry(ct_0,100,ct_1)))) { tmp_0 = tmp_0 + 1;; }
                ! [6: end if]
                }

            ! [7: end if]
            }

        ! [8: end repeat]
        }
        @pull ct_1; @pull ct_0;
    ! [9: if the named options count is less than 1 , abide by the immediately quit rule]
    if (((tmp_0 < 1))) { if (FollowRulebook(IMMEDIATELY_QUIT_R)) rtrue; }
    ! [10: say ~Would you like to ~ ( a )]
    say__p=1;ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=ct_0),(LocalParking-->2=ct_1),(LocalParking-->3=tmp_1),(LocalParking-->4=tmp_2),TX_R_140); .L_Say64; .L_SayX64;
    ! [11: repeat through the table of final question options begin]
    @push ct_0; @push ct_1;
    		for (tmp_1=T0_final_question_options, tmp_2=1, ct_0=tmp_1, ct_1=tmp_2:
    			tmp_2<=TableRows(tmp_1):
    			tmp_2++, ct_0=tmp_1, ct_1=tmp_2)
    			if (TableRowIsBlank(ct_0, ct_1)==false){
        ! [12: if the only if victorious entry is false or the story has ended finally begin]
        if (((((TableLookUpEntry(ct_0,101,ct_1) && true) == (0 && true)))) || (((story_complete)))){
            ! [13: if there is a final response rule entry or the final response activity entry is not empty begin]
            if ((((ExistsTableLookUpEntry(ct_0,103,ct_1)))) || (((~~(((Adj_17_t1_v32(TableLookUpEntry(ct_0,104,ct_1))))))))){
                ! [14: if there is a final question wording entry begin]
                if (((ExistsTableLookUpEntry(ct_0,100,ct_1)))){
                    ! [15: say final question wording entry]
                    say__p=1;ParaContent(); print (TEXT_TY_Say) TableLookUpEntry(ct_0,100,ct_1); .L_Say65; .L_SayX65;
                    ! [16: decrease named options count by 1]
                    tmp_0 = tmp_0 - 1;;
                    ! [17: if the named options count is 1 begin]
                    if (((tmp_0 == 1))){
                        ! [18: if the serial comma option is active , say ~,~]
                        if ((((Adj_25_t1_v16(6))))) { say__p=1;ParaContent(); print ","; .L_Say66; .L_SayX66; }
                        ! [19: say ~ or ~ ( b )]
                        say__p=1;ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=ct_0),(LocalParking-->2=ct_1),(LocalParking-->3=tmp_1),(LocalParking-->4=tmp_2),TX_R_141); .L_Say67; .L_SayX67;
                        ! [20: otherwise if the named options count is 0]
                        } else if (((tmp_0 == 0))) {
                        ! [21: say ~?[line break]~]
                        say__p=1;ParaContent(); print "?";ParaContent(); new_line; .L_Say68; .L_SayX68;
                        ! [22: otherwise]
                        } else {

                        ! [23: say ~, ~]
                        say__p=1;ParaContent(); print ", "; .L_Say69; .L_SayX69;
                        ! [24: end if]
                        }

                    ! [25: end if]
                    }

                ! [26: end if]
                }

            ! [27: end if]
            }

        ! [28: end repeat]
        }
        @pull ct_1; @pull ct_0;
        rfalse;
];
! From the Standard Rules
! No specific request
! This is the print the final prompt rule:
[ R_77 ;
    if (debug_rules) DB_Rule(R_77, 77);
    ! [1: say ~> [run paragraph on]~ ( a )]
    say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_142); .L_Say70; .L_SayX70;
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Handling the final question (B116_for_handling_the_final_)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! This is the standard respond to final question rule:
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! This is the standard respond to final question rule:
[ R_79 
    tmp_0 ! Let/loop value, e.g., '?-1,-1?'(deallocated by end of phrase)
    tmp_1 ! Let/loop value, e.g., '?-1,-1?'(deallocated by end of phrase)
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    if (debug_rules) DB_Rule(R_79, 79);
    ! [1: repeat through the table of final question options begin]
    @push ct_0; @push ct_1;
    		for (tmp_0=T0_final_question_options, tmp_1=1, ct_0=tmp_0, ct_1=tmp_1:
    			tmp_1<=TableRows(tmp_0):
    			tmp_1++, ct_0=tmp_0, ct_1=tmp_1)
    			if (TableRowIsBlank(ct_0, ct_1)==false){
        ! [2: if the only if victorious entry is false or the story has ended finally begin]
        if (((((TableLookUpEntry(ct_0,101,ct_1) && true) == (0 && true)))) || (((story_complete)))){
            ! [3: if there is a final response rule entry or the final response activity entry is not empty begin]
            if ((((ExistsTableLookUpEntry(ct_0,103,ct_1)))) || (((~~(((Adj_17_t1_v32(TableLookUpEntry(ct_0,104,ct_1))))))))){
                ! [4: if the player's command matches the topic entry begin]
                if (((SnippetMatches(players_command, TableLookUpEntry(ct_0,102,ct_1))))){
                    ! [5: if there is a final response rule entry , abide by final response rule entry]
                    if (((ExistsTableLookUpEntry(ct_0,103,ct_1)))) { if (FollowRulebook(TableLookUpEntry(ct_0,103,ct_1))) rtrue; }
                    ! [6: otherwise carry out the final response activity entry activity]
                    else { CarryOutActivity(TableLookUpEntry(ct_0,104,ct_1)); }
                    ! [7: rule succeeds]
                    RulebookSucceeds(); rtrue;
                    ! [8: end if]
                    }

                ! [9: end if]
                }

            ! [10: end if]
            }

        ! [11: end repeat]
        }
        @pull ct_1; @pull ct_0;
    ! [12: say ~Please give one of the answers above.~ ( a )]
    say__p=1;ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=ct_0),(LocalParking-->1=ct_1),(LocalParking-->2=tmp_0),(LocalParking-->3=tmp_1),TX_R_143); new_line; .L_Say71; .L_SayX71;
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: before Printing the locale description (B118_before_printing_the_loc)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Before printing the locale description ( this is the initialise locale description rule ):
!   === equally specific with ===
! Rule 2/2 ! Before printing the locale description ( this is the find notable locale objects rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Before printing the locale description ( this is the initialise locale description rule ):
[ R_82 
    tmp_0 ! Let/loop value, e.g., '?-1,-1?'(deallocated by end of phrase)
    tmp_1 ! Let/loop value, e.g., '?-1,-1?'(deallocated by end of phrase)
    ct_0 ! internal use only
    ct_1 ! internal use only
    ;
    if (debug_rules) DB_Rule(R_82, 82);
    ! [1: now the locale paragraph count is 0]
    (Global_Vars-->9) = 0;
    ! [2: repeat through the table of locale priorities begin]
    @push ct_0; @push ct_1;
    		for (tmp_0=T1_locale_priorities, tmp_1=1, ct_0=tmp_0, ct_1=tmp_1:
    			tmp_1<=TableRows(tmp_0):
    			tmp_1++, ct_0=tmp_0, ct_1=tmp_1)
    			if (TableRowIsBlank(ct_0, ct_1)==false){
        ! [3: blank out the whole row]
        TableBlankOutRow(ct_0, ct_1);
        ! [4: end repeat]
        }
        @pull ct_1; @pull ct_0;
        rfalse;
];
! From the Standard Rules
! No specific request
! Before printing the locale description ( this is the find notable locale objects rule ):
[ R_83 
    tmp_0 ! Let/loop value, e.g., 'domain': object
    ;
    if (debug_rules) DB_Rule(R_83, 83);
    ! [1: let the domain be the parameter-object]

    		tmp_0 = parameter_value;
    ! [2: carry out the choosing notable locale objects activity with the domain]
    CarryOutActivity(V31_choosing_notable_locale_, tmp_0);
    ! [3: continue the activity]
    rfalse;
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Printing the locale description (B119_for_printing_the_locale)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! For printing the locale description ( this is the interesting locale paragraphs rule ):
!   === equally specific with ===
! Rule 2/2 ! For printing the locale description ( this is the you-can-also-see rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! For printing the locale description ( this is the interesting locale paragraphs rule ):
[ R_84 
    tmp_0 ! Let/loop value, e.g., 'domain': object
    tmp_1 ! Let/loop value, e.g., '?-1,-1?'(deallocated by end of phrase)
    tmp_2 ! Let/loop value, e.g., '?-1,-1?'(deallocated by end of phrase)
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    if (debug_rules) DB_Rule(R_84, 84);
    ! [1: let the domain be the parameter-object]

    		tmp_0 = parameter_value;
    ! [2: sort the table of locale priorities in locale description priority order]
    TableSort(T1_locale_priorities, 106, 1);
    ! [3: repeat through the table of locale priorities begin]
    @push ct_0; @push ct_1;
    		for (tmp_1=T1_locale_priorities, tmp_2=1, ct_0=tmp_1, ct_1=tmp_2:
    			tmp_2<=TableRows(tmp_1):
    			tmp_2++, ct_0=tmp_1, ct_1=tmp_2)
    			if (TableRowIsBlank(ct_0, ct_1)==false){
        ! [4: carry out the printing a locale paragraph about activity with the notable-object entry]
        CarryOutActivity(V32_printing_a_locale_paragr, TableLookUpEntry(ct_0,105,ct_1));
        ! [5: end repeat]
        }
        @pull ct_1; @pull ct_0;
    ! [6: continue the activity]
    rfalse;
    RulebookSucceeds(); rtrue;
    rfalse;
];
! From the Standard Rules
! No specific request
! For printing the locale description ( this is the you-can-also-see rule ):
[ R_85 
    tmp_0 ! Let/loop value, e.g., 'domain': object
    tmp_1 ! Let/loop value, e.g., 'mentionable count': number
    tmp_2 ! Let/loop value, e.g., '?-1,-1?'(deallocated by end of phrase)
    tmp_3 ! Let/loop value, e.g., '?-1,-1?'(deallocated by end of phrase)
    tmp_4 ! Let/loop value, e.g., '?-1,-1?'(deallocated by end of phrase)
    tmp_5 ! Let/loop value, e.g., '?-1,-1?'(deallocated by end of phrase)
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    if (debug_rules) DB_Rule(R_85, 85);
    ! [1: let the domain be the parameter-object]

    		tmp_0 = parameter_value;
    ! [2: let the mentionable count be 0]

    		tmp_1 = 0;
    ! [3: repeat with item running through things begin]
    for (tmp_2=Prop_17(0), tmp_3=Prop_17(tmp_2): tmp_2: tmp_2=tmp_3, tmp_3=Prop_17(tmp_3)){
        ! [4: now the item is not marked for listing]
        (Adj_67_t3_v10(tmp_2));
        ! [5: end repeat]
        }

    ! [6: repeat through the table of locale priorities begin]
    @push ct_0; @push ct_1;
    		for (tmp_2=T1_locale_priorities, tmp_3=1, ct_0=tmp_2, ct_1=tmp_3:
    			tmp_3<=TableRows(tmp_2):
    			tmp_3++, ct_0=tmp_2, ct_1=tmp_3)
    			if (TableRowIsBlank(ct_0, ct_1)==false){
        ! [7: if the locale description priority entry is greater than 0 , now the notable-object entry is marked for listing]
        if (((TableLookUpEntry(ct_0,106,ct_1) > 0))) { (Adj_67_t2_v10(TableLookUpEntry(ct_0,105,ct_1))); }
        ! [8: increase the mentionable count by 1]
        tmp_1 = tmp_1 + 1;;
        ! [9: end repeat]
        }
        @pull ct_1; @pull ct_0;
    ! [10: if the mentionable count is greater than 0 begin]
    if (((tmp_1 > 0))){
        ! [11: repeat with item running through things begin]
        for (tmp_2=Prop_18(0), tmp_3=Prop_18(tmp_2): tmp_2: tmp_2=tmp_3, tmp_3=Prop_18(tmp_3)){
            ! [12: if the item is mentioned begin]
            if ((((Adj_69_t1_v10(tmp_2))))){
                ! [13: now the item is not marked for listing]
                (Adj_67_t3_v10(tmp_2));
                ! [14: end if]
                }

            ! [15: end repeat]
            }

        ! [16: begin the listing nondescript items activity with the domain]
        BeginActivity(V8_listing_nondescript_items, tmp_0);
        ! [17: if the number of marked for listing things is 0 begin]
        if ((((Prop_19()) == 0))){
            ! [18: abandon the listing nondescript items activity with the domain]
            AbandonActivity(V8_listing_nondescript_items, tmp_0);
            ! [19: otherwise]
            } else {

            ! [20: if handling the listing nondescript items activity with the domain begin]
            if (((~~(ForActivity(V8_listing_nondescript_items, tmp_0))))){
                ! [21: if the domain is the location begin]
                if (((tmp_0 == real_location))){
                    ! [22: say ~[We] ~ ( a )]
                    say__p=1;ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),(LocalParking-->3=tmp_3),(LocalParking-->4=ct_0),(LocalParking-->5=ct_1),TX_R_144); .L_Say72; .L_SayX72;
                    ! [23: otherwise if the domain is a supporter or the domain is an animal]
                    } else if ((((tmp_0 ofclass K6_supporter))) || (((tmp_0 ofclass K12_animal)))) {
                    ! [24: say ~On [the domain] [we] ~ ( b )]
                    say__p=1;ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),(LocalParking-->3=tmp_3),(LocalParking-->4=ct_0),(LocalParking-->5=ct_1),TX_R_145); .L_Say73; .L_SayX73;
                    ! [25: otherwise]
                    } else {

                    ! [26: say ~In [the domain] [we] ~ ( c )]
                    say__p=1;ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),(LocalParking-->3=tmp_3),(LocalParking-->4=ct_0),(LocalParking-->5=ct_1),TX_R_146); .L_Say74; .L_SayX74;
                    ! [27: end if]
                    }

                ! [28: if the locale paragraph count is greater than 0 begin]
                if ((((Global_Vars-->9) > 0))){
                    ! [29: say ~[can] also see ~ ( d )]
                    say__p=1;ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),(LocalParking-->3=tmp_3),(LocalParking-->4=ct_0),(LocalParking-->5=ct_1),TX_R_147); .L_Say75; .L_SayX75;
                    ! [30: otherwise]
                    } else {

                    ! [31: say ~[can] see ~ ( e )]
                    say__p=1;ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),(LocalParking-->3=tmp_3),(LocalParking-->4=ct_0),(LocalParking-->5=ct_1),TX_R_148); .L_Say76; .L_SayX76;
                    ! [32: end if]
                    }

                ! [33: let the common holder be nothing]

                		tmp_2 = nothing;
                ! [34: let contents form of list be true]

                		tmp_3 = 1;
                ! [35: repeat with list item running through marked for listing things begin]
                for (tmp_4=Prop_20(0), tmp_5=Prop_20(tmp_4): tmp_4: tmp_4=tmp_5, tmp_5=Prop_20(tmp_5)){
                    ! [36: if the holder of the list item is not the common holder begin]
                    if (((~~(((HolderOf(tmp_4)) == tmp_2))))){
                        ! [37: if the common holder is nothing , now the common holder is the holder of the list item]
                        if (((tmp_2 == nothing))) { tmp_2 = (HolderOf(tmp_4)); }
                        ! [38: otherwise now contents form of list is false]
                        else { tmp_3 = 0; }
                        ! [39: end if]
                        }

                    ! [40: if the list item is mentioned , now the list item is not marked for listing]
                    if ((((Adj_69_t1_v10(tmp_4))))) { (Adj_67_t3_v10(tmp_4)); }
                    ! [41: end repeat]
                    }

                ! [42: filter list recursion to unmentioned things]
                list_filter_routine = Prop_21;
                ! [43: if contents form of list is true and the common holder is not nothing , list the contents of the common holder , as a sentence , including contents , giving brief inventory information , tersely , not listing concealed items , listing marked items only]
                if (((((tmp_3 && true) == (1 && true)))) && (((~~((tmp_2 == nothing)))))) { WriteListFrom(child(tmp_2), 2776); }
                ! [44: otherwise say ~[a list of marked for listing things including contents]~]
                else { say__p=1;ParaContent(); objectloop(tmp_4 ofclass Object)
                			if (((tmp_4 ofclass K2_thing) && ((Adj_67_t1_v10(tmp_4)))))
                				give tmp_4 workflag2;
                			else
                				give tmp_4 ~workflag2;
                		WriteListOfMarkedObjects(ENGLISH_BIT+RECURSE_BIT+PARTINV_BIT+
                			TERSE_BIT+CONCEAL_BIT); .L_Say77; .L_SayX77; }
                ! [45: if the domain is the location , say ~ here~ ( f )]
                if (((tmp_0 == real_location))) { say__p=1;ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),(LocalParking-->3=tmp_3),(LocalParking-->4=ct_0),(LocalParking-->5=ct_1),(LocalParking-->6=tmp_4),(LocalParking-->7=tmp_5),TX_R_149); .L_Say78; .L_SayX78; }
                ! [46: say ~.[paragraph break]~]
                say__p=1;ParaContent(); print ".";ParaContent(); DivideParagraphPoint(); new_line; .L_Say79; .L_SayX79;
                ! [47: unfilter list recursion]
                list_filter_routine = 0;
                ! [48: end if]
                }

            ! [49: end the listing nondescript items activity with the domain]
            EndActivity(V8_listing_nondescript_items, tmp_0);
            ! [50: end if]
            }

        ! [51: end if]
        }

    ! [52: continue the activity]
    rfalse;
    RulebookSucceeds(); rtrue;
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Choosing notable locale objects (B122_for_choosing_notable_lo)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! For choosing notable locale objects ( this is the standard notable locale objects rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! For choosing notable locale objects ( this is the standard notable locale objects rule ):
[ R_86 
    tmp_0 ! Let/loop value, e.g., 'domain': object
    tmp_1 ! Let/loop value, e.g., 'held item': object
    ;
    if (debug_rules) DB_Rule(R_86, 86);
    ! [1: let the domain be the parameter-object]

    		tmp_0 = parameter_value;
    ! [2: let the held item be the first thing held by the domain]

    		tmp_1 = (child(tmp_0));
    ! [3: while the held item is a thing begin]
    while (((tmp_1 ofclass K2_thing))){
        ! [4: set the locale priority of the held item to 5]
        (PHR_81_r10 (tmp_1,5));
        ! [5: now the held item is the next thing held after the held item]
        tmp_1 = (sibling(tmp_1));
        ! [6: end while]
        }

    ! [7: continue the activity]
    rfalse;
    RulebookSucceeds(); rtrue;
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Printing a locale paragraph about (B125_for_printing_a_locale_p)
! ----------------------------------------------------------------------------------------------------
! Rule 1/8 ! For printing a locale paragraph about a supporter ( called the tabletop ) ( this is the initial appearance on supporters rule ):
!   >>> III.1 - Object To Which Rule Applies >>>
! Rule 2/8 ! For printing a locale paragraph about a thing ( called the item ) ( this is the don't mention player's supporter in room descriptions rule ):
!   === equally specific with ===
! Rule 3/8 ! For printing a locale paragraph about a thing ( called the item ) ( this is the don't mention scenery in room descriptions rule ):
!   === equally specific with ===
! Rule 4/8 ! For printing a locale paragraph about a thing ( called the item ) ( this is the don't mention undescribed items in room descriptions rule ):
!   === equally specific with ===
! Rule 5/8 ! For printing a locale paragraph about a thing ( called the item ) ( this is the set pronouns from items in room descriptions rule ):
!   === equally specific with ===
! Rule 6/8 ! For printing a locale paragraph about a thing ( called the item ) ( this is the offer items to writing a paragraph about rule ):
!   === equally specific with ===
! Rule 7/8 ! For printing a locale paragraph about a thing ( called the item ) ( this is the use initial appearance in room descriptions rule ):
!   === equally specific with ===
! Rule 8/8 ! For printing a locale paragraph about a thing ( called the item ) ( this is the describe what's on scenery supporters in room descriptions rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! For printing a locale paragraph about a supporter ( called the tabletop ) ( this is the initial appearance on supporters rule ):
[ R_93 
    tmp_0 ! Let/loop value, e.g., 'tabletop': supporter
    tmp_1 ! Let/loop value, e.g., '?-1,-1?'(deallocated by end of phrase)
    tmp_2 ! Let/loop value, e.g., '?-1,-1?'(deallocated by end of phrase)
    ;
    if ((((tmp_0 = parameter_value, (((tmp_0=(parameter_value), true) && (parameter_value ofclass K6_supporter))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_93, 93);
    ! [1: repeat with item running through not handled things on the tabletop which provide the property initial appearance begin]
    for (tmp_1=Prop_22(tmp_0,tmp_0,tmp_0,0), tmp_2=Prop_22(tmp_0,tmp_0,tmp_0,tmp_1): tmp_1: tmp_1=tmp_2, tmp_2=Prop_22(tmp_0,tmp_0,tmp_0,tmp_2)){
        ! [2: if the item is not a person and the initial appearance of the item is not ~~ begin]
        if ((((~~((tmp_1 ofclass K8_person))))) && (((~~(( BlkValueCompare(GProperty(10, tmp_1,initial), EMPTY_TEXT_VALUE) == 0)))))){
            ! [3: now the item is mentioned]
            (Adj_69_t2_v10(tmp_1));
            ! [4: say initial appearance of the item]
            @push self; say__p=1;ParaContent(); print (TEXT_TY_Say) GProperty(10, self=tmp_1,initial); .L_Say80; .L_SayX80;@pull self; 
            ! [5: say paragraph break]
            say__p=1;ParaContent(); DivideParagraphPoint(); new_line; .L_Say81; .L_SayX81;
            ! [6: end if]
            }

        ! [7: end repeat]
        }

    ! [8: continue the activity]
    rfalse;
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_93, 93, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! For printing a locale paragraph about a thing ( called the item ) ( this is the don't mention player's supporter in room descriptions rule ):
[ R_87 
    tmp_0 ! Let/loop value, e.g., 'item': thing
    ;
    if ((((tmp_0 = parameter_value, (((tmp_0=(parameter_value), true) && (parameter_value ofclass K2_thing))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_87, 87);
    ! [1: if the item encloses the player , set the locale priority of the item to 0]
    if (((IndirectlyContains(tmp_0,player)))) { (PHR_81_r10 (tmp_0,0)); }
    ! [2: continue the activity]
    rfalse;
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_87, 87, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! For printing a locale paragraph about a thing ( called the item ) ( this is the don't mention scenery in room descriptions rule ):
[ R_88 
    tmp_0 ! Let/loop value, e.g., 'item': thing
    ;
    if ((((tmp_0 = parameter_value, (((tmp_0=(parameter_value), true) && (parameter_value ofclass K2_thing))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_88, 88);
    ! [1: if the item is scenery , set the locale priority of the item to 0]
    if ((((Adj_61_t1_v10(tmp_0))))) { (PHR_81_r10 (tmp_0,0)); }
    ! [2: continue the activity]
    rfalse;
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_88, 88, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! For printing a locale paragraph about a thing ( called the item ) ( this is the don't mention undescribed items in room descriptions rule ):
[ R_89 
    tmp_0 ! Let/loop value, e.g., 'item': thing
    ;
    if ((((tmp_0 = parameter_value, (((tmp_0=(parameter_value), true) && (parameter_value ofclass K2_thing))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_89, 89);
    ! [1: if the item is undescribed begin]
    if ((((Adj_66_t1_v10(tmp_0))))){
        ! [2: set the locale priority of the item to 0]
        (PHR_81_r10 (tmp_0,0));
        ! [3: end if]
        }

    ! [4: continue the activity]
    rfalse;
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_89, 89, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! For printing a locale paragraph about a thing ( called the item ) ( this is the set pronouns from items in room descriptions rule ):
[ R_90 
    tmp_0 ! Let/loop value, e.g., 'item': thing
    ;
    if ((((tmp_0 = parameter_value, (((tmp_0=(parameter_value), true) && (parameter_value ofclass K2_thing))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_90, 90);
    ! [1: if the item is not mentioned , set pronouns from the item]
    if (((~~(((Adj_69_t1_v10(tmp_0))))))) { PronounNotice(tmp_0); }
    ! [2: continue the activity]
    rfalse;
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_90, 90, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! For printing a locale paragraph about a thing ( called the item ) ( this is the offer items to writing a paragraph about rule ):
[ R_91 
    tmp_0 ! Let/loop value, e.g., 'item': thing
    ;
    if ((((tmp_0 = parameter_value, (((tmp_0=(parameter_value), true) && (parameter_value ofclass K2_thing))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_91, 91);
    ! [1: if the item is not mentioned begin]
    if (((~~(((Adj_69_t1_v10(tmp_0))))))){
        ! [2: if a paragraph break is pending , say ~[conditional paragraph break]~]
        if (((say__p))) { say__p=1;ParaContent(); DivideParagraphPoint(); .L_Say82; .L_SayX82; }
        ! [3: carry out the writing a paragraph about activity with the item]
        CarryOutActivity(V7_writing_a_paragraph_about, tmp_0);
        ! [4: if a paragraph break is pending begin]
        if (((say__p))){
            ! [5: increase the locale paragraph count by 1]
            (Global_Vars-->9) = (Global_Vars-->9) + 1;;
            ! [6: now the item is mentioned]
            (Adj_69_t2_v10(tmp_0));
            ! [7: say ~[conditional paragraph break]~]
            say__p=1;ParaContent(); DivideParagraphPoint(); .L_Say83; .L_SayX83;
            ! [8: end if]
            }

        ! [9: end if]
        }

    ! [10: continue the activity]
    rfalse;
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_91, 91, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! For printing a locale paragraph about a thing ( called the item ) ( this is the use initial appearance in room descriptions rule ):
[ R_92 
    tmp_0 ! Let/loop value, e.g., 'item': thing
    tmp_1 ! Let/loop value, e.g., '?-1,-1?'(deallocated by end of phrase)
    tmp_2 ! Let/loop value, e.g., '?-1,-1?'(deallocated by end of phrase)
    ;
    if ((((tmp_0 = parameter_value, (((tmp_0=(parameter_value), true) && (parameter_value ofclass K2_thing))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_92, 92);
    ! [1: if the item is not mentioned begin]
    if (((~~(((Adj_69_t1_v10(tmp_0))))))){
        ! [2: if the item provides the property initial appearance and the item is not handled and the initial appearance of the item is not ~~ begin]
        if ((((WhetherProvides(tmp_0, false, initial)))) && ((((~~(((Adj_64_t1_v10(tmp_0))))))) && (((~~(( BlkValueCompare(GProperty(10, tmp_0,initial), EMPTY_TEXT_VALUE) == 0))))))){
            ! [3: increase the locale paragraph count by 1]
            (Global_Vars-->9) = (Global_Vars-->9) + 1;;
            ! [4: say ~[initial appearance of the item]~]
            @push self; say__p=1;ParaContent(); print (TEXT_TY_Say) GProperty(10, self=tmp_0,initial); .L_Say84; .L_SayX84;@pull self; 
            ! [5: say ~[paragraph break]~]
            say__p=1;ParaContent(); DivideParagraphPoint(); new_line; .L_Say85; .L_SayX85;
            ! [6: if a locale-supportable thing is on the item begin]
            if ((((Prop_23(tmp_0))))){
                ! [7: repeat with possibility running through things on the item begin]
                for (tmp_1=Prop_24(tmp_0,0), tmp_2=Prop_24(tmp_0,tmp_1): tmp_1: tmp_1=tmp_2, tmp_2=Prop_24(tmp_0,tmp_2)){
                    ! [8: now the possibility is marked for listing]
                    (Adj_67_t2_v10(tmp_1));
                    ! [9: if the possibility is mentioned begin]
                    if ((((Adj_69_t1_v10(tmp_1))))){
                        ! [10: now the possibility is not marked for listing]
                        (Adj_67_t3_v10(tmp_1));
                        ! [11: end if]
                        }

                    ! [12: end repeat]
                    }

                ! [13: say ~On [the item] ~ ( a )]
                say__p=1;ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TX_R_150); .L_Say86; .L_SayX86;
                ! [14: list the contents of the item , as a sentence , including contents , giving brief inventory information , tersely , not listing concealed items , prefacing with is/are , listing marked items only]
                WriteListFrom(child(tmp_0), 3800);
                ! [15: say ~.[paragraph break]~]
                say__p=1;ParaContent(); print ".";ParaContent(); DivideParagraphPoint(); new_line; .L_Say87; .L_SayX87;
                ! [16: end if]
                }

            ! [17: now the item is mentioned]
            (Adj_69_t2_v10(tmp_0));
            ! [18: end if]
            }

        ! [19: end if]
        }

    ! [20: continue the activity]
    rfalse;
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_92, 92, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! For printing a locale paragraph about a thing ( called the item ) ( this is the describe what's on scenery supporters in room descriptions rule ):
[ R_95 
    tmp_0 ! Let/loop value, e.g., 'item': thing
    tmp_1 ! Let/loop value, e.g., '?-1,-1?'(deallocated by end of phrase)
    tmp_2 ! Let/loop value, e.g., '?-1,-1?'(deallocated by end of phrase)
    ;
    if ((((tmp_0 = parameter_value, (((tmp_0=(parameter_value), true) && (parameter_value ofclass K2_thing))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_95, 95);
    ! [1: if the item is scenery and the item does not enclose the player begin]
    if (((((Adj_61_t1_v10(tmp_0))))) && (((~~((IndirectlyContains(tmp_0,player))))))){
        ! [2: if a locale-supportable thing is on the item begin]
        if ((((Prop_25(tmp_0))))){
            ! [3: set pronouns from the item]
            PronounNotice(tmp_0);
            ! [4: repeat with possibility running through things on the item begin]
            for (tmp_1=Prop_26(tmp_0,0), tmp_2=Prop_26(tmp_0,tmp_1): tmp_1: tmp_1=tmp_2, tmp_2=Prop_26(tmp_0,tmp_2)){
                ! [5: now the possibility is marked for listing]
                (Adj_67_t2_v10(tmp_1));
                ! [6: if the possibility is mentioned begin]
                if ((((Adj_69_t1_v10(tmp_1))))){
                    ! [7: now the possibility is not marked for listing]
                    (Adj_67_t3_v10(tmp_1));
                    ! [8: end if]
                    }

                ! [9: end repeat]
                }

            ! [10: increase the locale paragraph count by 1]
            (Global_Vars-->9) = (Global_Vars-->9) + 1;;
            ! [11: say ~On [the item] ~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TX_R_151); .L_Say88; .L_SayX88;
            ! [12: list the contents of the item , as a sentence , including contents , giving brief inventory information , tersely , not listing concealed items , prefacing with is/are , listing marked items only]
            WriteListFrom(child(tmp_0), 3800);
            ! [13: say ~.[paragraph break]~]
            say__p=1;ParaContent(); print ".";ParaContent(); DivideParagraphPoint(); new_line; .L_Say89; .L_SayX89;
            ! [14: end if]
            }

        ! [15: end if]
        }

    ! [16: continue the activity]
    rfalse;
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_95, 95, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Taking inventory (B131_carry_out_taking_invent)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Carry out taking inventory ( this is the print empty inventory rule ):
!   === equally specific with ===
! Rule 2/2 ! Carry out taking inventory ( this is the print standard inventory rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Carry out taking inventory ( this is the print empty inventory rule ):
[ R_96 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_96, 96);
    ! [1: if the first thing held by the player is nothing , say ~[We] [are] carrying nothing.~ ( a ) instead]
    if ((((child(player)) == nothing))) { say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_152); new_line; .L_Say90; .L_SayX90; rtrue; }
    } else if (debug_rules > 1) DB_Rule(R_96, 96, 'actor');
    rfalse;
];
! From the Standard Rules
! No specific request
! Carry out taking inventory ( this is the print standard inventory rule ):
[ R_97 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_97, 97);
    ! [1: say ~[We] [are] carrying:[line break]~ ( a )]
    say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_153); .L_Say91; .L_SayX91;
    ! [2: list the contents of the player , with newlines , indented , including contents , giving inventory information , with extra indentation]
    WriteListFrom(child(player), 8215);
    } else if (debug_rules > 1) DB_Rule(R_97, 97, 'actor');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Taking inventory (B132_report_taking_inventory)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor taking inventory ( this is the report other people taking inventory rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor taking inventory ( this is the report other people taking inventory rule ):
[ R_98 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_98, 98);
    ! [1: if the actor is not the player and the action is not silent begin]
    if ((((~~((actor == player))))) && (((keep_silent == false)))){
        ! [2: say ~[The actor] [look] through [their] possessions.~ ( a )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_154); new_line; .L_Say92; .L_SayX92;
        ! [3: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_98, 98, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Taking (B133_check_taking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/12 ! Check an actor taking ( this is the can't take yourself rule ):
!   === equally specific with ===
! Rule 2/12 ! Check an actor taking ( this is the can't take other people rule ):
!   === equally specific with ===
! Rule 3/12 ! Check an actor taking ( this is the can't take component parts rule ):
!   === equally specific with ===
! Rule 4/12 ! Check an actor taking ( this is the can't take people's possessions rule ):
!   === equally specific with ===
! Rule 5/12 ! Check an actor taking ( this is the can't take items out of play rule ):
!   === equally specific with ===
! Rule 6/12 ! Check an actor taking ( this is the can't take what you're inside rule ):
!   === equally specific with ===
! Rule 7/12 ! Check an actor taking ( this is the can't take what's already taken rule ):
!   === equally specific with ===
! Rule 8/12 ! Check an actor taking ( this is the can't take scenery rule ):
!   === equally specific with ===
! Rule 9/12 ! Check an actor taking ( this is the can only take things rule ):
!   === equally specific with ===
! Rule 10/12 ! Check an actor taking ( this is the can't take what's fixed in place rule ):
!   === equally specific with ===
! Rule 11/12 ! Check an actor taking ( this is the use player's holdall to avoid exceeding carrying capacity rule ):
!   === equally specific with ===
! Rule 12/12 ! Check an actor taking ( this is the can't exceed carrying capacity rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor taking ( this is the can't take yourself rule ):
[ R_99 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_99, 99);
    ! [1: if the actor is the noun begin]
    if (((actor == noun))){
        ! [2: if the actor is the player , say ~[We] [are] always self-possessed.~ ( a )]
        if (((actor == player))) { say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_155); new_line; .L_Say93; .L_SayX93; }
        ! [3: stop the action]
        rtrue;
        ! [4: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_99, 99, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor taking ( this is the can't take other people rule ):
[ R_100 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_100, 100);
    ! [1: if the noun is a person begin]
    if (((noun ofclass K8_person))){
        ! [2: if the actor is the player , say ~I don't suppose [the noun] [would care] for that.~ ( a )]
        if (((actor == player))) { say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_156); new_line; .L_Say94; .L_SayX94; }
        ! [3: stop the action]
        rtrue;
        ! [4: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_100, 100, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor taking ( this is the can't take component parts rule ):
[ R_101 
    tmp_0 ! Let/loop value, e.g., 'whole': thing
    ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_101, 101);
    ! [1: if the noun is part of something ( called the whole ) begin]
    if ((((noun.component_parent) ofclass K2_thing) && (tmp_0=((noun.component_parent)), true))){
        ! [2: if the actor is the player begin]
        if (((actor == player))){
            ! [3: say ~[regarding the noun][Those] [seem] to be a part of [the whole].~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),TX_R_157); new_line; .L_Say95; .L_SayX95;
            ! [4: end if]
            }

        ! [5: stop the action]
        rtrue;
        ! [6: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_101, 101, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor taking ( this is the can't take people's possessions rule ):
[ R_102 
    tmp_0 ! Let/loop value, e.g., 'local ceiling': object
    tmp_1 ! Let/loop value, e.g., 'owner': object
    ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_102, 102);
    ! [1: let the local ceiling be the common ancestor of the actor with the noun]

    		tmp_0 = (CommonAncestor(actor, noun));
    ! [2: let the owner be the not-counting-parts holder of the noun]

    		tmp_1 = (CoreOfParentOfCoreOf(noun));
    ! [3: while the owner is not nothing and the owner is not the local ceiling begin]
    while ((((~~((tmp_1 == nothing))))) && (((~~((tmp_1 == tmp_0)))))){
        ! [4: if the owner is a person begin]
        if (((tmp_1 ofclass K8_person))){
            ! [5: if the actor is the player begin]
            if (((actor == player))){
                ! [6: say ~[regarding the noun][Those] [seem] to belong to [the owner].~ ( a )]
                say__p=1;ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),TX_R_158); new_line; .L_Say96; .L_SayX96;
                ! [7: end if]
                }

            ! [8: stop the action]
            rtrue;
            ! [9: end if]
            }

        ! [10: let the owner be the not-counting-parts holder of the owner]
        tmp_1 = (CoreOfParentOfCoreOf(tmp_1));
        ! [11: end while]
        }

        } else if (debug_rules > 1) DB_Rule(R_102, 102, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor taking ( this is the can't take items out of play rule ):
[ R_103 
    tmp_0 ! Let/loop value, e.g., 'H': object
    ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_103, 103);
    ! [1: let h be the noun]

    		tmp_0 = noun;
    ! [2: while h is not nothing and h is not a room begin]
    while ((((~~((tmp_0 == nothing))))) && (((~~((tmp_0 ofclass K1_room)))))){
        ! [3: let h be the not-counting-parts holder of h]
        tmp_0 = (CoreOfParentOfCoreOf(tmp_0));
        ! [4: end while]
        }

    ! [5: if h is nothing begin]
    if (((tmp_0 == nothing))){
        ! [6: if the actor is the player begin]
        if (((actor == player))){
            ! [7: say ~[regarding the noun][Those] [aren't] available.~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),TX_R_159); new_line; .L_Say97; .L_SayX97;
            ! [8: end if]
            }

        ! [9: stop the action]
        rtrue;
        ! [10: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_103, 103, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor taking ( this is the can't take what you're inside rule ):
[ R_104 
    tmp_0 ! Let/loop value, e.g., 'local ceiling': object
    ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_104, 104);
    ! [1: let the local ceiling be the common ancestor of the actor with the noun]

    		tmp_0 = (CommonAncestor(actor, noun));
    ! [2: if the local ceiling is the noun begin]
    if (((tmp_0 == noun))){
        ! [3: if the actor is the player begin]
        if (((actor == player))){
            ! [4: say ~[We] [would have] to get [if noun is a supporter]off[otherwise]out of[end if] [the noun] first.~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),TX_R_160); new_line; .L_Say98; .L_SayX98;
            ! [5: end if]
            }

        ! [6: stop the action]
        rtrue;
        ! [7: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_104, 104, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor taking ( this is the can't take what's already taken rule ):
[ R_105 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_105, 105);
    ! [1: if the actor is carrying the noun or the actor is wearing the noun begin]
    if ((((actor == CarrierOf(noun)))) || (((actor == WearerOf(noun))))){
        ! [2: if the actor is the player begin]
        if (((actor == player))){
            ! [3: say ~[We] already [have] [regarding the noun][those].~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_161); new_line; .L_Say99; .L_SayX99;
            ! [4: end if]
            }

        ! [5: stop the action]
        rtrue;
        ! [6: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_105, 105, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor taking ( this is the can't take scenery rule ):
[ R_106 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_106, 106);
    ! [1: if the noun is scenery begin]
    if ((((Adj_61_t1_v10(noun))))){
        ! [2: if the actor is the player begin]
        if (((actor == player))){
            ! [3: say ~[regarding the noun][They're] hardly portable.~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_162); new_line; .L_Say100; .L_SayX100;
            ! [4: end if]
            }

        ! [5: stop the action]
        rtrue;
        ! [6: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_106, 106, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor taking ( this is the can only take things rule ):
[ R_107 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_107, 107);
    ! [1: if the noun is not a thing begin]
    if (((~~((noun ofclass K2_thing))))){
        ! [2: if the actor is the player begin]
        if (((actor == player))){
            ! [3: say ~[We] [cannot] carry [the noun].~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_163); new_line; .L_Say101; .L_SayX101;
            ! [4: end if]
            }

        ! [5: stop the action]
        rtrue;
        ! [6: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_107, 107, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor taking ( this is the can't take what's fixed in place rule ):
[ R_108 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_108, 108);
    ! [1: if the noun is fixed in place begin]
    if ((((Adj_59_t1_v10(noun))))){
        ! [2: if the actor is the player begin]
        if (((actor == player))){
            ! [3: say ~[regarding the noun][They're] fixed in place.~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_164); new_line; .L_Say102; .L_SayX102;
            ! [4: end if]
            }

        ! [5: stop the action]
        rtrue;
        ! [6: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_108, 108, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor taking ( this is the use player's holdall to avoid exceeding carrying capacity rule ):
[ R_109 
    tmp_0 ! Let/loop value, e.g., 'current working sack': player's holdall
    tmp_1 ! Let/loop value, e.g., '?-1,-1?'(deallocated by end of phrase)
    tmp_2 ! Let/loop value, e.g., '?-1,-1?'(deallocated by end of phrase)
    tmp_3 ! Let/loop value, e.g., '?-1,-1?'(deallocated by end of phrase)
    ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_109, 109);
    ! [1: if the number of things carried by the actor is at least the carrying capacity of the actor begin]
    if ((((Prop_27()) >= GProperty(10, actor,capacity)))){
        ! [2: if the actor is holding a player's holdall ( called the current working sack ) begin]
        if ((((Prop_28() && (tmp_0=deferred_calling_list-->0, true)) || (tmp_0 = 0,false)))){
            ! [3: let the transferred item be nothing]

            		tmp_1 = nothing;
            ! [4: repeat with the possible item running through things carried by the actor begin]
            for (tmp_2=Prop_29(0), tmp_3=Prop_29(tmp_2): tmp_2: tmp_2=tmp_3, tmp_3=Prop_29(tmp_3)){
                ! [5: if the possible item is not lit and the possible item is not the current working sack , let the transferred item be the possible item]
                if ((((~~(((Adj_55_t1_v10(tmp_2))))))) && (((~~((tmp_2 == tmp_0)))))) { tmp_1 = tmp_2; }
                ! [6: end repeat]
                }

            ! [7: if the transferred item is not nothing begin]
            if (((~~((tmp_1 == nothing))))){
                ! [8: if the actor is the player begin]
                if (((actor == player))){
                    ! [9: say ~(putting [the transferred item] into [the current working sack] to make room)[command clarification break]~ ( a )]
                    say__p=1;ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),(LocalParking-->3=tmp_3),TX_R_165); .L_Say103; .L_SayX103;
                    ! [10: end if]
                    }

                ! [11: silently try the actor trying inserting the transferred item into the current working sack]
                @push keep_silent; keep_silent=1; @push say__p; @push say__pc;
                		ClearParagraphing(1); TryAction(0, actor, ##Insert, tmp_1, tmp_0);; DivideParagraphPoint();
                		@pull say__pc; @pull say__p; AdjustParagraphPoint(); @pull keep_silent;
                ! [12: if the transferred item is not in the current working sack begin]
                if (((~~((tmp_0 == ContainerOf(tmp_1)))))){
                    ! [13: stop the action]
                    rtrue;
                    ! [14: end if]
                    }

                ! [15: end if]
                }

            ! [16: end if]
            }

        ! [17: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_109, 109, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor taking ( this is the can't exceed carrying capacity rule ):
[ R_110 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_110, 110);
    ! [1: if the number of things carried by the actor is at least the carrying capacity of the actor begin]
    if ((((Prop_30()) >= GProperty(10, actor,capacity)))){
        ! [2: if the actor is the player begin]
        if (((actor == player))){
            ! [3: say ~[We]['re] carrying too many things already.~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_166); new_line; .L_Say104; .L_SayX104;
            ! [4: end if]
            }

        ! [5: stop the action]
        rtrue;
        ! [6: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_110, 110, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Taking (B134_carry_out_taking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor taking ( this is the standard taking rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Carry out an actor taking ( this is the standard taking rule ):
[ R_111 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_111, 111);
    ! [1: now the actor carries the noun]
    MoveObject(noun,actor);
    } else if (debug_rules > 1) DB_Rule(R_111, 111, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Taking (B135_report_taking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor taking ( this is the standard report taking rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor taking ( this is the standard report taking rule ):
[ R_112 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_112, 112);
    ! [1: if the action is not silent begin]
    if (((keep_silent == false))){
        ! [2: if the actor is the player begin]
        if (((actor == player))){
            ! [3: say ~Taken.~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_167); new_line; .L_Say105; .L_SayX105;
            ! [4: otherwise]
            } else {

            ! [5: say ~[The actor] [pick] up [the noun].~ ( b )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_168); new_line; .L_Say106; .L_SayX106;
            ! [6: end if]
            }

        ! [7: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_112, 112, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Removing it from (B136_check_removing_it_from)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! Check an actor taking ( this is the can't take component parts rule ):
!   <<< I - Number of aspects constrained <<<
! Rule 2/4 ! Check an actor removing something from ( this is the can't remove what's not inside rule ):
!   === equally specific with ===
! Rule 3/4 ! Check an actor removing something from ( this is the can't remove from people rule ):
!   === equally specific with ===
! Rule 4/4 ! Check an actor removing something from ( this is the convert remove to take rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor removing something from ( this is the can't remove what's not inside rule ):
[ R_113 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_113, 113);
    ! [1: if the holder of the noun is not the second noun begin]
    if (((~~(((HolderOf(noun)) == second))))){
        ! [2: if the actor is the player begin]
        if (((actor == player))){
            ! [3: say ~But [regarding the noun][they] [aren't] there now.~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_169); new_line; .L_Say107; .L_SayX107;
            ! [4: end if]
            }

        ! [5: stop the action]
        rtrue;
        ! [6: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_113, 113, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor removing something from ( this is the can't remove from people rule ):
[ R_114 
    tmp_0 ! Let/loop value, e.g., 'owner': object
    ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_114, 114);
    ! [1: let the owner be the holder of the noun]

    		tmp_0 = (HolderOf(noun));
    ! [2: if the owner is a person begin]
    if (((tmp_0 ofclass K8_person))){
        ! [3: if the owner is the actor , convert to the taking off action on the noun]
        if (((tmp_0 == actor))) { return GVS_Convert(##Disrobe,noun,0); }
        ! [4: if the actor is the player begin]
        if (((actor == player))){
            ! [5: say ~[regarding the noun][Those] [seem] to belong to [the owner].~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),TX_R_170); new_line; .L_Say108; .L_SayX108;
            ! [6: end if]
            }

        ! [7: stop the action]
        rtrue;
        ! [8: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_114, 114, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor removing something from ( this is the convert remove to take rule ):
[ R_115 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_115, 115);
    ! [1: convert to the taking action on the noun]
    return GVS_Convert(##Take,noun,0);
    } else if (debug_rules > 1) DB_Rule(R_115, 115, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Dropping (B139_check_dropping)
! ----------------------------------------------------------------------------------------------------
! Rule 1/6 ! Check an actor dropping something which is part of the actor ( this is the can't drop body parts rule ):
!   >>> I - Number of aspects constrained >>>
! Rule 2/6 ! Check an actor dropping ( this is the can't drop yourself rule ):
!   === equally specific with ===
! Rule 3/6 ! Check an actor dropping ( this is the can't drop what's already dropped rule ):
!   === equally specific with ===
! Rule 4/6 ! Check an actor dropping ( this is the can't drop what's not held rule ):
!   === equally specific with ===
! Rule 5/6 ! Check an actor dropping ( this is the can't drop clothes being worn rule ):
!   === equally specific with ===
! Rule 6/6 ! Check an actor dropping ( this is the can't drop if this exceeds carrying capacity rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor dropping something which is part of the actor ( this is the can't drop body parts rule ):
[ R_117 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing) && (actor == (noun.component_parent)))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_117, 117);
    ! [1: if the actor is the player begin]
    if (((actor == player))){
        ! [2: say ~[We] [can't drop] part of [ourselves].~ ( a )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_171); new_line; .L_Say109; .L_SayX109;
        ! [3: end if]
        }

    ! [4: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_117, 117, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor dropping ( this is the can't drop yourself rule ):
[ R_116 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_116, 116);
    ! [1: if the noun is the actor begin]
    if (((noun == actor))){
        ! [2: if the actor is the player begin]
        if (((actor == player))){
            ! [3: say ~[We] [lack] the dexterity.~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_172); new_line; .L_Say110; .L_SayX110;
            ! [4: end if]
            }

        ! [5: stop the action]
        rtrue;
        ! [6: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_116, 116, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor dropping ( this is the can't drop what's already dropped rule ):
[ R_118 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_118, 118);
    ! [1: if the noun is in the holder of the actor begin]
    if ((((HolderOf(actor)) == ContainerOf(noun)))){
        ! [2: if the actor is the player begin]
        if (((actor == player))){
            ! [3: say ~[The noun] [are] already here.~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_173); new_line; .L_Say111; .L_SayX111;
            ! [4: end if]
            }

        ! [5: stop the action]
        rtrue;
        ! [6: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_118, 118, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor dropping ( this is the can't drop what's not held rule ):
[ R_119 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_119, 119);
    ! [1: if the actor is carrying the noun , continue the action]
    if (((actor == CarrierOf(noun)))) { rfalse; }
    ! [2: if the actor is wearing the noun , continue the action]
    if (((actor == WearerOf(noun)))) { rfalse; }
    ! [3: if the actor is the player begin]
    if (((actor == player))){
        ! [4: say ~[We] [haven't] got [regarding the noun][those].~ ( a )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_174); new_line; .L_Say112; .L_SayX112;
        ! [5: end if]
        }

    ! [6: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_119, 119, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor dropping ( this is the can't drop clothes being worn rule ):
[ R_120 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_120, 120);
    ! [1: if the actor is wearing the noun begin]
    if (((actor == WearerOf(noun)))){
        ! [2: if the actor is the player begin]
        if (((actor == player))){
            ! [3: say ~(first taking [the noun] off)[command clarification break]~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_175); .L_Say113; .L_SayX113;
            ! [4: end if]
            }

        ! [5: silently try the actor trying taking off the noun]
        @push keep_silent; keep_silent=1; @push say__p; @push say__pc;
        		ClearParagraphing(1); TryAction(0, actor, ##Disrobe, noun, 0);; DivideParagraphPoint();
        		@pull say__pc; @pull say__p; AdjustParagraphPoint(); @pull keep_silent;
        ! [6: if the actor is wearing the noun , stop the action]
        if (((actor == WearerOf(noun)))) { rtrue; }
        ! [7: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_120, 120, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor dropping ( this is the can't drop if this exceeds carrying capacity rule ):
[ R_121 
    tmp_0 ! Let/loop value, e.g., 'receptacle': object
    ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_121, 121);
    ! [1: let the receptacle be the holder of the actor]

    		tmp_0 = (HolderOf(actor));
    ! [2: if the receptacle is a room , continue the action]
    if (((tmp_0 ofclass K1_room))) { rfalse; }
    ! [3: if the receptacle provides the property carrying capacity begin]
    if (((WhetherProvides(tmp_0, false, capacity)))){
        ! [4: if the receptacle is a supporter begin]
        if (((tmp_0 ofclass K6_supporter))){
            ! [5: if the number of things on the receptacle is at least the carrying capacity of the receptacle begin]
            if ((((Prop_31(tmp_0)) >= GProperty(OBJECT_TY, tmp_0,capacity)))){
                ! [6: if the actor is the player begin]
                if (((actor == player))){
                    ! [7: now the prior named object is nothing]
                    prior_named_noun = nothing;
                    ! [8: say ~[There] [are] no more room on [the receptacle].~ ( a )]
                    say__p=1;ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),TX_R_176); new_line; .L_Say114; .L_SayX114;
                    ! [9: end if]
                    }

                ! [10: stop the action]
                rtrue;
                ! [11: end if]
                }

            ! [12: otherwise if the receptacle is a container]
            } else if (((tmp_0 ofclass K5_container))) {
            ! [13: if the number of things in the receptacle is at least the carrying capacity of the receptacle begin]
            if ((((Prop_32(tmp_0)) >= GProperty(OBJECT_TY, tmp_0,capacity)))){
                ! [14: if the actor is the player begin]
                if (((actor == player))){
                    ! [15: now the prior named object is nothing]
                    prior_named_noun = nothing;
                    ! [16: say ~[There] [are] no more room in [the receptacle].~ ( b )]
                    say__p=1;ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),TX_R_177); new_line; .L_Say115; .L_SayX115;
                    ! [17: end if]
                    }

                ! [18: stop the action]
                rtrue;
                ! [19: end if]
                }

            ! [20: end if]
            }

        ! [21: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_121, 121, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Dropping (B140_carry_out_dropping)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor dropping ( this is the standard dropping rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Carry out an actor dropping ( this is the standard dropping rule ):
[ R_122 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_122, 122);
    ! [1: now the noun is in the holder of the actor]
    MoveObject(noun,(HolderOf(actor)));
    } else if (debug_rules > 1) DB_Rule(R_122, 122, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Dropping (B141_report_dropping)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor dropping ( this is the standard report dropping rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor dropping ( this is the standard report dropping rule ):
[ R_123 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_123, 123);
    ! [1: if the action is not silent begin]
    if (((keep_silent == false))){
        ! [2: if the actor is the player begin]
        if (((actor == player))){
            ! [3: say ~Dropped.~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_178); new_line; .L_Say116; .L_SayX116;
            ! [4: otherwise]
            } else {

            ! [5: say ~[The actor] [put] down [the noun].~ ( b )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_179); new_line; .L_Say117; .L_SayX117;
            ! [6: end if]
            }

        ! [7: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_123, 123, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Putting it on (B142_check_putting_it_on)
! ----------------------------------------------------------------------------------------------------
! Rule 1/6 ! Check an actor putting something on ( this is the convert put to drop where possible rule ):
!   === equally specific with ===
! Rule 2/6 ! Check an actor putting something on ( this is the can't put what's not held rule ):
!   === equally specific with ===
! Rule 3/6 ! Check an actor putting something on ( this is the can't put something on itself rule ):
!   === equally specific with ===
! Rule 4/6 ! Check an actor putting something on ( this is the can't put onto what's not a supporter rule ):
!   === equally specific with ===
! Rule 5/6 ! Check an actor putting something on ( this is the can't put clothes being worn rule ):
!   === equally specific with ===
! Rule 6/6 ! Check an actor putting something on ( this is the can't put if this exceeds carrying capacity rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor putting something on ( this is the convert put to drop where possible rule ):
[ R_124 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_124, 124);
    ! [1: if the second noun is down or the actor is on the second noun , convert to the dropping action on the noun]
    if ((((second == I59_down))) || (((second == SupporterOf(actor))))) { return GVS_Convert(##Drop,noun,0); }
    } else if (debug_rules > 1) DB_Rule(R_124, 124, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor putting something on ( this is the can't put what's not held rule ):
[ R_125 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_125, 125);
    ! [1: if the actor is carrying the noun , continue the action]
    if (((actor == CarrierOf(noun)))) { rfalse; }
    ! [2: if the actor is wearing the noun , continue the action]
    if (((actor == WearerOf(noun)))) { rfalse; }
    ! [3: carry out the implicitly taking activity with the noun]
    CarryOutActivity(V25_implicitly_taking, noun);
    ! [4: if the actor is carrying the noun , continue the action]
    if (((actor == CarrierOf(noun)))) { rfalse; }
    ! [5: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_125, 125, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor putting something on ( this is the can't put something on itself rule ):
[ R_126 
    tmp_0 ! Let/loop value, e.g., 'noun-CPC': object
    tmp_1 ! Let/loop value, e.g., 'second-CPC': object
    tmp_2 ! Let/loop value, e.g., 'transfer ceiling': object
    ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_126, 126);
    ! [1: let the noun-cpc be the component parts core of the noun]

    		tmp_0 = CoreOf(noun);
    ! [2: let the second-cpc be the component parts core of the second noun]

    		tmp_1 = CoreOf(second);
    ! [3: let the transfer ceiling be the common ancestor of the noun-cpc with the second-cpc]

    		tmp_2 = (CommonAncestor(tmp_0, tmp_1));
    ! [4: if the transfer ceiling is the noun-cpc begin]
    if (((tmp_2 == tmp_0))){
        ! [5: if the actor is the player begin]
        if (((actor == player))){
            ! [6: say ~[We] [can't put] something on top of itself.~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TX_R_180); new_line; .L_Say118; .L_SayX118;
            ! [7: end if]
            }

        ! [8: stop the action]
        rtrue;
        ! [9: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_126, 126, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor putting something on ( this is the can't put onto what's not a supporter rule ):
[ R_127 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_127, 127);
    ! [1: if the second noun is not a supporter begin]
    if (((~~((second ofclass K6_supporter))))){
        ! [2: if the actor is the player begin]
        if (((actor == player))){
            ! [3: say ~Putting things on [the second noun] [would achieve] nothing.~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_181); new_line; .L_Say119; .L_SayX119;
            ! [4: end if]
            }

        ! [5: stop the action]
        rtrue;
        ! [6: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_127, 127, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor putting something on ( this is the can't put clothes being worn rule ):
[ R_128 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_128, 128);
    ! [1: if the actor is wearing the noun begin]
    if (((actor == WearerOf(noun)))){
        ! [2: if the actor is the player begin]
        if (((actor == player))){
            ! [3: say ~(first taking [regarding the noun][them] off)[command clarification break]~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_182); .L_Say120; .L_SayX120;
            ! [4: end if]
            }

        ! [5: silently try the actor trying taking off the noun]
        @push keep_silent; keep_silent=1; @push say__p; @push say__pc;
        		ClearParagraphing(1); TryAction(0, actor, ##Disrobe, noun, 0);; DivideParagraphPoint();
        		@pull say__pc; @pull say__p; AdjustParagraphPoint(); @pull keep_silent;
        ! [6: if the actor is wearing the noun , stop the action]
        if (((actor == WearerOf(noun)))) { rtrue; }
        ! [7: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_128, 128, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor putting something on ( this is the can't put if this exceeds carrying capacity rule ):
[ R_129 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_129, 129);
    ! [1: if the second noun provides the property carrying capacity begin]
    if (((WhetherProvides(second, false, capacity)))){
        ! [2: if the number of things on the second noun is at least the carrying capacity of the second noun begin]
        if ((((Prop_33()) >= GProperty(OBJECT_TY, second,capacity)))){
            ! [3: if the actor is the player begin]
            if (((actor == player))){
                ! [4: say ~[There] [are] no more room on [the second noun].~ ( a )]
                say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_183); new_line; .L_Say121; .L_SayX121;
                ! [5: end if]
                }

            ! [6: stop the action]
            rtrue;
            ! [7: end if]
            }

        ! [8: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_129, 129, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Putting it on (B143_carry_out_putting_it_on)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor putting something on ( this is the standard putting rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Carry out an actor putting something on ( this is the standard putting rule ):
[ R_130 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_130, 130);
    ! [1: now the noun is on the second noun]
    MoveObject(noun,second);
    } else if (debug_rules > 1) DB_Rule(R_130, 130, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Putting it on (B144_report_putting_it_on)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Report an actor putting something on ( this is the concise report putting rule ):
!   === equally specific with ===
! Rule 2/2 ! Report an actor putting something on ( this is the standard report putting rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor putting something on ( this is the concise report putting rule ):
[ R_131 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_131, 131);
    ! [1: if the action is not silent begin]
    if (((keep_silent == false))){
        ! [2: if the actor is the player and the i6 parser is running multiple actions begin]
        if ((((actor == player))) && (((multiflag==1)))){
            ! [3: say ~Done.~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_184); new_line; .L_Say122; .L_SayX122;
            ! [4: stop the action]
            rtrue;
            ! [5: end if]
            }

        ! [6: end if]
        }

    ! [7: continue the action]
    rfalse;
    } else if (debug_rules > 1) DB_Rule(R_131, 131, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Report an actor putting something on ( this is the standard report putting rule ):
[ R_132 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_132, 132);
    ! [1: if the action is not silent begin]
    if (((keep_silent == false))){
        ! [2: say ~[The actor] [put] [the noun] on [the second noun].~ ( a )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_185); new_line; .L_Say123; .L_SayX123;
        ! [3: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_132, 132, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Inserting it into (B145_check_inserting_it_into)
! ----------------------------------------------------------------------------------------------------
! Rule 1/7 ! Check an actor inserting something into ( this is the convert insert to drop where possible rule ):
!   === equally specific with ===
! Rule 2/7 ! Check an actor inserting something into ( this is the can't insert what's not held rule ):
!   === equally specific with ===
! Rule 3/7 ! Check an actor inserting something into ( this is the can't insert something into itself rule ):
!   === equally specific with ===
! Rule 4/7 ! Check an actor inserting something into ( this is the can't insert into closed containers rule ):
!   === equally specific with ===
! Rule 5/7 ! Check an actor inserting something into ( this is the can't insert into what's not a container rule ):
!   === equally specific with ===
! Rule 6/7 ! Check an actor inserting something into ( this is the can't insert clothes being worn rule ):
!   === equally specific with ===
! Rule 7/7 ! Check an actor inserting something into ( this is the can't insert if this exceeds carrying capacity rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor inserting something into ( this is the convert insert to drop where possible rule ):
[ R_133 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_133, 133);
    ! [1: if the second noun is down or the actor is in the second noun , convert to the dropping action on the noun]
    if ((((second == I59_down))) || (((second == ContainerOf(actor))))) { return GVS_Convert(##Drop,noun,0); }
    } else if (debug_rules > 1) DB_Rule(R_133, 133, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor inserting something into ( this is the can't insert what's not held rule ):
[ R_134 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_134, 134);
    ! [1: if the actor is carrying the noun , continue the action]
    if (((actor == CarrierOf(noun)))) { rfalse; }
    ! [2: if the actor is wearing the noun , continue the action]
    if (((actor == WearerOf(noun)))) { rfalse; }
    ! [3: carry out the implicitly taking activity with the noun]
    CarryOutActivity(V25_implicitly_taking, noun);
    ! [4: if the actor is carrying the noun , continue the action]
    if (((actor == CarrierOf(noun)))) { rfalse; }
    ! [5: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_134, 134, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor inserting something into ( this is the can't insert something into itself rule ):
[ R_135 
    tmp_0 ! Let/loop value, e.g., 'noun-CPC': object
    tmp_1 ! Let/loop value, e.g., 'second-CPC': object
    tmp_2 ! Let/loop value, e.g., 'transfer ceiling': object
    ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_135, 135);
    ! [1: let the noun-cpc be the component parts core of the noun]

    		tmp_0 = CoreOf(noun);
    ! [2: let the second-cpc be the component parts core of the second noun]

    		tmp_1 = CoreOf(second);
    ! [3: let the transfer ceiling be the common ancestor of the noun-cpc with the second-cpc]

    		tmp_2 = (CommonAncestor(tmp_0, tmp_1));
    ! [4: if the transfer ceiling is the noun-cpc begin]
    if (((tmp_2 == tmp_0))){
        ! [5: if the actor is the player begin]
        if (((actor == player))){
            ! [6: say ~[We] [can't put] something inside itself.~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TX_R_186); new_line; .L_Say124; .L_SayX124;
            ! [7: end if]
            }

        ! [8: stop the action]
        rtrue;
        ! [9: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_135, 135, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor inserting something into ( this is the can't insert into closed containers rule ):
[ R_136 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_136, 136);
    ! [1: if the second noun is a closed container begin]
    if (((second ofclass K5_container) && ((Adj_75_t1_v10(second))))){
        ! [2: if the actor is the player begin]
        if (((actor == player))){
            ! [3: say ~[The second noun] [are] closed.~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_187); new_line; .L_Say125; .L_SayX125;
            ! [4: end if]
            }

        ! [5: stop the action]
        rtrue;
        ! [6: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_136, 136, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor inserting something into ( this is the can't insert into what's not a container rule ):
[ R_137 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_137, 137);
    ! [1: if the second noun is not a container begin]
    if (((~~((second ofclass K5_container))))){
        ! [2: if the actor is the player begin]
        if (((actor == player))){
            ! [3: say ~[regarding the second noun][Those] [can't contain] things.~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_188); new_line; .L_Say126; .L_SayX126;
            ! [4: end if]
            }

        ! [5: stop the action]
        rtrue;
        ! [6: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_137, 137, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor inserting something into ( this is the can't insert clothes being worn rule ):
[ R_138 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_138, 138);
    ! [1: if the actor is wearing the noun begin]
    if (((actor == WearerOf(noun)))){
        ! [2: if the actor is the player begin]
        if (((actor == player))){
            ! [3: say ~(first taking [regarding the noun][them] off)[command clarification break]~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_189); .L_Say127; .L_SayX127;
            ! [4: end if]
            }

        ! [5: silently try the actor trying taking off the noun]
        @push keep_silent; keep_silent=1; @push say__p; @push say__pc;
        		ClearParagraphing(1); TryAction(0, actor, ##Disrobe, noun, 0);; DivideParagraphPoint();
        		@pull say__pc; @pull say__p; AdjustParagraphPoint(); @pull keep_silent;
        ! [6: if the actor is wearing the noun , stop the action]
        if (((actor == WearerOf(noun)))) { rtrue; }
        ! [7: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_138, 138, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor inserting something into ( this is the can't insert if this exceeds carrying capacity rule ):
[ R_139 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_139, 139);
    ! [1: if the second noun provides the property carrying capacity begin]
    if (((WhetherProvides(second, false, capacity)))){
        ! [2: if the number of things in the second noun is at least the carrying capacity of the second noun begin]
        if ((((Prop_34()) >= GProperty(OBJECT_TY, second,capacity)))){
            ! [3: if the actor is the player begin]
            if (((actor == player))){
                ! [4: now the prior named object is nothing]
                prior_named_noun = nothing;
                ! [5: say ~[There] [are] no more room in [the second noun].~ ( a )]
                say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_190); new_line; .L_Say128; .L_SayX128;
                ! [6: end if]
                }

            ! [7: stop the action]
            rtrue;
            ! [8: end if]
            }

        ! [9: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_139, 139, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Inserting it into (B146_carry_out_inserting_it_)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor inserting something into ( this is the standard inserting rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Carry out an actor inserting something into ( this is the standard inserting rule ):
[ R_140 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_140, 140);
    ! [1: now the noun is in the second noun]
    MoveObject(noun,second);
    } else if (debug_rules > 1) DB_Rule(R_140, 140, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Inserting it into (B147_report_inserting_it_int)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Report an actor inserting something into ( this is the concise report inserting rule ):
!   === equally specific with ===
! Rule 2/2 ! Report an actor inserting something into ( this is the standard report inserting rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor inserting something into ( this is the concise report inserting rule ):
[ R_141 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_141, 141);
    ! [1: if the action is not silent begin]
    if (((keep_silent == false))){
        ! [2: if the actor is the player and the i6 parser is running multiple actions begin]
        if ((((actor == player))) && (((multiflag==1)))){
            ! [3: say ~Done.~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_191); new_line; .L_Say129; .L_SayX129;
            ! [4: stop the action]
            rtrue;
            ! [5: end if]
            }

        ! [6: end if]
        }

    ! [7: continue the action]
    rfalse;
    } else if (debug_rules > 1) DB_Rule(R_141, 141, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Report an actor inserting something into ( this is the standard report inserting rule ):
[ R_142 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_142, 142);
    ! [1: if the action is not silent begin]
    if (((keep_silent == false))){
        ! [2: say ~[The actor] [put] [the noun] into [the second noun].~ ( a )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_192); new_line; .L_Say130; .L_SayX130;
        ! [3: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_142, 142, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Eating (B148_check_eating)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! Check an actor eating ( this is the can't eat unless edible rule ):
!   === equally specific with ===
! Rule 2/4 ! Check an actor eating ( this is the can't eat clothing without removing it first rule ):
!   === equally specific with ===
! Rule 3/4 ! Check an actor eating ( this is the can't eat other people's food rule ):
!   === equally specific with ===
! Rule 4/4 ! Check an actor eating ( this is the can't eat portable food without carrying it rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor eating ( this is the can't eat unless edible rule ):
[ R_143 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_143, 143);
    ! [1: if the noun is not a thing or the noun is not edible begin]
    if ((((~~((noun ofclass K2_thing))))) || (((~~(((Adj_57_t1_v10(noun)))))))){
        ! [2: if the actor is the player begin]
        if (((actor == player))){
            ! [3: say ~[regarding the noun][They're] plainly inedible.~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_193); new_line; .L_Say131; .L_SayX131;
            ! [4: end if]
            }

        ! [5: stop the action]
        rtrue;
        ! [6: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_143, 143, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor eating ( this is the can't eat clothing without removing it first rule ):
[ R_144 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_144, 144);
    ! [1: if the actor is wearing the noun begin]
    if (((actor == WearerOf(noun)))){
        ! [2: if the actor is the player begin]
        if (((actor == player))){
            ! [3: say ~(first taking [the noun] off)[command clarification break]~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_194); .L_Say132; .L_SayX132;
            ! [4: end if]
            }

        ! [5: try the actor trying taking off the noun]
        TryAction(0, actor, ##Disrobe, noun, 0);;
        ! [6: if the actor is wearing the noun , stop the action]
        if (((actor == WearerOf(noun)))) { rtrue; }
        ! [7: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_144, 144, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor eating ( this is the can't eat other people's food rule ):
[ R_145 
    tmp_0 ! Let/loop value, e.g., 'owner': person
    ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_145, 145);
    ! [1: if the noun is enclosed by a person ( called the owner ) who is not the actor begin]
    if ((((Prop_35() && (tmp_0=deferred_calling_list-->0, true)) || (tmp_0 = 0,false)))){
        ! [2: if the actor is the player begin]
        if (((actor == player))){
            ! [3: say ~[The owner] [might not appreciate] that.~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),TX_R_195); new_line; .L_Say133; .L_SayX133;
            ! [4: end if]
            }

        ! [5: stop the action]
        rtrue;
        ! [6: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_145, 145, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor eating ( this is the can't eat portable food without carrying it rule ):
[ R_146 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_146, 146);
    ! [1: if the noun is portable and the actor is not carrying the noun begin]
    if (((((Adj_60_t1_v10(noun))))) && (((~~((actor == CarrierOf(noun))))))){
        ! [2: carry out the implicitly taking activity with the noun]
        CarryOutActivity(V25_implicitly_taking, noun);
        ! [3: if the actor is not carrying the noun , stop the action]
        if (((~~((actor == CarrierOf(noun)))))) { rtrue; }
        ! [4: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_146, 146, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Eating (B149_carry_out_eating)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor eating ( this is the standard eating rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Carry out an actor eating ( this is the standard eating rule ):
[ R_147 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_147, 147);
    ! [1: now the noun is nowhere]
    RemoveFromPlay(noun);;
    } else if (debug_rules > 1) DB_Rule(R_147, 147, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Eating (B150_report_eating)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor eating ( this is the standard report eating rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor eating ( this is the standard report eating rule ):
[ R_148 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_148, 148);
    ! [1: if the action is not silent begin]
    if (((keep_silent == false))){
        ! [2: if the actor is the player begin]
        if (((actor == player))){
            ! [3: say ~[We] [eat] [the noun]. Not bad.~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_196); new_line; .L_Say134; .L_SayX134;
            ! [4: otherwise]
            } else {

            ! [5: say ~[The actor] [eat] [the noun].~ ( b )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_197); new_line; .L_Say135; .L_SayX135;
            ! [6: end if]
            }

        ! [7: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_148, 148, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Going (B151_check_going)
! ----------------------------------------------------------------------------------------------------
! Rule 1/6 ! Check an actor going when the actor is on a supporter ( called the chaise ) ( this is the stand up before going rule ):
!   >>> I - Number of aspects constrained >>>
! Rule 2/6 ! Check an actor going ( this is the can't travel in what's not a vehicle rule ):
!   === equally specific with ===
! Rule 3/6 ! Check an actor going ( this is the can't go through undescribed doors rule ):
!   === equally specific with ===
! Rule 4/6 ! Check an actor going ( this is the can't go through closed doors rule ):
!   === equally specific with ===
! Rule 5/6 ! Check an actor going ( this is the determine map connection rule ):
!   === equally specific with ===
! Rule 6/6 ! Check an actor going ( this is the can't go that way rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor going when the actor is on a supporter ( called the chaise ) ( this is the stand up before going rule ):
[ R_150 
    tmp_0 ! Let/loop value, e.g., 'chaise': supporter
    ;
    if ((((act_requester==nothing) && (self=actor,true) && (((SupporterOf(actor) ofclass K6_supporter) && (tmp_0=(SupporterOf(actor)), true)))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_150, 150);
    ! [1: if the actor is the player begin]
    if (((actor == player))){
        ! [2: say ~(first getting off [the chaise])[command clarification break]~ ( a )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),TX_R_198); .L_Say136; .L_SayX136;
        ! [3: end if]
        }

    ! [4: silently try the actor exiting]
    @push keep_silent; keep_silent=1; @push say__p; @push say__pc;
    		ClearParagraphing(1); TryAction(0, actor, ##Exit, 0, 0);; DivideParagraphPoint();
    		@pull say__pc; @pull say__p; AdjustParagraphPoint(); @pull keep_silent;
    } else if (debug_rules > 1) DB_Rule(R_150, 150, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor going ( this is the can't travel in what's not a vehicle rule ):
[ R_151 
    tmp_0 ! Let/loop value, e.g., 'nonvehicle': object
    ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_151, 151);
    ! [1: let nonvehicle be the holder of the actor]

    		tmp_0 = (HolderOf(actor));
    ! [2: if nonvehicle is the room gone from , continue the action]
    if (((tmp_0 == (MStack-->MstVO(20007,0))))) { rfalse; }
    ! [3: if nonvehicle is the vehicle gone by , continue the action]
    if (((tmp_0 == (MStack-->MstVO(20007,3))))) { rfalse; }
    ! [4: if the actor is the player begin]
    if (((actor == player))){
        ! [5: if nonvehicle is a supporter begin]
        if (((tmp_0 ofclass K6_supporter))){
            ! [6: say ~[We] [would have] to get off [the nonvehicle] first.~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),TX_R_199); new_line; .L_Say137; .L_SayX137;
            ! [7: otherwise]
            } else {

            ! [8: say ~[We] [would have] to get out of [the nonvehicle] first.~ ( b )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),TX_R_200); new_line; .L_Say138; .L_SayX138;
            ! [9: end if]
            }

        ! [10: end if]
        }

    ! [11: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_151, 151, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor going ( this is the can't go through undescribed doors rule ):
[ R_152 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_152, 152);
    ! [1: if the door gone through is not nothing and the door gone through is undescribed begin]
    if ((((~~(((MStack-->MstVO(20007,2)) == nothing))))) && ((((Adj_66_t1_v10((MStack-->MstVO(20007,2)))))))){
        ! [2: if the actor is the player begin]
        if (((actor == player))){
            ! [3: say ~[We] [can't go] that way.~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_201); new_line; .L_Say139; .L_SayX139;
            ! [4: end if]
            }

        ! [5: stop the action]
        rtrue;
        ! [6: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_152, 152, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor going ( this is the can't go through closed doors rule ):
[ R_153 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_153, 153);
    ! [1: if the door gone through is not nothing and the door gone through is closed begin]
    if ((((~~(((MStack-->MstVO(20007,2)) == nothing))))) && ((((Adj_75_t1_v10((MStack-->MstVO(20007,2)))))))){
        ! [2: if the actor is the player begin]
        if (((actor == player))){
            ! [3: say ~(first opening [the door gone through])[command clarification break]~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_202); .L_Say140; .L_SayX140;
            ! [4: end if]
            }

        ! [5: silently try the actor opening the door gone through]
        @push keep_silent; keep_silent=1; @push say__p; @push say__pc;
        		ClearParagraphing(1); TryAction(0, actor, ##Open, (MStack-->MstVO(20007,2)), 0);; DivideParagraphPoint();
        		@pull say__pc; @pull say__p; AdjustParagraphPoint(); @pull keep_silent;
        ! [6: if the door gone through is open , continue the action]
        if ((((Adj_74_t1_v10((MStack-->MstVO(20007,2))))))) { rfalse; }
        ! [7: stop the action]
        rtrue;
        ! [8: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_153, 153, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor going ( this is the determine map connection rule ):
[ R_154 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    @push formal_par1;
    I7RBLK = KERNEL_1();
    @pull formal_par1;
    @pull formal_par0;
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_1 
    tmp_0 ! Let/loop value, e.g., 'target': object
    tmp_1 ! Let/loop value, e.g., '?-1,-1?'(deallocated by end of phrase)
    ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_154, 154);
    ! [1: let the target be nothing]

    		tmp_0 = nothing;
    ! [2: if the noun is a direction begin]
    if (((noun ofclass K3_direction))){
        ! [3: let direction d be the noun]

        		tmp_1 = noun;
        ! [4: let the target be the room-or-door direction d from the room gone from]
        tmp_0 = 
        ! Resolution of run-time phrase ambiguity (deciding a value):
            (
                ! This value evaluates third (i.e., last)
                formal_rv
            +
                0*(
                    ! The following condition evaluates second
                    ((
                        ((((((formal_par0 ofclass K3_direction) && (formal_par0 ofclass K3_direction))))) && ((
                        formal_rv = RoomOrDoorFrom(formal_par1,formal_par0)) | 1)
                        )|| (ArgumentTypeFailed(2303, 1))

                    ))
                +
                    ! The following assignments evaluate first
                    ((formal_par1 = (MStack-->MstVO(20007,0))) +
                    (formal_par0 = tmp_1)
                    ))
            )

        ! Resolution complete
        ;
        ! [5: otherwise]
        } else {

        ! [6: if the noun is a door , let the target be the noun]
        if (((noun ofclass K4_door))) { tmp_0 = noun; }
        ! [7: end if]
        }

    ! [8: if the target is a door begin]
    if (((tmp_0 ofclass K4_door))){
        ! [9: now the target is the other side of the target from the room gone from]
        tmp_0 = 
        ! Resolution of run-time phrase ambiguity (deciding a value):
            (
                ! This value evaluates third (i.e., last)
                formal_rv
            +
                0*(
                    ! The following condition evaluates second
                    ((
                        ((((((formal_par0 ofclass K4_door) && (formal_par0 ofclass K4_door))))) && ((
                        formal_rv = OtherSideOfDoor(formal_par0,formal_par1)) | 1)
                        )|| (ArgumentTypeFailed(2307, 1))

                    ))
                +
                    ! The following assignments evaluate first
                    ((formal_par1 = (MStack-->MstVO(20007,0))) +
                    (formal_par0 = tmp_0)
                    ))
            )

        ! Resolution complete
        ;
        ! [10: end if]
        }

    ! [11: now the room gone to is the target]
    (MStack-->MstVO(20007,1)) = tmp_0;
    } else if (debug_rules > 1) DB_Rule(R_154, 154, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor going ( this is the can't go that way rule ):
[ R_155 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_155, 155);
    ! [1: if the room gone to is nothing begin]
    if ((((MStack-->MstVO(20007,1)) == nothing))){
        ! [2: if the door gone through is nothing begin]
        if ((((MStack-->MstVO(20007,2)) == nothing))){
            ! [3: if the actor is the player begin]
            if (((actor == player))){
                ! [4: say ~[We] [can't go] that way.~ ( a )]
                say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_203); new_line; .L_Say141; .L_SayX141;
                ! [5: end if]
                }

            ! [6: stop the action]
            rtrue;
            ! [7: end if]
            }

        ! [8: if the actor is the player begin]
        if (((actor == player))){
            ! [9: say ~[We] [can't], since [the door gone through] [lead] nowhere.~ ( b )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_204); new_line; .L_Say142; .L_SayX142;
            ! [10: end if]
            }

        ! [11: stop the action]
        rtrue;
        ! [12: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_155, 155, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Going (B152_carry_out_going)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Carry out an actor going ( this is the move player and vehicle rule ):
!   === equally specific with ===
! Rule 2/3 ! Carry out an actor going ( this is the move floating objects rule ):
!   === equally specific with ===
! Rule 3/3 ! Carry out an actor going ( this is the check light in new location rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Carry out an actor going ( this is the move player and vehicle rule ):
[ R_156 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_156, 156);
    ! [1: if the vehicle gone by is nothing , surreptitiously move the actor to the room gone to during going]
    if ((((MStack-->MstVO(20007,3)) == nothing))) { MoveDuringGoing(actor, (MStack-->MstVO(20007,1))); }
    ! [2: otherwise surreptitiously move the vehicle gone by to the room gone to during going]
    else { MoveDuringGoing((MStack-->MstVO(20007,3)), (MStack-->MstVO(20007,1))); }
    ! [3: if the location is not the location of the player begin]
    if (((~~((real_location == LocationOf(player)))))){
        ! [4: now the location is the location of the player]
        real_location = LocationOf(player);
        ! [5: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_156, 156, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Carry out an actor going ( this is the move floating objects rule ):
[ R_157 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_157, 157);
    ! [1: if the actor is the player or the player is within the vehicle gone by or the player is within the thing gone with begin]
    if ((((actor == player))) || (((((MStack-->MstVO(20007,3)) == ContainerOf(player)))) || ((((MStack-->MstVO(20007,4)) == ContainerOf(player)))))){
        ! [2: update backdrop positions]
        MoveFloatingObjects();
        ! [3: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_157, 157, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Carry out an actor going ( this is the check light in new location rule ):
[ R_158 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_158, 158);
    ! [1: if the actor is the player or the player is within the vehicle gone by or the player is within the thing gone with begin]
    if ((((actor == player))) || (((((MStack-->MstVO(20007,3)) == ContainerOf(player)))) || ((((MStack-->MstVO(20007,4)) == ContainerOf(player)))))){
        ! [2: surreptitiously reckon darkness]
        SilentlyConsiderLight();
        ! [3: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_158, 158, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Going (B153_report_going)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor going ( this is the describe room gone into rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor going ( this is the describe room gone into rule ):
[ R_159 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    @push formal_par1;
    I7RBLK = KERNEL_2();
    @pull formal_par1;
    @pull formal_par0;
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_2 
    tmp_0 ! Let/loop value, e.g., '?-1,-1?'(deallocated by end of phrase)
    tmp_1 ! Let/loop value, e.g., '?-1,-1?'(deallocated by end of phrase)
    tmp_2 ! Let/loop value, e.g., '?-1,-1?'(deallocated by end of phrase)
    ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_159, 159);
    ! [1: if the player is the actor begin]
    if (((player == actor))){
        ! [2: if the action is not silent begin]
        if (((keep_silent == false))){
            ! [3: produce a room description with going spacing conventions]
            LookAfterGoing();
            ! [4: end if]
            }

        ! [5: otherwise]
        } else {

        ! [6: if the noun is a direction begin]
        if (((noun ofclass K3_direction))){
            ! [7: if the location is the room gone from or the player is within the vehicle gone by or the player is within the thing gone with begin]
            if ((((real_location == (MStack-->MstVO(20007,0))))) || (((((MStack-->MstVO(20007,3)) == ContainerOf(player)))) || ((((MStack-->MstVO(20007,4)) == ContainerOf(player)))))){
                ! [8: if the room gone from is the room gone to begin]
                if ((((MStack-->MstVO(20007,0)) == (MStack-->MstVO(20007,1))))){
                    ! [9: continue the action]
                    rfalse;
                    ! [10: otherwise]
                    } else {

                    ! [11: if the noun is up begin]
                    if (((noun == I58_up))){
                        ! [12: say ~[The actor] [go] up~ ( a )]
                        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_205); .L_Say143; .L_SayX143;
                        ! [13: otherwise if the noun is down]
                        } else if (((noun == I59_down))) {
                        ! [14: say ~[The actor] [go] down~ ( b )]
                        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_206); .L_Say144; .L_SayX144;
                        ! [15: otherwise]
                        } else {

                        ! [16: say ~[The actor] [go] [noun]~ ( c )]
                        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_207); .L_Say145; .L_SayX145;
                        ! [17: end if]
                        }

                    ! [18: end if]
                    }

                ! [19: otherwise]
                } else {

                ! [20: let the back way be the opposite of the noun]

                		tmp_0 = GProperty(OBJECT_TY, noun,p10_opposite);
                ! [21: if the location is the room gone to begin]
                if (((real_location == (MStack-->MstVO(20007,1))))){
                    ! [22: let the room back the other way be the room back way from the location]

                    		tmp_1 = 
                    ! Resolution of run-time phrase ambiguity (deciding a value):
                        (
                            ! This value evaluates third (i.e., last)
                            formal_rv
                        +
                            0*(
                                ! The following condition evaluates second
                                ((
                                    ((((((formal_par0 ofclass K3_direction) && (formal_par0 ofclass K3_direction))) && (((formal_par1 ofclass K1_room) && (formal_par1 ofclass K1_room))))) && ((
                                    formal_rv = MapConnection(formal_par1,formal_par0)) | 1)
                                    )|| (ArgumentTypeFailed(2358, 1))

                                ))
                            +
                                ! The following assignments evaluate first
                                ((formal_par1 = real_location) +
                                (formal_par0 = tmp_0)
                                ))
                        )

                    ! Resolution complete
                    ;
                    ! [23: let the room normally this way be the room noun from the room gone from]

                    		tmp_2 = 
                    ! Resolution of run-time phrase ambiguity (deciding a value):
                        (
                            ! This value evaluates third (i.e., last)
                            formal_rv
                        +
                            0*(
                                ! The following condition evaluates second
                                ((
                                    ((((((formal_par0 ofclass K3_direction) && (formal_par0 ofclass K3_direction))))) && ((
                                    formal_rv = MapConnection(formal_par1,formal_par0)) | 1)
                                    )|| (ArgumentTypeFailed(2360, 1))

                                ))
                            +
                                ! The following assignments evaluate first
                                ((formal_par1 = (MStack-->MstVO(20007,0))) +
                                (formal_par0 = noun)
                                ))
                        )

                    ! Resolution complete
                    ;
                    ! [24: if the room back the other way is the room gone from or the room back the other way is the room normally this way begin]
                    if ((((tmp_1 == (MStack-->MstVO(20007,0))))) || (((tmp_1 == tmp_2)))){
                        ! [25: if the back way is up begin]
                        if (((tmp_0 == I58_up))){
                            ! [26: say ~[The actor] [arrive] from above~ ( d )]
                            say__p=1;ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TX_R_208); .L_Say146; .L_SayX146;
                            ! [27: otherwise if the back way is down]
                            } else if (((tmp_0 == I59_down))) {
                            ! [28: say ~[The actor] [arrive] from below~ ( e )]
                            say__p=1;ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TX_R_209); .L_Say147; .L_SayX147;
                            ! [29: otherwise]
                            } else {

                            ! [30: say ~[The actor] [arrive] from [the back way]~ ( f )]
                            say__p=1;ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TX_R_210); .L_Say148; .L_SayX148;
                            ! [31: end if]
                            }

                        ! [32: otherwise]
                        } else {

                        ! [33: say ~[The actor] [arrive]~ ( g )]
                        say__p=1;ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TX_R_211); .L_Say149; .L_SayX149;
                        ! [34: end if]
                        }

                    ! [35: otherwise]
                    } else {

                    ! [36: if the back way is up begin]
                    if (((tmp_0 == I58_up))){
                        ! [37: say ~[The actor] [arrive] at [the room gone to] from above~ ( h )]
                        say__p=1;ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TX_R_212); .L_Say150; .L_SayX150;
                        ! [38: otherwise if the back way is down]
                        } else if (((tmp_0 == I59_down))) {
                        ! [39: say ~[The actor] [arrive] at [the room gone to] from below~ ( i )]
                        say__p=1;ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TX_R_213); .L_Say151; .L_SayX151;
                        ! [40: otherwise]
                        } else {

                        ! [41: say ~[The actor] [arrive] at [the room gone to] from [the back way]~ ( j )]
                        say__p=1;ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TX_R_214); .L_Say152; .L_SayX152;
                        ! [42: end if]
                        }

                    ! [43: end if]
                    }

                ! [44: end if]
                }

            ! [45: otherwise if the location is the room gone from]
            } else if (((real_location == (MStack-->MstVO(20007,0))))) {
            ! [46: say ~[The actor] [go] through [the noun]~ ( k )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TX_R_215); .L_Say153; .L_SayX153;
            ! [47: otherwise]
            } else {

            ! [48: say ~[The actor] [arrive] from [the noun]~ ( l )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TX_R_216); .L_Say154; .L_SayX154;
            ! [49: end if]
            }

        ! [50: if the vehicle gone by is not nothing begin]
        if (((~~(((MStack-->MstVO(20007,3)) == nothing))))){
            ! [51: say ~ ~]
            say__p=1;ParaContent(); print " "; .L_Say155; .L_SayX155;
            ! [52: if the vehicle gone by is a supporter begin]
            if ((((MStack-->MstVO(20007,3)) ofclass K6_supporter))){
                ! [53: say ~on [the vehicle gone by]~ ( m )]
                say__p=1;ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TX_R_217); .L_Say156; .L_SayX156;
                ! [54: otherwise]
                } else {

                ! [55: say ~in [the vehicle gone by]~ ( n )]
                say__p=1;ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TX_R_218); .L_Say157; .L_SayX157;
                ! [56: end if]
                }

            ! [57: end if]
            }

        ! [58: if the thing gone with is not nothing begin]
        if (((~~(((MStack-->MstVO(20007,4)) == nothing))))){
            ! [59: if the player is within the thing gone with begin]
            if ((((MStack-->MstVO(20007,4)) == ContainerOf(player)))){
                ! [60: say ~, pushing [the thing gone with] in front, and [us] along too~ ( o )]
                say__p=1;ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TX_R_219); .L_Say158; .L_SayX158;
                ! [61: otherwise if the player is within the vehicle gone by]
                } else if ((((MStack-->MstVO(20007,3)) == ContainerOf(player)))) {
                ! [62: say ~, pushing [the thing gone with] in front~ ( p )]
                say__p=1;ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TX_R_220); .L_Say159; .L_SayX159;
                ! [63: otherwise if the location is the room gone from]
                } else if (((real_location == (MStack-->MstVO(20007,0))))) {
                ! [64: say ~, pushing [the thing gone with] away~ ( q )]
                say__p=1;ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TX_R_221); .L_Say160; .L_SayX160;
                ! [65: otherwise]
                } else {

                ! [66: say ~, pushing [the thing gone with] in~ ( r )]
                say__p=1;ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TX_R_222); .L_Say161; .L_SayX161;
                ! [67: end if]
                }

            ! [68: end if]
            }

        ! [69: if the player is within the vehicle gone by and the player is not within the thing gone with begin]
        if (((((MStack-->MstVO(20007,3)) == ContainerOf(player)))) && (((~~(((MStack-->MstVO(20007,4)) == ContainerOf(player))))))){
            ! [70: say ~, taking [us] along~ ( s )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TX_R_223); .L_Say162; .L_SayX162;
            ! [71: say ~.~]
            say__p=1;ParaContent(); print "."; new_line; .L_Say163; .L_SayX163;
            ! [72: try looking]
            TryAction(0, player, ##Look, 0, 0);;
            ! [73: continue the action]
            rfalse;
            ! [74: end if]
            }

        ! [75: say ~.~]
        say__p=1;ParaContent(); print "."; new_line; .L_Say164; .L_SayX164;
        ! [76: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_159, 159, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Entering (B154_check_entering)
! ----------------------------------------------------------------------------------------------------
! Rule 1/8 ! Check an actor entering ( this is the convert enter door into go rule ):
!   === equally specific with ===
! Rule 2/8 ! Check an actor entering ( this is the convert enter compass direction into go rule ):
!   === equally specific with ===
! Rule 3/8 ! Check an actor entering ( this is the can't enter what's already entered rule ):
!   === equally specific with ===
! Rule 4/8 ! Check an actor entering ( this is the can't enter what's not enterable rule ):
!   === equally specific with ===
! Rule 5/8 ! Check an actor entering ( this is the can't enter closed containers rule ):
!   === equally specific with ===
! Rule 6/8 ! Check an actor entering ( this is the can't enter if this exceeds carrying capacity rule ):
!   === equally specific with ===
! Rule 7/8 ! Check an actor entering ( this is the can't enter something carried rule ):
!   === equally specific with ===
! Rule 8/8 ! Check an actor entering ( this is the implicitly pass through other barriers rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor entering ( this is the convert enter door into go rule ):
[ R_161 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_161, 161);
    ! [1: if the noun is a door , convert to the going action on the noun]
    if (((noun ofclass K4_door))) { return GVS_Convert(##Go,noun,0); }
    } else if (debug_rules > 1) DB_Rule(R_161, 161, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor entering ( this is the convert enter compass direction into go rule ):
[ R_162 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_162, 162);
    ! [1: if the noun is a direction , convert to the going action on the noun]
    if (((noun ofclass K3_direction))) { return GVS_Convert(##Go,noun,0); }
    } else if (debug_rules > 1) DB_Rule(R_162, 162, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor entering ( this is the can't enter what's already entered rule ):
[ R_163 
    tmp_0 ! Let/loop value, e.g., 'local ceiling': object
    ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_163, 163);
    ! [1: if the actor is the noun , make no decision]
    if (((actor == noun))) { rfalse; }
    ! [2: let the local ceiling be the common ancestor of the actor with the noun]

    		tmp_0 = (CommonAncestor(actor, noun));
    ! [3: if the local ceiling is the noun begin]
    if (((tmp_0 == noun))){
        ! [4: if the player is the actor begin]
        if (((player == actor))){
            ! [5: if the noun is a supporter begin]
            if (((noun ofclass K6_supporter))){
                ! [6: say ~But [we]['re] already on [the noun].~ ( a )]
                say__p=1;ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),TX_R_224); new_line; .L_Say165; .L_SayX165;
                ! [7: otherwise]
                } else {

                ! [8: say ~But [we]['re] already in [the noun].~ ( b )]
                say__p=1;ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),TX_R_225); new_line; .L_Say166; .L_SayX166;
                ! [9: end if]
                }

            ! [10: end if]
            }

        ! [11: stop the action]
        rtrue;
        ! [12: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_163, 163, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor entering ( this is the can't enter what's not enterable rule ):
[ R_164 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_164, 164);
    ! [1: if the noun is not enterable begin]
    if (((~~(((Adj_71_t1_v10(noun))))))){
        ! [2: if the player is the actor begin]
        if (((player == actor))){
            ! [3: if the player's command includes ~stand~ begin]
            if (((matched_text=SnippetIncludes(Consult_Grammar_110,players_command)))){
                ! [4: say ~[regarding the noun][They're] not something [we] [can] stand on.~ ( a )]
                say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_226); new_line; .L_Say167; .L_SayX167;
                ! [5: otherwise if the player's command includes ~sit~]
                } else if (((matched_text=SnippetIncludes(Consult_Grammar_111,players_command)))) {
                ! [6: say ~[regarding the noun][They're] not something [we] [can] sit down on.~ ( b )]
                say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_227); new_line; .L_Say168; .L_SayX168;
                ! [7: otherwise if the player's command includes ~lie~]
                } else if (((matched_text=SnippetIncludes(Consult_Grammar_112,players_command)))) {
                ! [8: say ~[regarding the noun][They're] not something [we] [can] lie down on.~ ( c )]
                say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_228); new_line; .L_Say169; .L_SayX169;
                ! [9: otherwise]
                } else {

                ! [10: say ~[regarding the noun][They're] not something [we] [can] enter.~ ( d )]
                say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_229); new_line; .L_Say170; .L_SayX170;
                ! [11: end if]
                }

            ! [12: end if]
            }

        ! [13: stop the action]
        rtrue;
        ! [14: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_164, 164, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor entering ( this is the can't enter closed containers rule ):
[ R_165 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_165, 165);
    ! [1: if the noun is a closed container begin]
    if (((noun ofclass K5_container) && ((Adj_75_t1_v10(noun))))){
        ! [2: if the player is the actor begin]
        if (((player == actor))){
            ! [3: say ~[We] [can't get] into the closed [noun].~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_230); new_line; .L_Say171; .L_SayX171;
            ! [4: end if]
            }

        ! [5: stop the action]
        rtrue;
        ! [6: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_165, 165, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor entering ( this is the can't enter if this exceeds carrying capacity rule ):
[ R_166 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_166, 166);
    ! [1: if the noun provides the property carrying capacity begin]
    if (((WhetherProvides(noun, false, capacity)))){
        ! [2: if the noun is a supporter begin]
        if (((noun ofclass K6_supporter))){
            ! [3: if the number of things on the noun is at least the carrying capacity of the noun begin]
            if ((((Prop_36()) >= GProperty(OBJECT_TY, noun,capacity)))){
                ! [4: if the actor is the player begin]
                if (((actor == player))){
                    ! [5: now the prior named object is nothing]
                    prior_named_noun = nothing;
                    ! [6: say ~[There] [are] no more room on [the noun].~ ( a )]
                    say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_231); new_line; .L_Say172; .L_SayX172;
                    ! [7: end if]
                    }

                ! [8: stop the action]
                rtrue;
                ! [9: end if]
                }

            ! [10: otherwise if the noun is a container]
            } else if (((noun ofclass K5_container))) {
            ! [11: if the number of things in the noun is at least the carrying capacity of the noun begin]
            if ((((Prop_37()) >= GProperty(OBJECT_TY, noun,capacity)))){
                ! [12: if the actor is the player begin]
                if (((actor == player))){
                    ! [13: now the prior named object is nothing]
                    prior_named_noun = nothing;
                    ! [14: say ~[There] [are] no more room in [the noun].~ ( b )]
                    say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_232); new_line; .L_Say173; .L_SayX173;
                    ! [15: end if]
                    }

                ! [16: stop the action]
                rtrue;
                ! [17: end if]
                }

            ! [18: end if]
            }

        ! [19: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_166, 166, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor entering ( this is the can't enter something carried rule ):
[ R_167 
    tmp_0 ! Let/loop value, e.g., 'local ceiling': object
    ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_167, 167);
    ! [1: let the local ceiling be the common ancestor of the actor with the noun]

    		tmp_0 = (CommonAncestor(actor, noun));
    ! [2: if the local ceiling is the actor begin]
    if (((tmp_0 == actor))){
        ! [3: if the player is the actor begin]
        if (((player == actor))){
            ! [4: say ~[We] [can] only get into something free-standing.~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),TX_R_233); new_line; .L_Say174; .L_SayX174;
            ! [5: end if]
            }

        ! [6: stop the action]
        rtrue;
        ! [7: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_167, 167, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor entering ( this is the implicitly pass through other barriers rule ):
[ R_168 
    tmp_0 ! Let/loop value, e.g., 'local ceiling': object
    tmp_1 ! Let/loop value, e.g., 'target': object
    ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_168, 168);
    ! [1: if the holder of the actor is the holder of the noun , continue the action]
    if ((((HolderOf(actor)) == (HolderOf(noun))))) { rfalse; }
    ! [2: let the local ceiling be the common ancestor of the actor with the noun]

    		tmp_0 = (CommonAncestor(actor, noun));
    ! [3: while the holder of the actor is not the local ceiling begin]
    while (((~~(((HolderOf(actor)) == tmp_0))))){
        ! [4: let the current home be the holder of the actor]

        		tmp_1 = (HolderOf(actor));
        ! [5: if the player is the actor begin]
        if (((player == actor))){
            ! [6: if the current home is a supporter or the current home is an animal begin]
            if ((((tmp_1 ofclass K6_supporter))) || (((tmp_1 ofclass K12_animal)))){
                ! [7: say ~(getting off [the current home])[command clarification break]~ ( a )]
                say__p=1;ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),TX_R_234); .L_Say175; .L_SayX175;
                ! [8: otherwise]
                } else {

                ! [9: say ~(getting out of [the current home])[command clarification break]~ ( b )]
                say__p=1;ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),TX_R_235); .L_Say176; .L_SayX176;
                ! [10: end if]
                }

            ! [11: end if]
            }

        ! [12: silently try the actor trying exiting]
        @push keep_silent; keep_silent=1; @push say__p; @push say__pc;
        		ClearParagraphing(1); TryAction(0, actor, ##Exit, 0, 0);; DivideParagraphPoint();
        		@pull say__pc; @pull say__p; AdjustParagraphPoint(); @pull keep_silent;
        ! [13: if the holder of the actor is the current home , stop the action]
        if ((((HolderOf(actor)) == tmp_1))) { rtrue; }
        ! [14: end while]
        }

    ! [15: if the holder of the actor is the noun , stop the action]
    if ((((HolderOf(actor)) == noun))) { rtrue; }
    ! [16: if the holder of the actor is the holder of the noun , continue the action]
    if ((((HolderOf(actor)) == (HolderOf(noun))))) { rfalse; }
    ! [17: let the target be the holder of the noun]

    		tmp_1 = (HolderOf(noun));
    ! [18: if the noun is part of the target , let the target be the holder of the target]
    if (((tmp_1 == (noun.component_parent)))) { tmp_1 = (HolderOf(tmp_1)); }
    ! [19: while the target is a thing begin]
    while (((tmp_1 ofclass K2_thing))){
        ! [20: if the holder of the target is the local ceiling begin]
        if ((((HolderOf(tmp_1)) == tmp_0))){
            ! [21: if the player is the actor begin]
            if (((player == actor))){
                ! [22: if the target is a supporter begin]
                if (((tmp_1 ofclass K6_supporter))){
                    ! [23: say ~(getting onto [the target])[command clarification break]~ ( c )]
                    say__p=1;ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),TX_R_236); .L_Say177; .L_SayX177;
                    ! [24: otherwise if the target is a container]
                    } else if (((tmp_1 ofclass K5_container))) {
                    ! [25: say ~(getting into [the target])[command clarification break]~ ( d )]
                    say__p=1;ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),TX_R_237); .L_Say178; .L_SayX178;
                    ! [26: otherwise]
                    } else {

                    ! [27: say ~(entering [the target])[command clarification break]~ ( e )]
                    say__p=1;ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),TX_R_238); .L_Say179; .L_SayX179;
                    ! [28: end if]
                    }

                ! [29: end if]
                }

            ! [30: silently try the actor trying entering the target]
            @push keep_silent; keep_silent=1; @push say__p; @push say__pc;
            		ClearParagraphing(1); TryAction(0, actor, ##Enter, tmp_1, 0);; DivideParagraphPoint();
            		@pull say__pc; @pull say__p; AdjustParagraphPoint(); @pull keep_silent;
            ! [31: if the holder of the actor is not the target , stop the action]
            if (((~~(((HolderOf(actor)) == tmp_1))))) { rtrue; }
            ! [32: convert to the entering action on the noun]
            return GVS_Convert(##Enter,noun,0);
            ! [33: continue the action]
            rfalse;
            ! [34: end if]
            }

        ! [35: let the target be the holder of the target]
        tmp_1 = (HolderOf(tmp_1));
        ! [36: end while]
        }

        } else if (debug_rules > 1) DB_Rule(R_168, 168, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Entering (B155_carry_out_entering)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor entering ( this is the standard entering rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Carry out an actor entering ( this is the standard entering rule ):
[ R_169 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_169, 169);
    ! [1: surreptitiously move the actor to the noun]
    move actor to noun;
    } else if (debug_rules > 1) DB_Rule(R_169, 169, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Entering (B156_report_entering)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Report an actor entering ( this is the standard report entering rule ):
!   === equally specific with ===
! Rule 2/2 ! Report an actor entering ( this is the describe contents entered into rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor entering ( this is the standard report entering rule ):
[ R_170 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_170, 170);
    ! [1: if the actor is the player begin]
    if (((actor == player))){
        ! [2: if the action is not silent begin]
        if (((keep_silent == false))){
            ! [3: if the noun is a supporter begin]
            if (((noun ofclass K6_supporter))){
                ! [4: say ~[We] [get] onto [the noun].~ ( a )]
                say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_239); new_line; .L_Say180; .L_SayX180;
                ! [5: otherwise]
                } else {

                ! [6: say ~[We] [get] into [the noun].~ ( b )]
                say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_240); new_line; .L_Say181; .L_SayX181;
                ! [7: end if]
                }

            ! [8: end if]
            }

        ! [9: otherwise if the noun is a container]
        } else if (((noun ofclass K5_container))) {
        ! [10: say ~[The actor] [get] into [the noun].~ ( c )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_241); new_line; .L_Say182; .L_SayX182;
        ! [11: otherwise]
        } else {

        ! [12: say ~[The actor] [get] onto [the noun].~ ( d )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_242); new_line; .L_Say183; .L_SayX183;
        ! [13: end if]
        }

    ! [14: continue the action]
    rfalse;
    } else if (debug_rules > 1) DB_Rule(R_170, 170, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Report an actor entering ( this is the describe contents entered into rule ):
[ R_171 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_171, 171);
    ! [1: if the actor is the player , describe locale for the noun]
    if (((actor == player))) { (PHR_80_r11 (noun)); }
    } else if (debug_rules > 1) DB_Rule(R_171, 171, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Exiting (B157_check_exiting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! Check an actor exiting ( this is the convert exit into go out rule ):
!   === equally specific with ===
! Rule 2/4 ! Check an actor exiting ( this is the can't exit when not inside anything rule ):
!   === equally specific with ===
! Rule 3/4 ! Check an actor exiting ( this is the can't exit closed containers rule ):
!   === equally specific with ===
! Rule 4/4 ! Check an actor exiting ( this is the convert exit into get off rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor exiting ( this is the convert exit into go out rule ):
[ R_173 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    @push formal_par1;
    I7RBLK = KERNEL_3();
    @pull formal_par1;
    @pull formal_par0;
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_3 
    tmp_0 ! Let/loop value, e.g., 'local room': object
    ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_173, 173);
    ! [1: let the local room be the location of the actor]

    		tmp_0 = LocationOf(actor);
    ! [2: if the container exited from is the local room begin]
    if ((((MStack-->MstVO(20009,0)) == tmp_0))){
        ! [3: if the room-or-door outside from the local room is not nothing , convert to the going action on the outside]
        if (((~~((
        ! Resolution of run-time phrase ambiguity (deciding a value):
            (
                ! This value evaluates third (i.e., last)
                formal_rv
            +
                0*(
                    ! The following condition evaluates second
                    ((
                        ((((((formal_par1 ofclass K1_room) && (formal_par1 ofclass K1_room))))) && ((
                        formal_rv = RoomOrDoorFrom(formal_par1,formal_par0)) | 1)
                        )|| (ArgumentTypeFailed(2563, 1))

                    ))
                +
                    ! The following assignments evaluate first
                    ((formal_par1 = tmp_0) +
                    (formal_par0 = out_obj)
                    ))
            )

        ! Resolution complete
         == nothing))))) { return GVS_Convert(##Go,out_obj,0); }
        ! [4: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_173, 173, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor exiting ( this is the can't exit when not inside anything rule ):
[ R_174 
    tmp_0 ! Let/loop value, e.g., 'local room': object
    ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_174, 174);
    ! [1: let the local room be the location of the actor]

    		tmp_0 = LocationOf(actor);
    ! [2: if the container exited from is the local room begin]
    if ((((MStack-->MstVO(20009,0)) == tmp_0))){
        ! [3: if the player is the actor begin]
        if (((player == actor))){
            ! [4: say ~But [we] [aren't] in anything at the [if story tense is present tense]moment[otherwise]time[end if].~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),TX_R_243); new_line; .L_Say184; .L_SayX184;
            ! [5: end if]
            }

        ! [6: stop the action]
        rtrue;
        ! [7: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_174, 174, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor exiting ( this is the can't exit closed containers rule ):
[ R_175 
    tmp_0 ! Let/loop value, e.g., 'cage': container
    ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_175, 175);
    ! [1: if the actor is in a closed container ( called the cage ) begin]
    if (((ContainerOf(actor) ofclass K5_container) && (tmp_0=(ContainerOf(actor)), true) && ((Adj_75_t1_v10(ContainerOf(actor)))))){
        ! [2: if the player is the actor begin]
        if (((player == actor))){
            ! [3: say ~You can't get out of the closed [cage].~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),TX_R_244); new_line; .L_Say185; .L_SayX185;
            ! [4: end if]
            }

        ! [5: stop the action]
        rtrue;
        ! [6: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_175, 175, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor exiting ( this is the convert exit into get off rule ):
[ R_176 
    tmp_0 ! Let/loop value, e.g., 'platform': supporter
    ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_176, 176);
    ! [1: if the actor is on a supporter ( called the platform ) , convert to the getting off action on the platform]
    if (((SupporterOf(actor) ofclass K6_supporter) && (tmp_0=(SupporterOf(actor)), true))) { return GVS_Convert(##GetOff,tmp_0,0); }
    } else if (debug_rules > 1) DB_Rule(R_176, 176, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Exiting (B158_carry_out_exiting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor exiting ( this is the standard exiting rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Carry out an actor exiting ( this is the standard exiting rule ):
[ R_177 
    tmp_0 ! Let/loop value, e.g., 'former exterior': object
    ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_177, 177);
    ! [1: let the former exterior be the not-counting-parts holder of the container exited from]

    		tmp_0 = (CoreOfParentOfCoreOf((MStack-->MstVO(20009,0))));
    ! [2: surreptitiously move the actor to the former exterior]
    move actor to tmp_0;
    } else if (debug_rules > 1) DB_Rule(R_177, 177, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Exiting (B159_report_exiting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Report an actor exiting ( this is the standard report exiting rule ):
!   === equally specific with ===
! Rule 2/2 ! Report an actor exiting ( this is the describe room emerged into rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor exiting ( this is the standard report exiting rule ):
[ R_178 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_178, 178);
    ! [1: if the action is not silent begin]
    if (((keep_silent == false))){
        ! [2: if the actor is the player begin]
        if (((actor == player))){
            ! [3: if the container exited from is a supporter begin]
            if ((((MStack-->MstVO(20009,0)) ofclass K6_supporter))){
                ! [4: say ~[We] [get] off [the container exited from].~ ( a )]
                say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_245); new_line; .L_Say186; .L_SayX186;
                ! [5: otherwise]
                } else {

                ! [6: say ~[We] [get] out of [the container exited from].~ ( b )]
                say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_246); new_line; .L_Say187; .L_SayX187;
                ! [7: end if]
                }

            ! [8: otherwise]
            } else {

            ! [9: say ~[The actor] [get] out of [the container exited from].~ ( c )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_247); new_line; .L_Say188; .L_SayX188;
            ! [10: end if]
            }

        ! [11: end if]
        }

    ! [12: continue the action]
    rfalse;
    } else if (debug_rules > 1) DB_Rule(R_178, 178, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Report an actor exiting ( this is the describe room emerged into rule ):
[ R_179 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_179, 179);
    ! [1: if the actor is the player begin]
    if (((actor == player))){
        ! [2: surreptitiously reckon darkness]
        SilentlyConsiderLight();
        ! [3: produce a room description with going spacing conventions]
        LookAfterGoing();
        ! [4: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_179, 179, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Getting off (B160_check_getting_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor getting off ( this is the can't get off things rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor getting off ( this is the can't get off things rule ):
[ R_180 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_180, 180);
    ! [1: if the actor is on the noun , continue the action]
    if (((noun == SupporterOf(actor)))) { rfalse; }
    ! [2: if the actor is carried by the noun , continue the action]
    if (((noun == CarrierOf(actor)))) { rfalse; }
    ! [3: if the actor is the player begin]
    if (((actor == player))){
        ! [4: say ~But [we] [aren't] on [the noun] at the [if story tense is present tense]moment[otherwise]time[end if].~ ( a )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_248); new_line; .L_Say189; .L_SayX189;
        ! [5: end if]
        }

    ! [6: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_180, 180, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Getting off (B161_carry_out_getting_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor getting off ( this is the standard getting off rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Carry out an actor getting off ( this is the standard getting off rule ):
[ R_181 
    tmp_0 ! Let/loop value, e.g., 'former exterior': object
    ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_181, 181);
    ! [1: let the former exterior be the not-counting-parts holder of the noun]

    		tmp_0 = (CoreOfParentOfCoreOf(noun));
    ! [2: surreptitiously move the actor to the former exterior]
    move actor to tmp_0;
    } else if (debug_rules > 1) DB_Rule(R_181, 181, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Getting off (B162_report_getting_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Report an actor getting off ( this is the standard report getting off rule ):
!   === equally specific with ===
! Rule 2/2 ! Report an actor getting off ( this is the describe room stood up into rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor getting off ( this is the standard report getting off rule ):
[ R_182 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_182, 182);
    ! [1: if the action is not silent begin]
    if (((keep_silent == false))){
        ! [2: say ~[The actor] [get] off [the noun].~ ( a )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_249); new_line; .L_Say190; .L_SayX190;
        ! [3: end if]
        }

    ! [4: continue the action]
    rfalse;
    } else if (debug_rules > 1) DB_Rule(R_182, 182, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Report an actor getting off ( this is the describe room stood up into rule ):
[ R_183 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_183, 183);
    ! [1: if the actor is the player , produce a room description with going spacing conventions]
    if (((actor == player))) { LookAfterGoing(); }
    } else if (debug_rules > 1) DB_Rule(R_183, 183, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Looking (B164_carry_out_looking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/5 ! Carry out looking ( this is the declare everything unmentioned rule ):
!   === equally specific with ===
! Rule 2/5 ! Carry out looking ( this is the room description heading rule ):
!   === equally specific with ===
! Rule 3/5 ! Carry out looking ( this is the room description body text rule ):
!   === equally specific with ===
! Rule 4/5 ! Carry out looking ( this is the room description paragraphs about objects rule ):
!   === equally specific with ===
! Rule 5/5 ! Carry out looking ( this is the check new arrival rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Carry out looking ( this is the declare everything unmentioned rule ):
[ R_185 
    tmp_0 ! Let/loop value, e.g., '?-1,-1?'(deallocated by end of phrase)
    tmp_1 ! Let/loop value, e.g., '?-1,-1?'(deallocated by end of phrase)
    ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_185, 185);
    ! [1: repeat with item running through things begin]
    for (tmp_0=Prop_38(0), tmp_1=Prop_38(tmp_0): tmp_0: tmp_0=tmp_1, tmp_1=Prop_38(tmp_1)){
        ! [2: now the item is not mentioned]
        (Adj_69_t3_v10(tmp_0));
        ! [3: end repeat]
        }

        } else if (debug_rules > 1) DB_Rule(R_185, 185, 'actor');
        rfalse;
];
! From the Standard Rules
! No specific request
! Carry out looking ( this is the room description heading rule ):
[ R_186 
    tmp_0 ! Let/loop value, e.g., 'intermediate level': object
    tmp_1 ! Let/loop value, e.g., '?-1,-1?'(deallocated by end of phrase)
    ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_186, 186);
    ! [1: say bold type]
    say__p=1;ParaContent(); style bold; .L_Say191; .L_SayX191;
    ! [2: if the visibility level count is 0 begin]
    if ((((MStack-->MstVO(20011,2)) == 0))){
        ! [3: begin the printing the name of a dark room activity]
        BeginActivity(V9_printing_the_name_of_a_da);
        ! [4: if handling the printing the name of a dark room activity begin]
        if (((~~(ForActivity(V9_printing_the_name_of_a_da))))){
            ! [5: say ~Darkness~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_250); .L_Say192; .L_SayX192;
            ! [6: end if]
            }

        ! [7: end the printing the name of a dark room activity]
        EndActivity(V9_printing_the_name_of_a_da);
        ! [8: otherwise if the visibility ceiling is the location]
        } else if ((((MStack-->MstVO(20011,3)) == real_location))) {
        ! [9: say ~[visibility ceiling]~]
        say__p=1;ParaContent(); print (PrintShortName) (MStack-->MstVO(20011,3)); .L_Say193; .L_SayX193;
        ! [10: otherwise]
        } else {

        ! [11: say ~[The visibility ceiling]~]
        say__p=1;ParaContent(); print (The) (MStack-->MstVO(20011,3)); .L_Say194; .L_SayX194;
        ! [12: end if]
        }

    ! [13: say roman type]
    say__p=1;ParaContent(); style roman; .L_Say195; .L_SayX195;
    ! [14: let intermediate level be the visibility-holder of the actor]

    		tmp_0 = VisibilityParent(actor);
    ! [15: repeat with intermediate level count running from 2 to the visibility level count begin]
    for (tmp_1=2: tmp_1<=(MStack-->MstVO(20011,2)): tmp_1++){
        ! [16: if the intermediate level is a supporter or the intermediate level is an animal begin]
        if ((((tmp_0 ofclass K6_supporter))) || (((tmp_0 ofclass K12_animal)))){
            ! [17: say ~ (on [the intermediate level])~ ( b )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),TX_R_251); .L_Say196; .L_SayX196;
            ! [18: otherwise]
            } else {

            ! [19: say ~ (in [the intermediate level])~ ( c )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),TX_R_252); .L_Say197; .L_SayX197;
            ! [20: end if]
            }

        ! [21: let the intermediate level be the visibility-holder of the intermediate level]
        tmp_0 = VisibilityParent(tmp_0);
        ! [22: end repeat]
        }

    ! [23: say line break]
    say__p=1;ParaContent(); new_line; .L_Say198; .L_SayX198;
    ! [24: say run paragraph on with special look spacing]
    say__p=1;ParaContent(); SpecialLookSpacingBreak(); .L_Say199; .L_SayX199;
    } else if (debug_rules > 1) DB_Rule(R_186, 186, 'actor');
    rfalse;
];
! From the Standard Rules
! No specific request
! Carry out looking ( this is the room description body text rule ):
[ R_187 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_187, 187);
    ! [1: if the visibility level count is 0 begin]
    if ((((MStack-->MstVO(20011,2)) == 0))){
        ! [2: if set to abbreviated room descriptions , continue the action]
        if (((lookmode == 3))) { rfalse; }
        ! [3: if set to sometimes abbreviated room descriptions and abbreviated form allowed is true and darkness witnessed is true , continue the action]
        if ((((lookmode == 1))) && ((((((MStack-->MstVO(20011,1)) && true) == (1 && true)))) && (((((Global_Vars-->0) && true) == (1 && true)))))) { rfalse; }
        ! [4: begin the printing the description of a dark room activity]
        BeginActivity(V10_printing_the_description);
        ! [5: if handling the printing the description of a dark room activity begin]
        if (((~~(ForActivity(V10_printing_the_description))))){
            ! [6: now the prior named object is nothing]
            prior_named_noun = nothing;
            ! [7: say ~[It] [are] pitch dark, and [we] [can't see] a thing.~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_253); new_line; .L_Say200; .L_SayX200;
            ! [8: end if]
            }

        ! [9: end the printing the description of a dark room activity]
        EndActivity(V10_printing_the_description);
        ! [10: otherwise if the visibility ceiling is the location]
        } else if ((((MStack-->MstVO(20011,3)) == real_location))) {
        ! [11: if set to abbreviated room descriptions , continue the action]
        if (((lookmode == 3))) { rfalse; }
        ! [12: if set to sometimes abbreviated room descriptions and abbreviated form allowed is true and the location is visited , continue the action]
        if ((((lookmode == 1))) && ((((((MStack-->MstVO(20011,1)) && true) == (1 && true)))) && ((((Adj_53_t1_v10(real_location))))))) { rfalse; }
        ! [13: print the location's description]
        PrintOrRun(location, description);
        ! [14: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_187, 187, 'actor');
        rfalse;
];
! From the Standard Rules
! No specific request
! Carry out looking ( this is the room description paragraphs about objects rule ):
[ R_188 
    tmp_0 ! Let/loop value, e.g., '?-1,-1?'(deallocated by end of phrase)
    tmp_1 ! Let/loop value, e.g., '?-1,-1?'(deallocated by end of phrase)
    tmp_2 ! Let/loop value, e.g., '?-1,-1?'(deallocated by end of phrase)
    ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_188, 188);
    ! [1: if the visibility level count is greater than 0 begin]
    if ((((MStack-->MstVO(20011,2)) > 0))){
        ! [2: let the intermediate position be the actor]

        		tmp_0 = actor;
        ! [3: let the ip count be the visibility level count]

        		tmp_1 = (MStack-->MstVO(20011,2));
        ! [4: while the ip count is greater than 0 begin]
        while (((tmp_1 > 0))){
            ! [5: now the intermediate position is marked for listing]
            (Adj_67_t2_v10(tmp_0));
            ! [6: let the intermediate position be the visibility-holder of the intermediate position]
            tmp_0 = VisibilityParent(tmp_0);
            ! [7: decrease the ip count by 1]
            tmp_1 = tmp_1 - 1;;
            ! [8: end while]
            }

        ! [9: let the top-down ip count be the visibility level count]

        		tmp_2 = (MStack-->MstVO(20011,2));
        ! [10: while the top-down ip count is greater than 0 begin]
        while (((tmp_2 > 0))){
            ! [11: let the intermediate position be the actor]
            tmp_0 = actor;
            ! [12: let the ip count be 0]
            tmp_1 = 0;
            ! [13: while the ip count is less than the top-down ip count begin]
            while (((tmp_1 < tmp_2))){
                ! [14: let the intermediate position be the visibility-holder of the intermediate position]
                tmp_0 = VisibilityParent(tmp_0);
                ! [15: increase the ip count by 1]
                tmp_1 = tmp_1 + 1;;
                ! [16: end while]
                }

            ! [17: describe locale for the intermediate position]
            (PHR_80_r11 (tmp_0));
            ! [18: decrease the top-down ip count by 1]
            tmp_2 = tmp_2 - 1;;
            ! [19: end while]
            }

        ! [20: end if]
        }

    ! [21: continue the action]
    rfalse;
    } else if (debug_rules > 1) DB_Rule(R_188, 188, 'actor');
    rfalse;
];
! From the Standard Rules
! No specific request
! Carry out looking ( this is the check new arrival rule ):
[ R_189 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_189, 189);
    ! [1: if in darkness begin]
    if (((location==thedark))){
        ! [2: now the darkness witnessed is true]
        (Global_Vars-->0) = 1;
        ! [3: otherwise]
        } else {

        ! [4: if the location is a room , now the location is visited]
        if (((real_location ofclass K1_room))) { (Adj_53_t2_v10(real_location)); }
        ! [5: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_189, 189, 'actor');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Looking (B165_report_looking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor looking ( this is the other people looking rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor looking ( this is the other people looking rule ):
[ R_190 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_190, 190);
    ! [1: if the actor is not the player begin]
    if (((~~((actor == player))))){
        ! [2: say ~[The actor] [look] around.~ ( a )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_254); new_line; .L_Say201; .L_SayX201;
        ! [3: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_190, 190, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Examining (B167_carry_out_examining)
! ----------------------------------------------------------------------------------------------------
! Rule 1/6 ! Carry out examining ( this is the standard examining rule ):
!   === equally specific with ===
! Rule 2/6 ! Carry out examining ( this is the examine directions rule ):
!   === equally specific with ===
! Rule 3/6 ! Carry out examining ( this is the examine containers rule ):
!   === equally specific with ===
! Rule 4/6 ! Carry out examining ( this is the examine supporters rule ):
!   === equally specific with ===
! Rule 5/6 ! Carry out examining ( this is the examine devices rule ):
!   === equally specific with ===
! Rule 6/6 ! Carry out examining ( this is the examine undescribed things rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Carry out examining ( this is the standard examining rule ):
[ R_191 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_191, 191);
    ! [1: if the noun provides the property description and the description of the noun is not ~~ begin]
    if ((((WhetherProvides(noun, false, description)))) && (((~~(( BlkValueCompare(GProperty(OBJECT_TY, noun,description), EMPTY_TEXT_VALUE) == 0)))))){
        ! [2: say ~[description of the noun][line break]~]
        @push self; say__p=1;ParaContent(); print (TEXT_TY_Say) GProperty(OBJECT_TY, self=noun,description);@pull self; ParaContent(); new_line; .L_Say202; .L_SayX202;
        ! [3: now examine text printed is true]
        (MStack-->MstVO(20012,0)) = 1;
        ! [4: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_191, 191, 'actor');
        rfalse;
];
! From the Standard Rules
! No specific request
! Carry out examining ( this is the examine directions rule ):
[ R_192 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_192, 192);
    ! [1: if the noun is a direction begin]
    if (((noun ofclass K3_direction))){
        ! [2: say ~[We] [see] nothing unexpected in that direction.~ ( a )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_255); new_line; .L_Say203; .L_SayX203;
        ! [3: now examine text printed is true]
        (MStack-->MstVO(20012,0)) = 1;
        ! [4: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_192, 192, 'actor');
        rfalse;
];
! From the Standard Rules
! No specific request
! Carry out examining ( this is the examine containers rule ):
[ R_193 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_193, 193);
    ! [1: if the noun is a container begin]
    if (((noun ofclass K5_container))){
        ! [2: if the noun is open or the noun is transparent begin]
        if (((((Adj_74_t1_v10(noun))))) || ((((Adj_73_t1_v10(noun)))))){
            ! [3: if something described which is not scenery is in the noun and something which is not the player is in the noun begin]
            if (((((Prop_39())))) && ((((Prop_40()))))){
                ! [4: say ~In [the noun] ~ ( a )]
                say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_256); .L_Say204; .L_SayX204;
                ! [5: list the contents of the noun , as a sentence , tersely , not listing concealed items , prefacing with is/are]
                WriteListFrom(child(noun), 3144);
                ! [6: say ~.~]
                say__p=1;ParaContent(); print "."; new_line; .L_Say205; .L_SayX205;
                ! [7: now examine text printed is true]
                (MStack-->MstVO(20012,0)) = 1;
                ! [8: otherwise if examine text printed is false]
                } else if (((((MStack-->MstVO(20012,0)) && true) == (0 && true)))) {
                ! [9: if the player is in the noun begin]
                if (((noun == ContainerOf(player)))){
                    ! [10: make no decision]
                    rfalse;
                    ! [11: end if]
                    }

                ! [12: say ~[The noun] [are] empty.~ ( b )]
                say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_257); new_line; .L_Say206; .L_SayX206;
                ! [13: now examine text printed is true]
                (MStack-->MstVO(20012,0)) = 1;
                ! [14: end if]
                }

            ! [15: end if]
            }

        ! [16: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_193, 193, 'actor');
        rfalse;
];
! From the Standard Rules
! No specific request
! Carry out examining ( this is the examine supporters rule ):
[ R_194 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_194, 194);
    ! [1: if the noun is a supporter begin]
    if (((noun ofclass K6_supporter))){
        ! [2: if something described which is not scenery is on the noun and something which is not the player is on the noun begin]
        if (((((Prop_41())))) && ((((Prop_42()))))){
            ! [3: say ~On [the noun] ~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_258); .L_Say207; .L_SayX207;
            ! [4: list the contents of the noun , as a sentence , tersely , not listing concealed items , prefacing with is/are , including contents , giving brief inventory information]
            WriteListFrom(child(noun), 3288);
            ! [5: say ~.~]
            say__p=1;ParaContent(); print "."; new_line; .L_Say208; .L_SayX208;
            ! [6: now examine text printed is true]
            (MStack-->MstVO(20012,0)) = 1;
            ! [7: end if]
            }

        ! [8: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_194, 194, 'actor');
        rfalse;
];
! From the Standard Rules
! No specific request
! Carry out examining ( this is the examine devices rule ):
[ R_195 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_195, 195);
    ! [1: if the noun is a device begin]
    if (((noun ofclass K13_device))){
        ! [2: say ~[The noun] [are] [if story tense is present tense]currently [end if]switched [if the noun is switched on]on[otherwise]off[end if].~ ( a )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_259); new_line; .L_Say209; .L_SayX209;
        ! [3: now examine text printed is true]
        (MStack-->MstVO(20012,0)) = 1;
        ! [4: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_195, 195, 'actor');
        rfalse;
];
! From the Standard Rules
! No specific request
! Carry out examining ( this is the examine undescribed things rule ):
[ R_196 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_196, 196);
    ! [1: if examine text printed is false begin]
    if (((((MStack-->MstVO(20012,0)) && true) == (0 && true)))){
        ! [2: say ~[We] [see] nothing special about [the noun].~ ( a )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_260); new_line; .L_Say210; .L_SayX210;
        ! [3: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_196, 196, 'actor');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Examining (B168_report_examining)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor examining ( this is the report other people examining rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor examining ( this is the report other people examining rule ):
[ R_197 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_197, 197);
    ! [1: if the actor is not the player begin]
    if (((~~((actor == player))))){
        ! [2: say ~[The actor] [look] closely at [the noun].~ ( a )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_261); new_line; .L_Say211; .L_SayX211;
        ! [3: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_197, 197, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Looking under (B170_carry_out_looking_under)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor looking under ( this is the standard looking under rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Carry out an actor looking under ( this is the standard looking under rule ):
[ R_198 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_198, 198);
    ! [1: if the player is the actor begin]
    if (((player == actor))){
        ! [2: say ~[We] [find] nothing of interest.~ ( a )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_262); new_line; .L_Say212; .L_SayX212;
        ! [3: end if]
        }

    ! [4: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_198, 198, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Looking under (B171_report_looking_under)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor looking under ( this is the report other people looking under rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor looking under ( this is the report other people looking under rule ):
[ R_199 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_199, 199);
    ! [1: if the action is not silent begin]
    if (((keep_silent == false))){
        ! [2: if the actor is not the player begin]
        if (((~~((actor == player))))){
            ! [3: say ~[The actor] [look] under [the noun].~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_263); new_line; .L_Say213; .L_SayX213;
            ! [4: end if]
            }

        ! [5: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_199, 199, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Searching (B172_check_searching)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check an actor searching ( this is the can't search unless container or supporter rule ):
!   === equally specific with ===
! Rule 2/2 ! Check an actor searching ( this is the can't search closed opaque containers rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor searching ( this is the can't search unless container or supporter rule ):
[ R_200 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_200, 200);
    ! [1: if the noun is not a container and the noun is not a supporter begin]
    if ((((~~((noun ofclass K5_container))))) && (((~~((noun ofclass K6_supporter)))))){
        ! [2: if the player is the actor begin]
        if (((player == actor))){
            ! [3: say ~[We] [find] nothing of interest.~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_264); new_line; .L_Say214; .L_SayX214;
            ! [4: end if]
            }

        ! [5: stop the action]
        rtrue;
        ! [6: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_200, 200, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor searching ( this is the can't search closed opaque containers rule ):
[ R_201 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_201, 201);
    ! [1: if the noun is a closed opaque container begin]
    if (((noun ofclass K5_container) && ((Adj_75_t1_v10(noun))) && ((Adj_72_t1_v10(noun))))){
        ! [2: if the player is the actor begin]
        if (((player == actor))){
            ! [3: say ~[We] [can't see] inside, since [the noun] [are] closed.~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_265); new_line; .L_Say215; .L_SayX215;
            ! [4: end if]
            }

        ! [5: stop the action]
        rtrue;
        ! [6: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_201, 201, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Searching (B174_report_searching)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Report searching a container ( this is the standard search containers rule ):
!   === equally specific with ===
! Rule 2/3 ! Report searching a supporter ( this is the standard search supporters rule ):
!   >>> I - Number of aspects constrained >>>
! Rule 3/3 ! Report an actor searching ( this is the report other people searching rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report searching a container ( this is the standard search containers rule ):
[ R_202 ;
    if ((( (actor==player) && ((noun ofclass K5_container))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_202, 202);
    ! [1: if the noun contains a described thing which is not scenery begin]
    if ((((Prop_43())))){
        ! [2: say ~In [the noun] ~ ( a )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_266); .L_Say216; .L_SayX216;
        ! [3: list the contents of the noun , as a sentence , tersely , not listing concealed items , prefacing with is/are]
        WriteListFrom(child(noun), 3144);
        ! [4: say ~.~]
        say__p=1;ParaContent(); print "."; new_line; .L_Say217; .L_SayX217;
        ! [5: otherwise]
        } else {

        ! [6: say ~[The noun] [are] empty.~ ( b )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_267); new_line; .L_Say218; .L_SayX218;
        ! [7: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_202, 202, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Report searching a supporter ( this is the standard search supporters rule ):
[ R_203 ;
    if ((( (actor==player) && ((noun ofclass K6_supporter))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_203, 203);
    ! [1: if the noun supports a described thing which is not scenery begin]
    if ((((Prop_44())))){
        ! [2: say ~On [the noun] ~ ( a )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_268); .L_Say219; .L_SayX219;
        ! [3: list the contents of the noun , as a sentence , tersely , not listing concealed items , prefacing with is/are]
        WriteListFrom(child(noun), 3144);
        ! [4: say ~.~]
        say__p=1;ParaContent(); print "."; new_line; .L_Say220; .L_SayX220;
        ! [5: otherwise]
        } else {

        ! [6: now the prior named object is nothing]
        prior_named_noun = nothing;
        ! [7: say ~[There] [are] nothing on [the noun].~ ( b )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_269); new_line; .L_Say221; .L_SayX221;
        ! [8: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_203, 203, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Report an actor searching ( this is the report other people searching rule ):
[ R_204 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_204, 204);
    ! [1: if the actor is not the player begin]
    if (((~~((actor == player))))){
        ! [2: say ~[The actor] [search] [the noun].~ ( a )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_270); new_line; .L_Say222; .L_SayX222;
        ! [3: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_204, 204, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Consulting it about (B177_report_consulting_it_ab)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor consulting something about ( this is the block consulting rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor consulting something about ( this is the block consulting rule ):
[ R_205 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_205, 205);
    ! [1: if the actor is the player begin]
    if (((actor == player))){
        ! [2: say ~[We] [discover] nothing of interest in [the noun].~ ( a )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_271); new_line; .L_Say223; .L_SayX223;
        ! [3: otherwise]
        } else {

        ! [4: say ~[The actor] [look] at [the noun].~ ( b )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_272); new_line; .L_Say224; .L_SayX224;
        ! [5: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_205, 205, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Locking it with (B178_check_locking_it_with)
! ----------------------------------------------------------------------------------------------------
! Rule 1/5 ! Check an actor locking something with ( this is the can't lock without a lock rule ):
!   === equally specific with ===
! Rule 2/5 ! Check an actor locking something with ( this is the can't lock what's already locked rule ):
!   === equally specific with ===
! Rule 3/5 ! Check an actor locking something with ( this is the can't lock what's open rule ):
!   >>> I - Number of aspects constrained >>>
! Rule 4/5 ! This is the right second rule:
!   === equally specific with ===
! Rule 5/5 ! Check locking it with:
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor locking something with ( this is the can't lock without a lock rule ):
[ R_206 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_206, 206);
    ! [1: if the noun provides the property lockable and the noun is lockable begin]
    if ((((WhetherProvides(noun, true, lockable)))) && ((((Adj_78_t1_v10(noun)))))){
        ! [2: continue the action]
        rfalse;
        ! [3: end if]
        }

    ! [4: if the actor is the player begin]
    if (((actor == player))){
        ! [5: say ~[regarding the noun][Those] [don't] seem to be something [we] [can] lock.~ ( a )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_273); new_line; .L_Say225; .L_SayX225;
        ! [6: end if]
        }

    ! [7: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_206, 206, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor locking something with ( this is the can't lock what's already locked rule ):
[ R_207 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_207, 207);
    ! [1: if the noun is locked begin]
    if ((((Adj_79_t1_v10(noun))))){
        ! [2: if the actor is the player begin]
        if (((actor == player))){
            ! [3: say ~[regarding the noun][They're] locked at the [if story tense is present tense]moment[otherwise]time[end if].~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_274); new_line; .L_Say226; .L_SayX226;
            ! [4: end if]
            }

        ! [5: stop the action]
        rtrue;
        ! [6: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_207, 207, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor locking something with ( this is the can't lock what's open rule ):
[ R_208 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_208, 208);
    ! [1: if the noun is open begin]
    if ((((Adj_74_t1_v10(noun))))){
        ! [2: if the actor is the player begin]
        if (((actor == player))){
            ! [3: say ~First [we] [would have] to close [the noun].~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_275); new_line; .L_Say227; .L_SayX227;
            ! [4: end if]
            }

        ! [5: stop the action]
        rtrue;
        ! [6: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_208, 208, 'action');
        rfalse;
];
! From "Locksmith" by Emily Short
! No specific request
! This is the right second rule:
[ R_824 ;
    if (debug_rules) DB_Rule(R_824, 824);
    ! [1: if the second noun does not unlock the noun begin]
    if (((~~((second == (RGuard_f0_1(noun))))))){
        ! [2: say ~[The second noun] [do not fit] [the noun].~ ( a ) instead]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_276); new_line; rtrue; .L_Say228; .L_SayX228; rtrue;
        ! [3: end if]
        }

        rfalse;
];
! From "Locksmith" by Emily Short
! No specific request
! Check locking it with:
[ R_827 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_827, 827);
    ! [1: abide by the must have accessible the second noun rule]
    if (FollowRulebook(R_845)) rtrue;
    } else if (debug_rules > 1) DB_Rule(R_827, 827, 'actor');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Locking it with (B179_carry_out_locking_it_wi)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Carry out locking something with a passkey ( this is the standard passkey locking rule ):
!   >>> III.3.1 - Action/What/Second Thing Acted On >>>
! Rule 2/2 ! Carry out an actor locking something with ( this is the standard locking rule ):
! ----------------------------------------------------------------------------------------------------
! From "Locksmith" by Emily Short
! No specific request
! Carry out locking something with a passkey ( this is the standard passkey locking rule ):
[ R_835 ;
    if ((( (actor==player) && ((noun ofclass K2_thing)) && ((second ofclass K16_passkey))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_835, 835);
    ! [1: if the second noun unlocks the noun , now the second noun unbolts the noun]
    if (((second == (RGuard_f0_1(noun))))) { (RGuard_MT_2(second,noun)); }
    } else if (debug_rules > 1) DB_Rule(R_835, 835, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Carry out an actor locking something with ( this is the standard locking rule ):
[ R_210 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_210, 210);
    ! [1: now the noun is locked]
    (Adj_79_t2_v10(noun));
    } else if (debug_rules > 1) DB_Rule(R_210, 210, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Locking it with (B180_report_locking_it_with)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Report someone trying locking something with a passkey ( this is the observe someone locking rule ):
!   >>> III.3.1 - Action/What/Second Thing Acted On >>>
! Rule 2/2 ! Report an actor locking something with ( this is the standard report locking rule ):
! ----------------------------------------------------------------------------------------------------
! From "Locksmith" by Emily Short
! No specific request
! Report someone trying locking something with a passkey ( this is the observe someone locking rule ):
[ R_836 ;
    if ((( (actor~=player) && (act_requester==nothing) && ((actor ofclass K8_person)) && ((noun ofclass K2_thing)) && ((second ofclass K16_passkey))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_836, 836);
    ! [1: now the second noun unbolts the noun]
    (RGuard_MT_2(second,noun));
    } else if (debug_rules > 1) DB_Rule(R_836, 836, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Report an actor locking something with ( this is the standard report locking rule ):
[ R_211 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_211, 211);
    ! [1: if the actor is the player begin]
    if (((actor == player))){
        ! [2: if the action is not silent begin]
        if (((keep_silent == false))){
            ! [3: say ~[We] [lock] [the noun].~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_277); new_line; .L_Say229; .L_SayX229;
            ! [4: end if]
            }

        ! [5: otherwise]
        } else {

        ! [6: if the actor is visible begin]
        if ((((Adj_3_t1_v10(actor))))){
            ! [7: say ~[The actor] [lock] [the noun].~ ( b )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_278); new_line; .L_Say230; .L_SayX230;
            ! [8: end if]
            }

        ! [9: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_211, 211, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Unlocking it with (B181_check_unlocking_it_with)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! Check an actor unlocking something with ( this is the can't unlock without a lock rule ):
!   === equally specific with ===
! Rule 2/4 ! Check an actor unlocking something with ( this is the can't unlock what's already unlocked rule ):
!   >>> I - Number of aspects constrained >>>
! Rule 3/4 ! This is the right second rule:
!   === equally specific with ===
! Rule 4/4 ! Check unlocking it with ( this is the must be able to reach the key rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor unlocking something with ( this is the can't unlock without a lock rule ):
[ R_212 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_212, 212);
    ! [1: if the noun provides the property lockable and the noun is lockable begin]
    if ((((WhetherProvides(noun, true, lockable)))) && ((((Adj_78_t1_v10(noun)))))){
        ! [2: continue the action]
        rfalse;
        ! [3: end if]
        }

    ! [4: if the actor is the player begin]
    if (((actor == player))){
        ! [5: say ~[regarding the noun][Those] [don't] seem to be something [we] [can] unlock.~ ( a )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_279); new_line; .L_Say231; .L_SayX231;
        ! [6: end if]
        }

    ! [7: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_212, 212, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor unlocking something with ( this is the can't unlock what's already unlocked rule ):
[ R_213 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_213, 213);
    ! [1: if the noun is not locked begin]
    if (((~~(((Adj_79_t1_v10(noun))))))){
        ! [2: if the actor is the player begin]
        if (((actor == player))){
            ! [3: say ~[regarding the noun][They're] unlocked at the [if story tense is present tense]moment[otherwise]time[end if].~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_280); new_line; .L_Say232; .L_SayX232;
            ! [4: end if]
            }

        ! [5: stop the action]
        rtrue;
        ! [6: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_213, 213, 'action');
        rfalse;
];
! From "Locksmith" by Emily Short
! No specific request
! Check unlocking it with ( this is the must be able to reach the key rule ):
[ R_823 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_823, 823);
    ! [1: abide by the must have accessible the second noun rule]
    if (FollowRulebook(R_845)) rtrue;
    } else if (debug_rules > 1) DB_Rule(R_823, 823, 'actor');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Unlocking it with (B182_carry_out_unlocking_it_)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Carry out unlocking something with a passkey ( this is the standard passkey unlocking rule ):
!   >>> III.3.1 - Action/What/Second Thing Acted On >>>
! Rule 2/2 ! Carry out an actor unlocking something with ( this is the standard unlocking rule ):
! ----------------------------------------------------------------------------------------------------
! From "Locksmith" by Emily Short
! No specific request
! Carry out unlocking something with a passkey ( this is the standard passkey unlocking rule ):
[ R_833 ;
    if ((( (actor==player) && ((noun ofclass K2_thing)) && ((second ofclass K16_passkey))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_833, 833);
    ! [1: if the second noun unlocks the noun , now the second noun unbolts the noun]
    if (((second == (RGuard_f0_1(noun))))) { (RGuard_MT_2(second,noun)); }
    } else if (debug_rules > 1) DB_Rule(R_833, 833, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Carry out an actor unlocking something with ( this is the standard unlocking rule ):
[ R_215 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_215, 215);
    ! [1: now the noun is not locked]
    (Adj_79_t3_v10(noun));
    } else if (debug_rules > 1) DB_Rule(R_215, 215, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Unlocking it with (B183_report_unlocking_it_wit)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Report someone trying unlocking something with a passkey ( this is the observe someone unlocking rule ):
!   >>> III.3.1 - Action/What/Second Thing Acted On >>>
! Rule 2/2 ! Report an actor unlocking something with ( this is the standard report unlocking rule ):
! ----------------------------------------------------------------------------------------------------
! From "Locksmith" by Emily Short
! No specific request
! Report someone trying unlocking something with a passkey ( this is the observe someone unlocking rule ):
[ R_834 ;
    if ((( (actor~=player) && (act_requester==nothing) && ((actor ofclass K8_person)) && ((noun ofclass K2_thing)) && ((second ofclass K16_passkey))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_834, 834);
    ! [1: now the second noun unbolts the noun]
    (RGuard_MT_2(second,noun));
    } else if (debug_rules > 1) DB_Rule(R_834, 834, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Report an actor unlocking something with ( this is the standard report unlocking rule ):
[ R_216 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_216, 216);
    ! [1: if the actor is the player begin]
    if (((actor == player))){
        ! [2: if the action is not silent begin]
        if (((keep_silent == false))){
            ! [3: say ~[We] [unlock] [the noun].~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_281); new_line; .L_Say233; .L_SayX233;
            ! [4: end if]
            }

        ! [5: otherwise]
        } else {

        ! [6: if the actor is visible begin]
        if ((((Adj_3_t1_v10(actor))))){
            ! [7: say ~[The actor] [unlock] [the noun].~ ( b )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_282); new_line; .L_Say234; .L_SayX234;
            ! [8: end if]
            }

        ! [9: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_216, 216, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Switching on (B184_check_switching_on)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check an actor switching on ( this is the can't switch on unless switchable rule ):
!   === equally specific with ===
! Rule 2/2 ! Check an actor switching on ( this is the can't switch on what's already on rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor switching on ( this is the can't switch on unless switchable rule ):
[ R_217 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_217, 217);
    ! [1: if the noun provides the property switched on , continue the action]
    if (((WhetherProvides(noun, true, on)))) { rfalse; }
    ! [2: if the actor is the player begin]
    if (((actor == player))){
        ! [3: say ~[regarding the noun][They] [aren't] something [we] [can] switch.~ ( a )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_283); new_line; .L_Say235; .L_SayX235;
        ! [4: end if]
        }

    ! [5: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_217, 217, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor switching on ( this is the can't switch on what's already on rule ):
[ R_218 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_218, 218);
    ! [1: if the noun is switched on begin]
    if ((((Adj_84_t1_v10(noun))))){
        ! [2: if the actor is the player begin]
        if (((actor == player))){
            ! [3: say ~[regarding the noun][They're] already on.~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_284); new_line; .L_Say236; .L_SayX236;
            ! [4: end if]
            }

        ! [5: stop the action]
        rtrue;
        ! [6: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_218, 218, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Switching on (B185_carry_out_switching_on)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor switching on ( this is the standard switching on rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Carry out an actor switching on ( this is the standard switching on rule ):
[ R_219 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_219, 219);
    ! [1: now the noun is switched on]
    (Adj_84_t2_v10(noun));
    } else if (debug_rules > 1) DB_Rule(R_219, 219, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Switching on (B186_report_switching_on)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor switching on ( this is the standard report switching on rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor switching on ( this is the standard report switching on rule ):
[ R_220 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_220, 220);
    ! [1: if the action is not silent begin]
    if (((keep_silent == false))){
        ! [2: say ~[The actor] [switch] [the noun] on.~ ( a )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_285); new_line; .L_Say237; .L_SayX237;
        ! [3: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_220, 220, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Switching off (B187_check_switching_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check an actor switching off ( this is the can't switch off unless switchable rule ):
!   === equally specific with ===
! Rule 2/2 ! Check an actor switching off ( this is the can't switch off what's already off rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor switching off ( this is the can't switch off unless switchable rule ):
[ R_221 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_221, 221);
    ! [1: if the noun provides the property switched on , continue the action]
    if (((WhetherProvides(noun, true, on)))) { rfalse; }
    ! [2: if the actor is the player begin]
    if (((actor == player))){
        ! [3: say ~[regarding the noun][They] [aren't] something [we] [can] switch.~ ( a )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_286); new_line; .L_Say238; .L_SayX238;
        ! [4: end if]
        }

    ! [5: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_221, 221, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor switching off ( this is the can't switch off what's already off rule ):
[ R_222 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_222, 222);
    ! [1: if the noun is switched off begin]
    if ((((Adj_85_t1_v10(noun))))){
        ! [2: if the actor is the player begin]
        if (((actor == player))){
            ! [3: say ~[regarding the noun][They're] already off.~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_287); new_line; .L_Say239; .L_SayX239;
            ! [4: end if]
            }

        ! [5: stop the action]
        rtrue;
        ! [6: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_222, 222, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Switching off (B188_carry_out_switching_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor switching off ( this is the standard switching off rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Carry out an actor switching off ( this is the standard switching off rule ):
[ R_223 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_223, 223);
    ! [1: now the noun is switched off]
    (Adj_85_t2_v10(noun));
    } else if (debug_rules > 1) DB_Rule(R_223, 223, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Switching off (B189_report_switching_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor switching off ( this is the standard report switching off rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor switching off ( this is the standard report switching off rule ):
[ R_224 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_224, 224);
    ! [1: if the action is not silent begin]
    if (((keep_silent == false))){
        ! [2: say ~[The actor] [switch] [the noun] off.~ ( a )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_288); new_line; .L_Say240; .L_SayX240;
        ! [3: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_224, 224, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Opening (B190_check_opening)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Check an actor opening ( this is the can't open unless openable rule ):
!   === equally specific with ===
! Rule 2/3 ! Check an actor opening ( this is the can't open what's locked rule ):
!   === equally specific with ===
! Rule 3/3 ! Check an actor opening ( this is the can't open what's already open rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor opening ( this is the can't open unless openable rule ):
[ R_225 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_225, 225);
    ! [1: if the noun provides the property openable and the noun is openable begin]
    if ((((WhetherProvides(noun, true, openable)))) && ((((Adj_76_t1_v10(noun)))))){
        ! [2: continue the action]
        rfalse;
        ! [3: end if]
        }

    ! [4: if the actor is the player begin]
    if (((actor == player))){
        ! [5: say ~[regarding the noun][They] [aren't] something [we] [can] open.~ ( a )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_289); new_line; .L_Say241; .L_SayX241;
        ! [6: end if]
        }

    ! [7: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_225, 225, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor opening ( this is the can't open what's locked rule ):
[ R_226 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_226, 226);
    ! [1: if the noun provides the property lockable and the noun is locked begin]
    if ((((WhetherProvides(noun, true, lockable)))) && ((((Adj_79_t1_v10(noun)))))){
        ! [2: if the actor is the player begin]
        if (((actor == player))){
            ! [3: say ~[regarding the noun][They] [seem] to be locked.~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_290); new_line; .L_Say242; .L_SayX242;
            ! [4: end if]
            }

        ! [5: stop the action]
        rtrue;
        ! [6: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_226, 226, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor opening ( this is the can't open what's already open rule ):
[ R_227 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_227, 227);
    ! [1: if the noun is open begin]
    if ((((Adj_74_t1_v10(noun))))){
        ! [2: if the actor is the player begin]
        if (((actor == player))){
            ! [3: say ~[regarding the noun][They're] already open.~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_291); new_line; .L_Say243; .L_SayX243;
            ! [4: end if]
            }

        ! [5: stop the action]
        rtrue;
        ! [6: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_227, 227, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Opening (B191_carry_out_opening)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor opening ( this is the standard opening rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Carry out an actor opening ( this is the standard opening rule ):
[ R_228 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_228, 228);
    ! [1: now the noun is open]
    (Adj_74_t2_v10(noun));
    } else if (debug_rules > 1) DB_Rule(R_228, 228, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Opening (B192_report_opening)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Report an actor opening ( this is the reveal any newly visible interior rule ):
!   === equally specific with ===
! Rule 2/2 ! Report an actor opening ( this is the standard report opening rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor opening ( this is the reveal any newly visible interior rule ):
[ R_229 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_229, 229);
    ! [1: if the actor is the player and the noun is an opaque container and the first thing held by the noun is not nothing and the noun does not enclose the actor begin]
    if ((((actor == player))) && ((((noun ofclass K5_container) && ((Adj_72_t1_v10(noun))))) && ((((~~(((child(noun)) == nothing))))) && (((~~((IndirectlyContains(noun,actor))))))))){
        ! [2: if the action is not silent begin]
        if (((keep_silent == false))){
            ! [3: if the actor is the player begin]
            if (((actor == player))){
                ! [4: say ~[We] [open] [the noun], revealing ~ ( a )]
                say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_292); .L_Say244; .L_SayX244;
                ! [5: list the contents of the noun , as a sentence , tersely , not listing concealed items]
                WriteListFrom(child(noun), 2120);
                ! [6: say ~.~]
                say__p=1;ParaContent(); print "."; new_line; .L_Say245; .L_SayX245;
                ! [7: end if]
                }

            ! [8: end if]
            }

        ! [9: stop the action]
        rtrue;
        ! [10: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_229, 229, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Report an actor opening ( this is the standard report opening rule ):
[ R_230 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_230, 230);
    ! [1: if the actor is the player begin]
    if (((actor == player))){
        ! [2: if the action is not silent begin]
        if (((keep_silent == false))){
            ! [3: say ~[We] [open] [the noun].~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_293); new_line; .L_Say246; .L_SayX246;
            ! [4: end if]
            }

        ! [5: otherwise if the player can see the actor]
        } else if (((TestVisibility(player,actor)))) {
        ! [6: say ~[The actor] [open] [the noun].~ ( b )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_294); new_line; .L_Say247; .L_SayX247;
        ! [7: otherwise]
        } else {

        ! [8: say ~[The noun] [open].~ ( c )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_295); new_line; .L_Say248; .L_SayX248;
        ! [9: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_230, 230, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Closing (B193_check_closing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check an actor closing ( this is the can't close unless openable rule ):
!   === equally specific with ===
! Rule 2/2 ! Check an actor closing ( this is the can't close what's already closed rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor closing ( this is the can't close unless openable rule ):
[ R_231 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_231, 231);
    ! [1: if the noun provides the property openable and the noun is openable begin]
    if ((((WhetherProvides(noun, true, openable)))) && ((((Adj_76_t1_v10(noun)))))){
        ! [2: continue the action]
        rfalse;
        ! [3: end if]
        }

    ! [4: if the actor is the player begin]
    if (((actor == player))){
        ! [5: say ~[regarding the noun][They] [aren't] something [we] [can] close.~ ( a )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_296); new_line; .L_Say249; .L_SayX249;
        ! [6: end if]
        }

    ! [7: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_231, 231, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor closing ( this is the can't close what's already closed rule ):
[ R_232 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_232, 232);
    ! [1: if the noun is closed begin]
    if ((((Adj_75_t1_v10(noun))))){
        ! [2: if the actor is the player begin]
        if (((actor == player))){
            ! [3: say ~[regarding the noun][They're] already closed.~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_297); new_line; .L_Say250; .L_SayX250;
            ! [4: end if]
            }

        ! [5: stop the action]
        rtrue;
        ! [6: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_232, 232, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Closing (B194_carry_out_closing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor closing ( this is the standard closing rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Carry out an actor closing ( this is the standard closing rule ):
[ R_233 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_233, 233);
    ! [1: now the noun is closed]
    (Adj_75_t2_v10(noun));
    } else if (debug_rules > 1) DB_Rule(R_233, 233, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Closing (B195_report_closing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor closing ( this is the standard report closing rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor closing ( this is the standard report closing rule ):
[ R_234 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_234, 234);
    ! [1: if the actor is the player begin]
    if (((actor == player))){
        ! [2: if the action is not silent begin]
        if (((keep_silent == false))){
            ! [3: say ~[We] [close] [the noun].~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_298); new_line; .L_Say251; .L_SayX251;
            ! [4: end if]
            }

        ! [5: otherwise if the player can see the actor]
        } else if (((TestVisibility(player,actor)))) {
        ! [6: say ~[The actor] [close] [the noun].~ ( b )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_299); new_line; .L_Say252; .L_SayX252;
        ! [7: otherwise]
        } else {

        ! [8: say ~[The noun] [close].~ ( c )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_300); new_line; .L_Say253; .L_SayX253;
        ! [9: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_234, 234, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Wearing (B196_check_wearing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Check an actor wearing ( this is the can't wear what's not clothing rule ):
!   === equally specific with ===
! Rule 2/3 ! Check an actor wearing ( this is the can't wear what's not held rule ):
!   === equally specific with ===
! Rule 3/3 ! Check an actor wearing ( this is the can't wear what's already worn rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor wearing ( this is the can't wear what's not clothing rule ):
[ R_235 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_235, 235);
    ! [1: if the noun is not a thing or the noun is not wearable begin]
    if ((((~~((noun ofclass K2_thing))))) || (((~~(((Adj_62_t1_v10(noun)))))))){
        ! [2: if the actor is the player begin]
        if (((actor == player))){
            ! [3: say ~[We] [can't wear] [regarding the noun][those]!~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_301); new_line; .L_Say254; .L_SayX254;
            ! [4: end if]
            }

        ! [5: stop the action]
        rtrue;
        ! [6: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_235, 235, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor wearing ( this is the can't wear what's not held rule ):
[ R_236 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_236, 236);
    ! [1: if the holder of the noun is not the actor begin]
    if (((~~(((HolderOf(noun)) == actor))))){
        ! [2: if the actor is the player begin]
        if (((actor == player))){
            ! [3: say ~[We] [aren't] holding [regarding the noun][those]!~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_302); new_line; .L_Say255; .L_SayX255;
            ! [4: end if]
            }

        ! [5: stop the action]
        rtrue;
        ! [6: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_236, 236, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor wearing ( this is the can't wear what's already worn rule ):
[ R_237 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_237, 237);
    ! [1: if the actor is wearing the noun begin]
    if (((actor == WearerOf(noun)))){
        ! [2: if the actor is the player begin]
        if (((actor == player))){
            ! [3: say ~[We]['re] already wearing [regarding the noun][those]!~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_303); new_line; .L_Say256; .L_SayX256;
            ! [4: end if]
            }

        ! [5: stop the action]
        rtrue;
        ! [6: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_237, 237, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Wearing (B197_carry_out_wearing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor wearing ( this is the standard wearing rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Carry out an actor wearing ( this is the standard wearing rule ):
[ R_238 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_238, 238);
    ! [1: now the actor wears the noun]
    WearObject(noun,actor);
    } else if (debug_rules > 1) DB_Rule(R_238, 238, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Wearing (B198_report_wearing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor wearing ( this is the standard report wearing rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor wearing ( this is the standard report wearing rule ):
[ R_239 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_239, 239);
    ! [1: if the actor is the player begin]
    if (((actor == player))){
        ! [2: if the action is not silent begin]
        if (((keep_silent == false))){
            ! [3: say ~[We] [put] on [the noun].~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_304); new_line; .L_Say257; .L_SayX257;
            ! [4: end if]
            }

        ! [5: otherwise]
        } else {

        ! [6: say ~[The actor] [put] on [the noun].~ ( b )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_305); new_line; .L_Say258; .L_SayX258;
        ! [7: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_239, 239, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Taking off (B199_check_taking_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check an actor taking off ( this is the can't take off what's not worn rule ):
!   === equally specific with ===
! Rule 2/2 ! Check an actor taking off ( this is the can't exceed carrying capacity when taking off rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor taking off ( this is the can't take off what's not worn rule ):
[ R_241 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_241, 241);
    ! [1: if the actor is not wearing the noun begin]
    if (((~~((actor == WearerOf(noun)))))){
        ! [2: if the actor is the player begin]
        if (((actor == player))){
            ! [3: say ~[We] [aren't] wearing [the noun].~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_306); new_line; .L_Say259; .L_SayX259;
            ! [4: end if]
            }

        ! [5: stop the action]
        rtrue;
        ! [6: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_241, 241, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor taking off ( this is the can't exceed carrying capacity when taking off rule ):
[ R_242 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_242, 242);
    ! [1: if the number of things carried by the actor is at least the carrying capacity of the actor begin]
    if ((((Prop_45()) >= GProperty(10, actor,capacity)))){
        ! [2: if the actor is the player begin]
        if (((actor == player))){
            ! [3: say ~[We]['re] carrying too many things already.~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_307); new_line; .L_Say260; .L_SayX260;
            ! [4: end if]
            }

        ! [5: stop the action]
        rtrue;
        ! [6: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_242, 242, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Taking off (B200_carry_out_taking_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor taking off ( this is the standard taking off rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Carry out an actor taking off ( this is the standard taking off rule ):
[ R_243 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_243, 243);
    ! [1: now the actor carries the noun]
    MoveObject(noun,actor);
    } else if (debug_rules > 1) DB_Rule(R_243, 243, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Taking off (B201_report_taking_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor taking off ( this is the standard report taking off rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor taking off ( this is the standard report taking off rule ):
[ R_244 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_244, 244);
    ! [1: if the actor is the player begin]
    if (((actor == player))){
        ! [2: if the action is not silent begin]
        if (((keep_silent == false))){
            ! [3: say ~[We] [take] off [the noun].~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_308); new_line; .L_Say261; .L_SayX261;
            ! [4: end if]
            }

        ! [5: otherwise]
        } else {

        ! [6: say ~[The actor] [take] off [the noun].~ ( b )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_309); new_line; .L_Say262; .L_SayX262;
        ! [7: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_244, 244, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Giving it to (B202_check_giving_it_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/6 ! Check an actor giving something to ( this is the can't give what you haven't got rule ):
!   === equally specific with ===
! Rule 2/6 ! Check an actor giving something to ( this is the can't give to yourself rule ):
!   === equally specific with ===
! Rule 3/6 ! Check an actor giving something to ( this is the can't give to a non-person rule ):
!   === equally specific with ===
! Rule 4/6 ! Check an actor giving something to ( this is the can't give clothes being worn rule ):
!   === equally specific with ===
! Rule 5/6 ! Check an actor giving something to ( this is the block giving rule ):
!   === equally specific with ===
! Rule 6/6 ! Check an actor giving something to ( this is the can't exceed carrying capacity when giving rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor giving something to ( this is the can't give what you haven't got rule ):
[ R_245 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_245, 245);
    ! [1: if the actor is not the holder of the noun begin]
    if (((~~((actor == (HolderOf(noun))))))){
        ! [2: if the actor is the player begin]
        if (((actor == player))){
            ! [3: say ~[We] [aren't] holding [the noun].~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_310); new_line; .L_Say263; .L_SayX263;
            ! [4: end if]
            }

        ! [5: stop the action]
        rtrue;
        ! [6: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_245, 245, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor giving something to ( this is the can't give to yourself rule ):
[ R_246 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_246, 246);
    ! [1: if the actor is the second noun begin]
    if (((actor == second))){
        ! [2: if the actor is the player begin]
        if (((actor == player))){
            ! [3: say ~[We] [can't give] [the noun] to [ourselves].~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_311); new_line; .L_Say264; .L_SayX264;
            ! [4: end if]
            }

        ! [5: stop the action]
        rtrue;
        ! [6: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_246, 246, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor giving something to ( this is the can't give to a non-person rule ):
[ R_247 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_247, 247);
    ! [1: if the second noun is not a person begin]
    if (((~~((second ofclass K8_person))))){
        ! [2: if the actor is the player begin]
        if (((actor == player))){
            ! [3: say ~[The second noun] [aren't] able to receive things.~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_312); new_line; .L_Say265; .L_SayX265;
            ! [4: end if]
            }

        ! [5: stop the action]
        rtrue;
        ! [6: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_247, 247, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor giving something to ( this is the can't give clothes being worn rule ):
[ R_248 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_248, 248);
    ! [1: if the actor is wearing the noun begin]
    if (((actor == WearerOf(noun)))){
        ! [2: say ~(first taking [the noun] off)[command clarification break]~ ( a )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_313); .L_Say266; .L_SayX266;
        ! [3: silently try the actor trying taking off the noun]
        @push keep_silent; keep_silent=1; @push say__p; @push say__pc;
        		ClearParagraphing(1); TryAction(0, actor, ##Disrobe, noun, 0);; DivideParagraphPoint();
        		@pull say__pc; @pull say__p; AdjustParagraphPoint(); @pull keep_silent;
        ! [4: if the actor is wearing the noun , stop the action]
        if (((actor == WearerOf(noun)))) { rtrue; }
        ! [5: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_248, 248, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor giving something to ( this is the block giving rule ):
[ R_249 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_249, 249);
    ! [1: if the actor is the player begin]
    if (((actor == player))){
        ! [2: say ~[The second noun] [don't] seem interested.~ ( a )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_314); new_line; .L_Say267; .L_SayX267;
        ! [3: end if]
        }

    ! [4: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_249, 249, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor giving something to ( this is the can't exceed carrying capacity when giving rule ):
[ R_250 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_250, 250);
    ! [1: if the number of things carried by the second noun is at least the carrying capacity of the second noun begin]
    if ((((Prop_46()) >= GProperty(OBJECT_TY, second,capacity)))){
        ! [2: if the actor is the player begin]
        if (((actor == player))){
            ! [3: say ~[The second noun] [are] carrying too many things already.~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_315); new_line; .L_Say268; .L_SayX268;
            ! [4: end if]
            }

        ! [5: stop the action]
        rtrue;
        ! [6: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_250, 250, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Giving it to (B203_carry_out_giving_it_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor giving something to ( this is the standard giving rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Carry out an actor giving something to ( this is the standard giving rule ):
[ R_251 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_251, 251);
    ! [1: move the noun to the second noun]
    MoveObject(noun, second, 0, false);
    } else if (debug_rules > 1) DB_Rule(R_251, 251, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Giving it to (B204_report_giving_it_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor giving something to ( this is the standard report giving rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor giving something to ( this is the standard report giving rule ):
[ R_252 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_252, 252);
    ! [1: if the actor is the player begin]
    if (((actor == player))){
        ! [2: say ~[We] [give] [the noun] to [the second noun].~ ( a )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_316); new_line; .L_Say269; .L_SayX269;
        ! [3: otherwise if the second noun is the player]
        } else if (((second == player))) {
        ! [4: say ~[The actor] [give] [the noun] to [us].~ ( b )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_317); new_line; .L_Say270; .L_SayX270;
        ! [5: otherwise]
        } else {

        ! [6: say ~[The actor] [give] [the noun] to [the second noun].~ ( c )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_318); new_line; .L_Say271; .L_SayX271;
        ! [7: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_252, 252, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Showing it to (B205_check_showing_it_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Check an actor showing something to ( this is the can't show what you haven't got rule ):
!   === equally specific with ===
! Rule 2/3 ! Check an actor showing something to ( this is the convert show to yourself to examine rule ):
!   === equally specific with ===
! Rule 3/3 ! Check an actor showing something to ( this is the block showing rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor showing something to ( this is the can't show what you haven't got rule ):
[ R_253 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_253, 253);
    ! [1: if the actor is not the holder of the noun begin]
    if (((~~((actor == (HolderOf(noun))))))){
        ! [2: if the actor is the player begin]
        if (((actor == player))){
            ! [3: say ~[We] [aren't] holding [the noun].~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_319); new_line; .L_Say272; .L_SayX272;
            ! [4: end if]
            }

        ! [5: stop the action]
        rtrue;
        ! [6: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_253, 253, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor showing something to ( this is the convert show to yourself to examine rule ):
[ R_254 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_254, 254);
    ! [1: if the actor is the second noun begin]
    if (((actor == second))){
        ! [2: convert to the examining action on the noun]
        return GVS_Convert(##Examine,noun,0);
        ! [3: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_254, 254, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor showing something to ( this is the block showing rule ):
[ R_255 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_255, 255);
    ! [1: if the actor is the player begin]
    if (((actor == player))){
        ! [2: say ~[The second noun] [are] unimpressed.~ ( a )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_320); new_line; .L_Say273; .L_SayX273;
        ! [3: end if]
        }

    ! [4: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_255, 255, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Waking (B208_check_waking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor waking ( this is the block waking rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor waking ( this is the block waking rule ):
[ R_256 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_256, 256);
    ! [1: if the actor is the player begin]
    if (((actor == player))){
        ! [2: now the prior named object is nothing]
        prior_named_noun = nothing;
        ! [3: say ~That [seem] unnecessary.~ ( a )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_321); new_line; .L_Say274; .L_SayX274;
        ! [4: end if]
        }

    ! [5: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_256, 256, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Throwing it at (B211_check_throwing_it_at)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Check an actor throwing something at ( this is the implicitly remove thrown clothing rule ):
!   === equally specific with ===
! Rule 2/3 ! Check an actor throwing something at ( this is the futile to throw things at inanimate objects rule ):
!   === equally specific with ===
! Rule 3/3 ! Check an actor throwing something at ( this is the block throwing at rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor throwing something at ( this is the implicitly remove thrown clothing rule ):
[ R_257 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_257, 257);
    ! [1: if the actor is wearing the noun begin]
    if (((actor == WearerOf(noun)))){
        ! [2: say ~(first taking [the noun] off)[command clarification break]~ ( a )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_322); .L_Say275; .L_SayX275;
        ! [3: silently try the actor trying taking off the noun]
        @push keep_silent; keep_silent=1; @push say__p; @push say__pc;
        		ClearParagraphing(1); TryAction(0, actor, ##Disrobe, noun, 0);; DivideParagraphPoint();
        		@pull say__pc; @pull say__p; AdjustParagraphPoint(); @pull keep_silent;
        ! [4: if the actor is wearing the noun , stop the action]
        if (((actor == WearerOf(noun)))) { rtrue; }
        ! [5: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_257, 257, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor throwing something at ( this is the futile to throw things at inanimate objects rule ):
[ R_258 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_258, 258);
    ! [1: if the second noun is not a person begin]
    if (((~~((second ofclass K8_person))))){
        ! [2: if the actor is the player begin]
        if (((actor == player))){
            ! [3: say ~Futile.~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_323); new_line; .L_Say276; .L_SayX276;
            ! [4: end if]
            }

        ! [5: stop the action]
        rtrue;
        ! [6: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_258, 258, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor throwing something at ( this is the block throwing at rule ):
[ R_259 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_259, 259);
    ! [1: if the actor is the player begin]
    if (((actor == player))){
        ! [2: say ~[We] [lack] the nerve when it [if story tense is the past tense]came[otherwise]comes[end if] to the crucial moment.~ ( a )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_324); new_line; .L_Say277; .L_SayX277;
        ! [3: end if]
        }

    ! [4: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_259, 259, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Attacking (B214_check_attacking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor attacking ( this is the block attacking rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor attacking ( this is the block attacking rule ):
[ R_260 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_260, 260);
    ! [1: if the actor is the player begin]
    if (((actor == player))){
        ! [2: now the prior named object is nothing]
        prior_named_noun = nothing;
        ! [3: say ~Violence [aren't] the answer to this one.~ ( a )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_325); new_line; .L_Say278; .L_SayX278;
        ! [4: end if]
        }

    ! [5: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_260, 260, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Kissing (B217_check_kissing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check an actor kissing ( this is the kissing yourself rule ):
!   === equally specific with ===
! Rule 2/2 ! Check an actor kissing ( this is the block kissing rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor kissing ( this is the kissing yourself rule ):
[ R_261 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_261, 261);
    ! [1: if the noun is the actor begin]
    if (((noun == actor))){
        ! [2: if the actor is the player begin]
        if (((actor == player))){
            ! [3: say ~[We] [don't] get much from that.~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_326); new_line; .L_Say279; .L_SayX279;
            ! [4: end if]
            }

        ! [5: stop the action]
        rtrue;
        ! [6: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_261, 261, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor kissing ( this is the block kissing rule ):
[ R_262 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_262, 262);
    ! [1: if the actor is the player begin]
    if (((actor == player))){
        ! [2: say ~[The noun] [might not] like that.~ ( a )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_327); new_line; .L_Say280; .L_SayX280;
        ! [3: end if]
        }

    ! [4: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_262, 262, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Answering it that (B222_report_answering_it_tha)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor answering something that ( this is the block answering rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor answering something that ( this is the block answering rule ):
[ R_263 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_263, 263);
    ! [1: if the actor is the player begin]
    if (((actor == player))){
        ! [2: now the prior named object is nothing]
        prior_named_noun = nothing;
        ! [3: say ~[There] [are] no reply.~ ( a )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_328); new_line; .L_Say281; .L_SayX281;
        ! [4: end if]
        }

    ! [5: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_263, 263, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Telling it about (B223_check_telling_it_about)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor telling something about ( this is the telling yourself rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor telling something about ( this is the telling yourself rule ):
[ R_264 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_264, 264);
    ! [1: if the actor is the noun begin]
    if (((actor == noun))){
        ! [2: if the actor is the player begin]
        if (((actor == player))){
            ! [3: say ~[We] [talk] to [ourselves] a while.~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_329); new_line; .L_Say282; .L_SayX282;
            ! [4: end if]
            }

        ! [5: stop the action]
        rtrue;
        ! [6: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_264, 264, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Telling it about (B225_report_telling_it_about)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor telling something about ( this is the block telling rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor telling something about ( this is the block telling rule ):
[ R_265 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_265, 265);
    ! [1: if the actor is the player begin]
    if (((actor == player))){
        ! [2: now the prior named object is nothing]
        prior_named_noun = nothing;
        ! [3: say ~This [provoke] no reaction.~ ( a )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_330); new_line; .L_Say283; .L_SayX283;
        ! [4: end if]
        }

    ! [5: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_265, 265, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Asking it about (B228_report_asking_it_about)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor asking something about ( this is the block asking rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor asking something about ( this is the block asking rule ):
[ R_266 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_266, 266);
    ! [1: if the actor is the player begin]
    if (((actor == player))){
        ! [2: now the prior named object is nothing]
        prior_named_noun = nothing;
        ! [3: say ~[There] [are] no reply.~ ( a )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_331); new_line; .L_Say284; .L_SayX284;
        ! [4: end if]
        }

    ! [5: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_266, 266, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Asking it for (B229_check_asking_it_for)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check an actor asking something for ( this is the asking yourself for something rule ):
!   === equally specific with ===
! Rule 2/2 ! Check an actor asking something for ( this is the translate asking for to giving rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor asking something for ( this is the asking yourself for something rule ):
[ R_267 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_267, 267);
    ! [1: if the actor is the noun and the actor is the player begin]
    if ((((actor == noun))) && (((actor == player)))){
        ! [2: try taking inventory instead]
        TryAction(0, player, ##Inv, 0, 0);; rtrue;
        ! [3: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_267, 267, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor asking something for ( this is the translate asking for to giving rule ):
[ R_268 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_268, 268);
    ! [1: convert to request of the noun to perform giving it to action with the second noun and the actor]
    return ConvertToRequest(noun, ##Give, second, actor);
    } else if (debug_rules > 1) DB_Rule(R_268, 268, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Waiting (B234_report_waiting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor waiting ( this is the standard report waiting rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor waiting ( this is the standard report waiting rule ):
[ R_269 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_269, 269);
    ! [1: if the actor is the player begin]
    if (((actor == player))){
        ! [2: if the action is not silent begin]
        if (((keep_silent == false))){
            ! [3: now the prior named object is nothing]
            prior_named_noun = nothing;
            ! [4: say ~Time [pass].~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_332); new_line; .L_Say285; .L_SayX285;
            ! [5: end if]
            }

        ! [6: otherwise]
        } else {

        ! [7: say ~[The actor] [wait].~ ( b )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_333); new_line; .L_Say286; .L_SayX286;
        ! [8: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_269, 269, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Touching (B237_report_touching)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Report an actor touching ( this is the report touching yourself rule ):
!   === equally specific with ===
! Rule 2/3 ! Report an actor touching ( this is the report touching other people rule ):
!   === equally specific with ===
! Rule 3/3 ! Report an actor touching ( this is the report touching things rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor touching ( this is the report touching yourself rule ):
[ R_270 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_270, 270);
    ! [1: if the noun is the actor begin]
    if (((noun == actor))){
        ! [2: if the actor is the player begin]
        if (((actor == player))){
            ! [3: if the action is not silent begin]
            if (((keep_silent == false))){
                ! [4: say ~[We] [achieve] nothing by this.~ ( a )]
                say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_334); new_line; .L_Say287; .L_SayX287;
                ! [5: end if]
                }

            ! [6: otherwise]
            } else {

            ! [7: say ~[The actor] [touch] [themselves].~ ( b )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_335); new_line; .L_Say288; .L_SayX288;
            ! [8: end if]
            }

        ! [9: stop the action]
        rtrue;
        ! [10: end if]
        }

    ! [11: continue the action]
    rfalse;
    } else if (debug_rules > 1) DB_Rule(R_270, 270, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Report an actor touching ( this is the report touching other people rule ):
[ R_271 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_271, 271);
    ! [1: if the noun is a person begin]
    if (((noun ofclass K8_person))){
        ! [2: if the actor is the player begin]
        if (((actor == player))){
            ! [3: if the action is not silent begin]
            if (((keep_silent == false))){
                ! [4: say ~[The noun] [might not like] that.~ ( a )]
                say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_336); new_line; .L_Say289; .L_SayX289;
                ! [5: end if]
                }

            ! [6: otherwise if the noun is the player]
            } else if (((noun == player))) {
            ! [7: say ~[The actor] [touch] [us].~ ( b )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_337); new_line; .L_Say290; .L_SayX290;
            ! [8: otherwise]
            } else {

            ! [9: say ~[The actor] [touch] [the noun].~ ( c )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_338); new_line; .L_Say291; .L_SayX291;
            ! [10: end if]
            }

        ! [11: stop the action]
        rtrue;
        ! [12: end if]
        }

    ! [13: continue the action]
    rfalse;
    } else if (debug_rules > 1) DB_Rule(R_271, 271, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Report an actor touching ( this is the report touching things rule ):
[ R_272 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_272, 272);
    ! [1: if the actor is the player begin]
    if (((actor == player))){
        ! [2: if the action is not silent begin]
        if (((keep_silent == false))){
            ! [3: say ~[We] [feel] nothing unexpected.~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_339); new_line; .L_Say292; .L_SayX292;
            ! [4: end if]
            }

        ! [5: otherwise]
        } else {

        ! [6: say ~[The actor] [touch] [the noun].~ ( b )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_340); new_line; .L_Say293; .L_SayX293;
        ! [7: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_272, 272, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Waving (B238_check_waving)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor waving ( this is the can't wave what's not held rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor waving ( this is the can't wave what's not held rule ):
[ R_273 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_273, 273);
    ! [1: if the actor is not the holder of the noun begin]
    if (((~~((actor == (HolderOf(noun))))))){
        ! [2: if the actor is the player begin]
        if (((actor == player))){
            ! [3: say ~But [we] [aren't] holding [regarding the noun][those].~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_341); new_line; .L_Say294; .L_SayX294;
            ! [4: end if]
            }

        ! [5: stop the action]
        rtrue;
        ! [6: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_273, 273, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Waving (B240_report_waving)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor waving ( this is the report waving things rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor waving ( this is the report waving things rule ):
[ R_274 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_274, 274);
    ! [1: if the actor is the player begin]
    if (((actor == player))){
        ! [2: if the action is not silent begin]
        if (((keep_silent == false))){
            ! [3: say ~[We] [wave] [the noun].~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_342); new_line; .L_Say295; .L_SayX295;
            ! [4: end if]
            }

        ! [5: otherwise]
        } else {

        ! [6: say ~[The actor] [wave] [the noun].~ ( b )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_343); new_line; .L_Say296; .L_SayX296;
        ! [7: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_274, 274, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Pulling (B241_check_pulling)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Check an actor pulling ( this is the can't pull what's fixed in place rule ):
!   === equally specific with ===
! Rule 2/3 ! Check an actor pulling ( this is the can't pull scenery rule ):
!   === equally specific with ===
! Rule 3/3 ! Check an actor pulling ( this is the can't pull people rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor pulling ( this is the can't pull what's fixed in place rule ):
[ R_275 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_275, 275);
    ! [1: if the noun is fixed in place begin]
    if ((((Adj_59_t1_v10(noun))))){
        ! [2: if the actor is the player begin]
        if (((actor == player))){
            ! [3: say ~[regarding the noun][They] [are] fixed in place.~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_344); new_line; .L_Say297; .L_SayX297;
            ! [4: end if]
            }

        ! [5: stop the action]
        rtrue;
        ! [6: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_275, 275, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor pulling ( this is the can't pull scenery rule ):
[ R_276 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_276, 276);
    ! [1: if the noun is scenery begin]
    if ((((Adj_61_t1_v10(noun))))){
        ! [2: if the actor is the player begin]
        if (((actor == player))){
            ! [3: say ~[We] [are] unable to.~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_345); new_line; .L_Say298; .L_SayX298;
            ! [4: end if]
            }

        ! [5: stop the action]
        rtrue;
        ! [6: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_276, 276, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor pulling ( this is the can't pull people rule ):
[ R_277 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_277, 277);
    ! [1: if the noun is a person begin]
    if (((noun ofclass K8_person))){
        ! [2: if the actor is the player begin]
        if (((actor == player))){
            ! [3: say ~[The noun] [might not like] that.~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_346); new_line; .L_Say299; .L_SayX299;
            ! [4: end if]
            }

        ! [5: stop the action]
        rtrue;
        ! [6: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_277, 277, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Pulling (B243_report_pulling)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor pulling ( this is the report pulling rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor pulling ( this is the report pulling rule ):
[ R_278 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_278, 278);
    ! [1: if the actor is the player begin]
    if (((actor == player))){
        ! [2: if the action is not silent begin]
        if (((keep_silent == false))){
            ! [3: now the prior named object is nothing]
            prior_named_noun = nothing;
            ! [4: say ~Nothing obvious [happen].~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_347); new_line; .L_Say300; .L_SayX300;
            ! [5: end if]
            }

        ! [6: otherwise]
        } else {

        ! [7: say ~[The actor] [pull] [the noun].~ ( b )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_348); new_line; .L_Say301; .L_SayX301;
        ! [8: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_278, 278, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Pushing (B244_check_pushing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Check an actor pushing something ( this is the can't push what's fixed in place rule ):
!   === equally specific with ===
! Rule 2/3 ! Check an actor pushing something ( this is the can't push scenery rule ):
!   === equally specific with ===
! Rule 3/3 ! Check an actor pushing something ( this is the can't push people rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor pushing something ( this is the can't push what's fixed in place rule ):
[ R_279 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_279, 279);
    ! [1: if the noun is fixed in place begin]
    if ((((Adj_59_t1_v10(noun))))){
        ! [2: if the actor is the player begin]
        if (((actor == player))){
            ! [3: say ~[regarding the noun][They] [are] fixed in place.~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_349); new_line; .L_Say302; .L_SayX302;
            ! [4: end if]
            }

        ! [5: stop the action]
        rtrue;
        ! [6: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_279, 279, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor pushing something ( this is the can't push scenery rule ):
[ R_280 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_280, 280);
    ! [1: if the noun is scenery begin]
    if ((((Adj_61_t1_v10(noun))))){
        ! [2: if the actor is the player begin]
        if (((actor == player))){
            ! [3: say ~[We] [are] unable to.~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_350); new_line; .L_Say303; .L_SayX303;
            ! [4: end if]
            }

        ! [5: stop the action]
        rtrue;
        ! [6: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_280, 280, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor pushing something ( this is the can't push people rule ):
[ R_281 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_281, 281);
    ! [1: if the noun is a person begin]
    if (((noun ofclass K8_person))){
        ! [2: if the actor is the player begin]
        if (((actor == player))){
            ! [3: say ~[The noun] [might not like] that.~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_351); new_line; .L_Say304; .L_SayX304;
            ! [4: end if]
            }

        ! [5: stop the action]
        rtrue;
        ! [6: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_281, 281, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Pushing (B246_report_pushing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor pushing something ( this is the report pushing rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor pushing something ( this is the report pushing rule ):
[ R_282 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_282, 282);
    ! [1: if the actor is the player begin]
    if (((actor == player))){
        ! [2: if the action is not silent begin]
        if (((keep_silent == false))){
            ! [3: now the prior named object is nothing]
            prior_named_noun = nothing;
            ! [4: say ~Nothing obvious [happen].~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_352); new_line; .L_Say305; .L_SayX305;
            ! [5: end if]
            }

        ! [6: otherwise]
        } else {

        ! [7: say ~[The actor] [push] [the noun].~ ( b )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_353); new_line; .L_Say306; .L_SayX306;
        ! [8: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_282, 282, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Turning (B247_check_turning)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Check an actor turning ( this is the can't turn what's fixed in place rule ):
!   === equally specific with ===
! Rule 2/3 ! Check an actor turning ( this is the can't turn scenery rule ):
!   === equally specific with ===
! Rule 3/3 ! Check an actor turning ( this is the can't turn people rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor turning ( this is the can't turn what's fixed in place rule ):
[ R_283 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_283, 283);
    ! [1: if the noun is fixed in place begin]
    if ((((Adj_59_t1_v10(noun))))){
        ! [2: if the actor is the player begin]
        if (((actor == player))){
            ! [3: say ~[regarding the noun][They] [are] fixed in place.~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_354); new_line; .L_Say307; .L_SayX307;
            ! [4: end if]
            }

        ! [5: stop the action]
        rtrue;
        ! [6: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_283, 283, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor turning ( this is the can't turn scenery rule ):
[ R_284 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_284, 284);
    ! [1: if the noun is scenery begin]
    if ((((Adj_61_t1_v10(noun))))){
        ! [2: if the actor is the player begin]
        if (((actor == player))){
            ! [3: say ~[We] [are] unable to.~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_355); new_line; .L_Say308; .L_SayX308;
            ! [4: end if]
            }

        ! [5: stop the action]
        rtrue;
        ! [6: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_284, 284, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor turning ( this is the can't turn people rule ):
[ R_285 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_285, 285);
    ! [1: if the noun is a person begin]
    if (((noun ofclass K8_person))){
        ! [2: if the actor is the player begin]
        if (((actor == player))){
            ! [3: say ~[The noun] [might not like] that.~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_356); new_line; .L_Say309; .L_SayX309;
            ! [4: end if]
            }

        ! [5: stop the action]
        rtrue;
        ! [6: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_285, 285, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Turning (B249_report_turning)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor turning ( this is the report turning rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor turning ( this is the report turning rule ):
[ R_286 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_286, 286);
    ! [1: if the actor is the player begin]
    if (((actor == player))){
        ! [2: if the action is not silent begin]
        if (((keep_silent == false))){
            ! [3: now the prior named object is nothing]
            prior_named_noun = nothing;
            ! [4: say ~Nothing obvious [happen].~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_357); new_line; .L_Say310; .L_SayX310;
            ! [5: end if]
            }

        ! [6: otherwise]
        } else {

        ! [7: say ~[The actor] [turn] [the noun].~ ( b )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_358); new_line; .L_Say311; .L_SayX311;
        ! [8: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_286, 286, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Pushing it to (B250_check_pushing_it_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/6 ! Check an actor pushing something to ( this is the can't push unpushable things rule ):
!   === equally specific with ===
! Rule 2/6 ! Check an actor pushing something to ( this is the can't push to non-directions rule ):
!   === equally specific with ===
! Rule 3/6 ! Check an actor pushing something to ( this is the can't push vertically rule ):
!   === equally specific with ===
! Rule 4/6 ! Check an actor pushing something to ( this is the can't push from within rule ):
!   === equally specific with ===
! Rule 5/6 ! Check an actor pushing something to ( this is the standard pushing in directions rule ):
!   === equally specific with ===
! Rule 6/6 ! Check an actor pushing something to ( this is the block pushing in directions rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor pushing something to ( this is the can't push unpushable things rule ):
[ R_287 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_287, 287);
    ! [1: if the noun is not pushable between rooms begin]
    if (((~~(((Adj_63_t1_v10(noun))))))){
        ! [2: if the actor is the player begin]
        if (((actor == player))){
            ! [3: say ~[The noun] [cannot] be pushed from place to place.~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_359); new_line; .L_Say312; .L_SayX312;
            ! [4: end if]
            }

        ! [5: stop the action]
        rtrue;
        ! [6: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_287, 287, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor pushing something to ( this is the can't push to non-directions rule ):
[ R_288 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_288, 288);
    ! [1: if the second noun is not a direction begin]
    if (((~~((second ofclass K3_direction))))){
        ! [2: if the actor is the player begin]
        if (((actor == player))){
            ! [3: say ~[regarding the noun][They] [aren't] a direction.~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_360); new_line; .L_Say313; .L_SayX313;
            ! [4: end if]
            }

        ! [5: stop the action]
        rtrue;
        ! [6: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_288, 288, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor pushing something to ( this is the can't push vertically rule ):
[ R_289 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_289, 289);
    ! [1: if the second noun is up or the second noun is down begin]
    if ((((second == I58_up))) || (((second == I59_down)))){
        ! [2: if the actor is the player begin]
        if (((actor == player))){
            ! [3: say ~[The noun] [cannot] be pushed up or down.~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_361); new_line; .L_Say314; .L_SayX314;
            ! [4: end if]
            }

        ! [5: stop the action]
        rtrue;
        ! [6: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_289, 289, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor pushing something to ( this is the can't push from within rule ):
[ R_290 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_290, 290);
    ! [1: if the noun encloses the actor begin]
    if (((IndirectlyContains(noun,actor)))){
        ! [2: if the actor is the player begin]
        if (((actor == player))){
            ! [3: say ~[The noun] [cannot] be pushed from here.~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_362); new_line; .L_Say315; .L_SayX315;
            ! [4: end if]
            }

        ! [5: stop the action]
        rtrue;
        ! [6: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_290, 290, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor pushing something to ( this is the standard pushing in directions rule ):
[ R_291 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_291, 291);
    ! [1: convert to special going-with-push action]
    return ConvertToGoingWithPush();
    } else if (debug_rules > 1) DB_Rule(R_291, 291, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor pushing something to ( this is the block pushing in directions rule ):
[ R_292 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_292, 292);
    ! [1: if the actor is the player begin]
    if (((actor == player))){
        ! [2: say ~[The noun] [cannot] be pushed from place to place.~ ( a )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_363); new_line; .L_Say316; .L_SayX316;
        ! [3: end if]
        }

    ! [4: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_292, 292, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Squeezing (B253_check_squeezing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor squeezing ( this is the innuendo about squeezing people rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor squeezing ( this is the innuendo about squeezing people rule ):
[ R_293 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_293, 293);
    ! [1: if the noun is a person begin]
    if (((noun ofclass K8_person))){
        ! [2: if the actor is the player begin]
        if (((actor == player))){
            ! [3: say ~[The noun] [might not like] that.~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_364); new_line; .L_Say317; .L_SayX317;
            ! [4: end if]
            }

        ! [5: stop the action]
        rtrue;
        ! [6: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_293, 293, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Squeezing (B255_report_squeezing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor squeezing ( this is the report squeezing rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor squeezing ( this is the report squeezing rule ):
[ R_294 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_294, 294);
    ! [1: if the actor is the player begin]
    if (((actor == player))){
        ! [2: if the action is not silent begin]
        if (((keep_silent == false))){
            ! [3: say ~[We] [achieve] nothing by this.~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_365); new_line; .L_Say318; .L_SayX318;
            ! [4: end if]
            }

        ! [5: otherwise]
        } else {

        ! [6: say ~[The actor] [squeeze] [the noun].~ ( b )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_366); new_line; .L_Say319; .L_SayX319;
        ! [7: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_294, 294, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Saying yes (B256_check_saying_yes)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor saying yes ( this is the block saying yes rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor saying yes ( this is the block saying yes rule ):
[ R_295 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_295, 295);
    ! [1: if the actor is the player begin]
    if (((actor == player))){
        ! [2: say ~That was a rhetorical question.~ ( a )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_367); new_line; .L_Say320; .L_SayX320;
        ! [3: end if]
        }

    ! [4: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_295, 295, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Saying no (B259_check_saying_no)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor saying no ( this is the block saying no rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor saying no ( this is the block saying no rule ):
[ R_296 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_296, 296);
    ! [1: if the actor is the player begin]
    if (((actor == player))){
        ! [2: say ~That was a rhetorical question.~ ( a )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_368); new_line; .L_Say321; .L_SayX321;
        ! [3: end if]
        }

    ! [4: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_296, 296, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Burning (B262_check_burning)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor burning ( this is the block burning rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor burning ( this is the block burning rule ):
[ R_297 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_297, 297);
    ! [1: if the actor is the player begin]
    if (((actor == player))){
        ! [2: say ~This dangerous act [would achieve] little.~ ( a )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_369); new_line; .L_Say322; .L_SayX322;
        ! [3: end if]
        }

    ! [4: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_297, 297, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Waking up (B265_check_waking_up)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor waking up ( this is the block waking up rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor waking up ( this is the block waking up rule ):
[ R_298 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_298, 298);
    ! [1: if the actor is the player begin]
    if (((actor == player))){
        ! [2: now the prior named object is nothing]
        prior_named_noun = nothing;
        ! [3: say ~The dreadful truth [are], this [are not] a dream.~ ( a )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_370); new_line; .L_Say323; .L_SayX323;
        ! [4: end if]
        }

    ! [5: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_298, 298, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Thinking (B268_check_thinking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor thinking ( this is the block thinking rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor thinking ( this is the block thinking rule ):
[ R_299 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_299, 299);
    ! [1: if the actor is the player begin]
    if (((actor == player))){
        ! [2: say ~What a good idea.~ ( a )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_371); new_line; .L_Say324; .L_SayX324;
        ! [3: end if]
        }

    ! [4: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_299, 299, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Smelling (B273_report_smelling)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor smelling ( this is the report smelling rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor smelling ( this is the report smelling rule ):
[ R_300 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_300, 300);
    ! [1: if the actor is the player begin]
    if (((actor == player))){
        ! [2: if the action is not silent begin]
        if (((keep_silent == false))){
            ! [3: say ~[We] [smell] nothing unexpected.~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_372); new_line; .L_Say325; .L_SayX325;
            ! [4: end if]
            }

        ! [5: otherwise]
        } else {

        ! [6: say ~[The actor] [sniff].~ ( b )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_373); new_line; .L_Say326; .L_SayX326;
        ! [7: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_300, 300, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Listening to (B276_report_listening_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor listening to ( this is the report listening rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor listening to ( this is the report listening rule ):
[ R_301 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_301, 301);
    ! [1: if the actor is the player begin]
    if (((actor == player))){
        ! [2: if the action is not silent begin]
        if (((keep_silent == false))){
            ! [3: say ~[We] [hear] nothing unexpected.~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_374); new_line; .L_Say327; .L_SayX327;
            ! [4: end if]
            }

        ! [5: otherwise]
        } else {

        ! [6: say ~[The actor] [listen].~ ( b )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_375); new_line; .L_Say328; .L_SayX328;
        ! [7: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_301, 301, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Tasting (B279_report_tasting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor tasting ( this is the report tasting rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor tasting ( this is the report tasting rule ):
[ R_302 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_302, 302);
    ! [1: if the actor is the player begin]
    if (((actor == player))){
        ! [2: if the action is not silent begin]
        if (((keep_silent == false))){
            ! [3: say ~[We] [taste] nothing unexpected.~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_376); new_line; .L_Say329; .L_SayX329;
            ! [4: end if]
            }

        ! [5: otherwise]
        } else {

        ! [6: say ~[The actor] [taste] [the noun].~ ( b )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_377); new_line; .L_Say330; .L_SayX330;
        ! [7: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_302, 302, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Cutting (B280_check_cutting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor cutting ( this is the block cutting rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor cutting ( this is the block cutting rule ):
[ R_303 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_303, 303);
    ! [1: if the actor is the player begin]
    if (((actor == player))){
        ! [2: say ~Cutting [regarding the noun][them] up [would achieve] little.~ ( a )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_378); new_line; .L_Say331; .L_SayX331;
        ! [3: end if]
        }

    ! [4: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_303, 303, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Jumping (B285_report_jumping)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor jumping ( this is the report jumping rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor jumping ( this is the report jumping rule ):
[ R_304 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_304, 304);
    ! [1: if the actor is the player begin]
    if (((actor == player))){
        ! [2: if the action is not silent begin]
        if (((keep_silent == false))){
            ! [3: say ~[We] [jump] on the spot.~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_379); new_line; .L_Say332; .L_SayX332;
            ! [4: end if]
            }

        ! [5: otherwise]
        } else {

        ! [6: say ~[The actor] [jump] on the spot.~ ( b )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_380); new_line; .L_Say333; .L_SayX333;
        ! [7: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_304, 304, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Tying it to (B286_check_tying_it_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor tying something to ( this is the block tying rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor tying something to ( this is the block tying rule ):
[ R_305 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_305, 305);
    ! [1: if the actor is the player begin]
    if (((actor == player))){
        ! [2: say ~[We] [would achieve] nothing by this.~ ( a )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_381); new_line; .L_Say334; .L_SayX334;
        ! [3: end if]
        }

    ! [4: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_305, 305, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Drinking (B289_check_drinking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor drinking ( this is the block drinking rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor drinking ( this is the block drinking rule ):
[ R_306 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_306, 306);
    ! [1: if the actor is the player begin]
    if (((actor == player))){
        ! [2: now the prior named object is nothing]
        prior_named_noun = nothing;
        ! [3: say ~[There's] nothing suitable to drink here.~ ( a )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_382); new_line; .L_Say335; .L_SayX335;
        ! [4: end if]
        }

    ! [5: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_306, 306, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Saying sorry (B292_check_saying_sorry)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor saying sorry ( this is the block saying sorry rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor saying sorry ( this is the block saying sorry rule ):
[ R_307 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_307, 307);
    ! [1: if the actor is the player begin]
    if (((actor == player))){
        ! [2: say ~Oh, don't [if American dialect option is active]apologize[otherwise]apologise[end if].~ ( a )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_383); new_line; .L_Say336; .L_SayX336;
        ! [3: end if]
        }

    ! [4: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_307, 307, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Swinging (B295_check_swinging)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor swinging ( this is the block swinging rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor swinging ( this is the block swinging rule ):
[ R_308 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_308, 308);
    ! [1: if the actor is the player begin]
    if (((actor == player))){
        ! [2: now the prior named object is nothing]
        prior_named_noun = nothing;
        ! [3: say ~[There's] nothing sensible to swing here.~ ( a )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_384); new_line; .L_Say337; .L_SayX337;
        ! [4: end if]
        }

    ! [5: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_308, 308, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Rubbing (B298_check_rubbing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor rubbing ( this is the can't rub another person rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor rubbing ( this is the can't rub another person rule ):
[ R_309 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_309, 309);
    ! [1: if the noun is a person who is not the actor begin]
    if (((noun ofclass K8_person) && (~~((noun == actor))))){
        ! [2: if the actor is the player begin]
        if (((actor == player))){
            ! [3: say ~[The noun] [might not like] that.~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_385); new_line; .L_Say338; .L_SayX338;
            ! [4: end if]
            }

        ! [5: stop the action]
        rtrue;
        ! [6: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_309, 309, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Rubbing (B300_report_rubbing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor rubbing ( this is the report rubbing rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor rubbing ( this is the report rubbing rule ):
[ R_310 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_310, 310);
    ! [1: if the actor is the player begin]
    if (((actor == player))){
        ! [2: if the action is not silent begin]
        if (((keep_silent == false))){
            ! [3: say ~[We] [rub] [the noun].~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_386); new_line; .L_Say339; .L_SayX339;
            ! [4: end if]
            }

        ! [5: otherwise]
        } else {

        ! [6: say ~[The actor] [rub] [the noun].~ ( b )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_387); new_line; .L_Say340; .L_SayX340;
        ! [7: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_310, 310, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Setting it to (B301_check_setting_it_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor setting something to ( this is the block setting it to rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor setting something to ( this is the block setting it to rule ):
[ R_311 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_311, 311);
    ! [1: if the actor is the player begin]
    if (((actor == player))){
        ! [2: say ~No, [we] [can't set] [regarding the noun][those] to anything.~ ( a )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_388); new_line; .L_Say341; .L_SayX341;
        ! [3: end if]
        }

    ! [4: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_311, 311, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Waving hands (B306_report_waving_hands)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor waving hands ( this is the report waving hands rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor waving hands ( this is the report waving hands rule ):
[ R_312 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_312, 312);
    ! [1: if the actor is the player begin]
    if (((actor == player))){
        ! [2: if the action is not silent begin]
        if (((keep_silent == false))){
            ! [3: say ~[We] [wave].~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_389); new_line; .L_Say342; .L_SayX342;
            ! [4: end if]
            }

        ! [5: otherwise]
        } else {

        ! [6: say ~[The actor] [wave].~ ( b )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_390); new_line; .L_Say343; .L_SayX343;
        ! [7: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_312, 312, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Buying (B307_check_buying)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor buying ( this is the block buying rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor buying ( this is the block buying rule ):
[ R_313 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_313, 313);
    ! [1: if the actor is the player begin]
    if (((actor == player))){
        ! [2: now the prior named object is nothing]
        prior_named_noun = nothing;
        ! [3: say ~Nothing [are] on sale.~ ( a )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_391); new_line; .L_Say344; .L_SayX344;
        ! [4: end if]
        }

    ! [5: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_313, 313, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Climbing (B310_check_climbing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor climbing ( this is the block climbing rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor climbing ( this is the block climbing rule ):
[ R_314 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_314, 314);
    ! [1: if the actor is the player begin]
    if (((actor == player))){
        ! [2: say ~I don't think much is to be achieved by that.~ ( a )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_392); new_line; .L_Say345; .L_SayX345;
        ! [3: end if]
        }

    ! [4: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_314, 314, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Sleeping (B313_check_sleeping)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor sleeping ( this is the block sleeping rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor sleeping ( this is the block sleeping rule ):
[ R_315 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_315, 315);
    ! [1: if the actor is the player begin]
    if (((actor == player))){
        ! [2: say ~[We] [aren't] feeling especially drowsy.~ ( a )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_393); new_line; .L_Say346; .L_SayX346;
        ! [3: end if]
        }

    ! [4: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_315, 315, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Refusing keys (B362_for_refusing_keys)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Rule for refusing keys of something ( called locked-thing ) ( this is the standard printing key lack rule ):
! ----------------------------------------------------------------------------------------------------
! From "Locksmith" by Emily Short
! No specific request
! Rule for refusing keys of something ( called locked-thing ) ( this is the standard printing key lack rule ):
[ R_821 
    tmp_0 ! Let/loop value, e.g., 'locked-thing': thing
    ;
    if ((((tmp_0 = parameter_value, (((tmp_0=(parameter_value), true) && (parameter_value ofclass K2_thing))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_821, 821);
    ! [1: say ~[We] [lack] a key that fits [the locked-thing].~ ( a )]
    say__p=1;ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),TX_R_394); new_line; .L_Say347; .L_SayX347;
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_821, 821, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Unlocking keylessly (B364_check_unlocking_keyless)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor unlocking keylessly ( this is the check keylessly unlocking rule ):
! ----------------------------------------------------------------------------------------------------
! From "Locksmith" by Emily Short
! No specific request
! Check an actor unlocking keylessly ( this is the check keylessly unlocking rule ):
[ R_825 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_825, 825);
    ! [1: abide by the can't unlock without a lock rule]
    if (FollowRulebook(R_212)) rtrue;
    ! [2: abide by the can't unlock what's already unlocked rule]
    if (FollowRulebook(R_213)) rtrue;
    ! [3: abide by the need a matching key rule]
    if (FollowRulebook(R_819)) rtrue;
    ! [4: now the key unlocked with is the second noun]
    (MStack-->MstVO(20077,0)) = second;
    } else if (debug_rules > 1) DB_Rule(R_825, 825, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Unlocking keylessly (B365_carry_out_unlocking_key)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor unlocking keylessly ( this is the standard keylessly unlocking rule ):
! ----------------------------------------------------------------------------------------------------
! From "Locksmith" by Emily Short
! No specific request
! Carry out an actor unlocking keylessly ( this is the standard keylessly unlocking rule ):
[ R_826 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_826, 826);
    ! [1: if sequential action option is active begin]
    if ((((Adj_25_t1_v16(28))))){
        ! [2: do nothing]
        ;
        ! [3: otherwise if the person asked is the player]
        } else if (((actor == player))) {
        ! [4: say ~(with [the key unlocked with])[command clarification break]~ ( a )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_395); .L_Say348; .L_SayX348;
        ! [5: end if]
        }

    ! [6: try the person asked unlocking the noun with the key unlocked with]
    TryAction(0, actor, ##Unlock, noun, (MStack-->MstVO(20077,0)));;
    } else if (debug_rules > 1) DB_Rule(R_826, 826, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Locking keylessly (B367_check_locking_keylessly)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor locking keylessly ( this is the check keylessly locking rule ):
! ----------------------------------------------------------------------------------------------------
! From "Locksmith" by Emily Short
! No specific request
! Check an actor locking keylessly ( this is the check keylessly locking rule ):
[ R_828 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_828, 828);
    ! [1: abide by the can't lock without a lock rule]
    if (FollowRulebook(R_206)) rtrue;
    ! [2: abide by the can't lock what's already locked rule]
    if (FollowRulebook(R_207)) rtrue;
    ! [3: abide by the can't lock what's open rule]
    if (FollowRulebook(R_208)) rtrue;
    ! [4: abide by the need a matching key rule]
    if (FollowRulebook(R_819)) rtrue;
    ! [5: now the key locked with is the second noun]
    (MStack-->MstVO(20078,0)) = second;
    } else if (debug_rules > 1) DB_Rule(R_828, 828, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Locking keylessly (B368_carry_out_locking_keyle)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor locking keylessly ( this is the standard keylessly locking rule ):
! ----------------------------------------------------------------------------------------------------
! From "Locksmith" by Emily Short
! No specific request
! Carry out an actor locking keylessly ( this is the standard keylessly locking rule ):
[ R_829 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_829, 829);
    ! [1: if sequential action option is active begin]
    if ((((Adj_25_t1_v16(28))))){
        ! [2: do nothing]
        ;
        ! [3: otherwise if the person asked is the player]
        } else if (((actor == player))) {
        ! [4: say ~(with [the key locked with])[command clarification break]~ ( a )]
        say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_396); .L_Say349; .L_SayX349;
        ! [5: end if]
        }

    ! [6: try the person asked locking the noun with the key locked with]
    TryAction(0, actor, ##Lock, noun, (MStack-->MstVO(20078,0)));;
    } else if (debug_rules > 1) DB_Rule(R_829, 829, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Displaying (B371_for_displaying)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Rule for displaying ( this is the basic menu contents rule ):
! ----------------------------------------------------------------------------------------------------
! From "Menus" by Emily Short
! No specific request
! Rule for displaying ( this is the basic menu contents rule ):
[ R_899 ;
    if (debug_rules) DB_Rule(R_899, 899);
    ! [1: now current menu selection is 1]
    (Global_Vars-->20) = 1;
    ! [2: show menu contents]
    (PHR_898_r12 ());
    RulebookSucceeds(); rtrue;
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Pausing the game (B374_for_pausing_the_game)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! For pausing the game ( this is the standard pausing the game rule ):
! ----------------------------------------------------------------------------------------------------
! From "Basic Screen Effects" by Emily Short
! No specific request
! For pausing the game ( this is the standard pausing the game rule ):
[ R_910 ;
    if (debug_rules) DB_Rule(R_910, 910);
    ! [1: say ~[paragraph break]Please press SPACE to continue.~ ( a )]
    say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_397); new_line; .L_Say350; .L_SayX350;
    ! [2: wait for the space key]
    SPACEPause();
    ! [3: clear the screen]
    VM_ClearScreen(0);
    RulebookSucceeds(); rtrue;
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Reading (B376_check_reading)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check reading:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Check reading:
[ R_940 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_940, 940);
    ! [1: if the reading-material of the noun is ~~ begin]
    if ((( BlkValueCompare(GProperty(OBJECT_TY, noun,p15_reading_material), EMPTY_TEXT_VALUE) == 0))){
        ! [2: say ~Nothing is printed on [the noun].~ instead]
        say__p=1;ParaContent(); print "Nothing is printed on ";ParaContent(); print (the) noun;ParaContent(); print "."; new_line; rtrue; .L_Say351; .L_SayX351; rtrue;
        ! [3: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_940, 940, 'actor');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Reading (B377_carry_out_reading)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out reading:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Carry out reading:
[ R_941 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_941, 941);
    ! [1: say ~[reading-material of the noun].~]
    @push self; say__p=1;ParaContent(); print (TEXT_TY_Say) GProperty(OBJECT_TY, self=noun,p15_reading_material);@pull self; ParaContent(); print "."; new_line; .L_Say352; .L_SayX352;
    } else if (debug_rules > 1) DB_Rule(R_941, 941, 'actor');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: when chooseYourDestiny begins (B379_when_chooseyourdestiny_)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! When chooseYourDestiny begins:
! ----------------------------------------------------------------------------------------------------
! No specific request
! When chooseYourDestiny begins:
[ R_944 ;
    if (debug_rules) DB_Rule(R_944, 944);
    ! [1: say ~Do you pick up the wand?~]
    say__p=1;ParaContent(); print "Do you pick up the wand?"; new_line; .L_Say353; .L_SayX353;
    ! [2: if the player consents begin]
    if ((YesOrNo())){
        ! [3: say ~You pick up the wand, a strange power tingling down your arm as the end briefly glows.~]
        say__p=1;ParaContent(); print "You pick up the wand, a strange power tingling down your arm as the end briefly glows."; new_line; .L_Say354; .L_SayX354;
        ! [4: move witch to city park]
        MoveObject(I157_witch, I140_city_park, 0, false);
        ! [5: say witchconversation]
        say__p=1;ParaContent(); (PHR_946_r13 ()); .L_Say355; .L_SayX355;
        ! [6: otherwise]
        } else {

        ! [7: say ~Meh, you dont believe in magic anyway.~]
        say__p=1;ParaContent(); print "Meh, you dont believe in magic anyway."; new_line; .L_Say356; .L_SayX356;
        ! [8: say goodbitch]
        say__p=1;ParaContent(); (PHR_987_r14 ()); .L_Say357; .L_SayX357;
        ! [9: end if]
        }

        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: when chooseYourDestiny ends (B380_when_chooseyourdestiny_)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! When chooseYourDestiny ends:
! ----------------------------------------------------------------------------------------------------
! No specific request
! When chooseYourDestiny ends:
[ R_945 ;
    if (debug_rules) DB_Rule(R_945, 945);
    ! [1: say goodbitch]
    say__p=1;ParaContent(); (PHR_987_r14 ()); .L_Say358; .L_SayX358;
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: when gazelleTransformation begins (B381_when_gazelletransformat)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! When gazelleTransformation begins:
! ----------------------------------------------------------------------------------------------------
! No specific request
! When gazelleTransformation begins:
[ R_947 ;
    if (debug_rules) DB_Rule(R_947, 947);
    ! [1: say ~Suddenly he hunchs over, a cry of desperation leaving his mouth.  People stop to look at him as he tries to stand and collapses with another faint cry.~]
    say__p=1;ParaContent(); print "Suddenly he hunchs over, a cry of desperation leaving his mouth.  People stop to look at him as he tries to stand and collapses with another faint cry."; new_line; .L_Say359; .L_SayX359;
    ! [2: say ~After a few minutes, an ambulance shows up, and a blonde girl in a paramedics outfit steps out.  Damn she is cute.  Some people continue on their way as she runs to the collapsed man, but you can't help but stay and watch.  I wonder whats wrong with him?~]
    say__p=1;ParaContent(); print "After a few minutes, an ambulance shows up, and a blonde girl in a paramedics outfit steps out.  Damn she is cute.  Some people continue on their way as she runs to the collapsed man, but you can't help but stay and watch.  I wonder whats wrong with him?"; new_line; .L_Say360; .L_SayX360;
    ! [3: say randomgazelle]
    say__p=1;ParaContent(); (PHR_980_r15 ()); .L_Say361; .L_SayX361;
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: when gaggleBecomesHerd begins (B383_when_gagglebecomesherd_)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! when gaggleBecomesHerd begins:
! ----------------------------------------------------------------------------------------------------
! No specific request
! when gaggleBecomesHerd begins:
[ R_960 ;
    if (debug_rules) DB_Rule(R_960, 960);
    ! [1: say ~Suddenly a pulse of magic emerges from within the crowd, shooting at the laughing girls.  The sound it makes when it hits is like nothing you have ever heard, a mix of screams and whinnies, encompassed completely by the dispersing smoke.  When it clears you can see the girls hunched over, coughing and falling over, the four of them trying to find something sturdy to hold on to. One of them, a cute little brunette, suddenly yells in surprise and takes the hands she was coughing into away from her face in horror.  They are morphing into a dark brown mass, the arms holding them shaking in disbelief of what was happening.  'NoooooOEEEIIIIIII' her refusal turning into a high pitched whinny.^^Her hands were hooves by now, and her friends were following suit with their own changes.  What was once a plethora of giggling and teasing was now transformed into a cacophony of moans and whinnies. Two twin reheaded girls were holding eachother and crying, one of them with two large mare teets sticking over the top of her shorts and the other hardly recognizing her new tail had lifted and she had laid a pile of manure behind her.[pause_clear]~]
    say__p=1;ParaContent(); print "Suddenly a pulse of magic emerges from within the crowd, shooting at the laughing girls.  The sound it makes when it hits is like nothing you have ever heard, a mix of screams and whinnies, encompassed completely by the dispersing smoke.  When it clears you can see the girls hunched over, coughing and falling over, the four of them trying to find something sturdy to hold on to. One of them, a cute little brunette, suddenly yells in surprise and takes the hands she was coughing into away from her face in horror.  They are morphing into a dark brown mass, the arms holding them shaking in disbelief of what was happening.  ~NoooooOEEEIIIIIII~ her refusal turning into a high pitched whinny.^^Her hands were hooves by now, and her friends were following suit with their own changes.  What was once a plethora of giggling and teasing was now transformed into a cacophony of moans and whinnies. Two twin reheaded girls were holding eachother and crying, one of them with two large mare teets sticking over the top of her shorts and the other hardly recognizing her new tail had lifted and she had laid a pile of manure behind her."; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say362; .L_SayX362;
    ! [2: say ~The final one, a short blonde with a ponytail, was on her hand and knees looking frantically about.. and finally settling on a nearby lightpole.  You watch stunned at her crawling over, turning around and starting to rub her pussy against the light pole in some desperate attempt to ease her pleasure.^^As you watch the poor girl trying to get some relief, a blonde tail sprouts out of her pants, her skin turning to a light brown.  Shes snorting and moan as she coats the lightpole with her pussy juices, the humiliating act only happening because of her sheer desperation.  Her body is growing by the second and her moans become deeper as her torso expands into that of a ponies.  You can almost see the intelligence leave her eyes, her mind becoming only a mare in heat as she steps away from the pole, whickering and trotting about.^^The other girls had followed suit, prancing about confused with their new bodies.  One of the twin redheads is over sniffing the hindquarters of the brunette curiously.^^You need to go.  The crowd is gone, and all that's left here is a small herd of mares in heat.~]
    say__p=1;ParaContent(); print "The final one, a short blonde with a ponytail, was on her hand and knees looking frantically about.. and finally settling on a nearby lightpole.  You watch stunned at her crawling over, turning around and starting to rub her pussy against the light pole in some desperate attempt to ease her pleasure.^^As you watch the poor girl trying to get some relief, a blonde tail sprouts out of her pants, her skin turning to a light brown.  Shes snorting and moan as she coats the lightpole with her pussy juices, the humiliating act only happening because of her sheer desperation.  Her body is growing by the second and her moans become deeper as her torso expands into that of a ponies.  You can almost see the intelligence leave her eyes, her mind becoming only a mare in heat as she steps away from the pole, whickering and trotting about.^^The other girls had followed suit, prancing about confused with their new bodies.  One of the twin redheads is over sniffing the hindquarters of the brunette curiously.^^You need to go.  The crowd is gone, and all that's left here is a small herd of mares in heat."; new_line; .L_Say363; .L_SayX363;
    ! [3: if player is female begin]
    if ((((Adj_81_t1_v10(player))))){
        ! [4: say suckedintomare]
        say__p=1;ParaContent(); (PHR_1018_r16 ()); .L_Say364; .L_SayX364;
        ! [5: otherwise]
        } else {

        ! [6: say ~Shaking your head, you continue on your way.~]
        say__p=1;ParaContent(); print "Shaking your head, you continue on your way."; new_line; .L_Say365; .L_SayX365;
        ! [7: end if]
        }

        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: when newsCast begins (B385_when_newscast_begins)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! when newsCast begins:
! ----------------------------------------------------------------------------------------------------
! No specific request
! when newsCast begins:
[ R_961 ;
    if (debug_rules) DB_Rule(R_961, 961);
    ! [1: say minotaurscene]
    say__p=1;ParaContent(); (PHR_995_r17 ()); .L_Say366; .L_SayX366;
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: when Joining The Zoo begins (B387_when_joining_the_zoo_be)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! When Joining The Zoo begins:
! ----------------------------------------------------------------------------------------------------
! No specific request
! When Joining The Zoo begins:
[ R_963 ;
    if (debug_rules) DB_Rule(R_963, 963);
    ! [1: say becomefemalegiraffe]
    say__p=1;ParaContent(); (PHR_1001_r18 ()); .L_Say367; .L_SayX367;
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: when genieInABottle begins (B389_when_genieinabottle_beg)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! When genieInABottle begins:
! ----------------------------------------------------------------------------------------------------
! No specific request
! When genieInABottle begins:
[ R_966 ;
    if (debug_rules) DB_Rule(R_966, 966);
    ! [1: say becomefemalecamel]
    say__p=1;ParaContent(); (PHR_1000_r19 ()); .L_Say368; .L_SayX368;
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: when Exploring Your Office begins (B391_when_exploring_your_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! When Exploring Your Office begins:
! ----------------------------------------------------------------------------------------------------
! No specific request
! When Exploring Your Office begins:
[ R_969 ;
    if (debug_rules) DB_Rule(R_969, 969);
    ! [1: say talkwithmeredith]
    say__p=1;ParaContent(); (PHR_1020_r20 ()); .L_Say369; .L_SayX369;
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: when Jerked begins (B393_when_jerked_begins)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! When Jerked begins:
! ----------------------------------------------------------------------------------------------------
! No specific request
! When Jerked begins:
[ R_970 ;
    if (debug_rules) DB_Rule(R_970, 970);
    ! [1: say becomehog]
    say__p=1;ParaContent(); (PHR_1016_r21 ()); .L_Say370; .L_SayX370;
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: when supplyShopEvent begins (B395_when_supplyshopevent_be)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! when supplyShopEvent begins:
! ----------------------------------------------------------------------------------------------------
! No specific request
! when supplyShopEvent begins:
[ R_971 ;
    if (debug_rules) DB_Rule(R_971, 971);
    ! [1: say cuttripwire]
    say__p=1;ParaContent(); (PHR_972_r22 ()); .L_Say371; .L_SayX371;
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: when Here Girl begins (B397_when_here_girl_begins)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! When Here Girl begins:
! ----------------------------------------------------------------------------------------------------
! No specific request
! When Here Girl begins:
[ R_988 ;
    if (debug_rules) DB_Rule(R_988, 988);
    ! [1: say goodbitch]
    say__p=1;ParaContent(); (PHR_987_r14 ()); .L_Say372; .L_SayX372;
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: when Here Girl ends (B398_when_here_girl_ends)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! When Here Girl ends:
! ----------------------------------------------------------------------------------------------------
! No specific request
! When Here Girl ends:
[ R_989 ;
    if (debug_rules) DB_Rule(R_989, 989);
    ! [1: move the witch to the park entrance]
    MoveObject(I157_witch, I141_park_entrance, 0, false);
    ! [2: say ~She disappeared, leaving you to a life as an animal.~]
    say__p=1;ParaContent(); print "She disappeared, leaving you to a life as an animal."; new_line; .L_Say373; .L_SayX373;
    ! [3: say ~Game over Female Dog Her Bitch Forever.~]
    say__p=1;ParaContent(); print "Game over Female Dog Her Bitch Forever."; new_line; .L_Say374; .L_SayX374;
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: when SizeIncrease begins (B399_when_sizeincrease_begin)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! When SizeIncrease begins:
! ----------------------------------------------------------------------------------------------------
! No specific request
! When SizeIncrease begins:
[ R_993 ;
    if (debug_rules) DB_Rule(R_993, 993);
    ! [1: clear the screen]
    VM_ClearScreen(0);
    ! [2: say ~Are you quite sure you want to get any closer to that creepy statue?~]
    say__p=1;ParaContent(); print "Are you quite sure you want to get any closer to that creepy statue?"; new_line; .L_Say375; .L_SayX375;
    ! [3: if the player consents begin]
    if ((YesOrNo())){
        ! [4: say becomeferalelephant]
        say__p=1;ParaContent(); (PHR_992_r23 ()); .L_Say376; .L_SayX376;
        ! [5: otherwise]
        } else {

        ! [6: say ~On second thought, you were already pushing your luck today.~]
        say__p=1;ParaContent(); print "On second thought, you were already pushing your luck today."; new_line; .L_Say377; .L_SayX377;
        ! [7: end if]
        }

        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: when SizeIncrease ends (B400_when_sizeincrease_ends)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! When SizeIncrease ends:
! ----------------------------------------------------------------------------------------------------
! No specific request
! When SizeIncrease ends:
[ R_994 ;
    if (debug_rules) DB_Rule(R_994, 994);
    ! [1: say ~~]
    say__p=1;ParaContent(); print ""; .L_Say378; .L_SayX378;
    ! [2: say ~Game over Male Elephant Size Increase.~]
    say__p=1;ParaContent(); print "Game over Male Elephant Size Increase."; new_line; .L_Say379; .L_SayX379;
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: when dontCroak begins (B401_when_dontcroak_begins)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! When dontCroak begins:
! ----------------------------------------------------------------------------------------------------
! No specific request
! When dontCroak begins:
[ R_997 ;
    if (debug_rules) DB_Rule(R_997, 997);
    ! [1: clear the screen]
    VM_ClearScreen(0);
    ! [2: say ~~]
    say__p=1;ParaContent(); print ""; .L_Say380; .L_SayX380;
    ! [3: say becomefemalefrog]
    say__p=1;ParaContent(); (PHR_996_r24 ()); .L_Say381; .L_SayX381;
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: when MareTf begins (B403_when_maretf_begins)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! When MareTf begins:
! ----------------------------------------------------------------------------------------------------
! No specific request
! When MareTf begins:
[ R_1006 ;
    if (debug_rules) DB_Rule(R_1006, 1006);
    ! [1: say becomebaymare]
    say__p=1;ParaContent(); (PHR_1005_r25 ()); .L_Say382; .L_SayX382;
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: when SwineOption begins (B405_when_swineoption_begins)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! When SwineOption begins:
! ----------------------------------------------------------------------------------------------------
! No specific request
! When SwineOption begins:
[ R_1015 ;
    if (debug_rules) DB_Rule(R_1015, 1015);
    ! [1: clear the screen]
    VM_ClearScreen(0);
    ! [2: say ~'Well,' the witch asked, 'Which one? How bout you say yes for hog and no for sow..'~]
    say__p=1;ParaContent(); print "~Well,~ the witch asked, ~Which one? How bout you say yes for hog and no for sow..~"; new_line; .L_Say383; .L_SayX383;
    ! [3: if the player consents begin]
    if ((YesOrNo())){
        ! [4: say becomesowgirl]
        say__p=1;ParaContent(); (PHR_1009_r26 ()); .L_Say384; .L_SayX384;
        ! [5: otherwise]
        } else {

        ! [6: say becomesexdoll]
        say__p=1;ParaContent(); (PHR_1017_r27 ()); .L_Say385; .L_SayX385;
        ! [7: end if]
        }

        rfalse;
];
! ----------------------------------------------------------------------------------------------------
! Definitions of displaced and unbooked rules

! From the Standard Rules
! No specific request
! Check an actor locking something with ( this is the can't lock without the correct key rule ):
[ R_209 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_209, 209);
    ! [1: if the holder of the second noun is not the actor or the noun does not provide the property matching key or the matching key of the noun is not the second noun begin]
    if ((((~~(((HolderOf(second)) == actor))))) || ((((~~((WhetherProvides(noun, false, with_key)))))) || (((~~((GProperty(OBJECT_TY, noun,with_key) == second))))))){
        ! [2: if the actor is the player begin]
        if (((actor == player))){
            ! [3: say ~[regarding the second noun][Those] [don't] seem to fit the lock.~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_398); new_line; .L_Say386; .L_SayX386;
            ! [4: end if]
            }

        ! [5: stop the action]
        rtrue;
        ! [6: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_209, 209, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor unlocking something with ( this is the can't unlock without the correct key rule ):
[ R_214 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_214, 214);
    ! [1: if the holder of the second noun is not the actor or the noun does not provide the property matching key or the matching key of the noun is not the second noun begin]
    if ((((~~(((HolderOf(second)) == actor))))) || ((((~~((WhetherProvides(noun, false, with_key)))))) || (((~~((GProperty(OBJECT_TY, noun,with_key) == second))))))){
        ! [2: if the actor is the player begin]
        if (((actor == player))){
            ! [3: say ~[regarding the second noun][Those] [don't] seem to fit the lock.~ ( a )]
            say__p=1;ParaContent(); print (TEXT_TY_Say) (TX_R_399); new_line; .L_Say387; .L_SayX387;
            ! [4: end if]
            }

        ! [5: stop the action]
        rtrue;
        ! [6: end if]
        }

        } else if (debug_rules > 1) DB_Rule(R_214, 214, 'action');
        rfalse;
];
! From "Locksmith" by Emily Short
! No specific request
! This is the need a matching key rule:
[ R_819 
    tmp_0 ! Let/loop value, e.g., 'item': passkey
    ;
    if (debug_rules) DB_Rule(R_819, 819);
    ! [1: if the person asked encloses something ( called item ) which unlocks the noun begin]
    if ((((RGuard_f0_1(noun)) ofclass K2_thing) && (tmp_0=((RGuard_f0_1(noun))), true) && (IndirectlyContains(actor,(RGuard_f0_1(noun)))))){
        ! [2: now the second noun is the item]
        second = tmp_0;
        ! [3: abide by the must have accessible the second noun rule]
        if (FollowRulebook(R_845)) rtrue;
        ! [4: otherwise if a visible passkey ( called item ) unbolts the noun]
        } else if ((((RGuard_f0_2(noun)) ofclass K16_passkey) && (tmp_0=((RGuard_f0_2(noun))), true) && ((Adj_3_t1_v10((RGuard_f0_2(noun))))))) {
        ! [5: now the second noun is the item]
        second = tmp_0;
        ! [6: abide by the must have accessible the second noun rule]
        if (FollowRulebook(R_845)) rtrue;
        ! [7: otherwise]
        } else {

        ! [8: if the player is the person asked , say ~[key-refusal for noun]~]
        if (((player == actor))) { say__p=1;ParaContent(); (PHR_820_r28 (noun)); .L_Say388; .L_SayX388; }
        ! [9: stop the action]
        rtrue;
        ! [10: end if]
        }

        rfalse;
];
! From "Locksmith" by Emily Short
! No specific request
! This is the noun autotaking rule:
[ R_840 ;
    if (debug_rules) DB_Rule(R_840, 840);
    ! [1: if sequential action option is active begin]
    if ((((Adj_25_t1_v16(28))))){
        ! [2: if the player is the person asked begin]
        if (((player == actor))){
            ! [3: try taking the noun]
            TryAction(0, player, ##Take, noun, 0);;
            ! [4: otherwise]
            } else {

            ! [5: try the person asked trying taking the noun]
            TryAction(0, actor, ##Take, noun, 0);;
            ! [6: end if]
            }

        ! [7: otherwise]
        } else {

        ! [8: carry out the implicitly taking activity with the noun]
        CarryOutActivity(V25_implicitly_taking, noun);
        ! [9: end if]
        }

        rfalse;
];
! From "Locksmith" by Emily Short
! No specific request
! This is the second noun autotaking rule:
[ R_841 ;
    if (debug_rules) DB_Rule(R_841, 841);
    ! [1: if sequential action option is active begin]
    if ((((Adj_25_t1_v16(28))))){
        ! [2: if the player is the person asked begin]
        if (((player == actor))){
            ! [3: try taking the second noun]
            TryAction(0, player, ##Take, second, 0);;
            ! [4: otherwise]
            } else {

            ! [5: try the person asked trying taking the second noun]
            TryAction(0, actor, ##Take, second, 0);;
            ! [6: end if]
            }

        ! [7: otherwise]
        } else {

        ! [8: carry out the implicitly taking activity with the second noun]
        CarryOutActivity(V25_implicitly_taking, second);
        ! [9: end if]
        }

        rfalse;
];
! From "Locksmith" by Emily Short
! No specific request
! This is the must hold the noun rule:
[ R_842 ;
    if (debug_rules) DB_Rule(R_842, 842);
    ! [1: if the person asked does not have the noun , follow the noun autotaking rule]
    if (((~~((actor == OwnerOf(noun)))))) { FollowRulebook(R_840); }
    ! [2: if the person asked does not have the noun , stop the action]
    if (((~~((actor == OwnerOf(noun)))))) { rtrue; }
    ! [3: make no decision]
    rfalse;
    rfalse;
];
! From "Locksmith" by Emily Short
! No specific request
! This is the must hold the second noun rule:
[ R_843 ;
    if (debug_rules) DB_Rule(R_843, 843);
    ! [1: if the person asked does not have the second noun , follow the second noun autotaking rule]
    if (((~~((actor == OwnerOf(second)))))) { FollowRulebook(R_841); }
    ! [2: if the person asked does not have the second noun , stop the action]
    if (((~~((actor == OwnerOf(second)))))) { rtrue; }
    ! [3: make no decision]
    rfalse;
    rfalse;
];
! From "Locksmith" by Emily Short
! No specific request
! This is the must have accessible the noun rule:
[ R_844 
    tmp_0 ! Let/loop value, e.g., 'containing keychain': keychain
    ;
    if (debug_rules) DB_Rule(R_844, 844);
    ! [1: if the noun is not key-accessible begin]
    if (((~~(((Adj_42_t1_v10(noun))))))){
        ! [2: if the noun is on a keychain ( called the containing keychain ) , now the noun is the containing keychain]
        if (((SupporterOf(noun) ofclass K17_keychain) && (tmp_0=(SupporterOf(noun)), true))) { noun = tmp_0; }
        ! [3: follow the noun autotaking rule]
        FollowRulebook(R_840);
        ! [4: end if]
        }

    ! [5: if the noun is not key-accessible begin]
    if (((~~(((Adj_42_t1_v10(noun))))))){
        ! [6: if the player is the person asked , say ~Without holding [the noun], [we] [can] do nothing.~ ( a )]
        if (((player == actor))) { say__p=1;ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),TX_R_400); new_line; .L_Say389; .L_SayX389; }
        ! [7: stop the action]
        rtrue;
        ! [8: end if]
        }

    ! [9: make no decision]
    rfalse;
    rfalse;
];
! From "Locksmith" by Emily Short
! No specific request
! This is the must have accessible the second noun rule:
[ R_845 
    tmp_0 ! Let/loop value, e.g., '?-1,-1?'(deallocated by end of phrase)
    tmp_1 ! Let/loop value, e.g., 'containing keychain': keychain
    ;
    if (debug_rules) DB_Rule(R_845, 845);
    ! [1: if the second noun is not key-accessible begin]
    if (((~~(((Adj_42_t1_v10(second))))))){
        ! [2: let the held second noun be the second noun]

        		tmp_0 = second;
        ! [3: if the second noun is on a keychain ( called the containing keychain ) , now the second noun is the containing keychain]
        if (((SupporterOf(second) ofclass K17_keychain) && (tmp_1=(SupporterOf(second)), true))) { second = tmp_1; }
        ! [4: follow the second noun autotaking rule]
        FollowRulebook(R_841);
        ! [5: now the second noun is the held second noun]
        second = tmp_0;
        ! [6: end if]
        }

    ! [7: if the second noun is not key-accessible begin]
    if (((~~(((Adj_42_t1_v10(second))))))){
        ! [8: if the player is the person asked , say ~Without holding [the second noun], [we] [can] do nothing.~ ( a )]
        if (((player == actor))) { say__p=1;ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),TX_R_401); new_line; .L_Say390; .L_SayX390; }
        ! [9: stop the action]
        rtrue;
        ! [10: end if]
        }

    ! [11: make no decision]
    rfalse;
    rfalse;
];
! From "Menus" by Emily Short
! No specific request
! This is the quit rule:
[ R_892 ;
    if (debug_rules) DB_Rule(R_892, 892);
    ! [1: decrease the menu depth by 1]
    (Global_Vars-->16) = (Global_Vars-->16) - 1;;
    ! [2: rule succeeds]
    RulebookSucceeds(); rtrue;
    rfalse;
];
! From "Menus" by Emily Short
! No specific request
! This is the move down rule:
[ R_893 ;
    if (debug_rules) DB_Rule(R_893, 893);
    ! [1: if current menu selection is less than the number of filled rows in the current menu , increase current menu selection by 1]
    if ((((Global_Vars-->20) < TableFilledRows((Global_Vars-->19))))) { (Global_Vars-->20) = (Global_Vars-->20) + 1;; }
    ! [2: reprint the current menu]
    (PHR_897_r29 ((Global_Vars-->19)));
    ! [3: make no decision]
    rfalse;
    rfalse;
];
! From "Menus" by Emily Short
! No specific request
! This is the move up rule:
[ R_894 ;
    if (debug_rules) DB_Rule(R_894, 894);
    ! [1: if current menu selection is greater than 1 , decrease current menu selection by 1]
    if ((((Global_Vars-->20) > 1))) { (Global_Vars-->20) = (Global_Vars-->20) - 1;; }
    ! [2: reprint the current menu]
    (PHR_897_r29 ((Global_Vars-->19)));
    ! [3: make no decision]
    rfalse;
    rfalse;
];
! From "Menus" by Emily Short
! No specific request
! This is the select rule:
[ R_895 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_4();
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_4 
    tmp_0 ! Let/loop value, e.g., '?-1,-1?'(deallocated by end of phrase)
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    if (debug_rules) DB_Rule(R_895, 895);
    ! [1: choose row current menu selection in the current menu]
    ct_0 = (Global_Vars-->19); ct_1 = (Global_Vars-->20);
    ! [2: if there is a toggle entry begin]
    if (((ExistsTableLookUpEntry(ct_0,110,ct_1)))){
        ! [3: follow the toggle entry]
        FollowRulebook(TableLookUpEntry(ct_0,110,ct_1));
        ! [4: reprint the current menu]
        (PHR_897_r29 ((Global_Vars-->19)));
        ! [5: otherwise]
        } else {

        ! [6: if there is a subtable entry begin]
        if (((ExistsTableLookUpEntry(ct_0,108,ct_1)))){
            ! [7: now the current menu title is title entry]
            BlkValueCopy((Global_Vars-->18), TableLookUpEntry(ct_0,107,ct_1));
            ! [8: now the current menu selection is 1]
            (Global_Vars-->20) = 1;
            ! [9: now the current menu is subtable entry]
            (Global_Vars-->19) = TableLookUpEntry(ct_0,108,ct_1);
            ! [10: show menu contents]
            (PHR_898_r12 ());
            ! [11: otherwise]
            } else {

            ! [12: let the temporary title be the current menu title]
            tmp_0 = I7SFRAME; 
            		BlkValueCopy(tmp_0, (Global_Vars-->18));
            ! [13: now the current menu title is title entry]
            BlkValueCopy((Global_Vars-->18), TableLookUpEntry(ct_0,107,ct_1));
            ! [14: now the endnode flag is 1]
            (Global_Vars-->17) = 1;
            ! [15: redraw status line]
            DrawStatusLine();
            ! [16: now the endnode flag is 0]
            (Global_Vars-->17) = 0;
            ! [17: clear only the main screen]
            VM_ClearScreen(2);
            ! [18: say ~[variable letter spacing][description entry][paragraph break]~]
            say__p=1;ParaContent(); font on;ParaContent(); print (TEXT_TY_Say) TableLookUpEntry(ct_0,109,ct_1);ParaContent(); DivideParagraphPoint(); new_line; .L_Say391; .L_SayX391;
            ! [19: pause the game]
            (PHR_909_r30 ());
            ! [20: now the current menu title is temporary title]
            BlkValueCopy((Global_Vars-->18), tmp_0);
            ! [21: reprint the current menu]
            (PHR_897_r29 ((Global_Vars-->19)));
            ! [22: end if]
            }

        ! [23: end if]
        }

        rfalse;
];
! From "Menus" by Emily Short
! No specific request
! This is the hint toggle rule:
[ R_903 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_5();
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_5 
    tmp_0 ! Let/loop value, e.g., 'temporary title': text
    tmp_1 ! Let/loop value, e.g., '__index': number
    tmp_2 ! Let/loop value, e.g., '?-1,-1?'(deallocated by end of phrase)
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    if (debug_rules) DB_Rule(R_903, 903);
    ! [1: choose row current menu selection in the current menu]
    ct_0 = (Global_Vars-->19); ct_1 = (Global_Vars-->20);
    ! [2: let the temporary title be the current menu title]
    tmp_0 = I7SFRAME; 
    		BlkValueCopy(tmp_0, (Global_Vars-->18));
    ! [3: now the current menu title is title entry]
    BlkValueCopy((Global_Vars-->18), TableLookUpEntry(ct_0,107,ct_1));
    ! [4: now the endnode flag is 1]
    (Global_Vars-->17) = 1;
    ! [5: redraw status line]
    DrawStatusLine();
    ! [6: now the endnode flag is 0]
    (Global_Vars-->17) = 0;
    ! [7: say known hints from the subtable entry]
    say__p=1;ParaContent(); (PHR_901_r31 (TableLookUpEntry(ct_0,108,ct_1))); .L_Say392; .L_SayX392;
    ! [8: let __index be 0]

    		tmp_1 = 0;
    ! [9: while __index < 1 begin]
    while (((tmp_1 < 1))){
        ! [10: let __x be the chosen letter]

        		tmp_2 = VM_KeyChar();
        ! [11: if __x is 13 or __x is 31 or __x is 32 , let __index be 1]
        if ((((tmp_2 == 13))) || ((((tmp_2 == 31))) || (((tmp_2 == 32))))) { tmp_1 = 1; }
        ! [12: if __x is 72 or __x is 104 , say hints from the subtable entry]
        if ((((tmp_2 == 72))) || (((tmp_2 == 104)))) { say__p=1;ParaContent(); (PHR_902_r32 (TableLookUpEntry(ct_0,108,ct_1))); .L_Say393; .L_SayX393; }
        ! [13: end while]
        }

    ! [14: now the current menu title is temporary title]
    BlkValueCopy((Global_Vars-->18), tmp_0);
    rfalse;
];
! Definitions of adjectives

! From the Standard Rules
! No specific request
! Definition:
[ R_0 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_1 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_2 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_3 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_4 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_5 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_6 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_7 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_8 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_39 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_40 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_41 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_42 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_43 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_44 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_45 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_46 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_47 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_48 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_49 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_50 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_51 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_52 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_53 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_54 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_55 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_56 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_57 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_58 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_59 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_60 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_61 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_62 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_63 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_64 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_94 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From "Locksmith" by Emily Short
! No specific request
! Definition:
[ R_822 
    t_0 ! Call parameter: object
    ;
    ! [1: if the person asked carries it , yes]
    if (((actor == CarrierOf(t_0)))) { rtrue; }
    ! [2: if it is on a keychain which is carried by the person asked , yes]
    if (((SupporterOf(t_0) ofclass K17_keychain) && (actor == CarrierOf(SupporterOf(t_0))))) { rtrue; }
    ! [3: no]
    rfalse;
    return false;
];
! From "Locksmith" by Emily Short
! No specific request
! Definition:
[ R_830 
    t_0 ! Call parameter: object
    ;
    return false;
];
[ Adj_0_t1_v10 
    t_0 ! Call parameter: thing
    ;
    ! meaning of "worn"
      if (t_0 ofclass K2_thing) return ((((player == WearerOf(t_0)))));
    rfalse;
];
[ Adj_1_t1_v10 
    t_0 ! Call parameter: thing
    ;
    ! meaning of "carried"
      if (t_0 ofclass K2_thing) return ((((player == CarrierOf(t_0)))));
    rfalse;
];
[ Adj_2_t1_v10 
    t_0 ! Call parameter: thing
    ;
    ! meaning of "held"
      if (t_0 ofclass K2_thing) return ((((player == HolderOf(t_0)))));
    rfalse;
];
[ Adj_3_t1_v10 
    t_0 ! Call parameter: thing
    ;
    ! meaning of "visible"
      if (t_0 ofclass K2_thing) return ((((TestVisibility(player,t_0)))));
    rfalse;
];
[ Adj_4_t1_v10 
    t_0 ! Call parameter: thing
    ;
    ! meaning of "invisible"
      if (t_0 ofclass K2_thing) return (~~(((((TestVisibility(player,t_0)))))));
    rfalse;
];
[ Adj_5_t1_v10 
    t_0 ! Call parameter: thing
    ;
    ! meaning of "touchable"
      if (t_0 ofclass K2_thing) return ((((TestTouchability(player,t_0)))));
    rfalse;
];
[ Adj_6_t1_v10 
    t_0 ! Call parameter: thing
    ;
    ! meaning of "untouchable"
      if (t_0 ofclass K2_thing) return (~~(((((TestTouchability(player,t_0)))))));
    rfalse;
];
[ Adj_7_t1_v10 
    t_0 ! Call parameter: thing
    ;
    ! meaning of "concealed"
      if (t_0 ofclass K2_thing) return ((((TestConcealment((HolderOf(t_0)),t_0)))));
    rfalse;
];
[ Adj_8_t1_v10 
    t_0 ! Call parameter: thing
    ;
    ! meaning of "unconcealed"
      if (t_0 ofclass K2_thing) return (~~(((((TestConcealment((HolderOf(t_0)),t_0)))))));
    rfalse;
];
[ Adj_9_t1_v10 
    t_0 ! Call parameter: number
    ;
    ! meaning of "on-stage"
      if (t_0 ofclass K2_thing) return ((OnStage(t_0, -1)));
    rfalse;
];
[ Adj_10_t1_v10 
    t_0 ! Call parameter: number
    ;
    ! meaning of "off-stage"
      if (t_0 ofclass K2_thing) return (~~(((OnStage(t_0, -1)))));
    rfalse;
];
[ Adj_11_t1_v10 
    t_0 ! Call parameter: thing
    ;
    ! meaning of "offstage"
      if (t_0 ofclass K2_thing) return (((((~~Adj_9_t1_v10(t_0))))));
    rfalse;
];
[ Adj_12_t1_v10 
    t_0 ! Call parameter: room
    ;
    ! meaning of "adjacent"
      if (t_0 ofclass K1_room) return ((((TestAdjacency(real_location,t_0)))));
    rfalse;
];
[ Adj_13_t1_v11 
    t_0 ! Call parameter: number
    ;
    ! meaning of "even"
    return (((((IntegerRemainder(t_0, 2)) == 0))));
    rfalse;
];
[ Adj_14_t1_v11 
    t_0 ! Call parameter: number
    ;
    ! meaning of "odd"
    return (~~((((((IntegerRemainder(t_0, 2)) == 0))))));
    rfalse;
];
[ Adj_15_t1_v11 
    t_0 ! Call parameter: number
    ;
    ! meaning of "positive"
    return ((((t_0 > 0))));
    rfalse;
];
[ Adj_15_t1_v12 
    t_0 ! Call parameter: real number
    ;
    ! meaning of "positive"
    return ((((REAL_NUMBER_TY_Compare(t_0, NUMBER_TY_to_REAL_NUMBER_TY(0)) > 0))));
    rfalse;
];
[ Adj_16_t1_v11 
    t_0 ! Call parameter: number
    ;
    ! meaning of "negative"
    return ((((t_0 < 0))));
    rfalse;
];
[ Adj_16_t1_v12 
    t_0 ! Call parameter: real number
    ;
    ! meaning of "negative"
    return ((((REAL_NUMBER_TY_Compare(t_0, NUMBER_TY_to_REAL_NUMBER_TY(0)) < 0))));
    rfalse;
];
[ Adj_17_t1_v14 
    t_0 ! Call parameter: number
    ;
    ! meaning of "empty"
    return ((TEXT_TY_Empty(t_0)));
    rfalse;
];
[ Adj_17_t1_v20 
    t_0 ! Call parameter: table name
    ;
    ! meaning of "empty"
    return ((((TableFilledRows(t_0) == 0))));
    rfalse;
];
[ Adj_17_t1_v31 
    t_0 ! Call parameter: number
    ;
    ! meaning of "empty"
    return ((RulebookEmpty(t_0)));
    rfalse;
];
[ Adj_17_t1_v32 
    t_0 ! Call parameter: number
    ;
    ! meaning of "empty"
    return ((ActivityEmpty(t_0)));
    rfalse;
];
[ Adj_17_t1_v33 
    t_0 ! Call parameter: number
    ;
    ! meaning of "empty"
    return ((LIST_OF_TY_Empty(t_0)));
    rfalse;
];
[ Adj_17_t1_v29 
    t_0 ! Call parameter: number
    ;
    ! meaning of "empty"
    return ((RELATION_TY_Empty(t_0, -1)));
    rfalse;
];
[ Adj_18_t1_v14 
    t_0 ! Call parameter: number
    ;
    ! meaning of "non-empty"
    return (~~(((TEXT_TY_Empty(t_0)))));
    rfalse;
];
[ Adj_18_t1_v20 
    t_0 ! Call parameter: table name
    ;
    ! meaning of "non-empty"
    return (~~(((((TableFilledRows(t_0) == 0))))));
    rfalse;
];
[ Adj_18_t1_v31 
    t_0 ! Call parameter: number
    ;
    ! meaning of "non-empty"
    return (~~(((RulebookEmpty(t_0)))));
    rfalse;
];
[ Adj_18_t1_v32 
    t_0 ! Call parameter: number
    ;
    ! meaning of "non-empty"
    return (~~(((ActivityEmpty(t_0)))));
    rfalse;
];
[ Adj_18_t1_v33 
    t_0 ! Call parameter: number
    ;
    ! meaning of "non-empty"
    return (~~(((LIST_OF_TY_Empty(t_0)))));
    rfalse;
];
[ Adj_18_t1_v29 
    t_0 ! Call parameter: number
    ;
    ! meaning of "non-empty"
    return (~~(((RELATION_TY_Empty(t_0, -1)))));
    rfalse;
];
[ Adj_19_t1_v14 
    t_0 ! Call parameter: number
    ;
    ! meaning of "substituted"
    return ((TEXT_TY_IsSubstituted(t_0)));
    rfalse;
];
[ Adj_20_t1_v14 
    t_0 ! Call parameter: number
    ;
    ! meaning of "unsubstituted"
    return (~~(((TEXT_TY_IsSubstituted(t_0)))));
    rfalse;
];
[ Adj_21_t1_v42 
    t_0 ! Call parameter: scene
    ;
    ! meaning of "happening"
    return ((scene_status-->(t_0-1)==1));
    rfalse;
];
[ Adj_22_t1_v20 
    t_0 ! Call parameter: table name
    ;
    ! meaning of "full"
    return ((((TableBlankRows(t_0) == 0))));
    rfalse;
];
[ Adj_23_t1_v20 
    t_0 ! Call parameter: table name
    ;
    ! meaning of "non-full"
    return (~~(((((TableBlankRows(t_0) == 0))))));
    rfalse;
];
[ Adj_24_t1_v32 
    t_0 ! Call parameter: number
    ;
    ! meaning of "going on"
    return ((TestActivity(t_0)));
    rfalse;
];
[ Adj_25_t1_v16 
    t_0 ! Call parameter: number
    ;
    ! meaning of "active"
    return ((TestUseOption(t_0)));
    rfalse;
];
[ Adj_26_t1_v16 
    t_0 ! Call parameter: number
    ;
    ! meaning of "inactive"
    return (~~(((TestUseOption(t_0)))));
    rfalse;
];
[ Adj_27_t1_v29 
    t_0 ! Call parameter: number
    ;
    ! meaning of "equivalence"
    return ((RELATION_TY_EquivalenceAdjective(t_0, -1)));
    rfalse;
];
[ Adj_28_t1_v29 
    t_0 ! Call parameter: number
    ;
    ! meaning of "symmetric"
    return ((RELATION_TY_SymmetricAdjective(t_0, -1)));
    rfalse;
];
[ Adj_29_t1_v29 
    t_0 ! Call parameter: number
    ;
    ! meaning of "one-to-one"
    return ((RELATION_TY_OToOAdjective(t_0, -1)));
    rfalse;
];
[ Adj_30_t1_v29 
    t_0 ! Call parameter: number
    ;
    ! meaning of "one-to-various"
    return ((RELATION_TY_OToVAdjective(t_0, -1)));
    rfalse;
];
[ Adj_31_t1_v29 
    t_0 ! Call parameter: number
    ;
    ! meaning of "various-to-one"
    return ((RELATION_TY_VToOAdjective(t_0, -1)));
    rfalse;
];
[ Adj_32_t1_v29 
    t_0 ! Call parameter: number
    ;
    ! meaning of "various-to-various"
    return ((RELATION_TY_VToVAdjective(t_0, -1)));
    rfalse;
];
[ Adj_33_t1_v18 
    t_0 ! Call parameter: number
    ;
    ! meaning of "modal"
    return ((VerbIsModal(t_0)));
    rfalse;
];
[ Adj_34_t1_v18 
    t_0 ! Call parameter: number
    ;
    ! meaning of "non-modal"
    return (~~(((VerbIsModal(t_0)))));
    rfalse;
];
[ Adj_35_t1_v18 
    t_0 ! Call parameter: number
    ;
    ! meaning of "meaningful"
    return ((VerbIsMeaningful(t_0)));
    rfalse;
];
[ Adj_36_t1_v18 
    t_0 ! Call parameter: number
    ;
    ! meaning of "meaningless"
    return (~~(((VerbIsMeaningful(t_0)))));
    rfalse;
];
[ Adj_37_t1_v12 
    t_0 ! Call parameter: real number
    ;
    ! meaning of "infinite"
    return ((((( REAL_NUMBER_TY_Compare(t_0, 2139095040) == 0))) || ((( REAL_NUMBER_TY_Compare(t_0, -8388608) == 0)))));
    rfalse;
];
[ Adj_38_t1_v12 
    t_0 ! Call parameter: real number
    ;
    ! meaning of "finite"
    return (~~(((((( REAL_NUMBER_TY_Compare(t_0, 2139095040) == 0))) || ((( REAL_NUMBER_TY_Compare(t_0, -8388608) == 0)))))));
    rfalse;
];
[ Adj_39_t1_v12 
    t_0 ! Call parameter: number
    ;
    ! meaning of "nonexistent"
    return ((REAL_NUMBER_TY_Nan(t_0)));
    rfalse;
];
[ Adj_40_t1_v12 
    t_0 ! Call parameter: number
    ;
    ! meaning of "existent"
    return (~~(((REAL_NUMBER_TY_Nan(t_0)))));
    rfalse;
];
[ Adj_41_t1_v10 
    t_0 ! Call parameter: thing
    ;
    ! meaning of "locale-supportable"
      if (t_0 ofclass K2_thing) return (((((~~(((Adj_61_t1_v10(t_0))))))) && ((((~~(((Adj_69_t1_v10(t_0))))))) && (((~~(((Adj_66_t1_v10(t_0))))))))));
    rfalse;
];
[ Adj_42_t1_v10 
    t_0 ! Call parameter: thing
    ;
    ! meaning of "key-accessible"
      if (t_0 ofclass K2_thing) return ((R_822(t_0)));
    rfalse;
];
[ Adj_43_t1_v10 
    t_0 ! Call parameter: passkey
    ;
    ! meaning of "identified"
      if (t_0 ofclass K16_passkey) return (((((Prop_47(t_0))))));
    rfalse;
];
[ Adj_44_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "plural-named"
      if (t_0) return (GetEitherOrProperty(t_0, pluralname));
    rfalse;
];
[ Adj_45_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "singular-named"
      if (t_0) return (GetEitherOrProperty(t_0, pluralname) == false);
    rfalse;
];
[ Adj_46_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "proper-named"
      if (t_0) return (GetEitherOrProperty(t_0, proper));
    rfalse;
];
[ Adj_47_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "improper-named"
      if (t_0) return (GetEitherOrProperty(t_0, proper) == false);
    rfalse;
];
[ Adj_48_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "ambiguously plural"
      if (t_0) return (GetEitherOrProperty(t_0, ambigpluralname));
    rfalse;
];
[ Adj_49_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "privately-named"
      if (t_0) return (GetEitherOrProperty(t_0, privately_named));
    rfalse;
];
[ Adj_50_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "publicly-named"
      if (t_0) return (GetEitherOrProperty(t_0, privately_named) == false);
    rfalse;
];
[ Adj_51_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "lighted"
      if (t_0) return (GetEitherOrProperty(t_0, light));
    rfalse;
];
[ Adj_52_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "dark"
      if (t_0) return (GetEitherOrProperty(t_0, light) == false);
    rfalse;
];
[ Adj_53_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "visited"
      if (t_0) return (GetEitherOrProperty(t_0, visited));
    rfalse;
];
[ Adj_54_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unvisited"
      if (t_0) return (GetEitherOrProperty(t_0, visited) == false);
    rfalse;
];
[ Adj_55_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "lit"
      if (t_0) return (GetEitherOrProperty(t_0, light));
    rfalse;
];
[ Adj_56_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unlit"
      if (t_0) return (GetEitherOrProperty(t_0, light) == false);
    rfalse;
];
[ Adj_57_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "edible"
      if (t_0) return (GetEitherOrProperty(t_0, edible));
    rfalse;
];
[ Adj_58_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "inedible"
      if (t_0) return (GetEitherOrProperty(t_0, edible) == false);
    rfalse;
];
[ Adj_59_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "fixed in place"
      if (t_0) return (GetEitherOrProperty(t_0, static));
    rfalse;
];
[ Adj_60_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "portable"
      if (t_0) return (GetEitherOrProperty(t_0, static) == false);
    rfalse;
];
[ Adj_61_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "scenery"
      if (t_0) return (GetEitherOrProperty(t_0, scenery));
    rfalse;
];
[ Adj_62_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "wearable"
      if (t_0) return (GetEitherOrProperty(t_0, clothing));
    rfalse;
];
[ Adj_63_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "pushable between rooms"
      if (t_0) return (GetEitherOrProperty(t_0, pushable));
    rfalse;
];
[ Adj_64_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "handled"
      if (t_0) return (GetEitherOrProperty(t_0, moved));
    rfalse;
];
[ Adj_65_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "described"
      if (t_0) return (GetEitherOrProperty(t_0, concealed) == false);
    rfalse;
];
[ Adj_66_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "undescribed"
      if (t_0) return (GetEitherOrProperty(t_0, concealed));
    rfalse;
];
[ Adj_67_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "marked for listing"
      if (t_0) return (GetEitherOrProperty(t_0, workflag));
    rfalse;
];
[ Adj_68_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unmarked for listing"
      if (t_0) return (GetEitherOrProperty(t_0, workflag) == false);
    rfalse;
];
[ Adj_69_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "mentioned"
      if (t_0) return (GetEitherOrProperty(t_0, mentioned));
    rfalse;
];
[ Adj_70_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unmentioned"
      if (t_0) return (GetEitherOrProperty(t_0, mentioned) == false);
    rfalse;
];
[ Adj_71_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "enterable"
      if (t_0) return (GetEitherOrProperty(t_0, enterable));
    rfalse;
];
[ Adj_72_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "opaque"
      if (t_0) return (GetEitherOrProperty(t_0, transparent) == false);
    rfalse;
];
[ Adj_73_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "transparent"
      if (t_0) return (GetEitherOrProperty(t_0, transparent));
    rfalse;
];
[ Adj_74_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "open"
      if (t_0) return (GetEitherOrProperty(t_0, open));
    rfalse;
];
[ Adj_75_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "closed"
      if (t_0) return (GetEitherOrProperty(t_0, open) == false);
    rfalse;
];
[ Adj_76_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "openable"
      if (t_0) return (GetEitherOrProperty(t_0, openable));
    rfalse;
];
[ Adj_77_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unopenable"
      if (t_0) return (GetEitherOrProperty(t_0, openable) == false);
    rfalse;
];
[ Adj_78_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "lockable"
      if (t_0) return (GetEitherOrProperty(t_0, lockable));
    rfalse;
];
[ Adj_79_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "locked"
      if (t_0) return (GetEitherOrProperty(t_0, locked));
    rfalse;
];
[ Adj_80_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unlocked"
      if (t_0) return (GetEitherOrProperty(t_0, locked) == false);
    rfalse;
];
[ Adj_81_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "female"
      if (t_0) return (GetEitherOrProperty(t_0, female));
    rfalse;
];
[ Adj_82_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "male"
      if (t_0) return (GetEitherOrProperty(t_0, male));
    rfalse;
];
[ Adj_83_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "neuter"
      if (t_0) return (GetEitherOrProperty(t_0, neuter));
    rfalse;
];
[ Adj_84_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "switched on"
      if (t_0) return (GetEitherOrProperty(t_0, on));
    rfalse;
];
[ Adj_85_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "switched off"
      if (t_0) return (GetEitherOrProperty(t_0, on) == false);
    rfalse;
];
[ Adj_86_t1_v42 
    t_0 ! Call parameter: scene
    ;
    ! meaning of "recurring"
    return (GProperty(SCENE_TY, t_0, p58_recurring));
    rfalse;
];
[ Adj_87_t1_v42 
    t_0 ! Call parameter: scene
    ;
    ! meaning of "non-recurring"
    return (GProperty(SCENE_TY, t_0, p58_recurring) == false);
    rfalse;
];
[ Adj_88_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "ordinarily enumerated"
      if (t_0) return (GetEitherOrProperty(t_0, ambigpluralname) == false);
    rfalse;
];
[ Adj_89_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "masculine"
      if (t_0) return (GProperty(10, t_0, p62_gender) == 1);
    rfalse;
];
[ Adj_90_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "feminine"
      if (t_0) return (GProperty(10, t_0, p62_gender) == 2);
    rfalse;
];
[ Adj_91_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unknown"
      if (t_0) return (GProperty(10, t_0, p62_gender) == 3);
    rfalse;
];
[ Adj_92_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "distant"
      if (t_0) return (GetEitherOrProperty(t_0, p63_distant));
    rfalse;
];
[ Adj_93_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "near"
      if (t_0) return (GetEitherOrProperty(t_0, p63_distant) == false);
    rfalse;
];
[ Adj_94_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "cursed"
      if (t_0) return (GetEitherOrProperty(t_0, p65_cursed));
    rfalse;
];
[ Adj_95_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "uncursed"
      if (t_0) return (GetEitherOrProperty(t_0, p65_cursed) == false);
    rfalse;
];
[ Adj_96_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "indoors"
      if (t_0) return (GetEitherOrProperty(t_0, p67_indoors));
    rfalse;
];
[ Adj_97_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "outdoors"
      if (t_0) return (GetEitherOrProperty(t_0, p67_indoors) == false);
    rfalse;
];
[ Adj_98_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "explored"
      if (t_0) return (GetEitherOrProperty(t_0, p69_explored));
    rfalse;
];
[ Adj_99_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unexplored"
      if (t_0) return (GetEitherOrProperty(t_0, p69_explored) == false);
    rfalse;
];
[ Adj_100_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "<nameless>"
      if (t_0) return (GetEitherOrProperty(t_0, worn));
    rfalse;
];
[ Adj_101_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "<nameless>"
      if (t_0) return (GetEitherOrProperty(t_0, absent));
    rfalse;
];
[ Adj_102_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "<nameless>"
      if (t_0) return (GetEitherOrProperty(t_0, mark_as_room));
    rfalse;
];
[ Adj_103_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "<nameless>"
      if (t_0) return (GetEitherOrProperty(t_0, mark_as_thing));
    rfalse;
];
[ Adj_9_t2_v10 
    t_0 ! Call parameter: number
    ;
    ! meaning of "on-stage"
      if (t_0 ofclass K2_thing) return ((OnStage(t_0, true)));
    rfalse;
];
[ Adj_10_t2_v10 
    t_0 ! Call parameter: number
    ;
    ! meaning of "off-stage"
      if (t_0 ofclass K2_thing) return ((OnStage(t_0, false)));
    rfalse;
];
[ Adj_17_t2_v29 
    t_0 ! Call parameter: number
    ;
    ! meaning of "empty"
    return ((RELATION_TY_Empty(t_0, true)));
    rfalse;
];
[ Adj_18_t2_v29 
    t_0 ! Call parameter: number
    ;
    ! meaning of "non-empty"
    return ((RELATION_TY_Empty(t_0, false)));
    rfalse;
];
[ Adj_27_t2_v29 
    t_0 ! Call parameter: number
    ;
    ! meaning of "equivalence"
    return ((RELATION_TY_EquivalenceAdjective(t_0, true)));
    rfalse;
];
[ Adj_28_t2_v29 
    t_0 ! Call parameter: number
    ;
    ! meaning of "symmetric"
    return ((RELATION_TY_SymmetricAdjective(t_0, true)));
    rfalse;
];
[ Adj_29_t2_v29 
    t_0 ! Call parameter: number
    ;
    ! meaning of "one-to-one"
    return ((RELATION_TY_OToOAdjective(t_0, true)));
    rfalse;
];
[ Adj_30_t2_v29 
    t_0 ! Call parameter: number
    ;
    ! meaning of "one-to-various"
    return ((RELATION_TY_OToVAdjective(t_0, true)));
    rfalse;
];
[ Adj_31_t2_v29 
    t_0 ! Call parameter: number
    ;
    ! meaning of "various-to-one"
    return ((RELATION_TY_VToOAdjective(t_0, true)));
    rfalse;
];
[ Adj_32_t2_v29 
    t_0 ! Call parameter: number
    ;
    ! meaning of "various-to-various"
    return ((RELATION_TY_VToVAdjective(t_0, true)));
    rfalse;
];
[ Adj_44_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "plural-named"
      if (t_0) return (SetEitherOrProperty(t_0, pluralname));
    rfalse;
];
[ Adj_45_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "singular-named"
      if (t_0) return (SetEitherOrProperty(t_0, pluralname, true));
    rfalse;
];
[ Adj_46_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "proper-named"
      if (t_0) return (SetEitherOrProperty(t_0, proper));
    rfalse;
];
[ Adj_47_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "improper-named"
      if (t_0) return (SetEitherOrProperty(t_0, proper, true));
    rfalse;
];
[ Adj_48_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "ambiguously plural"
      if (t_0) return (SetEitherOrProperty(t_0, ambigpluralname));
    rfalse;
];
[ Adj_49_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "privately-named"
      if (t_0) return (SetEitherOrProperty(t_0, privately_named));
    rfalse;
];
[ Adj_50_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "publicly-named"
      if (t_0) return (SetEitherOrProperty(t_0, privately_named, true));
    rfalse;
];
[ Adj_51_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "lighted"
      if (t_0) return (SetEitherOrProperty(t_0, light));
    rfalse;
];
[ Adj_52_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "dark"
      if (t_0) return (SetEitherOrProperty(t_0, light, true));
    rfalse;
];
[ Adj_53_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "visited"
      if (t_0) return (SetEitherOrProperty(t_0, visited));
    rfalse;
];
[ Adj_54_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unvisited"
      if (t_0) return (SetEitherOrProperty(t_0, visited, true));
    rfalse;
];
[ Adj_55_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "lit"
      if (t_0) return (SetEitherOrProperty(t_0, light));
    rfalse;
];
[ Adj_56_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unlit"
      if (t_0) return (SetEitherOrProperty(t_0, light, true));
    rfalse;
];
[ Adj_57_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "edible"
      if (t_0) return (SetEitherOrProperty(t_0, edible));
    rfalse;
];
[ Adj_58_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "inedible"
      if (t_0) return (SetEitherOrProperty(t_0, edible, true));
    rfalse;
];
[ Adj_59_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "fixed in place"
      if (t_0) return (SetEitherOrProperty(t_0, static));
    rfalse;
];
[ Adj_60_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "portable"
      if (t_0) return (SetEitherOrProperty(t_0, static, true));
    rfalse;
];
[ Adj_61_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "scenery"
      if (t_0) return (SetEitherOrProperty(t_0, scenery));
    rfalse;
];
[ Adj_62_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "wearable"
      if (t_0) return (SetEitherOrProperty(t_0, clothing));
    rfalse;
];
[ Adj_63_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "pushable between rooms"
      if (t_0) return (SetEitherOrProperty(t_0, pushable));
    rfalse;
];
[ Adj_64_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "handled"
      if (t_0) return (SetEitherOrProperty(t_0, moved));
    rfalse;
];
[ Adj_65_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "described"
      if (t_0) return (SetEitherOrProperty(t_0, concealed, true));
    rfalse;
];
[ Adj_66_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "undescribed"
      if (t_0) return (SetEitherOrProperty(t_0, concealed));
    rfalse;
];
[ Adj_67_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "marked for listing"
      if (t_0) return (SetEitherOrProperty(t_0, workflag));
    rfalse;
];
[ Adj_68_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unmarked for listing"
      if (t_0) return (SetEitherOrProperty(t_0, workflag, true));
    rfalse;
];
[ Adj_69_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "mentioned"
      if (t_0) return (SetEitherOrProperty(t_0, mentioned));
    rfalse;
];
[ Adj_70_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unmentioned"
      if (t_0) return (SetEitherOrProperty(t_0, mentioned, true));
    rfalse;
];
[ Adj_71_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "enterable"
      if (t_0) return (SetEitherOrProperty(t_0, enterable));
    rfalse;
];
[ Adj_72_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "opaque"
      if (t_0) return (SetEitherOrProperty(t_0, transparent, true));
    rfalse;
];
[ Adj_73_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "transparent"
      if (t_0) return (SetEitherOrProperty(t_0, transparent));
    rfalse;
];
[ Adj_74_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "open"
      if (t_0) return (SetEitherOrProperty(t_0, open));
    rfalse;
];
[ Adj_75_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "closed"
      if (t_0) return (SetEitherOrProperty(t_0, open, true));
    rfalse;
];
[ Adj_76_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "openable"
      if (t_0) return (SetEitherOrProperty(t_0, openable));
    rfalse;
];
[ Adj_77_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unopenable"
      if (t_0) return (SetEitherOrProperty(t_0, openable, true));
    rfalse;
];
[ Adj_78_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "lockable"
      if (t_0) return (SetEitherOrProperty(t_0, lockable));
    rfalse;
];
[ Adj_79_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "locked"
      if (t_0) return (SetEitherOrProperty(t_0, locked));
    rfalse;
];
[ Adj_80_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unlocked"
      if (t_0) return (SetEitherOrProperty(t_0, locked, true));
    rfalse;
];
[ Adj_81_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "female"
      if (t_0) return (SetEitherOrProperty(t_0, female));
    rfalse;
];
[ Adj_82_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "male"
      if (t_0) return (SetEitherOrProperty(t_0, male));
    rfalse;
];
[ Adj_83_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "neuter"
      if (t_0) return (SetEitherOrProperty(t_0, neuter));
    rfalse;
];
[ Adj_84_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "switched on"
      if (t_0) return (SetEitherOrProperty(t_0, on));
    rfalse;
];
[ Adj_85_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "switched off"
      if (t_0) return (SetEitherOrProperty(t_0, on, true));
    rfalse;
];
[ Adj_86_t2_v42 
    t_0 ! Call parameter: scene
    ;
    ! meaning of "recurring"
    return (WriteGProperty(SCENE_TY, t_0, p58_recurring, true));
    rfalse;
];
[ Adj_87_t2_v42 
    t_0 ! Call parameter: scene
    ;
    ! meaning of "non-recurring"
    return (WriteGProperty(SCENE_TY, t_0, p58_recurring));
    rfalse;
];
[ Adj_88_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "ordinarily enumerated"
      if (t_0) return (SetEitherOrProperty(t_0, ambigpluralname, true));
    rfalse;
];
[ Adj_89_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "masculine"
      if (t_0) return (WriteGProperty(10, t_0, p62_gender, 1));
    rfalse;
];
[ Adj_90_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "feminine"
      if (t_0) return (WriteGProperty(10, t_0, p62_gender, 2));
    rfalse;
];
[ Adj_91_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unknown"
      if (t_0) return (WriteGProperty(10, t_0, p62_gender, 3));
    rfalse;
];
[ Adj_92_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "distant"
      if (t_0) return (SetEitherOrProperty(t_0, p63_distant));
    rfalse;
];
[ Adj_93_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "near"
      if (t_0) return (SetEitherOrProperty(t_0, p63_distant, true));
    rfalse;
];
[ Adj_94_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "cursed"
      if (t_0) return (SetEitherOrProperty(t_0, p65_cursed));
    rfalse;
];
[ Adj_95_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "uncursed"
      if (t_0) return (SetEitherOrProperty(t_0, p65_cursed, true));
    rfalse;
];
[ Adj_96_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "indoors"
      if (t_0) return (SetEitherOrProperty(t_0, p67_indoors));
    rfalse;
];
[ Adj_97_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "outdoors"
      if (t_0) return (SetEitherOrProperty(t_0, p67_indoors, true));
    rfalse;
];
[ Adj_98_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "explored"
      if (t_0) return (SetEitherOrProperty(t_0, p69_explored));
    rfalse;
];
[ Adj_99_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unexplored"
      if (t_0) return (SetEitherOrProperty(t_0, p69_explored, true));
    rfalse;
];
[ Adj_100_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "<nameless>"
      if (t_0) return (SetEitherOrProperty(t_0, worn));
    rfalse;
];
[ Adj_101_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "<nameless>"
      if (t_0) return (SetEitherOrProperty(t_0, absent));
    rfalse;
];
[ Adj_102_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "<nameless>"
      if (t_0) return (SetEitherOrProperty(t_0, mark_as_room));
    rfalse;
];
[ Adj_103_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "<nameless>"
      if (t_0) return (SetEitherOrProperty(t_0, mark_as_thing));
    rfalse;
];
[ Adj_9_t3_v10 
    t_0 ! Call parameter: number
    ;
    ! meaning of "on-stage"
      if (t_0 ofclass K2_thing) return ((OnStage(t_0, false)));
    rfalse;
];
[ Adj_10_t3_v10 
    t_0 ! Call parameter: number
    ;
    ! meaning of "off-stage"
      if (t_0 ofclass K2_thing) return ((OnStage(t_0, true)));
    rfalse;
];
[ Adj_17_t3_v29 
    t_0 ! Call parameter: number
    ;
    ! meaning of "empty"
    return ((RELATION_TY_Empty(t_0, false)));
    rfalse;
];
[ Adj_18_t3_v29 
    t_0 ! Call parameter: number
    ;
    ! meaning of "non-empty"
    return ((RELATION_TY_Empty(t_0, true)));
    rfalse;
];
[ Adj_27_t3_v29 
    t_0 ! Call parameter: number
    ;
    ! meaning of "equivalence"
    return ((RELATION_TY_EquivalenceAdjective(t_0, false)));
    rfalse;
];
[ Adj_28_t3_v29 
    t_0 ! Call parameter: number
    ;
    ! meaning of "symmetric"
    return ((RELATION_TY_SymmetricAdjective(t_0, false)));
    rfalse;
];
[ Adj_29_t3_v29 
    t_0 ! Call parameter: number
    ;
    ! meaning of "one-to-one"
    return ((RELATION_TY_OToOAdjective(t_0, false)));
    rfalse;
];
[ Adj_30_t3_v29 
    t_0 ! Call parameter: number
    ;
    ! meaning of "one-to-various"
    return ((RELATION_TY_OToVAdjective(t_0, false)));
    rfalse;
];
[ Adj_31_t3_v29 
    t_0 ! Call parameter: number
    ;
    ! meaning of "various-to-one"
    return ((RELATION_TY_VToOAdjective(t_0, false)));
    rfalse;
];
[ Adj_32_t3_v29 
    t_0 ! Call parameter: number
    ;
    ! meaning of "various-to-various"
    return ((RELATION_TY_VToVAdjective(t_0, false)));
    rfalse;
];
[ Adj_44_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "plural-named"
      if (t_0) return (SetEitherOrProperty(t_0, pluralname, true));
    rfalse;
];
[ Adj_45_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "singular-named"
      if (t_0) return (SetEitherOrProperty(t_0, pluralname));
    rfalse;
];
[ Adj_46_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "proper-named"
      if (t_0) return (SetEitherOrProperty(t_0, proper, true));
    rfalse;
];
[ Adj_47_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "improper-named"
      if (t_0) return (SetEitherOrProperty(t_0, proper));
    rfalse;
];
[ Adj_48_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "ambiguously plural"
      if (t_0) return (SetEitherOrProperty(t_0, ambigpluralname, true));
    rfalse;
];
[ Adj_49_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "privately-named"
      if (t_0) return (SetEitherOrProperty(t_0, privately_named, true));
    rfalse;
];
[ Adj_50_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "publicly-named"
      if (t_0) return (SetEitherOrProperty(t_0, privately_named));
    rfalse;
];
[ Adj_51_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "lighted"
      if (t_0) return (SetEitherOrProperty(t_0, light, true));
    rfalse;
];
[ Adj_52_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "dark"
      if (t_0) return (SetEitherOrProperty(t_0, light));
    rfalse;
];
[ Adj_53_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "visited"
      if (t_0) return (SetEitherOrProperty(t_0, visited, true));
    rfalse;
];
[ Adj_54_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unvisited"
      if (t_0) return (SetEitherOrProperty(t_0, visited));
    rfalse;
];
[ Adj_55_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "lit"
      if (t_0) return (SetEitherOrProperty(t_0, light, true));
    rfalse;
];
[ Adj_56_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unlit"
      if (t_0) return (SetEitherOrProperty(t_0, light));
    rfalse;
];
[ Adj_57_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "edible"
      if (t_0) return (SetEitherOrProperty(t_0, edible, true));
    rfalse;
];
[ Adj_58_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "inedible"
      if (t_0) return (SetEitherOrProperty(t_0, edible));
    rfalse;
];
[ Adj_59_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "fixed in place"
      if (t_0) return (SetEitherOrProperty(t_0, static, true));
    rfalse;
];
[ Adj_60_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "portable"
      if (t_0) return (SetEitherOrProperty(t_0, static));
    rfalse;
];
[ Adj_61_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "scenery"
      if (t_0) return (SetEitherOrProperty(t_0, scenery, true));
    rfalse;
];
[ Adj_62_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "wearable"
      if (t_0) return (SetEitherOrProperty(t_0, clothing, true));
    rfalse;
];
[ Adj_63_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "pushable between rooms"
      if (t_0) return (SetEitherOrProperty(t_0, pushable, true));
    rfalse;
];
[ Adj_64_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "handled"
      if (t_0) return (SetEitherOrProperty(t_0, moved, true));
    rfalse;
];
[ Adj_65_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "described"
      if (t_0) return (SetEitherOrProperty(t_0, concealed));
    rfalse;
];
[ Adj_66_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "undescribed"
      if (t_0) return (SetEitherOrProperty(t_0, concealed, true));
    rfalse;
];
[ Adj_67_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "marked for listing"
      if (t_0) return (SetEitherOrProperty(t_0, workflag, true));
    rfalse;
];
[ Adj_68_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unmarked for listing"
      if (t_0) return (SetEitherOrProperty(t_0, workflag));
    rfalse;
];
[ Adj_69_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "mentioned"
      if (t_0) return (SetEitherOrProperty(t_0, mentioned, true));
    rfalse;
];
[ Adj_70_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unmentioned"
      if (t_0) return (SetEitherOrProperty(t_0, mentioned));
    rfalse;
];
[ Adj_71_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "enterable"
      if (t_0) return (SetEitherOrProperty(t_0, enterable, true));
    rfalse;
];
[ Adj_72_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "opaque"
      if (t_0) return (SetEitherOrProperty(t_0, transparent));
    rfalse;
];
[ Adj_73_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "transparent"
      if (t_0) return (SetEitherOrProperty(t_0, transparent, true));
    rfalse;
];
[ Adj_74_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "open"
      if (t_0) return (SetEitherOrProperty(t_0, open, true));
    rfalse;
];
[ Adj_75_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "closed"
      if (t_0) return (SetEitherOrProperty(t_0, open));
    rfalse;
];
[ Adj_76_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "openable"
      if (t_0) return (SetEitherOrProperty(t_0, openable, true));
    rfalse;
];
[ Adj_77_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unopenable"
      if (t_0) return (SetEitherOrProperty(t_0, openable));
    rfalse;
];
[ Adj_78_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "lockable"
      if (t_0) return (SetEitherOrProperty(t_0, lockable, true));
    rfalse;
];
[ Adj_79_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "locked"
      if (t_0) return (SetEitherOrProperty(t_0, locked, true));
    rfalse;
];
[ Adj_80_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unlocked"
      if (t_0) return (SetEitherOrProperty(t_0, locked));
    rfalse;
];
[ Adj_81_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "female"
      if (t_0) return (SetEitherOrProperty(t_0, female, true));
    rfalse;
];
[ Adj_82_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "male"
      if (t_0) return (SetEitherOrProperty(t_0, male, true));
    rfalse;
];
[ Adj_83_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "neuter"
      if (t_0) return (SetEitherOrProperty(t_0, neuter, true));
    rfalse;
];
[ Adj_84_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "switched on"
      if (t_0) return (SetEitherOrProperty(t_0, on, true));
    rfalse;
];
[ Adj_85_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "switched off"
      if (t_0) return (SetEitherOrProperty(t_0, on));
    rfalse;
];
[ Adj_86_t3_v42 
    t_0 ! Call parameter: scene
    ;
    ! meaning of "recurring"
    return (WriteGProperty(SCENE_TY, t_0, p58_recurring));
    rfalse;
];
[ Adj_87_t3_v42 
    t_0 ! Call parameter: scene
    ;
    ! meaning of "non-recurring"
    return (WriteGProperty(SCENE_TY, t_0, p58_recurring, true));
    rfalse;
];
[ Adj_88_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "ordinarily enumerated"
      if (t_0) return (SetEitherOrProperty(t_0, ambigpluralname));
    rfalse;
];
[ Adj_92_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "distant"
      if (t_0) return (SetEitherOrProperty(t_0, p63_distant, true));
    rfalse;
];
[ Adj_93_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "near"
      if (t_0) return (SetEitherOrProperty(t_0, p63_distant));
    rfalse;
];
[ Adj_94_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "cursed"
      if (t_0) return (SetEitherOrProperty(t_0, p65_cursed, true));
    rfalse;
];
[ Adj_95_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "uncursed"
      if (t_0) return (SetEitherOrProperty(t_0, p65_cursed));
    rfalse;
];
[ Adj_96_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "indoors"
      if (t_0) return (SetEitherOrProperty(t_0, p67_indoors, true));
    rfalse;
];
[ Adj_97_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "outdoors"
      if (t_0) return (SetEitherOrProperty(t_0, p67_indoors));
    rfalse;
];
[ Adj_98_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "explored"
      if (t_0) return (SetEitherOrProperty(t_0, p69_explored, true));
    rfalse;
];
[ Adj_99_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unexplored"
      if (t_0) return (SetEitherOrProperty(t_0, p69_explored));
    rfalse;
];
[ Adj_100_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "<nameless>"
      if (t_0) return (SetEitherOrProperty(t_0, worn, true));
    rfalse;
];
[ Adj_101_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "<nameless>"
      if (t_0) return (SetEitherOrProperty(t_0, absent, true));
    rfalse;
];
[ Adj_102_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "<nameless>"
      if (t_0) return (SetEitherOrProperty(t_0, mark_as_room, true));
    rfalse;
];
[ Adj_103_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "<nameless>"
      if (t_0) return (SetEitherOrProperty(t_0, mark_as_thing, true));
    rfalse;
];



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Timed Events
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Array TimedEventsTable table 0 0;

Array TimedEventTimesTable table 0 0;



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Rulebooks
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


Array rulebooks_array --> B0_startup B1_turn_sequence B2_shutdown B3_scene_changing B4_when_play_begins B5_when_play_ends B6_when_scene_begins B7_when_scene_ends B8_every_turn B9_action_processing B10_setting_action_variables B11_specific_action_processi B12_player_s_action_awarenes B13_accessibility B14_reaching_inside B15_reaching_outside B16_visibility B17_persuasion B18_unsuccessful_attempt_by B19_before B20_instead B21_check B22_carry_out B23_after B24_report B25_does_the_player_mean B26_when_entire_game_begins B27_when_entire_game_ends B28_before_printing_the_name B29_for_printing_the_name B30_after_printing_the_name B31_before_printing_the_plur B32_for_printing_the_plural_ B33_after_printing_the_plura B34_before_printing_a_number B35_for_printing_a_number B36_after_printing_a_number B37_before_printing_room_des B38_for_printing_room_descri B39_after_printing_room_desc B40_before_printing_inventor B41_for_printing_inventory_d B42_after_printing_inventory B43_before_listing_contents B44_for_listing_contents B45_after_listing_contents B46_before_grouping_together B47_for_grouping_together B48_after_grouping_together B49_before_writing_a_paragra B50_for_writing_a_paragraph_ B51_after_writing_a_paragrap B52_before_listing_nondescri B53_for_listing_nondescript_ B54_after_listing_nondescrip B55_before_printing_the_name B56_for_printing_the_name_of B57_after_printing_the_name_ B58_before_printing_the_desc B59_for_printing_the_descrip B60_after_printing_the_descr B61_before_printing_the_anno B62_for_printing_the_announc B63_after_printing_the_annou B64_before_printing_the_anno B65_for_printing_the_announc B66_after_printing_the_annou B67_before_printing_a_refusa B68_for_printing_a_refusal_t B69_after_printing_a_refusal B70_before_constructing_the_ B71_for_constructing_the_sta B72_after_constructing_the_s B73_before_printing_the_bann B74_for_printing_the_banner_ B75_after_printing_the_banne B76_before_reading_a_command B77_for_reading_a_command B78_after_reading_a_command B79_before_deciding_the_scop B80_for_deciding_the_scope B81_after_deciding_the_scope B82_before_deciding_the_conc B83_for_deciding_the_conceal B84_after_deciding_the_conce B85_before_deciding_whether_ B86_for_deciding_whether_all B87_after_deciding_whether_a B88_before_clarifying_the_pa B89_for_clarifying_the_parse B90_after_clarifying_the_par B91_before_asking_which_do_y B92_for_asking_which_do_you_ B93_after_asking_which_do_yo B94_before_printing_a_parser B95_for_printing_a_parser_er B96_after_printing_a_parser_ B97_before_supplying_a_missi B98_for_supplying_a_missing_ B99_after_supplying_a_missin B100_before_supplying_a_miss B101_for_supplying_a_missing B102_after_supplying_a_missi B103_before_implicitly_takin B104_for_implicitly_taking B105_after_implicitly_taking B106_before_starting_the_vir B107_for_starting_the_virtua B108_after_starting_the_virt B109_before_amusing_a_victor B110_for_amusing_a_victoriou B111_after_amusing_a_victori B112_before_printing_the_pla B113_for_printing_the_player B114_after_printing_the_play B115_before_handling_the_fin B116_for_handling_the_final_ B117_after_handling_the_fina B118_before_printing_the_loc B119_for_printing_the_locale B120_after_printing_the_loca B121_before_choosing_notable B122_for_choosing_notable_lo B123_after_choosing_notable_ B124_before_printing_a_local B125_for_printing_a_locale_p B126_after_printing_a_locale B127_before_issuing_the_resp B128_for_issuing_the_respons B129_after_issuing_the_respo B130_check_taking_inventory B131_carry_out_taking_invent B132_report_taking_inventory B133_check_taking B134_carry_out_taking B135_report_taking B136_check_removing_it_from B137_carry_out_removing_it_f B138_report_removing_it_from B139_check_dropping B140_carry_out_dropping B141_report_dropping B142_check_putting_it_on B143_carry_out_putting_it_on B144_report_putting_it_on B145_check_inserting_it_into B146_carry_out_inserting_it_ B147_report_inserting_it_int B148_check_eating B149_carry_out_eating B150_report_eating B151_check_going B152_carry_out_going B153_report_going B154_check_entering B155_carry_out_entering B156_report_entering B157_check_exiting B158_carry_out_exiting B159_report_exiting B160_check_getting_off B161_carry_out_getting_off B162_report_getting_off B163_check_looking B164_carry_out_looking B165_report_looking B166_check_examining B167_carry_out_examining B168_report_examining B169_check_looking_under B170_carry_out_looking_under B171_report_looking_under B172_check_searching B173_carry_out_searching B174_report_searching B175_check_consulting_it_abo B176_carry_out_consulting_it B177_report_consulting_it_ab B178_check_locking_it_with B179_carry_out_locking_it_wi B180_report_locking_it_with B181_check_unlocking_it_with B182_carry_out_unlocking_it_ B183_report_unlocking_it_wit B184_check_switching_on B185_carry_out_switching_on B186_report_switching_on B187_check_switching_off B188_carry_out_switching_off B189_report_switching_off B190_check_opening B191_carry_out_opening B192_report_opening B193_check_closing B194_carry_out_closing B195_report_closing B196_check_wearing B197_carry_out_wearing B198_report_wearing B199_check_taking_off B200_carry_out_taking_off B201_report_taking_off B202_check_giving_it_to B203_carry_out_giving_it_to B204_report_giving_it_to B205_check_showing_it_to B206_carry_out_showing_it_to B207_report_showing_it_to B208_check_waking B209_carry_out_waking B210_report_waking B211_check_throwing_it_at B212_carry_out_throwing_it_a B213_report_throwing_it_at B214_check_attacking B215_carry_out_attacking B216_report_attacking B217_check_kissing B218_carry_out_kissing B219_report_kissing B220_check_answering_it_that B221_carry_out_answering_it_ B222_report_answering_it_tha B223_check_telling_it_about B224_carry_out_telling_it_ab B225_report_telling_it_about B226_check_asking_it_about B227_carry_out_asking_it_abo B228_report_asking_it_about B229_check_asking_it_for B230_carry_out_asking_it_for B231_report_asking_it_for B232_check_waiting B233_carry_out_waiting B234_report_waiting B235_check_touching B236_carry_out_touching B237_report_touching B238_check_waving B239_carry_out_waving B240_report_waving B241_check_pulling B242_carry_out_pulling B243_report_pulling B244_check_pushing B245_carry_out_pushing B246_report_pushing B247_check_turning B248_carry_out_turning B249_report_turning B250_check_pushing_it_to B251_carry_out_pushing_it_to B252_report_pushing_it_to B253_check_squeezing B254_carry_out_squeezing B255_report_squeezing B256_check_saying_yes B257_carry_out_saying_yes B258_report_saying_yes B259_check_saying_no B260_carry_out_saying_no B261_report_saying_no B262_check_burning B263_carry_out_burning B264_report_burning B265_check_waking_up B266_carry_out_waking_up B267_report_waking_up B268_check_thinking B269_carry_out_thinking B270_report_thinking B271_check_smelling B272_carry_out_smelling B273_report_smelling B274_check_listening_to B275_carry_out_listening_to B276_report_listening_to B277_check_tasting B278_carry_out_tasting B279_report_tasting B280_check_cutting B281_carry_out_cutting B282_report_cutting B283_check_jumping B284_carry_out_jumping B285_report_jumping B286_check_tying_it_to B287_carry_out_tying_it_to B288_report_tying_it_to B289_check_drinking B290_carry_out_drinking B291_report_drinking B292_check_saying_sorry B293_carry_out_saying_sorry B294_report_saying_sorry B295_check_swinging B296_carry_out_swinging B297_report_swinging B298_check_rubbing B299_carry_out_rubbing B300_report_rubbing B301_check_setting_it_to B302_carry_out_setting_it_to B303_report_setting_it_to B304_check_waving_hands B305_carry_out_waving_hands B306_report_waving_hands B307_check_buying B308_carry_out_buying B309_report_buying B310_check_climbing B311_carry_out_climbing B312_report_climbing B313_check_sleeping B314_carry_out_sleeping B315_report_sleeping B316_check_quitting_the_game B317_carry_out_quitting_the_ B318_report_quitting_the_gam B319_check_saving_the_game B320_carry_out_saving_the_ga B321_report_saving_the_game B322_check_restoring_the_gam B323_carry_out_restoring_the B324_report_restoring_the_ga B325_check_restarting_the_ga B326_carry_out_restarting_th B327_report_restarting_the_g B328_check_verifying_the_sto B329_carry_out_verifying_the B330_report_verifying_the_st B331_check_switching_the_sto B332_carry_out_switching_the B333_report_switching_the_st B334_check_switching_the_sto B335_carry_out_switching_the B336_report_switching_the_st B337_check_requesting_the_st B338_carry_out_requesting_th B339_report_requesting_the_s B340_check_requesting_the_sc B341_carry_out_requesting_th B342_report_requesting_the_s B343_check_preferring_abbrev B344_carry_out_preferring_ab B345_report_preferring_abbre B346_check_preferring_unabbr B347_carry_out_preferring_un B348_report_preferring_unabb B349_check_preferring_someti B350_carry_out_preferring_so B351_report_preferring_somet B352_check_switching_score_n B353_carry_out_switching_sco B354_report_switching_score_ B355_check_switching_score_n B356_carry_out_switching_sco B357_report_switching_score_ B358_check_requesting_the_pr B359_carry_out_requesting_th B360_report_requesting_the_p B361_before_refusing_keys B362_for_refusing_keys B363_after_refusing_keys B364_check_unlocking_keyless B365_carry_out_unlocking_key B366_report_unlocking_keyles B367_check_locking_keylessly B368_carry_out_locking_keyle B369_report_locking_keylessl B370_before_displaying B371_for_displaying B372_after_displaying B373_before_pausing_the_game B374_for_pausing_the_game B375_after_pausing_the_game B376_check_reading B377_carry_out_reading B378_report_reading B379_when_chooseyourdestiny_ B380_when_chooseyourdestiny_ B381_when_gazelletransformat B382_when_gazelletransformat B383_when_gagglebecomesherd_ B384_when_gagglebecomesherd_ B385_when_newscast_begins B386_when_newscast_ends B387_when_joining_the_zoo_be B388_when_joining_the_zoo_en B389_when_genieinabottle_beg B390_when_genieinabottle_end B391_when_exploring_your_off B392_when_exploring_your_off B393_when_jerked_begins B394_when_jerked_ends B395_when_supplyshopevent_be B396_when_supplyshopevent_en B397_when_here_girl_begins B398_when_here_girl_ends B399_when_sizeincrease_begin B400_when_sizeincrease_ends B401_when_dontcroak_begins B402_when_dontcroak_ends B403_when_maretf_begins B404_when_maretf_ends B405_when_swineoption_begins B406_when_swineoption_ends 0;

[ EMPTY_RULEBOOK 
    forbid_breaks ! Implied call parameter
    ;
    rfalse;
];
[ B0_startup 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = INITIALISE_MEMORY_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return INITIALISE_MEMORY_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = VIRTUAL_MACHINE_STARTUP_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return VIRTUAL_MACHINE_STARTUP_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = SEED_RANDOM_NUMBER_GENERATOR_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return SEED_RANDOM_NUMBER_GENERATOR_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = UPDATE_CHRONOLOGICAL_RECORDS_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return UPDATE_CHRONOLOGICAL_RECORDS_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_9();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_9;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = POSITION_PLAYER_IN_MODEL_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return POSITION_PLAYER_IN_MODEL_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_10();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_10;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_11();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_11;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_12();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_12;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_13();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_13;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_14();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_14;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 11 rule(s)
];
[ B1_turn_sequence 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = PARSE_COMMAND_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return PARSE_COMMAND_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_9();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_9;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = GENERATE_ACTION_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return GENERATE_ACTION_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_16();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_16;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_15();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_15;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = TIMED_EVENTS_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return TIMED_EVENTS_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = ADVANCE_TIME_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return ADVANCE_TIME_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = UPDATE_CHRONOLOGICAL_RECORDS_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return UPDATE_CHRONOLOGICAL_RECORDS_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_17();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_17;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = ADJUST_LIGHT_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return ADJUST_LIGHT_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = NOTE_OBJECT_ACQUISITIONS_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return NOTE_OBJECT_ACQUISITIONS_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_18();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_18;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 12 rule(s)
];
[ B2_shutdown 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_19();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_19;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = RESURRECT_PLAYER_IF_ASKED_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return RESURRECT_PLAYER_IF_ASKED_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_20();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_20;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = ASK_FINAL_QUESTION_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return ASK_FINAL_QUESTION_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 4 rule(s)
];
[ B3_scene_changing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = DetectSceneChange();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return DetectSceneChange;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B4_when_play_begins 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_935();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_935;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B5_when_play_ends = EMPTY_RULEBOOK;
[ B6_when_scene_begins 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_65();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_65;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B7_when_scene_ends = EMPTY_RULEBOOK;
[ B8_every_turn 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_939();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_939;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_959();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_959;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_962();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_962;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_965();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_965;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_976();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_976;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_978();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_978;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_887();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_887;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 7 rule(s)
];
[ B9_action_processing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_22();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_22;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_21();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_21;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_23();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_23;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = BASIC_VISIBILITY_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return BASIC_VISIBILITY_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = BASIC_ACCESSIBILITY_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return BASIC_ACCESSIBILITY_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_838();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_838;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_24();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_24;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = REQUESTED_ACTIONS_REQUIRE_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return REQUESTED_ACTIONS_REQUIRE_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = CARRY_OUT_REQUESTED_ACTIONS_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return CARRY_OUT_REQUESTED_ACTIONS_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = DESCEND_TO_SPECIFIC_ACTION_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return DESCEND_TO_SPECIFIC_ACTION_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_25();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_25;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 11 rule(s)
];
[ B10_setting_action_variables 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    if (action == ##Go) {
        rv = R_149();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_149;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Exit) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_172();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_172;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Look) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_184();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_184;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    return 0; ! 3 rule(s)
];
[ B11_specific_action_processi 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = WORK_OUT_DETAILS_OF_SPECIFIC_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return WORK_OUT_DETAILS_OF_SPECIFIC_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_26();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_26;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_27();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_27;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_28();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_28;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_29();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_29;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_30();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_30;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_31();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_31;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_32();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_32;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 8 rule(s)
];
[ B12_player_s_action_awarenes 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_33();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_33;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_34();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_34;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_35();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_35;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_36();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_36;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 4 rule(s)
];
[ B13_accessibility 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = ACCESS_THROUGH_BARRIERS_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return ACCESS_THROUGH_BARRIERS_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B14_reaching_inside 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    p ! rulebook parameter
    ;
    original_deadflag = deadflag;
    p = parameter_value;
    parameter_value = p;
    rv = CANT_REACH_INSIDE_ROOMS_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return CANT_REACH_INSIDE_ROOMS_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = CANT_REACH_INSIDE_CLOSED_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return CANT_REACH_INSIDE_CLOSED_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
[ B15_reaching_outside 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = CANT_REACH_OUTSIDE_CLOSED_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return CANT_REACH_OUTSIDE_CLOSED_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B16_visibility 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_37();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_37;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B17_persuasion = EMPTY_RULEBOOK;
Constant B18_unsuccessful_attempt_by = EMPTY_RULEBOOK;
[ B19_before 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    if (action == ##Go) {
        rv = R_815();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_815;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Open) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_953();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_953;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Go) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_811();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_811;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Lock) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_816();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_816;
        }
        latest_rule_result-->0 = 0;
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_812();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_812;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##A78_locking_keylessly) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_817();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_817;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Open) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_818();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_818;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##A78_locking_keylessly) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_813();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_813;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Open) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_814();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_814;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    return 0; ! 9 rule(s)
];
[ B20_instead 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    if (action == ##Open) {
        rv = R_954();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_954;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##LookUnder) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_955();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_955;
        }
        latest_rule_result-->0 = 0;
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_956();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_956;
        }
        latest_rule_result-->0 = 0;
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_957();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_957;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Search) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_958();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_958;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Examine) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_937();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_937;
        }
        latest_rule_result-->0 = 0;
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_938();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_938;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Insert) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_943();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_943;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##PutOn) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_837();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_837;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Take) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_964();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_964;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Enter) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_967();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_967;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Search) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_949();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_949;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    return 0; ! 12 rule(s)
];
Constant B21_check = EMPTY_RULEBOOK;
Constant B22_carry_out = EMPTY_RULEBOOK;
[ B23_after 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    if (action == ##Examine) {
        rv = R_948();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_948;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Open) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_951();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_951;
        }
        latest_rule_result-->0 = 0;
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_950();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_950;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Examine) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_973();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_973;
        }
        latest_rule_result-->0 = 0;
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_832();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_832;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Close) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_952();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_952;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Look) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_810();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_810;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    return 0; ! 7 rule(s)
];
Constant B24_report = EMPTY_RULEBOOK;
[ B25_does_the_player_mean 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    if (action == ##Take) {
        rv = R_38();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_38;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Disrobe) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_240();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_240;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    return 0; ! 2 rule(s)
];
Constant B26_when_entire_game_begins = EMPTY_RULEBOOK;
Constant B27_when_entire_game_ends = EMPTY_RULEBOOK;
[ B28_before_printing_the_name 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_66();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_66;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B29_for_printing_the_name 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = STANDARD_NAME_PRINTING_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return STANDARD_NAME_PRINTING_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B30_after_printing_the_name 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    p ! rulebook parameter
    ;
    original_deadflag = deadflag;
    p = parameter_value;
    parameter_value = p;
    rv = R_831();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_831;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_888();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_888;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_846();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_846;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 3 rule(s)
];
Constant B31_before_printing_the_plur = EMPTY_RULEBOOK;
[ B32_for_printing_the_plural_ 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_67();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_67;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B33_after_printing_the_plura = EMPTY_RULEBOOK;
Constant B34_before_printing_a_number = EMPTY_RULEBOOK;
[ B35_for_printing_a_number 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_68();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_68;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B36_after_printing_a_number = EMPTY_RULEBOOK;
Constant B37_before_printing_room_des = EMPTY_RULEBOOK;
Constant B38_for_printing_room_descri = EMPTY_RULEBOOK;
Constant B39_after_printing_room_desc = EMPTY_RULEBOOK;
Constant B40_before_printing_inventor = EMPTY_RULEBOOK;
Constant B41_for_printing_inventory_d = EMPTY_RULEBOOK;
Constant B42_after_printing_inventory = EMPTY_RULEBOOK;
Constant B43_before_listing_contents = EMPTY_RULEBOOK;
[ B44_for_listing_contents 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = STANDARD_CONTENTS_LISTING_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return STANDARD_CONTENTS_LISTING_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B45_after_listing_contents = EMPTY_RULEBOOK;
Constant B46_before_grouping_together = EMPTY_RULEBOOK;
Constant B47_for_grouping_together = EMPTY_RULEBOOK;
Constant B48_after_grouping_together = EMPTY_RULEBOOK;
Constant B49_before_writing_a_paragra = EMPTY_RULEBOOK;
Constant B50_for_writing_a_paragraph_ = EMPTY_RULEBOOK;
Constant B51_after_writing_a_paragrap = EMPTY_RULEBOOK;
Constant B52_before_listing_nondescri = EMPTY_RULEBOOK;
Constant B53_for_listing_nondescript_ = EMPTY_RULEBOOK;
Constant B54_after_listing_nondescrip = EMPTY_RULEBOOK;
Constant B55_before_printing_the_name = EMPTY_RULEBOOK;
Constant B56_for_printing_the_name_of = EMPTY_RULEBOOK;
Constant B57_after_printing_the_name_ = EMPTY_RULEBOOK;
Constant B58_before_printing_the_desc = EMPTY_RULEBOOK;
Constant B59_for_printing_the_descrip = EMPTY_RULEBOOK;
Constant B60_after_printing_the_descr = EMPTY_RULEBOOK;
Constant B61_before_printing_the_anno = EMPTY_RULEBOOK;
Constant B62_for_printing_the_announc = EMPTY_RULEBOOK;
Constant B63_after_printing_the_annou = EMPTY_RULEBOOK;
Constant B64_before_printing_the_anno = EMPTY_RULEBOOK;
[ B65_for_printing_the_announc 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_69();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_69;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B66_after_printing_the_annou = EMPTY_RULEBOOK;
Constant B67_before_printing_a_refusa = EMPTY_RULEBOOK;
Constant B68_for_printing_a_refusal_t = EMPTY_RULEBOOK;
Constant B69_after_printing_a_refusal = EMPTY_RULEBOOK;
Constant B70_before_constructing_the_ = EMPTY_RULEBOOK;
[ B71_for_constructing_the_sta 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_900();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_900;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B72_after_constructing_the_s = EMPTY_RULEBOOK;
Constant B73_before_printing_the_bann = EMPTY_RULEBOOK;
[ B74_for_printing_the_banner_ 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_942();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_942;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B75_after_printing_the_banne = EMPTY_RULEBOOK;
Constant B76_before_reading_a_command = EMPTY_RULEBOOK;
Constant B77_for_reading_a_command = EMPTY_RULEBOOK;
[ B78_after_reading_a_command 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    p ! rulebook parameter
    ;
    original_deadflag = deadflag;
    p = parameter_value;
    parameter_value = p;
    rv = R_936();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_936;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_974();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_974;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_975();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_975;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 3 rule(s)
];
Constant B79_before_deciding_the_scop = EMPTY_RULEBOOK;
Constant B80_for_deciding_the_scope = EMPTY_RULEBOOK;
Constant B81_after_deciding_the_scope = EMPTY_RULEBOOK;
Constant B82_before_deciding_the_conc = EMPTY_RULEBOOK;
Constant B83_for_deciding_the_conceal = EMPTY_RULEBOOK;
Constant B84_after_deciding_the_conce = EMPTY_RULEBOOK;
Constant B85_before_deciding_whether_ = EMPTY_RULEBOOK;
[ B86_for_deciding_whether_all 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    p ! rulebook parameter
    ;
    original_deadflag = deadflag;
    p = parameter_value;
    parameter_value = p;
    rv = R_73();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_73;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_70();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_70;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_72();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_72;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_71();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_71;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_839();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_839;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 5 rule(s)
];
Constant B87_after_deciding_whether_a = EMPTY_RULEBOOK;
Constant B88_before_clarifying_the_pa = EMPTY_RULEBOOK;
Constant B89_for_clarifying_the_parse = EMPTY_RULEBOOK;
Constant B90_after_clarifying_the_par = EMPTY_RULEBOOK;
Constant B91_before_asking_which_do_y = EMPTY_RULEBOOK;
Constant B92_for_asking_which_do_you_ = EMPTY_RULEBOOK;
Constant B93_after_asking_which_do_yo = EMPTY_RULEBOOK;
Constant B94_before_printing_a_parser = EMPTY_RULEBOOK;
Constant B95_for_printing_a_parser_er = EMPTY_RULEBOOK;
Constant B96_after_printing_a_parser_ = EMPTY_RULEBOOK;
Constant B97_before_supplying_a_missi = EMPTY_RULEBOOK;
[ B98_for_supplying_a_missing_ 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    p ! rulebook parameter
    ;
    original_deadflag = deadflag;
    p = parameter_value;
    parameter_value = p;
    rv = R_74();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_74;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_75();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_75;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_76();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_76;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_160();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_160;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 4 rule(s)
];
Constant B99_after_supplying_a_missin = EMPTY_RULEBOOK;
Constant B100_before_supplying_a_miss = EMPTY_RULEBOOK;
Constant B101_for_supplying_a_missing = EMPTY_RULEBOOK;
Constant B102_after_supplying_a_missi = EMPTY_RULEBOOK;
Constant B103_before_implicitly_takin = EMPTY_RULEBOOK;
[ B104_for_implicitly_taking 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = STANDARD_IMPLICIT_TAKING_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return STANDARD_IMPLICIT_TAKING_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B105_after_implicitly_taking = EMPTY_RULEBOOK;
Constant B106_before_starting_the_vir = EMPTY_RULEBOOK;
[ B107_for_starting_the_virtua 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = ENABLE_GLULX_ACCEL_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return ENABLE_GLULX_ACCEL_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B108_after_starting_the_virt = EMPTY_RULEBOOK;
Constant B109_before_amusing_a_victor = EMPTY_RULEBOOK;
Constant B110_for_amusing_a_victoriou = EMPTY_RULEBOOK;
Constant B111_after_amusing_a_victori = EMPTY_RULEBOOK;
Constant B112_before_printing_the_pla = EMPTY_RULEBOOK;
[ B113_for_printing_the_player 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    p ! rulebook parameter
    ;
    original_deadflag = deadflag;
    p = parameter_value;
    parameter_value = p;
    rv = PRINT_OBITUARY_HEADLINE_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return PRINT_OBITUARY_HEADLINE_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = PRINT_FINAL_SCORE_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return PRINT_FINAL_SCORE_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = DISPLAY_FINAL_STATUS_LINE_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return DISPLAY_FINAL_STATUS_LINE_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 3 rule(s)
];
Constant B114_after_printing_the_play = EMPTY_RULEBOOK;
[ B115_before_handling_the_fin 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    p ! rulebook parameter
    ;
    original_deadflag = deadflag;
    p = parameter_value;
    parameter_value = p;
    rv = R_78();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_78;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_77();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_77;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = READ_FINAL_ANSWER_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return READ_FINAL_ANSWER_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 3 rule(s)
];
[ B116_for_handling_the_final_ 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_79();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_79;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B117_after_handling_the_fina = EMPTY_RULEBOOK;
[ B118_before_printing_the_loc 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    p ! rulebook parameter
    ;
    original_deadflag = deadflag;
    p = parameter_value;
    parameter_value = p;
    rv = R_82();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_82;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_83();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_83;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
[ B119_for_printing_the_locale 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    p ! rulebook parameter
    ;
    original_deadflag = deadflag;
    p = parameter_value;
    parameter_value = p;
    rv = R_84();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_84;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_85();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_85;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
Constant B120_after_printing_the_loca = EMPTY_RULEBOOK;
Constant B121_before_choosing_notable = EMPTY_RULEBOOK;
[ B122_for_choosing_notable_lo 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_86();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_86;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B123_after_choosing_notable_ = EMPTY_RULEBOOK;
Constant B124_before_printing_a_local = EMPTY_RULEBOOK;
[ B125_for_printing_a_locale_p 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    p ! rulebook parameter
    ;
    original_deadflag = deadflag;
    p = parameter_value;
    parameter_value = p;
    rv = R_93();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_93;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_87();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_87;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_88();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_88;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_89();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_89;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_90();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_90;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_91();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_91;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_92();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_92;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_95();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_95;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 8 rule(s)
];
Constant B126_after_printing_a_locale = EMPTY_RULEBOOK;
Constant B127_before_issuing_the_resp = EMPTY_RULEBOOK;
[ B128_for_issuing_the_respons 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = STANDARD_RESPONSE_ISSUING_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return STANDARD_RESPONSE_ISSUING_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B129_after_issuing_the_respo = EMPTY_RULEBOOK;
Constant B130_check_taking_inventory = EMPTY_RULEBOOK;
[ B131_carry_out_taking_invent 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_96();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_96;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_97();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_97;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
[ B132_report_taking_inventory 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_98();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_98;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B133_check_taking 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_99();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_99;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_100();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_100;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_101();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_101;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_102();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_102;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_103();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_103;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_104();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_104;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_105();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_105;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_106();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_106;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_107();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_107;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_108();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_108;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_109();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_109;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_110();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_110;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 12 rule(s)
];
[ B134_carry_out_taking 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_111();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_111;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B135_report_taking 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_112();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_112;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B136_check_removing_it_from 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_101();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_101;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_113();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_113;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_114();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_114;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_115();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_115;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 4 rule(s)
];
Constant B137_carry_out_removing_it_f = EMPTY_RULEBOOK;
Constant B138_report_removing_it_from = EMPTY_RULEBOOK;
[ B139_check_dropping 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_117();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_117;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_116();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_116;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_118();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_118;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_119();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_119;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_120();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_120;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_121();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_121;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 6 rule(s)
];
[ B140_carry_out_dropping 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_122();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_122;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B141_report_dropping 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_123();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_123;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B142_check_putting_it_on 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_124();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_124;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_125();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_125;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_126();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_126;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_127();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_127;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_128();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_128;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_129();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_129;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 6 rule(s)
];
[ B143_carry_out_putting_it_on 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_130();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_130;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B144_report_putting_it_on 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_131();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_131;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_132();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_132;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
[ B145_check_inserting_it_into 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_133();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_133;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_134();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_134;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_135();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_135;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_136();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_136;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_137();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_137;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_138();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_138;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_139();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_139;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 7 rule(s)
];
[ B146_carry_out_inserting_it_ 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_140();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_140;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B147_report_inserting_it_int 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_141();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_141;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_142();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_142;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
[ B148_check_eating 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_143();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_143;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_144();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_144;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_145();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_145;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_146();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_146;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 4 rule(s)
];
[ B149_carry_out_eating 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_147();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_147;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B150_report_eating 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_148();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_148;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B151_check_going 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_150();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_150;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_151();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_151;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_152();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_152;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_153();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_153;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_154();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_154;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_155();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_155;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 6 rule(s)
];
[ B152_carry_out_going 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_156();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_156;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_157();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_157;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_158();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_158;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 3 rule(s)
];
[ B153_report_going 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_159();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_159;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B154_check_entering 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_161();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_161;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_162();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_162;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_163();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_163;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_164();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_164;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_165();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_165;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_166();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_166;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_167();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_167;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_168();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_168;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 8 rule(s)
];
[ B155_carry_out_entering 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_169();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_169;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B156_report_entering 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_170();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_170;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_171();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_171;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
[ B157_check_exiting 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_173();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_173;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_174();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_174;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_175();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_175;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_176();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_176;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 4 rule(s)
];
[ B158_carry_out_exiting 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_177();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_177;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B159_report_exiting 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_178();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_178;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_179();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_179;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
[ B160_check_getting_off 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_180();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_180;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B161_carry_out_getting_off 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_181();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_181;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B162_report_getting_off 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_182();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_182;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_183();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_183;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
Constant B163_check_looking = EMPTY_RULEBOOK;
[ B164_carry_out_looking 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_185();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_185;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_186();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_186;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_187();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_187;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_188();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_188;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_189();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_189;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 5 rule(s)
];
[ B165_report_looking 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_190();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_190;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B166_check_examining = EMPTY_RULEBOOK;
[ B167_carry_out_examining 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_191();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_191;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_192();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_192;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_193();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_193;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_194();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_194;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_195();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_195;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_196();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_196;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 6 rule(s)
];
[ B168_report_examining 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_197();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_197;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B169_check_looking_under = EMPTY_RULEBOOK;
[ B170_carry_out_looking_under 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_198();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_198;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B171_report_looking_under 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_199();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_199;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B172_check_searching 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_200();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_200;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_201();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_201;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
Constant B173_carry_out_searching = EMPTY_RULEBOOK;
[ B174_report_searching 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_202();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_202;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_203();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_203;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_204();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_204;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 3 rule(s)
];
Constant B175_check_consulting_it_abo = EMPTY_RULEBOOK;
Constant B176_carry_out_consulting_it = EMPTY_RULEBOOK;
[ B177_report_consulting_it_ab 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_205();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_205;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B178_check_locking_it_with 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_206();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_206;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_207();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_207;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_208();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_208;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_824();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_824;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_827();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_827;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 5 rule(s)
];
[ B179_carry_out_locking_it_wi 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_835();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_835;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_210();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_210;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
[ B180_report_locking_it_with 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_836();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_836;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_211();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_211;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
[ B181_check_unlocking_it_with 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_212();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_212;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_213();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_213;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_824();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_824;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_823();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_823;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 4 rule(s)
];
[ B182_carry_out_unlocking_it_ 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_833();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_833;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_215();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_215;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
[ B183_report_unlocking_it_wit 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_834();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_834;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_216();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_216;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
[ B184_check_switching_on 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_217();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_217;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_218();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_218;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
[ B185_carry_out_switching_on 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_219();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_219;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B186_report_switching_on 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_220();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_220;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B187_check_switching_off 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_221();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_221;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_222();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_222;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
[ B188_carry_out_switching_off 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_223();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_223;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B189_report_switching_off 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_224();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_224;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B190_check_opening 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_225();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_225;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_226();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_226;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_227();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_227;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 3 rule(s)
];
[ B191_carry_out_opening 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_228();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_228;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B192_report_opening 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_229();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_229;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_230();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_230;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
[ B193_check_closing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_231();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_231;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_232();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_232;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
[ B194_carry_out_closing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_233();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_233;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B195_report_closing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_234();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_234;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B196_check_wearing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_235();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_235;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_236();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_236;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_237();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_237;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 3 rule(s)
];
[ B197_carry_out_wearing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_238();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_238;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B198_report_wearing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_239();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_239;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B199_check_taking_off 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_241();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_241;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_242();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_242;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
[ B200_carry_out_taking_off 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_243();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_243;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B201_report_taking_off 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_244();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_244;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B202_check_giving_it_to 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_245();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_245;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_246();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_246;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_247();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_247;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_248();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_248;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_249();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_249;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_250();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_250;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 6 rule(s)
];
[ B203_carry_out_giving_it_to 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_251();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_251;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B204_report_giving_it_to 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_252();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_252;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B205_check_showing_it_to 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_253();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_253;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_254();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_254;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_255();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_255;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 3 rule(s)
];
Constant B206_carry_out_showing_it_to = EMPTY_RULEBOOK;
Constant B207_report_showing_it_to = EMPTY_RULEBOOK;
[ B208_check_waking 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_256();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_256;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B209_carry_out_waking = EMPTY_RULEBOOK;
Constant B210_report_waking = EMPTY_RULEBOOK;
[ B211_check_throwing_it_at 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_257();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_257;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_258();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_258;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_259();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_259;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 3 rule(s)
];
Constant B212_carry_out_throwing_it_a = EMPTY_RULEBOOK;
Constant B213_report_throwing_it_at = EMPTY_RULEBOOK;
[ B214_check_attacking 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_260();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_260;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B215_carry_out_attacking = EMPTY_RULEBOOK;
Constant B216_report_attacking = EMPTY_RULEBOOK;
[ B217_check_kissing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_261();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_261;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_262();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_262;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
Constant B218_carry_out_kissing = EMPTY_RULEBOOK;
Constant B219_report_kissing = EMPTY_RULEBOOK;
Constant B220_check_answering_it_that = EMPTY_RULEBOOK;
Constant B221_carry_out_answering_it_ = EMPTY_RULEBOOK;
[ B222_report_answering_it_tha 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_263();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_263;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B223_check_telling_it_about 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_264();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_264;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B224_carry_out_telling_it_ab = EMPTY_RULEBOOK;
[ B225_report_telling_it_about 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_265();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_265;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B226_check_asking_it_about = EMPTY_RULEBOOK;
Constant B227_carry_out_asking_it_abo = EMPTY_RULEBOOK;
[ B228_report_asking_it_about 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_266();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_266;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B229_check_asking_it_for 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_267();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_267;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_268();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_268;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
Constant B230_carry_out_asking_it_for = EMPTY_RULEBOOK;
Constant B231_report_asking_it_for = EMPTY_RULEBOOK;
Constant B232_check_waiting = EMPTY_RULEBOOK;
Constant B233_carry_out_waiting = EMPTY_RULEBOOK;
[ B234_report_waiting 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_269();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_269;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B235_check_touching = EMPTY_RULEBOOK;
Constant B236_carry_out_touching = EMPTY_RULEBOOK;
[ B237_report_touching 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_270();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_270;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_271();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_271;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_272();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_272;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 3 rule(s)
];
[ B238_check_waving 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_273();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_273;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B239_carry_out_waving = EMPTY_RULEBOOK;
[ B240_report_waving 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_274();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_274;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B241_check_pulling 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_275();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_275;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_276();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_276;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_277();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_277;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 3 rule(s)
];
Constant B242_carry_out_pulling = EMPTY_RULEBOOK;
[ B243_report_pulling 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_278();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_278;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B244_check_pushing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_279();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_279;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_280();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_280;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_281();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_281;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 3 rule(s)
];
Constant B245_carry_out_pushing = EMPTY_RULEBOOK;
[ B246_report_pushing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_282();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_282;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B247_check_turning 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_283();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_283;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_284();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_284;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_285();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_285;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 3 rule(s)
];
Constant B248_carry_out_turning = EMPTY_RULEBOOK;
[ B249_report_turning 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_286();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_286;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B250_check_pushing_it_to 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_287();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_287;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_288();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_288;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_289();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_289;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_290();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_290;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_291();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_291;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_292();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_292;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 6 rule(s)
];
Constant B251_carry_out_pushing_it_to = EMPTY_RULEBOOK;
Constant B252_report_pushing_it_to = EMPTY_RULEBOOK;
[ B253_check_squeezing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_293();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_293;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B254_carry_out_squeezing = EMPTY_RULEBOOK;
[ B255_report_squeezing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_294();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_294;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B256_check_saying_yes 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_295();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_295;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B257_carry_out_saying_yes = EMPTY_RULEBOOK;
Constant B258_report_saying_yes = EMPTY_RULEBOOK;
[ B259_check_saying_no 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_296();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_296;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B260_carry_out_saying_no = EMPTY_RULEBOOK;
Constant B261_report_saying_no = EMPTY_RULEBOOK;
[ B262_check_burning 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_297();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_297;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B263_carry_out_burning = EMPTY_RULEBOOK;
Constant B264_report_burning = EMPTY_RULEBOOK;
[ B265_check_waking_up 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_298();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_298;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B266_carry_out_waking_up = EMPTY_RULEBOOK;
Constant B267_report_waking_up = EMPTY_RULEBOOK;
[ B268_check_thinking 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_299();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_299;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B269_carry_out_thinking = EMPTY_RULEBOOK;
Constant B270_report_thinking = EMPTY_RULEBOOK;
Constant B271_check_smelling = EMPTY_RULEBOOK;
Constant B272_carry_out_smelling = EMPTY_RULEBOOK;
[ B273_report_smelling 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_300();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_300;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B274_check_listening_to = EMPTY_RULEBOOK;
Constant B275_carry_out_listening_to = EMPTY_RULEBOOK;
[ B276_report_listening_to 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_301();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_301;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B277_check_tasting = EMPTY_RULEBOOK;
Constant B278_carry_out_tasting = EMPTY_RULEBOOK;
[ B279_report_tasting 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_302();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_302;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B280_check_cutting 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_303();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_303;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B281_carry_out_cutting = EMPTY_RULEBOOK;
Constant B282_report_cutting = EMPTY_RULEBOOK;
Constant B283_check_jumping = EMPTY_RULEBOOK;
Constant B284_carry_out_jumping = EMPTY_RULEBOOK;
[ B285_report_jumping 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_304();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_304;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B286_check_tying_it_to 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_305();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_305;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B287_carry_out_tying_it_to = EMPTY_RULEBOOK;
Constant B288_report_tying_it_to = EMPTY_RULEBOOK;
[ B289_check_drinking 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_306();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_306;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B290_carry_out_drinking = EMPTY_RULEBOOK;
Constant B291_report_drinking = EMPTY_RULEBOOK;
[ B292_check_saying_sorry 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_307();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_307;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B293_carry_out_saying_sorry = EMPTY_RULEBOOK;
Constant B294_report_saying_sorry = EMPTY_RULEBOOK;
[ B295_check_swinging 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_308();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_308;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B296_carry_out_swinging = EMPTY_RULEBOOK;
Constant B297_report_swinging = EMPTY_RULEBOOK;
[ B298_check_rubbing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_309();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_309;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B299_carry_out_rubbing = EMPTY_RULEBOOK;
[ B300_report_rubbing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_310();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_310;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B301_check_setting_it_to 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_311();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_311;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B302_carry_out_setting_it_to = EMPTY_RULEBOOK;
Constant B303_report_setting_it_to = EMPTY_RULEBOOK;
Constant B304_check_waving_hands = EMPTY_RULEBOOK;
Constant B305_carry_out_waving_hands = EMPTY_RULEBOOK;
[ B306_report_waving_hands 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_312();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_312;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B307_check_buying 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_313();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_313;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B308_carry_out_buying = EMPTY_RULEBOOK;
Constant B309_report_buying = EMPTY_RULEBOOK;
[ B310_check_climbing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_314();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_314;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B311_carry_out_climbing = EMPTY_RULEBOOK;
Constant B312_report_climbing = EMPTY_RULEBOOK;
[ B313_check_sleeping 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_315();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_315;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B314_carry_out_sleeping = EMPTY_RULEBOOK;
Constant B315_report_sleeping = EMPTY_RULEBOOK;
Constant B316_check_quitting_the_game = EMPTY_RULEBOOK;
[ B317_carry_out_quitting_the_ 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = QUIT_THE_GAME_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return QUIT_THE_GAME_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B318_report_quitting_the_gam = EMPTY_RULEBOOK;
Constant B319_check_saving_the_game = EMPTY_RULEBOOK;
[ B320_carry_out_saving_the_ga 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = SAVE_THE_GAME_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return SAVE_THE_GAME_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B321_report_saving_the_game = EMPTY_RULEBOOK;
Constant B322_check_restoring_the_gam = EMPTY_RULEBOOK;
[ B323_carry_out_restoring_the 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = RESTORE_THE_GAME_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return RESTORE_THE_GAME_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B324_report_restoring_the_ga = EMPTY_RULEBOOK;
Constant B325_check_restarting_the_ga = EMPTY_RULEBOOK;
[ B326_carry_out_restarting_th 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = RESTART_THE_GAME_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return RESTART_THE_GAME_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B327_report_restarting_the_g = EMPTY_RULEBOOK;
Constant B328_check_verifying_the_sto = EMPTY_RULEBOOK;
[ B329_carry_out_verifying_the 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = VERIFY_THE_STORY_FILE_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return VERIFY_THE_STORY_FILE_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B330_report_verifying_the_st = EMPTY_RULEBOOK;
Constant B331_check_switching_the_sto = EMPTY_RULEBOOK;
[ B332_carry_out_switching_the 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = SWITCH_TRANSCRIPT_ON_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return SWITCH_TRANSCRIPT_ON_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B333_report_switching_the_st = EMPTY_RULEBOOK;
Constant B334_check_switching_the_sto = EMPTY_RULEBOOK;
[ B335_carry_out_switching_the 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = SWITCH_TRANSCRIPT_OFF_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return SWITCH_TRANSCRIPT_OFF_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B336_report_switching_the_st = EMPTY_RULEBOOK;
Constant B337_check_requesting_the_st = EMPTY_RULEBOOK;
[ B338_carry_out_requesting_th 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = ANNOUNCE_STORY_FILE_VERSION_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return ANNOUNCE_STORY_FILE_VERSION_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B339_report_requesting_the_s = EMPTY_RULEBOOK;
Constant B340_check_requesting_the_sc = EMPTY_RULEBOOK;
[ B341_carry_out_requesting_th 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = ANNOUNCE_SCORE_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return ANNOUNCE_SCORE_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B342_report_requesting_the_s = EMPTY_RULEBOOK;
Constant B343_check_preferring_abbrev = EMPTY_RULEBOOK;
[ B344_carry_out_preferring_ab 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = PREFER_ABBREVIATED_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return PREFER_ABBREVIATED_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B345_report_preferring_abbre 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = REP_PREFER_ABBREVIATED_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return REP_PREFER_ABBREVIATED_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B346_check_preferring_unabbr = EMPTY_RULEBOOK;
[ B347_carry_out_preferring_un 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = PREFER_UNABBREVIATED_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return PREFER_UNABBREVIATED_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B348_report_preferring_unabb 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = REP_PREFER_UNABBREVIATED_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return REP_PREFER_UNABBREVIATED_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B349_check_preferring_someti = EMPTY_RULEBOOK;
[ B350_carry_out_preferring_so 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = PREFER_SOMETIMES_ABBREVIATED_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return PREFER_SOMETIMES_ABBREVIATED_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B351_report_preferring_somet 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = REP_PREFER_SOMETIMES_ABBR_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return REP_PREFER_SOMETIMES_ABBR_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B352_check_switching_score_n = EMPTY_RULEBOOK;
[ B353_carry_out_switching_sco 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = SWITCH_SCORE_NOTIFY_ON_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return SWITCH_SCORE_NOTIFY_ON_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B354_report_switching_score_ 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = REP_SWITCH_NOTIFY_ON_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return REP_SWITCH_NOTIFY_ON_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B355_check_switching_score_n = EMPTY_RULEBOOK;
[ B356_carry_out_switching_sco 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = SWITCH_SCORE_NOTIFY_OFF_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return SWITCH_SCORE_NOTIFY_OFF_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B357_report_switching_score_ 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = REP_SWITCH_NOTIFY_OFF_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return REP_SWITCH_NOTIFY_OFF_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B358_check_requesting_the_pr = EMPTY_RULEBOOK;
[ B359_carry_out_requesting_th 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = ANNOUNCE_PRONOUN_MEANINGS_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return ANNOUNCE_PRONOUN_MEANINGS_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B360_report_requesting_the_p = EMPTY_RULEBOOK;
Constant B361_before_refusing_keys = EMPTY_RULEBOOK;
[ B362_for_refusing_keys 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_821();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_821;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B363_after_refusing_keys = EMPTY_RULEBOOK;
[ B364_check_unlocking_keyless 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_825();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_825;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B365_carry_out_unlocking_key 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_826();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_826;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B366_report_unlocking_keyles = EMPTY_RULEBOOK;
[ B367_check_locking_keylessly 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_828();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_828;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B368_carry_out_locking_keyle 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_829();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_829;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B369_report_locking_keylessl = EMPTY_RULEBOOK;
Constant B370_before_displaying = EMPTY_RULEBOOK;
[ B371_for_displaying 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_899();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_899;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B372_after_displaying = EMPTY_RULEBOOK;
Constant B373_before_pausing_the_game = EMPTY_RULEBOOK;
[ B374_for_pausing_the_game 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_910();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_910;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B375_after_pausing_the_game = EMPTY_RULEBOOK;
[ B376_check_reading 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_940();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_940;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B377_carry_out_reading 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_941();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_941;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B378_report_reading = EMPTY_RULEBOOK;
[ B379_when_chooseyourdestiny_ 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_944();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_944;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B380_when_chooseyourdestiny_ 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_945();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_945;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B381_when_gazelletransformat 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_947();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_947;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B382_when_gazelletransformat = EMPTY_RULEBOOK;
[ B383_when_gagglebecomesherd_ 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_960();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_960;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B384_when_gagglebecomesherd_ = EMPTY_RULEBOOK;
[ B385_when_newscast_begins 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_961();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_961;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B386_when_newscast_ends = EMPTY_RULEBOOK;
[ B387_when_joining_the_zoo_be 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_963();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_963;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B388_when_joining_the_zoo_en = EMPTY_RULEBOOK;
[ B389_when_genieinabottle_beg 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_966();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_966;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B390_when_genieinabottle_end = EMPTY_RULEBOOK;
[ B391_when_exploring_your_off 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_969();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_969;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B392_when_exploring_your_off = EMPTY_RULEBOOK;
[ B393_when_jerked_begins 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_970();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_970;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B394_when_jerked_ends = EMPTY_RULEBOOK;
[ B395_when_supplyshopevent_be 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_971();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_971;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B396_when_supplyshopevent_en = EMPTY_RULEBOOK;
[ B397_when_here_girl_begins 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_988();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_988;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B398_when_here_girl_ends 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_989();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_989;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B399_when_sizeincrease_begin 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_993();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_993;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B400_when_sizeincrease_ends 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_994();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_994;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B401_when_dontcroak_begins 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_997();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_997;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B402_when_dontcroak_ends = EMPTY_RULEBOOK;
[ B403_when_maretf_begins 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_1006();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1006;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B404_when_maretf_ends = EMPTY_RULEBOOK;
[ B405_when_swineoption_begins 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_1015();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1015;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B406_when_swineoption_ends = EMPTY_RULEBOOK;



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Scenes
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


[ DetectSceneChange 
    chs ! count of changes made
    ch ! flag: change made
    ;
    if (scene_status-->0 == 1) {
        if ((((deadflag~=0)))) {
            ch = true;
            if (debug_scenes) print "[Scene 'Entire Game' ends]^";
            if (GProperty(42, 1, p58_recurring)) scene_status-->0 = 0; else scene_status-->0 = 2; FollowRulebook(27);
            FollowRulebook(WHEN_SCENE_ENDS_RB, 1);
            scene_ended-->0 = the_time;
            scene_endings-->0 = (scene_endings-->0)|2;
            scene_latest_ending-->0 = 1;
            jump CScene;
        }
    }
    if (scene_status-->0 == 0) {
        if ((((deadflag==0)))) {
            ch = true;
            if (debug_scenes) print "[Scene 'Entire Game' begins]^";
            scene_status-->0 = 1; FollowRulebook(WHEN_SCENE_BEGINS_RB, 1);
            FollowRulebook(26);
            scene_started-->0 = the_time;
            scene_endings-->0 = (scene_endings-->0)|1;
            scene_latest_ending-->0 = 0;
            jump CScene;
        }
    }
    if (scene_status-->1 == 1) {
    }
    if (scene_status-->1 == 0) {
        if (((((action ==##Examine) &&  (actor==player) && ((noun == I154_wand) && (true)))))) {
            ch = true;
            if (debug_scenes) print "[Scene 'chooseYourDestiny' begins]^";
            scene_status-->1 = 1; FollowRulebook(WHEN_SCENE_BEGINS_RB, 2);
            FollowRulebook(379);
            scene_started-->1 = the_time;
            scene_endings-->1 = (scene_endings-->1)|1;
            scene_latest_ending-->1 = 0;
            jump CScene;
        }
    }
    if (scene_status-->2 == 1) {
    }
    if (scene_status-->2 == 0) {
        if (((((action ==##Examine) &&  (actor==player) && ((noun == I178_crying_man) && (true)))))) {
            ch = true;
            if (debug_scenes) print "[Scene 'gazelleTransformation' begins]^";
            scene_status-->2 = 1; FollowRulebook(WHEN_SCENE_BEGINS_RB, 3);
            FollowRulebook(381);
            scene_started-->2 = the_time;
            scene_endings-->2 = (scene_endings-->2)|1;
            scene_latest_ending-->2 = 0;
            jump CScene;
        }
    }
    if (scene_status-->3 == 1) {
    }
    if (scene_status-->3 == 0) {
        if (((((action ==##Examine) &&  (actor==player) && ((noun == I218_gaggle_of_girls) && (true)))))) {
            ch = true;
            if (debug_scenes) print "[Scene 'gaggleBecomesHerd' begins]^";
            scene_status-->3 = 1; FollowRulebook(WHEN_SCENE_BEGINS_RB, 4);
            FollowRulebook(383);
            scene_started-->3 = the_time;
            scene_endings-->3 = (scene_endings-->3)|1;
            scene_latest_ending-->3 = 0;
            jump CScene;
        }
    }
    if (scene_status-->4 == 1) {
    }
    if (scene_status-->4 == 0) {
        if (((((action ==##Examine) &&  (actor==player) && ((noun == I228_tv_station) && (true)))))) {
            ch = true;
            if (debug_scenes) print "[Scene 'newsCast' begins]^";
            scene_status-->4 = 1; FollowRulebook(WHEN_SCENE_BEGINS_RB, 5);
            FollowRulebook(385);
            scene_started-->4 = the_time;
            scene_endings-->4 = (scene_endings-->4)|1;
            scene_latest_ending-->4 = 0;
            jump CScene;
        }
    }
    if (scene_status-->5 == 1) {
    }
    if (scene_status-->5 == 0) {
        if (((((action ==##Enter) &&  (actor==player) && ((noun == I291_portal) && (true)))))) {
            ch = true;
            if (debug_scenes) print "[Scene 'Joining The Zoo' begins]^";
            scene_status-->5 = 1; FollowRulebook(WHEN_SCENE_BEGINS_RB, 6);
            FollowRulebook(387);
            scene_started-->5 = the_time;
            scene_endings-->5 = (scene_endings-->5)|1;
            scene_latest_ending-->5 = 0;
            jump CScene;
        }
    }
    if (scene_status-->6 == 1) {
    }
    if (scene_status-->6 == 0) {
        if (((((action ==##Examine) &&  (actor==player) && ((noun == I340_wall_of_artifacts) && (true)))))) {
            ch = true;
            if (debug_scenes) print "[Scene 'genieInABottle' begins]^";
            scene_status-->6 = 1; FollowRulebook(WHEN_SCENE_BEGINS_RB, 7);
            FollowRulebook(389);
            scene_started-->6 = the_time;
            scene_endings-->6 = (scene_endings-->6)|1;
            scene_latest_ending-->6 = 0;
            jump CScene;
        }
    }
    if (scene_status-->7 == 1) {
    }
    if (scene_status-->7 == 0) {
        if (((((action ==##Enter) &&  (actor==player) && ((noun == I364_stairs_to_your_office) && (true)))))) {
            ch = true;
            if (debug_scenes) print "[Scene 'Exploring Your Office' begins]^";
            scene_status-->7 = 1; FollowRulebook(WHEN_SCENE_BEGINS_RB, 8);
            FollowRulebook(391);
            scene_started-->7 = the_time;
            scene_endings-->7 = (scene_endings-->7)|1;
            scene_latest_ending-->7 = 0;
            jump CScene;
        }
    }
    if (scene_status-->8 == 1) {
    }
    if (scene_status-->8 == 0) {
        if (((((action ==##Eat) &&  (actor==player) && ((noun == I370_amazing_meal) && (true)))))) {
            ch = true;
            if (debug_scenes) print "[Scene 'Jerked' begins]^";
            scene_status-->8 = 1; FollowRulebook(WHEN_SCENE_BEGINS_RB, 9);
            FollowRulebook(393);
            scene_started-->8 = the_time;
            scene_endings-->8 = (scene_endings-->8)|1;
            scene_latest_ending-->8 = 0;
            jump CScene;
        }
    }
    if (scene_status-->9 == 1) {
    }
    if (scene_status-->9 == 0) {
        if (((((action ==##Enter) &&  (actor==player) && ((noun == I397_supply_shop) && (true)))))) {
            ch = true;
            if (debug_scenes) print "[Scene 'supplyShopEvent' begins]^";
            scene_status-->9 = 1; FollowRulebook(WHEN_SCENE_BEGINS_RB, 10);
            FollowRulebook(395);
            scene_started-->9 = the_time;
            scene_endings-->9 = (scene_endings-->9)|1;
            scene_latest_ending-->9 = 0;
            jump CScene;
        }
    }
    if (scene_status-->10 == 1) {
    }
    if (scene_status-->10 == 0) {
        if (((((action ==##Examine) &&  (actor==player) && ((noun == I157_witch) && (true)))))) {
            ch = true;
            if (debug_scenes) print "[Scene 'Here Girl' begins]^";
            scene_status-->10 = 1; FollowRulebook(WHEN_SCENE_BEGINS_RB, 11);
            FollowRulebook(397);
            scene_started-->10 = the_time;
            scene_endings-->10 = (scene_endings-->10)|1;
            scene_latest_ending-->10 = 0;
            jump CScene;
        }
    }
    if (scene_status-->11 == 1) {
    }
    if (scene_status-->11 == 0) {
        if (((((action ==##Examine) &&  (actor==player) && ((noun == I198_elephant_statue) && (true)))))) {
            ch = true;
            if (debug_scenes) print "[Scene 'SizeIncrease' begins]^";
            scene_status-->11 = 1; FollowRulebook(WHEN_SCENE_BEGINS_RB, 12);
            FollowRulebook(399);
            scene_started-->11 = the_time;
            scene_endings-->11 = (scene_endings-->11)|1;
            scene_latest_ending-->11 = 0;
            jump CScene;
        }
    }
    if (scene_status-->12 == 1) {
    }
    if (scene_status-->12 == 0) {
        if (((((action ==##Eat) &&  (actor==player) && ((noun == I237_small_green_pastry) && (true)))))) {
            ch = true;
            if (debug_scenes) print "[Scene 'dontCroak' begins]^";
            scene_status-->12 = 1; FollowRulebook(WHEN_SCENE_BEGINS_RB, 13);
            FollowRulebook(401);
            scene_started-->12 = the_time;
            scene_endings-->12 = (scene_endings-->12)|1;
            scene_latest_ending-->12 = 0;
            jump CScene;
        }
    }
    if (scene_status-->13 == 1) {
    }
    if (scene_status-->13 == 0) {
        if (((((action ==##Examine) &&  (actor==player) && ((noun == I271_becky) && (true)))))) {
            ch = true;
            if (debug_scenes) print "[Scene 'MareTf' begins]^";
            scene_status-->13 = 1; FollowRulebook(WHEN_SCENE_BEGINS_RB, 14);
            FollowRulebook(403);
            scene_started-->13 = the_time;
            scene_endings-->13 = (scene_endings-->13)|1;
            scene_latest_ending-->13 = 0;
            jump CScene;
        }
    }
    if (scene_status-->14 == 1) {
    }
    if (scene_status-->14 == 0) {
    }
    .CScene;
    if (chs>20) ">--> The scene change machinery is stuck.";

    if (ch>0) DetectSceneChange(++chs);

    rfalse;
];

#IFDEF DEBUG;
[ ShowSceneStatus 
    chs ! internal use only
    sc ! internal use only
    ch ! internal use only
    ;
    if (scene_status-->0 == 1) {
        print "Scene 'Entire Game' playing (for ", the_time-(scene_started-->0), " mins now)^";
    } else {
        if (scene_latest_ending-->0 > 0) {
            print "Scene 'Entire Game' ended";
            print "^";
        }
    }
    if (scene_status-->1 == 1) {
        print "Scene 'chooseYourDestiny' playing (for ", the_time-(scene_started-->1), " mins now)^";
    } else {
        if (scene_latest_ending-->1 > 0) {
            print "Scene 'chooseYourDestiny' ended";
            print "^";
        }
    }
    if (scene_status-->2 == 1) {
        print "Scene 'gazelleTransformation' playing (for ", the_time-(scene_started-->2), " mins now)^";
    } else {
        if (scene_latest_ending-->2 > 0) {
            print "Scene 'gazelleTransformation' ended";
            print "^";
        }
    }
    if (scene_status-->3 == 1) {
        print "Scene 'gaggleBecomesHerd' playing (for ", the_time-(scene_started-->3), " mins now)^";
    } else {
        if (scene_latest_ending-->3 > 0) {
            print "Scene 'gaggleBecomesHerd' ended";
            print "^";
        }
    }
    if (scene_status-->4 == 1) {
        print "Scene 'newsCast' playing (for ", the_time-(scene_started-->4), " mins now)^";
    } else {
        if (scene_latest_ending-->4 > 0) {
            print "Scene 'newsCast' ended";
            print "^";
        }
    }
    if (scene_status-->5 == 1) {
        print "Scene 'Joining The Zoo' playing (for ", the_time-(scene_started-->5), " mins now)^";
    } else {
        if (scene_latest_ending-->5 > 0) {
            print "Scene 'Joining The Zoo' ended";
            print "^";
        }
    }
    if (scene_status-->6 == 1) {
        print "Scene 'genieInABottle' playing (for ", the_time-(scene_started-->6), " mins now)^";
    } else {
        if (scene_latest_ending-->6 > 0) {
            print "Scene 'genieInABottle' ended";
            print "^";
        }
    }
    if (scene_status-->7 == 1) {
        print "Scene 'Exploring Your Office' playing (for ", the_time-(scene_started-->7), " mins now)^";
    } else {
        if (scene_latest_ending-->7 > 0) {
            print "Scene 'Exploring Your Office' ended";
            print "^";
        }
    }
    if (scene_status-->8 == 1) {
        print "Scene 'Jerked' playing (for ", the_time-(scene_started-->8), " mins now)^";
    } else {
        if (scene_latest_ending-->8 > 0) {
            print "Scene 'Jerked' ended";
            print "^";
        }
    }
    if (scene_status-->9 == 1) {
        print "Scene 'supplyShopEvent' playing (for ", the_time-(scene_started-->9), " mins now)^";
    } else {
        if (scene_latest_ending-->9 > 0) {
            print "Scene 'supplyShopEvent' ended";
            print "^";
        }
    }
    if (scene_status-->10 == 1) {
        print "Scene 'Here Girl' playing (for ", the_time-(scene_started-->10), " mins now)^";
    } else {
        if (scene_latest_ending-->10 > 0) {
            print "Scene 'Here Girl' ended";
            print "^";
        }
    }
    if (scene_status-->11 == 1) {
        print "Scene 'SizeIncrease' playing (for ", the_time-(scene_started-->11), " mins now)^";
    } else {
        if (scene_latest_ending-->11 > 0) {
            print "Scene 'SizeIncrease' ended";
            print "^";
        }
    }
    if (scene_status-->12 == 1) {
        print "Scene 'dontCroak' playing (for ", the_time-(scene_started-->12), " mins now)^";
    } else {
        if (scene_latest_ending-->12 > 0) {
            print "Scene 'dontCroak' ended";
            print "^";
        }
    }
    if (scene_status-->13 == 1) {
        print "Scene 'MareTf' playing (for ", the_time-(scene_started-->13), " mins now)^";
    } else {
        if (scene_latest_ending-->13 > 0) {
            print "Scene 'MareTf' ended";
            print "^";
        }
    }
    if (scene_status-->14 == 1) {
        print "Scene 'SwineOption' playing (for ", the_time-(scene_started-->14), " mins now)^";
    } else {
        if (scene_latest_ending-->14 > 0) {
            print "Scene 'SwineOption' ended";
            print "^";
        }
    }
];

#ENDIF;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: The New Library
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====




! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: Summary
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: Action Data
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant AD_ACTION = 0; ! The I6 action number (0 to 4095)
Constant AD_REQUIREMENTS = 1; ! Such as requiring light; a bitmap, see below
Constant AD_NOUN_KOV = 2; ! Kind of value of the first noun
Constant AD_SECOND_KOV = 3; ! Kind of value of the second noun
Constant AD_VARIABLES_CREATOR = 4; ! Routine to initialise variables owned
Constant AD_VARIABLES_ID = 5; ! Frame ID for variables owned by action

Constant AD_RECORD_SIZE = 6;

[ FindAction fa t;
	if (fa == -1) fa = action;
	t = 1;
	while (t <= ActionData-->0) {
		if (fa == ActionData-->t) return t;
		t = t + AD_RECORD_SIZE;
	}
	rfalse;
];

[ ActionNumberIndexed i;
	if ((i>=0) && (i < AD_RECORDS)) return ActionData-->(i*AD_RECORD_SIZE + AD_ACTION + 1);
	return 0;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: Requirements Bitmap
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant TOUCH_NOUN_ABIT   = $$00000001;
Constant TOUCH_SECOND_ABIT = $$00000010;
Constant LIGHT_ABIT        = $$00000100;
Constant NEED_NOUN_ABIT    = $$00001000;
Constant NEED_SECOND_ABIT  = $$00010000;
Constant OUT_OF_WORLD_ABIT = $$00100000;
Constant CARRY_NOUN_ABIT   = $$01000000;
Constant CARRY_SECOND_ABIT = $$10000000;

[ NeedToCarryNoun;       return TestActionMask(CARRY_NOUN_ABIT); ];
[ NeedToCarrySecondNoun; return TestActionMask(CARRY_SECOND_ABIT); ];
[ NeedToTouchNoun;       return TestActionMask(TOUCH_NOUN_ABIT); ];
[ NeedToTouchSecondNoun; return TestActionMask(TOUCH_SECOND_ABIT); ];
[ NeedLightForAction;    return TestActionMask(LIGHT_ABIT); ];

[ TestActionMask match mask at; 
	at = FindAction(-1); 
	if (at == 0) rfalse; 
	mask = ActionData-->(at+AD_REQUIREMENTS); 
	if (mask & match) rtrue; 
	rfalse; 
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: Try Action
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TryAction req by ac n s stora smeta tbits saved_command text_of_command;
	if (stora) return STORED_ACTION_TY_New(ac, n, s, by, req, stora);
	tbits = req & (16+32);
	req = req & 1;
	@push actor; @push act_requester; @push inp1; @push inp2;
	@push parsed_number; smeta = meta;
	actor = by; if (req) act_requester = player; else act_requester = 0;

	by = FindAction(ac);
	if (by) {
		if (ActionData-->(by+AD_NOUN_KOV) == OBJECT_TY) inp1 = n;
		else { inp1 = 1; parsed_number = n; }
		if (ActionData-->(by+AD_SECOND_KOV) == OBJECT_TY) inp2 = s;
		else { inp2 = 1; parsed_number = s; }
		if (((ActionData-->(by+AD_NOUN_KOV) == UNDERSTANDING_TY) ||
			(ActionData-->(by+AD_SECOND_KOV) == UNDERSTANDING_TY)) && (tbits)) {
			saved_command = BlkValueCreate(TEXT_TY);
			BlkValueCast(saved_command, SNIPPET_TY, players_command);
			text_of_command = BlkValueCreate(TEXT_TY);
			BlkValueCopy(text_of_command, parsed_number);
			SetPlayersCommand(text_of_command);
			if (tbits == 16) {
				n = players_command; inp1 = 1; parsed_number = players_command;
			} else {
				s = players_command; inp2 = 1; parsed_number = players_command;
			}
			BlkValueFree(text_of_command);
			@push consult_from; @push consult_words;
			consult_from = 1; consult_words = parsed_number - 100;
		}
	}

	BeginAction(ac, n, s, 0, true);

	if (saved_command) {
		@pull consult_words; @pull consult_from;
		SetPlayersCommand(saved_command);
		BlkValueFree(saved_command);
	}

	meta = smeta; @pull parsed_number;
	@pull inp2; @pull inp1; @pull act_requester; @pull actor;
	TrackActions(true, smeta);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: I6 Angle Brackets
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ R_Process a i j;
	@push inp1; @push inp2;
    inp1 = i; inp2 = j; BeginAction(a, i, j);
    @pull inp2; @pull inp1;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: Conversion
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Global converted_action_outcome = -1;
[ GVS_Convert ac n s;
	converted_action_outcome = BeginAction(ac, n, s);
	rtrue;
];

[ ConvertToRequest X AN Y Z;
	WORK_OUT_DETAILS_OF_SPECIFIC_R();
	if (X == player) TryAction(false, X, AN, Y, Z);
	else TryAction(true, X, AN, Y, Z);
	rtrue;
];

[ ConvertToGoingWithPush i oldrm newrm infl;
	i=noun;
	if (IndirectlyContains(noun, actor) == false) { move i to actor; infl = true; }
	move_pushing = i;
	oldrm = LocationOf(noun);
	BeginAction(##Go, second);
	newrm = LocationOf(actor);
	move_pushing = nothing; move i to newrm;
	if (newrm ~= oldrm) {
		if (IndirectlyContains(i, player)) TryAction(0, player, ##Look, 0, 0);
		RulebookSucceeds();
	} else RulebookFails();
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: Implicit Take
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ImplicitTake obj ks;
	if (actor == player) { STANDARD_IMPLICIT_TAKING_RM('A', obj); }
	else {
		if (TestVisibility(player, actor))
			STANDARD_IMPLICIT_TAKING_RM('B', obj, actor);
	}
	ClearParagraphing(3);
	@push keep_silent; keep_silent = true;
	@push say__p; @push say__pc; ClearParagraphing(4);
	if (act_requester) TryAction(true, actor, ##Take, obj, nothing);
	else TryAction(false, actor, ##Take, obj, nothing);
	DivideParagraphPoint(); @pull say__pc; @pull say__p; AdjustParagraphPoint(); @pull keep_silent;
	if (obj in actor) rtrue;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: Look After Going
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LookAfterGoing;
	GoingLookBreak();
	AbbreviatedRoomDescription();
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: Abbreviated Room Description
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ AbbreviatedRoomDescription  prior_action pos frame_id;
	prior_action = action; 

	action = ##Look;
	pos = FindAction(##Look);
	if ((pos) && (ActionData-->(pos+AD_VARIABLES_CREATOR))) {
		frame_id = ActionData-->(pos+AD_VARIABLES_ID);
		Mstack_Create_Frame(ActionData-->(pos+AD_VARIABLES_CREATOR), frame_id);
		FollowRulebook(SETTING_ACTION_VARIABLES_RB);
		(MStack-->MstVO(frame_id, 0)) = prior_action; ! "room-describing action"
		(MStack-->MstVO(frame_id, 1)) = true; ! "abbreviated form allowed"
	}
	LookSub(); ! The I6 verb routine for "looking"
	if (frame_id) Mstack_Destroy_Frame(ActionData-->(pos+AD_VARIABLES_CREATOR), frame_id);

	action = prior_action;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: Begin Action
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BeginAction a n s moi notrack  rv;
	ChronologyPoint();

	@push action; @push noun; @push second; @push self; @push multiple_object_item;

	action = a; noun = n; second = s; self = noun; multiple_object_item = moi;
	if (action < 4096) rv = ActionPrimitive();

	@pull multiple_object_item; @pull self; @pull second; @pull noun; @pull action;
	
	if (notrack == false) TrackActions(true, meta);
	return rv;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: Action Primitive
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ActionPrimitive  rv p1 p2 p3 p4 p5 frame_id;
	MStack_CreateRBVars(ACTION_PROCESSING_RB);

	if ((keep_silent == false) && (multiflag == false)) DivideParagraphPoint();
	reason_the_action_failed = 0;

	frame_id = -1;
	p1 = FindAction(action);
	if ((p1) && (ActionData-->(p1+AD_VARIABLES_CREATOR))) {
		frame_id = ActionData-->(p1+AD_VARIABLES_ID);
		Mstack_Create_Frame(ActionData-->(p1+AD_VARIABLES_CREATOR), frame_id);
	}
	if (ActionVariablesNotTypeSafe()) {
		if (frame_id ~= -1)
			Mstack_Destroy_Frame(ActionData-->(p1+AD_VARIABLES_CREATOR), frame_id);
		MStack_DestroyRBVars(ACTION_PROCESSING_RB);
		return;
	}

	FollowRulebook(SETTING_ACTION_VARIABLES_RB);

	#IFDEF DEBUG;
	if ((trace_actions) && (FindAction(-1))) {
		print "["; p1=actor; p2=act_requester; p3=action; p4=noun; p5=second;
		DB_Action(p1,p2,p3,p4,p5);
		print "]^"; ClearParagraphing(5);
	}
	++debug_rule_nesting;
	#ENDIF;
	TrackActions(false, meta);
	if ((meta) && (actor ~= player)) {
		ACTION_PROCESSING_INTERNAL_RM('A', actor); new_line; rv = RS_FAILS; }
	else if (meta) { DESCEND_TO_SPECIFIC_ACTION_R(); rv = RulebookOutcome(); }
	else { FollowRulebook(ACTION_PROCESSING_RB); rv = RulebookOutcome(); }
	#IFDEF DEBUG;
	--debug_rule_nesting;
	if ((trace_actions) && (FindAction(-1))) {
		print "["; DB_Action(p1,p2,p3,p4,p5); print " - ";
		switch (rv) {
			RS_SUCCEEDS: print "succeeded";
			RS_FAILS: print "failed";
				#IFNDEF MEMORY_ECONOMY;
				if (reason_the_action_failed)
					print " the ",
						(RulePrintingRule) reason_the_action_failed;
			    #ENDIF;
			default: print "ended without result";
		}
		print "]^"; say__p = 1;
		SetRulebookOutcome(rv); ! In case disturbed by printing activities
	}
	#ENDIF;
	if (rv == RS_SUCCEEDS) UpdateActionBitmap();
	if (frame_id ~= -1) {
		p1 = FindAction(action);
		Mstack_Destroy_Frame(ActionData-->(p1+AD_VARIABLES_CREATOR), frame_id);
	}
	MStack_DestroyRBVars(ACTION_PROCESSING_RB);
	if ((keep_silent == false) && (multiflag == false)) DivideParagraphPoint();
	if (rv == RS_SUCCEEDS) rtrue;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: Internal Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ACTION_PROCESSING_INTERNAL_R; ];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: Type Safety
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ActionVariablesNotTypeSafe mask noun_kova second_kova at;
	at = FindAction(-1); if (at == 0) rfalse; ! For any I6-defined actions

	noun_kova = ActionData-->(at+AD_NOUN_KOV);
	second_kova = ActionData-->(at+AD_SECOND_KOV);

	!print "at = ", at, " nst = ", noun_kova, "^";
	!print "consult_from = ", consult_from, " consult_words = ", consult_from, "^";
	!print "inp1 = ", inp1, " noun = ", noun, "^";
	!print "inp2 = ", inp2, " second = ", second, "^";
	!print "sst = ", second_kova, "^";

	if (noun_kova == SNIPPET_TY or UNDERSTANDING_TY) {
	    if (inp1 ~= 1) { inp2 = inp1; second = noun; }
	    parsed_number = 100*consult_from + consult_words;
	    inp1 = 1; noun = nothing; ! noun = parsed_number;
	}
	if (second_kova == SNIPPET_TY or UNDERSTANDING_TY) {
	    parsed_number = 100*consult_from + consult_words;
	    inp2 = 1; second = nothing; ! second = parsed_number;
	}

	mask = ActionData-->(at+AD_REQUIREMENTS);
	if (mask & OUT_OF_WORLD_ABIT) { meta = 1; rfalse; }
	meta = 0;

	if (inp1 == 1) {
	    if (noun_kova == OBJECT_TY) {
	    	if (actor == player) { ACTION_PROCESSING_INTERNAL_RM('B'); new_line; }
	        rtrue;
	    }
	} else {
	    if (noun_kova ~= OBJECT_TY) {
	    	if (actor == player) { ACTION_PROCESSING_INTERNAL_RM('C'); new_line; }
	        rtrue;
	    }
	    if ((mask & NEED_NOUN_ABIT) && (noun == nothing)) {
	    	@push act_requester; act_requester = nothing;
	        CarryOutActivity(SUPPLYING_A_MISSING_NOUN_ACT);
	        @pull act_requester;
	        if (noun == nothing) {
	        	if (say__p) rtrue;
		    	if (actor == player) { ACTION_PROCESSING_INTERNAL_RM('D'); new_line; }
		        rtrue;
	    	}
	    }
	    if (((mask & NEED_NOUN_ABIT) == 0) && (noun ~= nothing)) {
	    	if (actor == player) { ACTION_PROCESSING_INTERNAL_RM('E'); new_line; }
	        rtrue;
	    }
	}

	if (inp2 == 1) {
	    if (second_kova == OBJECT_TY) {
	    	if (actor == player) { ACTION_PROCESSING_INTERNAL_RM('F'); new_line; }
	        rtrue;
	    }
	} else {
	    if (second_kova ~= OBJECT_TY) {
	    	if (actor == player) { ACTION_PROCESSING_INTERNAL_RM('G'); new_line; }
	        rtrue;
	    }
	    if ((mask & NEED_SECOND_ABIT) && (second == nothing)) {
	        @push act_requester; act_requester = nothing;
	        CarryOutActivity(SUPPLYING_A_MISSING_SECOND_ACT);
	        @pull act_requester;
	        if (second == nothing) {
	        	if (say__p) rtrue;
		    	if (actor == player) { ACTION_PROCESSING_INTERNAL_RM('H'); new_line; }
		        rtrue;
	        }
	    }
	    if (((mask & NEED_SECOND_ABIT) == 0) && (second ~= nothing)) {
	    	if (actor == player) { ACTION_PROCESSING_INTERNAL_RM('I'); new_line; }
	        rtrue;
	    }
	}

	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: Basic Visibility Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BASIC_VISIBILITY_R;
	if (act_requester) rfalse;
	if ((NeedLightForAction()) &&
		(actor == player) &&
		(FollowRulebook(VISIBLE_RB)) &&
		(RulebookSucceeded())) {
		BeginActivity(REFUSAL_TO_ACT_IN_DARK_ACT);
		if (ForActivity(REFUSAL_TO_ACT_IN_DARK_ACT)==false) {
			BASIC_VISIBILITY_RM('A'); new_line;
		}
		EndActivity(REFUSAL_TO_ACT_IN_DARK_ACT);
		reason_the_action_failed = BASIC_VISIBILITY_R;
		RulebookFails();
		rtrue;
	}
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: Basic Accessibility Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BASIC_ACCESSIBILITY_R mask at;
	if (act_requester) rfalse;
	at = FindAction(-1);
	if (at == 0) rfalse;
	mask = ActionData-->(at+AD_REQUIREMENTS);

	if ((mask & TOUCH_NOUN_ABIT) && noun && (inp1 ~= 1)) {
		if (noun ofclass K3_direction) {
			RulebookFails();
			reason_the_action_failed = BASIC_ACCESSIBILITY_R; 
			if (actor~=player) rtrue;
			BASIC_ACCESSIBILITY_RM('A'); new_line;
			RulebookFails();
			reason_the_action_failed = BASIC_ACCESSIBILITY_R; 
			rtrue;
		}
		if (ObjectIsUntouchable(noun, (actor~=player), actor)) {
			RulebookFails();
			reason_the_action_failed = BASIC_ACCESSIBILITY_R;
			rtrue;
		}
	}

	if ((mask & TOUCH_SECOND_ABIT) && second && (inp2 ~= 1)) {
		if (second ofclass K3_direction) {
			RulebookFails();
			reason_the_action_failed = BASIC_ACCESSIBILITY_R;
			if (actor~=player) rtrue;
			BASIC_ACCESSIBILITY_RM('A'); new_line;
			RulebookFails();
			reason_the_action_failed = BASIC_ACCESSIBILITY_R; 
			rtrue;
		}
		if (ObjectIsUntouchable(second, (actor~=player), actor)) {
			RulebookFails();
			reason_the_action_failed = BASIC_ACCESSIBILITY_R;
			rtrue;
		}
	}
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: Carrying Requirements Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ CARRYING_REQUIREMENTS_R mask at;
	
	at = FindAction(-1);
	if (at == 0) rfalse;
	mask = ActionData-->(at+AD_REQUIREMENTS);

	if ((mask & TOUCH_NOUN_ABIT) && noun && (inp1 ~= 1)) {
		if ((mask & CARRY_NOUN_ABIT) && (noun notin actor)) {
			CarryOutActivity(IMPLICITLY_TAKING_ACT, noun);
			if (noun notin actor) {
				RulebookFails();
				reason_the_action_failed = CARRYING_REQUIREMENTS_R;
				rtrue;
			}
		}
	}

	if ((mask & TOUCH_SECOND_ABIT) && second && (inp2 ~= 1)) {
		if ((mask & CARRY_SECOND_ABIT) && (second notin actor)) {
			CarryOutActivity(IMPLICITLY_TAKING_ACT, second);
 			if (second notin actor) {
				RulebookFails();
				reason_the_action_failed = CARRYING_REQUIREMENTS_R;
				rtrue;
			}
		}
	}
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: Standard Implicit Taking Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ STANDARD_IMPLICIT_TAKING_R;
	ImplicitTake(parameter_value);
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: Requested Actions Require Persuasion Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ REQUESTED_ACTIONS_REQUIRE_R rv;
	if ((actor ~= player) && (act_requester)) {
		@push say__p;
		say__p = 0;
		rv = FollowRulebook(PERSUADE_RB);
		if (RulebookSucceeded() == false) {
			if ((deadflag == false) && (say__p == FALSE)) {
				REQUESTED_ACTIONS_REQUIRE_RM('A', actor);
				new_line;
			}
			ActRulebookFails(rv); rtrue;
		}
		@pull say__p;
	}
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: Carry Out Requested Actions Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ CARRY_OUT_REQUESTED_ACTIONS_R rv;
	if ((actor ~= player) && (act_requester)) {
		@push act_requester; act_requester = nothing;
		rv = BeginAction(action, noun, second);
		if (((meta) || (rv == false)) && (deadflag == false)) {
			if (FollowRulebook(UNSUCCESSFUL_ATTEMPT_RB) == false) {
				CARRY_OUT_REQUESTED_ACTIONS_RM('A', actor); new_line;
			}
		}
		@pull act_requester;
		FollowRulebook(AFTER_RB);
		ActRulebookSucceeds();
		rtrue;
	}
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: Generic Verb Subroutine
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Array Details_of_Specific_Action-->5;

[ GenericVerbSub ch co re vis rv;
	@push converted_action_outcome;
	converted_action_outcome = -1;

	Details_of_Specific_Action-->0 = true;
	if (meta) Details_of_Specific_Action-->0 = false;
	Details_of_Specific_Action-->1 = keep_silent;
	Details_of_Specific_Action-->2 = ch; ! Check rules for the action
	Details_of_Specific_Action-->3 = co; ! Carry out rules for the action
	Details_of_Specific_Action-->4 = re; ! Report rules for the action

	FollowRulebook(SPECIFIC_ACTION_PROCESSING_RB, 0, true);
	if ((RulebookFailed()) && (converted_action_outcome == 1)) ActRulebookSucceeds();

	@pull converted_action_outcome;
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: Work Out Details Of Specific Action Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ WORK_OUT_DETAILS_OF_SPECIFIC_R;
	MStack-->MstVO(SPECIFIC_ACTION_PROCESSING_RB, 0) = Details_of_Specific_Action-->0;
	MStack-->MstVO(SPECIFIC_ACTION_PROCESSING_RB, 1) = Details_of_Specific_Action-->1;
	MStack-->MstVO(SPECIFIC_ACTION_PROCESSING_RB, 2) = Details_of_Specific_Action-->2;
	MStack-->MstVO(SPECIFIC_ACTION_PROCESSING_RB, 3) = Details_of_Specific_Action-->3;
	MStack-->MstVO(SPECIFIC_ACTION_PROCESSING_RB, 4) = Details_of_Specific_Action-->4;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: Actions Bitmap
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TestActionBitmap obj act i j k bitmap;
	if (obj == nothing) bitmap = ActionHappened;
	else {
		if (~~(obj provides action_bitmap)) rfalse;
		bitmap = obj.&action_bitmap;
	}
	if (act == -1) return (((bitmap->0) & 1) ~= 0); 
	for (i=0, k=2: i<ActionCount: i++) {
		if (act == ActionCoding-->i) {
			return (((bitmap->j) & k) ~= 0);
		}
		k = k*2; if (k == 256) { k = 1; j++; }
	}
	rfalse;
];

[ UpdateActionBitmap;
	SetActionBitmap(noun, action);
	if (action == ##Go) SetActionBitmap(location, ##Enter);
];

[ SetActionBitmap obj act i j k bitmap;
	for (i=0, k=2: i<ActionCount: i++) {
		if (act == ActionCoding-->i) {
			if (obj provides action_bitmap) {
				bitmap = obj.&action_bitmap;
				bitmap->0 = (bitmap->0) | 1;
				bitmap->j = (bitmap->j) | k;
			}
			ActionHappened->0 = (ActionHappened->0) | 1;
			ActionHappened->j = (ActionHappened->j) | k;
		}
		k = k*2; if (k == 256) { k = 1; j++; }
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: Printing Actions
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SayActionName act; DB_Action(0, 0, act, 0, 0, 2); ];

[ DA_Name n; if (n ofclass K3_direction) print (name) n; else print (the) n; ];
[ DA_Topic x a b c d i cf cw;
	cw = x%100; cf = x/100;
	print "~";
	for (a=cf:d<cw:d++,a++) {
		wn = a; b = WordAddress(a); c = WordLength(a);
		for (i=b:i<b+c:i++) {
			print (char) 0->i;
		}
		if (d<cw-1) print " ";
	}
	print "~";
];
[ DA_Number n; print n; ];
[ DA_TruthState n; if (n==0) print "false"; else print "true"; ];
[ DB_Action ac acr act n s for_say t at l j v c clc;
	if ((for_say == 0) && (debug_rule_nesting > 0))
		print "(", debug_rule_nesting, ") ";
	if ((ac ~= player) && (for_say ~= 2)) {
		if (acr) print "asking ", (the) ac, " to try ";
		else print (the) ac, " ";
	}
	DB_Action_Details(act, n, s, for_say);
	if ((keep_silent) && (for_say == 0)) print " - silently";
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Activities.i6t: The Activities Stack
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant MAX_NESTED_ACTIVITIES = 20;
Global activities_sp = 0;
Array activities_stack --> MAX_NESTED_ACTIVITIES;
Array activity_parameters_stack --> MAX_NESTED_ACTIVITIES;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Activities.i6t: Rule Debugging Inhibition
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Global inhibit_flag = 0;
Global saved_debug_rules = 0;
[ FixInhibitFlag n act inhibit_rule_debugging;
	for (n=0:n<activities_sp:n++) {
		act = activities_stack-->n;
		if (act == PRINTING_THE_NAME_ACT or PRINTING_THE_PLURAL_NAME_ACT or
			PRINTING_ROOM_DESC_DETAILS_ACT or PRINTING_INVENTORY_DETAILS_ACT or
			LISTING_CONTENTS_ACT or GROUPING_TOGETHER_ACT or PRINTING_RESPONSE_ACT)
				inhibit_rule_debugging = true;
	}
	if ((inhibit_flag == false) && (inhibit_rule_debugging)) {
		saved_debug_rules = debug_rules;
		debug_rules = 0;
	}
	if ((inhibit_flag) && (inhibit_rule_debugging == false)) {
		debug_rules = saved_debug_rules;
	}
	inhibit_flag = inhibit_rule_debugging;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Activities.i6t: Testing Activities
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TestActivity A desc val i;
	for (i=0:i<activities_sp:i++)
		if (activities_stack-->i == A) {
			if (desc) {
				if ((desc)(activity_parameters_stack-->i)) rtrue;
			} else if (val) {
				if (val == activity_parameters_stack-->i) rtrue;
			} else rtrue;
		}
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Activities.i6t: Emptiness
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ActivityEmpty A x;
	x = Activity_before_rulebooks-->A;
	if (rulebooks_array-->x ~= EMPTY_RULEBOOK) rfalse;
	x = Activity_for_rulebooks-->A;
	if (rulebooks_array-->x ~= EMPTY_RULEBOOK) rfalse;
	x = Activity_after_rulebooks-->A;
	if (rulebooks_array-->x ~= EMPTY_RULEBOOK) rfalse;
	rtrue;
];

[ RulebookEmpty rb;
	if (rulebooks_array-->rb ~= EMPTY_RULEBOOK) rfalse;
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Activities.i6t: Process Activity Rulebook
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ProcessActivityRulebook rulebook parameter  rv;
	@push self;
	if (parameter) self = parameter;
	rv = FollowRulebook(rulebook, parameter, true);
	@pull self;
	if (rv) rtrue;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Activities.i6t: Carrying Out Activities
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ CarryOutActivity A o rv;
	BeginActivity(A, o);
	rv = ForActivity(A, o);
	EndActivity(A, o);
	return rv;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Activities.i6t: Begin
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BeginActivity A o x;
	if (activities_sp == MAX_NESTED_ACTIVITIES) return RunTimeProblem(RTP_TOOMANYACTS);
	activity_parameters_stack-->activities_sp = o;
	activities_stack-->(activities_sp++) = A;
	FixInhibitFlag();
	MStack_CreateAVVars(A);
	if (Activity_atb_rulebooks->A) { x = action; action = action_to_be; }
	o = ProcessActivityRulebook(Activity_before_rulebooks-->A, o);
	if (Activity_atb_rulebooks->A) action = x;
	return o;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Activities.i6t: For
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ForActivity A o x;
	if (Activity_atb_rulebooks->A) { x = action; action = action_to_be; }
	o = ProcessActivityRulebook(Activity_for_rulebooks-->A, o);
	if (Activity_atb_rulebooks->A) action = x;
	return o;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Activities.i6t: End
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ EndActivity A o rv x;
	if ((activities_sp > 0) && (activities_stack-->(activities_sp-1) == A)) {
		if (Activity_atb_rulebooks->A) { x = action; action = action_to_be; }
		rv = ProcessActivityRulebook(Activity_after_rulebooks-->A, o);
		if (Activity_atb_rulebooks->A) action = x;
		activities_sp--; FixInhibitFlag();
		MStack_DestroyAVVars(A);
		return rv;
	}
	return RunTimeProblem(RTP_CANTABANDON);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Activities.i6t: Abandon
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ AbandonActivity A o;
	if ((activities_sp > 0) && (activities_stack-->(activities_sp-1) == A)) {
		activities_sp--; FixInhibitFlag();
		MStack_DestroyAVVars(A);
		return;
	}
	return RunTimeProblem(RTP_CANTEND);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Figures.i6t: Resource Usage
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Array ResourceUsageFlags ->
	(1+0+5);


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Figures.i6t: Figures
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ DisplayFigure resource_ID one_time;
	if ((one_time) && (ResourceUsageFlags->resource_ID)) return;
	ResourceUsageFlags->resource_ID = true;
	print "^"; VM_Picture(resource_ID); print "^";
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Figures.i6t: Sound Effects
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PlaySound resource_ID one_time;
	if (resource_ID == 0) return; ! The "silence" non-sound effect
	if ((one_time) && (ResourceUsageFlags->resource_ID)) return;
	ResourceUsageFlags->resource_ID = true;
	VM_SoundEffect(resource_ID);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! FileIO.i6t: Language
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#IFDEF PLUGIN_FILES;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! FileIO.i6t: Structure
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant AUXF_MAGIC = 0; ! First word holds a safety constant
Constant AUXF_MAGIC_VALUE = 16339; ! Should be first word of any valid file structure
Constant AUXF_STATUS = 1; ! One of the following:
	Constant AUXF_STATUS_IS_CLOSED = 1; ! Currently closed, or perhaps doesn't exist
	Constant AUXF_STATUS_IS_OPEN_FOR_READ = 2;
	Constant AUXF_STATUS_IS_OPEN_FOR_WRITE = 3;
	Constant AUXF_STATUS_IS_OPEN_FOR_APPEND = 4;
Constant AUXF_BINARY = 2; ! False for text files (I7 default), true for binary
Constant AUXF_STREAM = 3; ! Stream for an open file (meaningless otherwise)
Constant AUXF_FILENAME = 4; ! Packed address of constant string
Constant AUXF_IFID_OF_OWNER = 5; ! UUID_ARRAY if owned by this project, or
	! string array of IFID of owner wrapped in //...//, or NULL to leave open


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! FileIO.i6t: Instances
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant NO_EXTERNAL_FILES 0;
Array TableOfExternalFiles --> 0 0;



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! FileIO.i6t: Errors
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FileIO_Error extf err_text  struc;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES)) {
		print "^*** Error on unknown file: ", (string) err_text, " ***^";
	} else {
		struc = TableOfExternalFiles-->extf;
		print "^*** Error on file '",
			(string) struc-->AUXF_FILENAME, "': ",
			(string) err_text, " ***^";
	}
	RunTimeProblem(RTP_FILEIOERROR);
	return 0;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! FileIO.i6t: Glulx Material
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#IFDEF TARGET_GLULX;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! FileIO.i6t: Existence
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FileIO_Exists extf  fref struc rv usage;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES)) rfalse;
	struc = TableOfExternalFiles-->extf;
	if ((struc == 0) || (struc-->AUXF_MAGIC ~= AUXF_MAGIC_VALUE)) rfalse;
	if (struc-->AUXF_BINARY) usage = fileusage_BinaryMode;
	else usage = fileusage_TextMode;
	fref = glk_fileref_create_by_name(fileusage_Data + usage,
		Glulx_ChangeAnyToCString(struc-->AUXF_FILENAME), 0);
	rv = glk_fileref_does_file_exist(fref);
	glk_fileref_destroy(fref);
	return rv;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! FileIO.i6t: Readiness
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FileIO_Ready extf  struc fref usage str ch;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES)) rfalse;
	struc = TableOfExternalFiles-->extf;
	if ((struc == 0) || (struc-->AUXF_MAGIC ~= AUXF_MAGIC_VALUE)) rfalse;
	if (struc-->AUXF_BINARY) usage = fileusage_BinaryMode;
	else usage = fileusage_TextMode;
	fref = glk_fileref_create_by_name(fileusage_Data + usage,
		Glulx_ChangeAnyToCString(struc-->AUXF_FILENAME), 0);
	if (glk_fileref_does_file_exist(fref) == false) {
		glk_fileref_destroy(fref);
		rfalse;
	}
	str = glk_stream_open_file(fref, filemode_Read, 0);
	ch = glk_get_char_stream(str);
	glk_stream_close(str, 0);
	glk_fileref_destroy(fref);
	if (ch ~= '*') rfalse;
	rtrue;
];

[ FileIO_MarkReady extf readiness  struc fref str ch usage;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES))
		return FileIO_Error(extf, "tried to open a non-file");
	struc = TableOfExternalFiles-->extf;
	if ((struc == 0) || (struc-->AUXF_MAGIC ~= AUXF_MAGIC_VALUE)) rfalse;
	if (struc-->AUXF_BINARY) usage = fileusage_BinaryMode;
	else usage = fileusage_TextMode;
	fref = glk_fileref_create_by_name(fileusage_Data + usage,
		Glulx_ChangeAnyToCString(struc-->AUXF_FILENAME), 0);
	if (glk_fileref_does_file_exist(fref) == false) {
		glk_fileref_destroy(fref);
		return FileIO_Error(extf, "only existing files can be marked");
	}
	if (struc-->AUXF_STATUS ~= AUXF_STATUS_IS_CLOSED) {
		glk_fileref_destroy(fref);
		return FileIO_Error(extf, "only closed files can be marked");
	}
	str = glk_stream_open_file(fref, filemode_ReadWrite, 0);
	glk_stream_set_position(str, 0, 0); ! seek start
	if (readiness) ch = '*'; else ch = '-';
	glk_put_char_stream(str, ch); ! mark as complete
	glk_stream_close(str, 0);
	glk_fileref_destroy(fref);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! FileIO.i6t: Open File
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FileIO_Open extf write_flag append_flag
	struc fref str mode ix ch not_this_ifid owner force_header usage;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES))
		return FileIO_Error(extf, "tried to open a non-file");
	struc = TableOfExternalFiles-->extf;
	if ((struc == 0) || (struc-->AUXF_MAGIC ~= AUXF_MAGIC_VALUE)) rfalse;
	if (struc-->AUXF_STATUS ~= AUXF_STATUS_IS_CLOSED)
		return FileIO_Error(extf, "tried to open a file already open");
	if (struc-->AUXF_BINARY) usage = fileusage_BinaryMode;
	else usage = fileusage_TextMode;
	fref = glk_fileref_create_by_name(fileusage_Data + usage,
		Glulx_ChangeAnyToCString(struc-->AUXF_FILENAME), 0);
	if (write_flag) {
		if (append_flag) {
			mode = filemode_WriteAppend;
			if (glk_fileref_does_file_exist(fref) == false)
				force_header = true;
		}
		else mode = filemode_Write;
	} else {
		mode = filemode_Read;
		if (glk_fileref_does_file_exist(fref) == false) {
			glk_fileref_destroy(fref);
			return FileIO_Error(extf, "tried to open a file which does not exist");
		}
	}
	str = glk_stream_open_file(fref, mode, 0);
	glk_fileref_destroy(fref);
	if (str == 0) return FileIO_Error(extf, "tried to open a file but failed");
	struc-->AUXF_STREAM = str;
	if (write_flag) {
		if (append_flag)
			struc-->AUXF_STATUS = AUXF_STATUS_IS_OPEN_FOR_APPEND;
		else
			struc-->AUXF_STATUS = AUXF_STATUS_IS_OPEN_FOR_WRITE;
		glk_stream_set_current(str);
		if ((append_flag == FALSE) || (force_header)) {
			print "- ";
			for (ix=6: ix <= UUID_ARRAY->0: ix++) print (char) UUID_ARRAY->ix;
			print " ", (string) struc-->AUXF_FILENAME, "^";
		}
	} else {
		struc-->AUXF_STATUS = AUXF_STATUS_IS_OPEN_FOR_READ;
		ch = FileIO_GetC(extf);
		if (ch ~= '-' or '*') { jump BadFile; }
		if (ch == '-')
			return FileIO_Error(extf, "tried to open a file which was incomplete");
		ch = FileIO_GetC(extf);
		if (ch ~= ' ') { jump BadFile; }
		ch = FileIO_GetC(extf);
		if (ch ~= '/') { jump BadFile; }
		ch = FileIO_GetC(extf);
		if (ch ~= '/') { jump BadFile; }
		owner = struc-->AUXF_IFID_OF_OWNER;
		ix = 3;
		if (owner == UUID_ARRAY) ix = 8;
		if (owner ~= NULL) {
			for (: ix <= owner->0: ix++) {
				ch = FileIO_GetC(extf);
				if (ch == -1) { jump BadFile; }
				if (ch ~= owner->ix) not_this_ifid = true;
				if (ch == ' ') break;
			}
			if (not_this_ifid == false) {
				ch = FileIO_GetC(extf);
				if (ch ~= ' ') { jump BadFile; }
			}
		}
		while (ch ~= -1) {
			ch = FileIO_GetC(extf);
			if (ch == 10 or 13) break;
		}
		if (not_this_ifid) {
			struc-->AUXF_STATUS = AUXF_STATUS_IS_CLOSED;
			glk_stream_close(str, 0);
			return FileIO_Error(extf,
				"tried to open a file owned by another project");
		}
	}
	return struc-->AUXF_STREAM;
	.BadFile;
	struc-->AUXF_STATUS = AUXF_STATUS_IS_CLOSED;
	glk_stream_close(str, 0);
	return FileIO_Error(extf, "tried to open a file which seems to be malformed");
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! FileIO.i6t: Close File
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FileIO_Close extf  struc;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES))
		return FileIO_Error(extf, "tried to open a non-file");
	struc = TableOfExternalFiles-->extf;
	if (struc-->AUXF_STATUS ~=
		AUXF_STATUS_IS_OPEN_FOR_READ or
		AUXF_STATUS_IS_OPEN_FOR_WRITE or
		AUXF_STATUS_IS_OPEN_FOR_APPEND)
		return FileIO_Error(extf, "tried to close a file which is not open");
	if ((struc-->AUXF_BINARY == false) &&
		(struc-->AUXF_STATUS ==
		AUXF_STATUS_IS_OPEN_FOR_WRITE or
		AUXF_STATUS_IS_OPEN_FOR_APPEND)) {
		glk_set_window(gg_mainwin);
	}
	if (struc-->AUXF_STATUS ==
		AUXF_STATUS_IS_OPEN_FOR_WRITE or
		AUXF_STATUS_IS_OPEN_FOR_APPEND) {
		glk_stream_set_position(struc-->AUXF_STREAM, 0, 0); ! seek start
		glk_put_char_stream(struc-->AUXF_STREAM, '*'); ! mark as complete
	}
	glk_stream_close(struc-->AUXF_STREAM, 0);
	struc-->AUXF_STATUS = AUXF_STATUS_IS_CLOSED;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! FileIO.i6t: Get Character
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FileIO_GetC extf  struc;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES)) return -1;
	struc = TableOfExternalFiles-->extf;
	if (struc-->AUXF_STATUS ~= AUXF_STATUS_IS_OPEN_FOR_READ) return -1;
	return glk_get_char_stream(struc-->AUXF_STREAM);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! FileIO.i6t: Put Character
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FileIO_PutC extf char  struc;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES)) return -1;
		return FileIO_Error(extf, "tried to write to a non-file");
	struc = TableOfExternalFiles-->extf;
	if (struc-->AUXF_STATUS ~=
		AUXF_STATUS_IS_OPEN_FOR_WRITE or
		AUXF_STATUS_IS_OPEN_FOR_APPEND)
		return FileIO_Error(extf,
			"tried to write to a file which is not open for writing");
	return glk_put_char_stream(struc-->AUXF_STREAM, char);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! FileIO.i6t: Print Line
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FileIO_PrintLine extf ch  struc;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES))
		return FileIO_Error(extf, "tried to write to a non-file");
	struc = TableOfExternalFiles-->extf;
	for (::) {
		ch = FileIO_GetC(extf);
		if (ch == -1) rfalse;
		if (ch == 10 or 13) { print "^"; rtrue; }
		print (char) ch;
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! FileIO.i6t: Print Contents
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FileIO_PrintContents extf tab  struc;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES))
		return FileIO_Error(extf, "tried to access a non-file");
	struc = TableOfExternalFiles-->extf;
	if (struc-->AUXF_BINARY)
		return FileIO_Error(extf, "printing text will not work with binary files");
	if (FileIO_Open(extf, false) == 0) rfalse;
	while (FileIO_PrintLine(extf)) ;
	FileIO_Close(extf);
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! FileIO.i6t: Print Text
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FileIO_PutContents extf text append_flag  struc str ch;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES))
		return FileIO_Error(extf, "tried to access a non-file");
	struc = TableOfExternalFiles-->extf;
	if (struc-->AUXF_BINARY)
		return FileIO_Error(extf, "writing text will not work with binary files");
	str = FileIO_Open(extf, true, append_flag);
	if (str == 0) rfalse;
	@push say__p; @push say__pc;
	ClearParagraphing(19);
	TEXT_TY_Say(text);
	FileIO_Close(extf);
	@pull say__pc; @pull say__p;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! FileIO.i6t: Serialising Tables
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FileIO_PutTable extf tab rv  struc;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES))
		return FileIO_Error(extf, "tried to write table to a non-file");
	struc = TableOfExternalFiles-->extf;
	if (struc-->AUXF_BINARY)
		return FileIO_Error(extf, "writing a table will not work with binary files");
	if (FileIO_Open(extf, true) == 0) rfalse;
	rv = TablePrint(tab);
	FileIO_Close(extf);
	if (rv) return RunTimeProblem(RTP_TABLE_CANTSAVE, tab);
	rtrue;
];

[ FileIO_GetTable extf tab  struc;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES))
		return FileIO_Error(extf, "tried to read table from a non-file");
	struc = TableOfExternalFiles-->extf;
	if (struc-->AUXF_BINARY)
		return FileIO_Error(extf, "reading a table will not work with binary files");
	if (FileIO_Open(extf, false) == 0) rfalse;
	TableRead(tab, extf);
	FileIO_Close(extf);
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! FileIO.i6t: Z-Machine Stubs
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#IFNOT; ! TARGET_GLULX
[ FileIO_Exists extf; rfalse; ];
[ FileIO_Ready extf; rfalse; ];
[ FileIO_GetC extf; return -1; ];
[ FileIO_PutTable extf tab;
	return FileIO_Error(extf, "external files can only be used under Glulx");
];
[ FileIO_MarkReady extf status; FileIO_PutTable(extf); ];
[ FileIO_GetTable extf tab; FileIO_PutTable(extf); ];
[ FileIO_PrintContents extf; FileIO_PutTable(extf); ];
[ FileIO_PutContents extf; FileIO_PutTable(extf); ];
#ENDIF; ! TARGET_GLULX


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! FileIO.i6t: Back To Core
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#IFNOT; ! PLUGIN_FILES
[ FileIO_GetC extf; return -1; ];
#ENDIF; ! PLUGIN_FILES


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! MStack.i6t: The Memory Stack
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant MAX_MSTACK_FRAME = 2 + 6;
Constant MSTACK_CAPACITY = 20;
Constant MSTACK_SIZE = MSTACK_CAPACITY*MAX_MSTACK_FRAME;

Array MStack --> MSTACK_SIZE;
Global MStack_Top = 0; ! Topmost word currently used


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! MStack.i6t: Create Frame
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ Mstack_Create_Frame creator id extent;
	if (creator == 0) rfalse;
	extent = creator.call(MStack_Top+2, 1);
	if (extent == 0) rfalse;
	if (MStack_Top + MAX_MSTACK_FRAME >= MSTACK_SIZE + 2) {
		RunTimeProblem(RTP_MSTACKMEMORY, MSTACK_SIZE);
		Mstack_Backtrace();
		rfalse;
	}
	MStack_Top++;
	MStack-->MStack_Top = id;
	MStack_Top++;
	MStack_Top = MStack_Top + extent;
	MStack-->MStack_Top = -(extent+2);
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! MStack.i6t: Destroy Frame
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ Mstack_Destroy_Frame creator id pos;
	pos = Mstack_Seek_Frame(id);
	if (pos == 0) rfalse; ! Not found: do nothing
	MStack_Top = pos - 2; ! Clear mstack down to just below this frame
	if (creator) creator.call(pos, -1);
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! MStack.i6t: Seek Frame
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Global MStack_Frame_Extent = 0;

[ Mstack_Seek_Frame id pos;
	pos = MStack_Top;
	while ((pos > 0) && (MStack-->pos ~= 0)) {
		MStack_Frame_Extent = MStack-->pos;
		pos = pos + MStack_Frame_Extent;
		MStack_Frame_Extent = (-2) - MStack_Frame_Extent;
		if (MStack-->(pos+1) == id) return pos+2;
	}
	MStack_Frame_Extent = 0;
	return 0; ! Not found
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! MStack.i6t: Backtrace
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ Mstack_Backtrace pos k;
	print "Mstack backtrace: size ", MStack_Top+1, " words^";
	pos = MStack_Top;
	while (MStack-->pos ~= 0) {
		MStack_Frame_Extent = MStack-->pos;
		pos = pos + MStack_Frame_Extent;
		MStack_Frame_Extent = (-2) - MStack_Frame_Extent;
		print "Block at ", pos+2,
			" owner ID ", MStack-->(pos+1), " size ", MStack_Frame_Extent, "^";
		for (k=0: k<MStack_Frame_Extent: k++) print MStack-->(pos+2+k), " ";
		print "^";
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! MStack.i6t: Access to Variables
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ MstVO id off pos;
	pos = Mstack_Seek_Frame(id);
	if (pos == 0) {
		print "Variable unavailable for this action, activity or rulebook: ",
			"internal ID number ",
			id, "/", off, "^";
		rfalse;
	}
	if ((off<0) || (off >= MStack_Frame_Extent)) {
		print "Variable stack offset wrong: ", id, "/", off, " at ", pos, "^";
		rfalse;
	}
	return pos+off;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! MStack.i6t: Access to Nonexistent Variables
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ MstVON id off pos;
	pos = Mstack_Seek_Frame(id);
	if (pos == 0) {
		return 0; ! word position 0 on the M-stack
	}
	if ((off<0) || (off >= MStack_Frame_Extent)) {
		print "Variable stack offset wrong: ", id, "/", off, " at ", pos, "^";
		rfalse;
	}
	return pos+off;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! MStack.i6t: Rulebook Variables
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#IFNDEF MEMORY_ECONOMY;
Array rulebook_var_creators --> 0 0 0 0 0 0 0 0 0 RBSTVC_9 0 RBSTVC_11 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0;
#endif;
[  RBSTVC_9 
    pos ! Implied call parameter
    state ! Implied call parameter
    ;
    if (state == 1) {
        MStack-->pos = selfobj; pos++;
    } else {
        pos++;
    }
    return 1;
];
[  RBSTVC_11 
    pos ! Implied call parameter
    state ! Implied call parameter
    ;
    if (state == 1) {
        MStack-->pos = false; pos++;
        MStack-->pos = false; pos++;
        MStack-->pos = 0; pos++;
        MStack-->pos = 0; pos++;
        MStack-->pos = 0; pos++;
        MStack-->pos = false; pos++;
    } else {
        pos++;
        pos++;
        pos++;
        pos++;
        pos++;
        pos++;
    }
    return 6;
];


[ MStack_CreateRBVars rb cr;
#ifdef MEMORY_ECONOMY;
switch (rb) {
9: cr = RBSTVC_9;
11: cr = RBSTVC_11;
}
#IFNOT;
cr = rulebook_var_creators-->rb;
#endif;

	if (cr == 0) return;
	Mstack_Create_Frame(cr, rb);
];

[ MStack_DestroyRBVars rb cr;
#ifdef MEMORY_ECONOMY;
switch (rb) {
9: cr = RBSTVC_9;
11: cr = RBSTVC_11;
}
#IFNOT;
cr = rulebook_var_creators-->rb;
#endif;

	if (cr == 0) return;
	Mstack_Destroy_Frame(cr, rb);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! MStack.i6t: Activity Variables
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Array activity_var_creators --> 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0;


[ MStack_CreateAVVars av cr;
	cr = activity_var_creators-->av;
	if (cr == 0) return;
	Mstack_Create_Frame(cr, av + 10000);
];

[ MStack_DestroyAVVars av cr;
	cr = activity_var_creators-->av;
	if (cr == 0) return;
	Mstack_Destroy_Frame(cr, av + 10000);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OutOfWorld.i6t: Perform Undo
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ Perform_Undo;
	#ifdef PREVENT_UNDO; IMMEDIATELY_UNDO_RM('A'); new_line; return; #endif;
	if (IterationsOfTurnSequence == 0) { IMMEDIATELY_UNDO_RM('B'); new_line; return; }
	if (undo_flag == 0) { IMMEDIATELY_UNDO_RM('C'); new_line; return; }
	if (undo_flag == 1) { IMMEDIATELY_UNDO_RM('D'); new_line; return; }
	if (VM_Undo() == 0) { IMMEDIATELY_UNDO_RM('A'); new_line; }
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OutOfWorld.i6t: Announce Score Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ANNOUNCE_SCORE_R;
	if (actor ~= player) rfalse;
	#Iftrue USE_SCORING == 0; ANNOUNCE_SCORE_RM('C'); new_line;
	#ifnot; ANNOUNCE_SCORE_RM('A'); PrintRank();
	#endif;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OutOfWorld.i6t: Switch Score Notification On Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SWITCH_SCORE_NOTIFY_ON_R;
	if (actor ~= player) rfalse;
	#Iftrue USE_SCORING == 0; ANNOUNCE_SCORE_R();
	#ifnot; notify_mode=1; #endif;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OutOfWorld.i6t: Standard Report Switching Score Notification On Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ REP_SWITCH_NOTIFY_ON_R;
	if (actor ~= player) rfalse;
	#Iftrue USE_SCORING ~= 0; REP_SWITCH_NOTIFY_ON_RM('A'); new_line; #endif;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OutOfWorld.i6t: Switch Score Notification Off Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SWITCH_SCORE_NOTIFY_OFF_R;
	if (actor ~= player) rfalse;
	#Iftrue USE_SCORING == 0; ANNOUNCE_SCORE_R();
	#ifnot; notify_mode=0; #endif;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OutOfWorld.i6t: Standard Report Switching Score Notification Off Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ REP_SWITCH_NOTIFY_OFF_R;
	if (actor ~= player) rfalse;
	#Iftrue USE_SCORING ~= 0; REP_SWITCH_NOTIFY_OFF_RM('A'); new_line; #endif;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OutOfWorld.i6t: Prefer Sometimes Abbreviated Room Descriptions Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PREFER_SOMETIMES_ABBREVIATED_R;
	if (actor ~= player) rfalse;
	lookmode=1;
]; ! Brief


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OutOfWorld.i6t: Standard Report Prefer Sometimes Abbreviated Room Descriptions Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ REP_PREFER_SOMETIMES_ABBR_R;
	if (actor ~= player) rfalse;
	print (TEXT_TY_Say) Story; REP_PREFER_SOMETIMES_ABBR_RM('A'); new_line;
]; ! Brief


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OutOfWorld.i6t: Prefer Unabbreviated Room Descriptions Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PREFER_UNABBREVIATED_R;
	if (actor ~= player) rfalse;
	lookmode=2;
]; ! Verbose


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OutOfWorld.i6t: Standard Report Prefer Unabbreviated Room Descriptions Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ REP_PREFER_UNABBREVIATED_R;
	if (actor ~= player) rfalse;
	print (TEXT_TY_Say) Story; REP_PREFER_UNABBREVIATED_RM('A'); new_line;
]; ! Verbose


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OutOfWorld.i6t: Prefer Abbreviated Room Descriptions Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PREFER_ABBREVIATED_R;
	if (actor ~= player) rfalse;
	lookmode=3;
]; ! Superbrief


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OutOfWorld.i6t: Standard Report Prefer Abbreviated Room Descriptions Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ REP_PREFER_ABBREVIATED_R;
	if (actor ~= player) rfalse;
	print (TEXT_TY_Say) Story; REP_PREFER_ABBREVIATED_RM('A'); new_line;
]; ! Superbrief


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OutOfWorld.i6t: Announce Pronoun Meanings Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ANNOUNCE_PRONOUN_MEANINGS_R x y c d;
	if (actor ~= player) rfalse;
	ANNOUNCE_PRONOUN_MEANINGS_RM('A');

	c = (LanguagePronouns-->0)/3;
	if (player ~= selfobj) c++;

	if (c==0) { ANNOUNCE_PRONOUN_MEANINGS_RM('D'); rtrue; }

	for (x = 1, d = 0 : x <= LanguagePronouns-->0: x = x+3) {
		print "~", (address) LanguagePronouns-->x, "~ ";
		y = LanguagePronouns-->(x+2);
		if (y == NULL) ANNOUNCE_PRONOUN_MEANINGS_RM('C');
		else { ANNOUNCE_PRONOUN_MEANINGS_RM('B'); print (the) y; }
		d++;
		if (d < c-1) print ", ";
		if (d == c-1) {
			#ifdef SERIAL_COMMA; print ","; #endif;
			LIST_WRITER_INTERNAL_RM('C');
		}
	}
	if (player ~= selfobj) {
		print "~", (address) ME1__WD, "~ "; ANNOUNCE_PRONOUN_MEANINGS_RM('B');
		c = player; player = selfobj;
		print (the) c; player = c;
	}
	".";
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Printing.i6t: Paragraph Control
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Printing.i6t: State
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

!Constant TRACE_I7_SPACING;

[ ClearParagraphing r;
	say__p = 0; say__pc = 0;
];

[ DivideParagraphPoint;
	#ifdef TRACE_I7_SPACING; print "[DPP", say__p, say__pc, "]"; #endif;
	if (say__p) {
		new_line; say__p = 0; say__pc = say__pc | PARA_COMPLETED;
		say__pc_save = true;
		if (say__pc & PARA_PROMPTSKIP) say__pc = say__pc - PARA_PROMPTSKIP;
		if (say__pc & PARA_SUPPRESSPROMPTSKIP) say__pc = say__pc - PARA_SUPPRESSPROMPTSKIP;
	}
	#ifdef TRACE_I7_SPACING; print "[-->", say__p, say__pc, "]"; #endif;
	say__pc = say__pc | PARA_CONTENTEXPECTED;
	say__pc_save = (say__pc & PARA_COMPLETED);
];

[ AdjustParagraphPoint;
	#ifdef TRACE_I7_SPACING; print "[APP ", say__p, " ", say__pc, " ", say__pc_save, "]^"; #endif;
	if (say__pc_save) say__pc = (say__pc | PARA_COMPLETED);
];

[ ParaContent;
	if (say__pc & PARA_CONTENTEXPECTED) {
		say__pc = say__pc - PARA_CONTENTEXPECTED;
		say__p = 1;
	}
];

[ GoingLookBreak;
	if (say__pc & PARA_COMPLETED == 0) new_line;
	ClearParagraphing(10);
];

[ CommandClarificationBreak;
	new_line;
	ClearParagraphing(11);
];

[ RunParagraphOn;
	#ifdef TRACE_I7_SPACING; print "[RPO", say__p, say__pc, "]"; #endif;
	say__p = 0;
	say__pc = say__pc | PARA_PROMPTSKIP;
	say__pc = say__pc | PARA_SUPPRESSPROMPTSKIP;
];

[ SpecialLookSpacingBreak;
	#ifdef TRACE_I7_SPACING; print "[SLS", say__p, say__pc, "]"; #endif;
	say__p = 0;
	say__pc = say__pc | PARA_PROMPTSKIP;
];

[ EnsureBreakBeforePrompt;
	if ((say__p) ||
		((say__pc & PARA_PROMPTSKIP) && ((say__pc & PARA_SUPPRESSPROMPTSKIP)==0)))
		new_line;
	ClearParagraphing(12);
];

[ PrintSingleParagraph matter;
	say__p = 1;
	say__pc = say__pc | PARA_NORULEBOOKBREAKS;
	TEXT_TY_Say(matter);
	DivideParagraphPoint(13);
	say__pc = 0;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Printing.i6t: Say Number
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ STextSubstitution;
	if (say__n ~= 1) print "s";
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Printing.i6t: Prompt
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PrintPrompt i;
	RunTimeProblemShow();
	ClearRTP();
	style roman;
	EnsureBreakBeforePrompt();
	TEXT_TY_Say( (Global_Vars-->1) );
	ClearBoxedText();
	ClearParagraphing(14);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Printing.i6t: Boxed Quotations
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Global pending_boxed_quotation; ! a routine to overlay the quotation on screen

[ DisplayBoxedQuotation Q;
	pending_boxed_quotation = Q;
];

[ ClearBoxedText i;
	if (pending_boxed_quotation) {
		for (i=0: Runtime_Quotations_Displayed-->i: i++)
			if (Runtime_Quotations_Displayed-->i == pending_boxed_quotation) {
				pending_boxed_quotation = 0;
				return;
			}
		Runtime_Quotations_Displayed-->i = pending_boxed_quotation;

		ClearParagraphing(15);
		pending_boxed_quotation();
		ClearParagraphing(16);

		pending_boxed_quotation = 0;
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Printing.i6t: Score Notification
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ NotifyTheScore d;
#Iftrue USE_SCORING ~= 0;
	if (notify_mode == 1) {
		DivideParagraphPoint();
		VM_Style(NOTE_VMSTY);
		d = score-last_score;
		if (d > 0) { ANNOUNCE_SCORE_RM('D', d); }
		else if (d < 0) { ANNOUNCE_SCORE_RM('E', -d); }
		new_line;
		VM_Style(NORMAL_VMSTY);
	}
#Endif;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Printing.i6t: Status Line
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#Ifdef TARGET_ZCODE;
#Iftrue (#version_number == 6);
[ DrawStatusLine; Z6_DrawStatusLine(); ];
#Endif;
#Endif;

#Ifndef DrawStatusLine;
[ DrawStatusLine width posb;
	@push say__p; @push say__pc;
	BeginActivity(CONSTRUCTING_STATUS_LINE_ACT);
	VM_StatusLineHeight(1); VM_MoveCursorInStatusLine(1, 1); 
	if (statuswin_current) {
		width = VM_ScreenWidth(); posb = width-15;
		spaces width;
		ClearParagraphing(17);
		if (ForActivity(CONSTRUCTING_STATUS_LINE_ACT) == false) {
			VM_MoveCursorInStatusLine(1, 2);
			TEXT_TY_Say(left_hand_status_line);
			VM_MoveCursorInStatusLine(1, posb);
			TEXT_TY_Say(right_hand_status_line);
		}
		VM_MoveCursorInStatusLine(1, 1); VM_MainWindow();
	}
	ClearParagraphing(18);
	EndActivity(CONSTRUCTING_STATUS_LINE_ACT);
	@pull say__pc; @pull say__p;
];
#Endif;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Printing.i6t: Status Line Utilities
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Array T_SL_Score_Moves --> CONSTANT_PACKED_TEXT_STORAGE SL_Score_Moves;

[ SL_Score_Moves;
	if (not_yet_in_play) return;
	#Iftrue USE_SCORING > 0; print sline1, "/", sline2; #endif;
];

Array T_SL_Location --> CONSTANT_PACKED_TEXT_STORAGE SL_Location;

[ SL_Location even_before;
	if ((not_yet_in_play) && (even_before == false)) return;
	if (location == thedark) {
		BeginActivity(PRINTING_NAME_OF_DARK_ROOM_ACT);
		if (ForActivity(PRINTING_NAME_OF_DARK_ROOM_ACT) == false)
 			DARKNESS_NAME_INTERNAL_RM('A');
		EndActivity(PRINTING_NAME_OF_DARK_ROOM_ACT);
	} else {
		FindVisibilityLevels();
		if (visibility_ceiling == location) print (name) location;
		else print (The) visibility_ceiling;
	}
];

[ DARKNESS_NAME_INTERNAL_R; ];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Printing.i6t: Banner
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ Banner;
   BeginActivity(PRINTING_BANNER_TEXT_ACT);
   if (ForActivity(PRINTING_BANNER_TEXT_ACT) == false) {
	   	VM_Style(HEADER_VMSTY);
		TEXT_TY_Say(Story);
		VM_Style(NORMAL_VMSTY);
		new_line;
		TEXT_TY_Say(Headline);
		#ifdef Story_Author;
		print " by "; TEXT_TY_Say(Story_Author);
		#endif; ! Story_Author
		new_line;
		VM_Describe_Release();
		print " / Inform 7 build ", (PrintI6Text) NI_BUILD_COUNT, " ";
		print "(I6/v"; inversion;
		print " lib ", (PrintI6Text) LibRelease, ") ";
		#Ifdef STRICT_MODE;
		print "S";
		#Endif; ! STRICT_MODE
		#Ifdef DEBUG;
		print "D";
		#Endif; ! DEBUG
		new_line;
    }
    EndActivity(PRINTING_BANNER_TEXT_ACT);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Printing.i6t: Print Decimal Number
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ DecimalNumber num; print num; ];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Printing.i6t: Print English Number
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ EnglishNumber n; LanguageNumber(n); ];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Printing.i6t: Print Text
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PrintI6Text x;
	if (x ofclass String) print (string) x;
	if (x ofclass Routine) return (x)();
	if (x == EMPTY_TEXT_PACKED) rfalse;
	rtrue;
];
[ I7_String x; TEXT_TY_Say(x); ]; ! An alternative name now used only by extensions


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Printing.i6t: Print Or Run
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PrintOrRun obj prop no_break  pv st routine_return_value;
	@push self; self = obj;
	if (prop == 0) {
		print (name) prop; routine_return_value = true;
	} else {
		routine_return_value = TEXT_TY_Say(obj.prop);
	}
	@pull self;
	if (routine_return_value) {
		say__p = 1;
		if (no_break == false) {
			new_line;
			DivideParagraphPoint();
		}
	}

	return routine_return_value;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Printing.i6t: Short Name Storage
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Array StorageForShortName buffer 250;

[ CPrintOrRun obj prop  v length i;
    if ((obj ofclass String or Routine) || (prop == 0))
        VM_PrintToBuffer (StorageForShortName, 160, obj);
    else {
    	if (obj.prop == NULL) rfalse;
        if (metaclass(obj.prop) == Routine or String)
            VM_PrintToBuffer(StorageForShortName, 160, obj, prop);
        else return RunTimeError(2, obj, prop);
	}

    length = StorageForShortName-->0;

    StorageForShortName->WORDSIZE = VM_LowerToUpperCase(StorageForShortName->WORDSIZE);
    for (i=WORDSIZE: i<length+WORDSIZE: i++) print (char) StorageForShortName->i;
    if (i>WORDSIZE) say__p = 1;

    return;
];

[ Cap str nocaps;
    if (nocaps) print (string) str;
    else CPrintOrRun(str, 0);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Printing.i6t: Object Names I
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PSN__ o;
    if (o == 0) { LIST_WRITER_INTERNAL_RM('Y'); rtrue; }
    switch (metaclass(o)) {
		Routine:  print "<routine ", o, ">"; rtrue;
		String:   print "<string ~", (string) o, "~>"; rtrue;
		nothing:  print "<illegal object number ", o, ">"; rtrue;
    }
    RegardingSingleObject(o);
    CarryOutActivity(PRINTING_THE_NAME_ACT, o);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Printing.i6t: Standard Name Printing Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Global caps_mode = false;

[ STANDARD_NAME_PRINTING_R obj;
	obj = parameter_value;
    if (obj == 0) {
    	LIST_WRITER_INTERNAL_RM('Y'); return;
    }
    switch (metaclass(obj)) {
		Routine:  print "<routine ", obj, ">"; return;
		String:   print "<string ~", (string) obj, "~>"; return;
		nothing:  print "<illegal object number ", obj, ">"; return;
    }
    if (obj == player) { 
   	    if (indef_mode == NULL && caps_mode) PRINT_PROTAGONIST_INTERNAL_RM('A');
   	    else PRINT_PROTAGONIST_INTERNAL_RM('B');
   	    return;
   	}
    #Ifdef LanguagePrintShortName;
    if (LanguagePrintShortName(obj)) return;
    #Endif; ! LanguagePrintShortName
    if (indef_mode && obj.&short_name_indef ~= 0 &&
    	PrintOrRun(obj, short_name_indef, true) ~= 0) return;
    if (caps_mode &&
    	obj.&cap_short_name ~= 0 && PrintOrRun(obj, cap_short_name, true) ~= 0) {
    	caps_mode = false;
    	return;
    }
    if (obj.&short_name ~= 0 && PrintOrRun(obj, short_name, true) ~= 0) return;
    print (object) obj;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Printing.i6t: Internal Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PRINT_PROTAGONIST_INTERNAL_R; ];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Printing.i6t: Object Names II
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Global short_name_case;

[ PrefaceByArticle obj acode pluralise capitalise  i artform findout artval;
    if (obj provides articles) {
        artval=(obj.&articles)-->(acode+short_name_case*LanguageCases);
        if (capitalise)
            print (Cap) artval, " ";
        else
            print (string) artval, " ";
        if (pluralise) return;
        print (PSN__) obj; return;
    }

    i = GetGNAOfObject(obj);
    if (pluralise) {
        if (i < 3 || (i >= 6 && i < 9)) i = i + 3;
    }
    i = LanguageGNAsToArticles-->i;

    artform = LanguageArticles
        + 3*WORDSIZE*LanguageContractionForms*(short_name_case + i*LanguageCases);

    #Iftrue (LanguageContractionForms == 2);
    if (artform-->acode ~= artform-->(acode+3)) findout = true;
    #Endif; ! LanguageContractionForms
    #Iftrue (LanguageContractionForms == 3);
    if (artform-->acode ~= artform-->(acode+3)) findout = true;
    if (artform-->(acode+3) ~= artform-->(acode+6)) findout = true;
    #Endif; ! LanguageContractionForms
    #Iftrue (LanguageContractionForms == 4);
    if (artform-->acode ~= artform-->(acode+3)) findout = true;
    if (artform-->(acode+3) ~= artform-->(acode+6)) findout = true;
    if (artform-->(acode+6) ~= artform-->(acode+9)) findout = true;
    #Endif; ! LanguageContractionForms
    #Iftrue (LanguageContractionForms > 4);
    findout = true;
    #Endif; ! LanguageContractionForms

    #Ifdef TARGET_ZCODE;
    if (standard_interpreter ~= 0 && findout) {
        StorageForShortName-->0 = 160;
        @output_stream 3 StorageForShortName;
        if (pluralise) print (number) pluralise; else print (PSN__) obj;
        @output_stream -3;
        acode = acode + 3*LanguageContraction(StorageForShortName + 2);
    }
    #Ifnot; ! TARGET_GLULX
    if (findout) {
        if (pluralise)
            Glulx_PrintAnyToArray(StorageForShortName, 160, EnglishNumber, pluralise);
        else
            Glulx_PrintAnyToArray(StorageForShortName, 160, PSN__, obj);
        acode = acode + 3*LanguageContraction(StorageForShortName);
    }
    #Endif; ! TARGET_

    Cap (artform-->acode, ~~capitalise); ! print article
    if (pluralise) return;
    print (PSN__) obj;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Printing.i6t: Object Names III
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ IndefArt obj i;
	if (obj == 0) { LIST_WRITER_INTERNAL_RM('Y'); rtrue; }
    i = indef_mode; indef_mode = true;
    if (obj has proper) { indef_mode = NULL; print (PSN__) obj; indef_mode = i; return; }
    if ((obj provides article) && (TEXT_TY_Compare(obj.article, EMPTY_TEXT_VALUE) ~= 0)) {
        PrintOrRun(obj, article, true); print " ", (PSN__) obj; indef_mode = i;
        return;
    }
    PrefaceByArticle(obj, 2); indef_mode = i;
];

[ CIndefArt obj i;
	if (obj == 0) { LIST_WRITER_INTERNAL_RM('X'); rtrue; }
    i = indef_mode; indef_mode = true;
    if (obj has proper) {
    	indef_mode = NULL;
		caps_mode = true;
    	print (PSN__) obj;
    	indef_mode = i;
    	caps_mode = false;
    	return;
    }
    if ((obj provides article) && (TEXT_TY_Compare(obj.article, EMPTY_TEXT_VALUE) ~= 0)) {
        TEXT_TY_Say_Capitalised(obj.article); print " ", (PSN__) obj; indef_mode = i;
        return;
    }
    PrefaceByArticle(obj, 2, 0, 1); indef_mode = i;
];

[ DefArt obj i;
    i = indef_mode; indef_mode = false;
    if ((~~obj ofclass Object) || obj has proper) {
        indef_mode = NULL; print (PSN__) obj; indef_mode = i;
        return;
    }
    PrefaceByArticle(obj, 1); indef_mode = i;
];

[ CDefArt obj i;
    i = indef_mode; indef_mode = false;
    if ((obj ofclass Object) && (obj has proper || obj == player)) {
    	indef_mode = NULL;
    	caps_mode = true;
    	print (PSN__) obj;
    	indef_mode = i;
    	caps_mode = false;
    	return;
    }
    if ((~~obj ofclass Object) || obj has proper) {
        indef_mode = NULL; print (PSN__) obj; indef_mode = i;
        return;
    }
    PrefaceByArticle(obj, 0); indef_mode = i;
];

[ PrintShortName obj i;
    i = indef_mode; indef_mode = NULL;
    PSN__(obj); indef_mode = i;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Printing.i6t: Say One Of
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ I7_SOO_PAR oldval count; if (count <= 1) return count; return random(count); ];
[ I7_SOO_RAN oldval count v; if (count <= 1) return count;
	v = oldval; while (v == oldval) v = random(count); return v; ];
[ I7_SOO_STI oldval count v; if (oldval) return oldval; return I7_SOO_PAR(oldval, count); ];
[ I7_SOO_CYC oldval count; oldval++; if (oldval > count) oldval = 1; return oldval; ];
[ I7_SOO_STOP oldval count; oldval++; if (oldval > count) oldval = count; return oldval; ];
[ I7_SOO_TAP oldval count tn rn c; if (count <= 1) return count; tn = count*(count+1)/2;
	rn = random(tn); for (c=1:c<=count:c++) { rn = rn - c; if (rn<=0) return (count-c+1); } ];
[ I7_SOO_TRAN oldval count; if (oldval<count) return oldval+1; 
	return count + 1 + I7_SOO_RAN(oldval%(count+1), count); ];
[ I7_SOO_TPAR oldval count; if (oldval<count) return oldval+1; 
	return count + 1 + I7_SOO_PAR(oldval%(count+1), count); ];

Array I7_SOO_SHUF->32;

[ I7_SOO_SHU oldval count sd ct v i j s ssd scope cc base;
	base = count+1;
	v = oldval%base; oldval = oldval/base; ct = oldval%base; sd = oldval/base;
	if (count > 32) return I7_SOO_PAR(oldval, count);
	if (count <= 1) v = count;
	else {
		!print "^In v=", v, " ct=", ct, " sd=", sd, "^";
		cc = base*base;
		scope = (MAX_POSITIVE_NUMBER-1)/cc;
		!print "Scope = ", scope, "^";
		if (sd == 0) { sd = random(scope); ct=0; }
		for (i=0:i<count:i++) I7_SOO_SHUF->i = i;
		ssd = sd;
		for (i=0:i<count-1:i++) {
			j = (sd)%(count-i)+i; sd = (sd*31973)+17; if (sd<0) sd=-sd;
			s = I7_SOO_SHUF->j; I7_SOO_SHUF->j = I7_SOO_SHUF->i; I7_SOO_SHUF->i = s;
		}
		!for (i=0:i<count:i++) print I7_SOO_SHUF->i, " "; print "^";
		v = (I7_SOO_SHUF->ct)+1;
		ct++; if (ct >= count) { ct = 0; ssd = 0; }
	}
	!print "Out v=", v, " ct=", ct, " ssd=", sd, "^";
	!print "Return ", v + ct*base + ssd*base*base, "^";
	return v + ct*base + ssd*base*base;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Relations.i6t: Relation Records
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant RR_NAME     		5;
Constant RR_PERMISSIONS		6;
Constant RR_STORAGE			7;
Constant RR_KIND			8;
Constant RR_HANDLER			9;
Constant RR_DESCRIPTION		10;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Relations.i6t: Valency Adjectives
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant VALENCY_MASK = RELS_EQUIVALENCE+RELS_SYMMETRIC+RELS_X_UNIQUE+RELS_Y_UNIQUE;
[ RELATION_TY_EquivalenceAdjective rel set  perms state handler;
	perms = RlnGetF(rel, RR_PERMISSIONS);
	if (perms & RELS_EQUIVALENCE) state = true;
	if (set < 0) return state;
	if ((set) && (state == false)) {
		perms = perms + RELS_EQUIVALENCE;
		if (perms & RELS_SYMMETRIC == 0) perms = perms + RELS_SYMMETRIC;
	}
	if ((set == false) && (state)) {
		perms = perms - RELS_EQUIVALENCE;
		if (perms & RELS_SYMMETRIC) perms = perms - RELS_SYMMETRIC;
	}
	RlnSetF(rel, RR_PERMISSIONS, perms);
	handler = RlnGetF(rel, RR_HANDLER);
	if (handler(rel, RELS_SET_VALENCY, perms & VALENCY_MASK) == 0)
		"*** Can't change this to an equivalence relation ***";		
];

[ RELATION_TY_SymmetricAdjective rel set  perms state handler;
	perms = RlnGetF(rel, RR_PERMISSIONS);
	if (perms & RELS_SYMMETRIC) state = true;
	if (set < 0) return state;
	if ((set) && (state == false)) perms = perms + RELS_SYMMETRIC;
	if ((set == false) && (state)) perms = perms - RELS_SYMMETRIC;
	RlnSetF(rel, RR_PERMISSIONS, perms);
	handler = RlnGetF(rel, RR_HANDLER);
	if (handler(rel, RELS_SET_VALENCY, perms & VALENCY_MASK) == 0)
		"*** Can't change this to a symmetric relation ***";		
];

[ RELATION_TY_OToOAdjective rel set  perms state handler i;
	perms = RlnGetF(rel, RR_PERMISSIONS);
	if (perms & (RELS_X_UNIQUE+RELS_Y_UNIQUE) == RELS_X_UNIQUE+RELS_Y_UNIQUE) state = true;
	if (set < 0) return state;
	if ((set) && (state == false)) {
		if (perms & RELS_X_UNIQUE == 0) perms = perms + RELS_X_UNIQUE;
		if (perms & RELS_Y_UNIQUE == 0) perms = perms + RELS_Y_UNIQUE;
		if (perms & RELS_EQUIVALENCE) perms = perms - RELS_EQUIVALENCE;
	}
	if ((set == false) && (state)) {
		if (perms & RELS_X_UNIQUE) perms = perms - RELS_X_UNIQUE;
		if (perms & RELS_Y_UNIQUE) perms = perms - RELS_Y_UNIQUE;
	}
	RlnSetF(rel, RR_PERMISSIONS, perms);
	handler = RlnGetF(rel, RR_HANDLER);
	if (handler(rel, RELS_SET_VALENCY, perms & VALENCY_MASK) == 0)
		"*** Can't change this to a one-to-one relation ***";		
];

[ RELATION_TY_OToVAdjective rel set  perms state handler;
	perms = RlnGetF(rel, RR_PERMISSIONS);
	if (perms & (RELS_X_UNIQUE+RELS_Y_UNIQUE) == RELS_X_UNIQUE) state = true;
	if (set < 0) return state;
	if ((set) && (state == false)) {
		if (perms & RELS_X_UNIQUE == 0) perms = perms + RELS_X_UNIQUE;
		if (perms & RELS_Y_UNIQUE) perms = perms - RELS_Y_UNIQUE;
		if (perms & RELS_SYMMETRIC) perms = perms - RELS_SYMMETRIC;
		if (perms & RELS_EQUIVALENCE) perms = perms - RELS_EQUIVALENCE;
	}
	if ((set == false) && (state)) {
		if (perms & RELS_X_UNIQUE) perms = perms - RELS_X_UNIQUE;
		if (perms & RELS_Y_UNIQUE) perms = perms - RELS_Y_UNIQUE;
	}
	RlnSetF(rel, RR_PERMISSIONS, perms);
	handler = RlnGetF(rel, RR_HANDLER);
	if (handler(rel, RELS_SET_VALENCY, perms & VALENCY_MASK) == 0)
		"*** Can't change this to a one-to-various relation ***";		
];

[ RELATION_TY_VToOAdjective rel set  perms state handler;
	perms = RlnGetF(rel, RR_PERMISSIONS);
	if (perms & (RELS_X_UNIQUE+RELS_Y_UNIQUE) == RELS_Y_UNIQUE) state = true;
	if (set < 0) return state;
	if ((set) && (state == false)) {
		if (perms & RELS_X_UNIQUE) perms = perms - RELS_X_UNIQUE;
		if (perms & RELS_Y_UNIQUE == 0) perms = perms + RELS_Y_UNIQUE;
		if (perms & RELS_SYMMETRIC) perms = perms - RELS_SYMMETRIC;
		if (perms & RELS_EQUIVALENCE) perms = perms - RELS_EQUIVALENCE;
	}
	if ((set == false) && (state)) {
		if (perms & RELS_X_UNIQUE) perms = perms - RELS_X_UNIQUE;
		if (perms & RELS_Y_UNIQUE) perms = perms - RELS_Y_UNIQUE;
	}
	RlnSetF(rel, RR_PERMISSIONS, perms);
	handler = RlnGetF(rel, RR_HANDLER);
	if (handler(rel, RELS_SET_VALENCY, perms & VALENCY_MASK) == 0)
		"*** Can't change this to a various-to-one relation ***";		
];

[ RELATION_TY_VToVAdjective rel set  perms state handler;
	perms = RlnGetF(rel, RR_PERMISSIONS);
	if (perms & (RELS_X_UNIQUE+RELS_Y_UNIQUE) == 0) state = true;
	if (set < 0) return state;
	if ((set) && (state == false)) {
		if (perms & RELS_X_UNIQUE) perms = perms - RELS_X_UNIQUE;
		if (perms & RELS_Y_UNIQUE) perms = perms - RELS_Y_UNIQUE;
	}
	if ((set == false) && (state)) {
		if (perms & RELS_X_UNIQUE == 0) perms = perms + RELS_X_UNIQUE;
		if (perms & RELS_Y_UNIQUE == 0) perms = perms + RELS_Y_UNIQUE;
	}
	RlnSetF(rel, RR_PERMISSIONS, perms);
	handler = RlnGetF(rel, RR_HANDLER);
	if (handler(rel, RELS_SET_VALENCY, perms & VALENCY_MASK) == 0)
		"*** Can't change this to a various-to-various relation ***";		
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Relations.i6t: One To One Relations
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ Relation_Now1to1 obj1 relation_property obj2 ol; ! Assert 1-1 true
	if (obj2) objectloop (ol provides relation_property)
		if (ol.relation_property == obj2) ol.relation_property = nothing;
	if (obj1) obj1.relation_property = obj2;
];

[ Relation_NowN1toV obj1 relation_property obj2; ! Assert 1-1 false
	if ((obj1) && (obj1.relation_property == obj2)) obj1.relation_property = nothing;
];

[ Relation_Now1to1V obj1 obj2 KOV relation_property ol N; ! Assert 1-1 true
	if (obj2) {
		N = KOVDomainSize(KOV);
		for (ol=1: ol<=N: ol++)
			if (GProperty(KOV, ol, relation_property) == obj2)
				WriteGProperty(KOV, ol, relation_property, 0);
	}
	if (obj1) WriteGProperty(KOV, obj1, relation_property, obj2);
];

[ Relation_NowN1toVV obj1 obj2 KOV relation_property; ! Assert 1-1 false
	if ((obj1) && (GProperty(KOV, obj1, relation_property) == obj2))
		WriteGProperty(KOV, obj1, relation_property, 0);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Relations.i6t: Symmetric One To One Relations
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ Relation_NowS1to1 obj1 relation_property obj2; ! Assert symmetric 1-1 true
	if ((obj1 ofclass Object) && (obj1 provides relation_property) &&
		(obj2 ofclass Object) && (obj2 provides relation_property)) {
		if (obj1.relation_property) { (obj1.relation_property).relation_property = 0; }
		if (obj2.relation_property) { (obj2.relation_property).relation_property = 0; }
		obj1.relation_property = obj2; obj2.relation_property = obj1;
	}
];

[ Relation_NowSN1to1 obj1 relation_property obj2; ! Assert symmetric 1-1 false
	if ((obj1 ofclass Object) && (obj1 provides relation_property) &&
		(obj2 ofclass Object) && (obj2 provides relation_property) &&
		(obj1.relation_property == obj2)) {
		obj1.relation_property = 0; obj2.relation_property = 0;
	}
];

[ Relation_NowS1to1V obj1 obj2 KOV relation_property; ! Assert symmetric 1-1 true
	if (GProperty(KOV, obj1, relation_property))
		WriteGProperty(KOV, GProperty(KOV, obj1, relation_property), relation_property, 0);
	if (GProperty(KOV, obj2, relation_property)) 
		WriteGProperty(KOV, GProperty(KOV, obj2, relation_property), relation_property, 0);
	WriteGProperty(KOV, obj1, relation_property, obj2);
	WriteGProperty(KOV, obj2, relation_property, obj1);
];

[ Relation_NowSN1to1V obj1 obj2 KOV relation_property; ! Assert symmetric 1-1 false
	if (GProperty(KOV, obj1, relation_property) == obj2) {
		WriteGProperty(KOV, obj1, relation_property, 0);
		WriteGProperty(KOV, obj2, relation_property, 0);
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Relations.i6t: Various To Various Relations
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant VTOVS_LEFT_INDEX_PROP = 0;
Constant VTOVS_RIGHT_INDEX_PROP = 1;
Constant VTOVS_LEFT_DOMAIN_SIZE = 2;
Constant VTOVS_RIGHT_DOMAIN_SIZE = 3;
Constant VTOVS_LEFT_PRINTING_ROUTINE = 4;
Constant VTOVS_RIGHT_PRINTING_ROUTINE = 5;
Constant VTOVS_CACHE_BROKEN = 6;
Constant VTOVS_CACHE = 7;

[ Relation_NowVtoV obj1 relation obj2 sym pr pr2 i1 i2 vtov_structure;
	if (sym && (obj2 ~= obj1)) { Relation_NowVtoV(obj2, relation, obj1, false); }
	vtov_structure = RlnGetF(relation, RR_STORAGE);
	pr = vtov_structure-->VTOVS_LEFT_INDEX_PROP;
	pr2 = vtov_structure-->VTOVS_RIGHT_INDEX_PROP;
	vtov_structure-->VTOVS_CACHE_BROKEN = true; ! Mark any cache as broken
	if (pr) {
		if ((obj1 ofclass Object) && (obj1 provides pr)) i1 = obj1.pr;
		else return RunTimeProblem(RTP_IMPREL, obj1, relation);
	} else i1 = obj1-1;
	if (pr2) {
		if ((obj2 ofclass Object) && (obj2 provides pr2)) i2 = obj2.pr2;
		else return RunTimeProblem(RTP_IMPREL, obj2, relation);
	} else i2 = obj2-1;
	pr = i1*(vtov_structure-->VTOVS_RIGHT_DOMAIN_SIZE) + i2;
	i1 = IncreasingPowersOfTwo_TB-->(pr%16);
	pr = pr/16 + 8;
	vtov_structure-->pr = (vtov_structure-->pr) | i1;
];

[ Relation_NowNVtoV obj1 relation obj2 sym pr pr2 i1 i2 vtov_structure;
	if (sym && (obj2 ~= obj1)) { Relation_NowNVtoV(obj2, relation, obj1, false); }
	vtov_structure = RlnGetF(relation, RR_STORAGE);
	pr = vtov_structure-->VTOVS_LEFT_INDEX_PROP;
	pr2 = vtov_structure-->VTOVS_RIGHT_INDEX_PROP;
	vtov_structure-->VTOVS_CACHE_BROKEN = true; ! Mark any cache as broken
	if (pr) {
		if ((obj1 ofclass Object) && (obj1 provides pr)) i1 = obj1.pr;
		else return RunTimeProblem(RTP_IMPREL, obj1, relation);
	} else i1 = obj1-1;
	if (pr2) {
		if ((obj2 ofclass Object) && (obj2 provides pr2)) i2 = obj2.pr2;
		else return RunTimeProblem(RTP_IMPREL, obj2, relation);
	} else i2 = obj2-1;
	pr = i1*(vtov_structure-->VTOVS_RIGHT_DOMAIN_SIZE) + i2;
	i1 = IncreasingPowersOfTwo_TB-->(pr%16);
	pr = pr/16 + 8;
	if ((vtov_structure-->pr) & i1) vtov_structure-->pr = vtov_structure-->pr - i1;
];

[ Relation_TestVtoV obj1 relation obj2 sym pr pr2 i1 i2 vtov_structure;
	vtov_structure = RlnGetF(relation, RR_STORAGE);
	pr = vtov_structure-->VTOVS_LEFT_INDEX_PROP;
	pr2 = vtov_structure-->VTOVS_RIGHT_INDEX_PROP;
	if (sym && (obj2 > obj1)) { sym = obj1; obj1 = obj2; obj2 = sym; }
	if (pr) {
		if ((obj1 ofclass Object) && (obj1 provides pr)) i1 = obj1.pr;
		else { RunTimeProblem(RTP_IMPREL, obj1, relation); rfalse; }
	} else i1 = obj1-1;
	if (pr2) {
		if ((obj2 ofclass Object) && (obj2 provides pr2)) i2 = obj2.pr2;
		else { RunTimeProblem(RTP_IMPREL, obj2, relation); rfalse; }
	} else i2 = obj2-1;
	pr = i1*(vtov_structure-->VTOVS_RIGHT_DOMAIN_SIZE) + i2;
	i1 = IncreasingPowersOfTwo_TB-->(pr%16);
	pr = pr/16 + 8;
	if ((vtov_structure-->pr) & i1) rtrue; rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Relations.i6t: Equivalence Relations
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ Relation_NowEquiv obj1 relation_property obj2 big little;
	big = obj1.relation_property; little = obj2.relation_property;
	if (big == little) return;
	if (big < little) { little = obj1.relation_property; big = obj2.relation_property; }
	objectloop (obj1 provides relation_property)
		if (obj1.relation_property == big) obj1.relation_property = little;
];

[ Relation_NowNEquiv obj1 relation_property obj2 old new;
	old = obj1.relation_property; new = obj2.relation_property;
	if (old ~= new) return;
	new = 0;
	objectloop (obj2 provides relation_property)
		if (obj2.relation_property > new) new = obj2.relation_property;
	new++;
	obj1.relation_property = new;
];

[ Relation_NowEquivV obj1 obj2 KOV relation_property n big little i;
	big = GProperty(KOV, obj1, relation_property);
	little = GProperty(KOV, obj2, relation_property);
	if (big == little) return;
	if (big < little) {
		little = GProperty(KOV, obj1, relation_property);
		big = GProperty(KOV, obj2, relation_property);
	}
	n = KOVDomainSize(KOV);
	for (i=1: i<=n: i++)
		if (GProperty(KOV, i, relation_property) == big)
			WriteGProperty(KOV, i, relation_property, little);
];

[ Relation_NowNEquivV obj1 obj2 KOV relation_property n old new i;
	old = GProperty(KOV, obj1, relation_property); 
	new = GProperty(KOV, obj2, relation_property);
	if (old ~= new) return;
	new = 0;
	n = KOVDomainSize(KOV);
	for (i=1: i<=n: i++)
		if (GProperty(KOV, i, relation_property) > new)
			new = GProperty(KOV, i, relation_property);
	new++;
	WriteGProperty(KOV, obj1, relation_property, new);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Relations.i6t: Show Various to Various
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ Relation_ShowVtoV relation sym x obj1 obj2 pr pr2 proutine1 proutine2 vtov_structure;
	vtov_structure = RlnGetF(relation, RR_STORAGE);
	pr = vtov_structure-->VTOVS_LEFT_INDEX_PROP;
	pr2 = vtov_structure-->VTOVS_RIGHT_INDEX_PROP;
	proutine1 = vtov_structure-->VTOVS_LEFT_PRINTING_ROUTINE;
	proutine2 = vtov_structure-->VTOVS_RIGHT_PRINTING_ROUTINE;
 
	if (pr && pr2) {
		objectloop (obj1 provides pr)
		  objectloop (obj2 provides pr2) {
				if (sym && obj2 > obj1) continue;
				if (Relation_TestVtoV(obj1, relation, obj2)) {
					if (x == 0) { print (string) RlnGetF(relation, RR_DESCRIPTION), ":^"; x=1; }
					print "  ", (The) obj1;
					if (sym) print "  <=>  "; else print "  >=>  ";
					print (the) obj2, "^";
				}
		  }
		return;
	}
	if (pr && (pr2==0)) {
		objectloop (obj1 provides pr)
		  for (obj2=1:obj2<=vtov_structure-->VTOVS_RIGHT_DOMAIN_SIZE:obj2++) {
				if (Relation_TestVtoV(obj1, relation, obj2)) {
					if (x == 0) { print (string) RlnGetF(relation, RR_DESCRIPTION), ":^"; x=1; }
					print "  ", (The) obj1, "  >=>  ";
					(proutine2).call(obj2);
					print "^";
				}
		  }
		return;
	}
	if ((pr==0) && (pr2)) {
		for (obj1=1:obj1<=vtov_structure-->2:obj1++)
		  objectloop (obj2 provides pr2) {
				if (Relation_TestVtoV(obj1, relation, obj2)) {
					if (x == 0) { print (string) RlnGetF(relation, RR_DESCRIPTION), ":^"; x=1; }
					print "  ";
					(proutine1).call(obj1);
					print "  >=>  ", (the) obj2, "^";
				}
		  }
		return;
	}
	for (obj1=1:obj1<=vtov_structure-->2:obj1++)
		  for (obj2=1:obj2<=vtov_structure-->VTOVS_RIGHT_DOMAIN_SIZE:obj2++)
			if (Relation_TestVtoV(obj1, relation, obj2)) {
				if (x == 0) { print (string) RlnGetF(relation, RR_DESCRIPTION), ":^"; x=1; }
				print "  ";
				(proutine1).call(obj1);
				print "  >=>  ";
				(proutine2).call(obj2);
				print "^";
		  }
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Relations.i6t: Show One to One
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ Relation_ShowOtoO relation sym x relation_property t N obj1 obj2;
	relation_property = RlnGetF(relation, RR_STORAGE);
	t = KindBaseTerm(RlnGetF(relation, RR_KIND), 0); ! Kind of left term
	N = KOVDomainSize(t);
	if (t == OBJECT_TY) {
		objectloop (obj1 provides relation_property) {
			obj2 = obj1.relation_property;
			if (sym && obj2 < obj1) continue;
			if (obj2 == 0) continue;
			if (x == 0) { print (string) RlnGetF(relation, RR_DESCRIPTION), ":^"; x=1; }
			print "  ", (The) obj1;
			if (sym) print "  ==  "; else print "  >=>  ";
			print (the) obj2, "^";
		}
	} else {
		for (obj1=1: obj1<=N: obj1++) {
			obj2 = GProperty(t, obj1, relation_property);
			if (sym && obj2 < obj1) continue;
			if (obj2 == 0) continue;
			if (x == 0) { print (string) RlnGetF(relation, RR_DESCRIPTION), ":^"; x=1; }
			print "  ";
			PrintKindValuePair(t, obj1);
			if (sym) print "  ==  "; else print "  >=>  ";
			PrintKindValuePair(t, obj2);
			print "^";
		}
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Relations.i6t: Show Reversed One to One
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ Relation_RShowOtoO relation sym x relation_property obj1 obj2 t1 t2 N1 N2;
	relation_property = RlnGetF(relation, RR_STORAGE);
	t1 = KindBaseTerm(RlnGetF(relation, RR_KIND), 0); ! Kind of left term
	t2 = KindBaseTerm(RlnGetF(relation, RR_KIND), 1); ! Kind of right term
	if (t2 == OBJECT_TY) {
		if (t1 == OBJECT_TY) {
			objectloop (obj1) {
				objectloop (obj2 provides relation_property) {
					if (obj2.relation_property ~= obj1) continue;
					if (x == 0) { print (string) RlnGetF(relation, RR_DESCRIPTION), ":^"; x=1; }
					print "  ", (The) obj1;
					print "  >=>  ";
					print (the) obj2, "^";
				}
			}
		} else {
			N1 = KOVDomainSize(t1);
			for (obj1=1: obj1<=N1: obj1++) {
				objectloop (obj2 provides relation_property) {
					if (obj2.relation_property ~= obj1) continue;
					if (x == 0) { print (string) RlnGetF(relation, RR_DESCRIPTION), ":^"; x=1; }
					print "  "; PrintKindValuePair(t1, obj1);
					print "  >=>  ";
					print (the) obj2, "^";
				}
			}
		}
	} else {
		N2 = KOVDomainSize(t2);
		if (t1 == OBJECT_TY) {
			objectloop (obj1) {
				for (obj2=1: obj2<=N2: obj2++) {
					if (GProperty(t2, obj2, relation_property) ~= obj1) continue;
					if (x == 0) { print (string) RlnGetF(relation, RR_DESCRIPTION), ":^"; x=1; }
					print "  ", (The) obj1;
					print "  >=>  ";
					PrintKindValuePair(t2, obj2);
					print "^";
				}
			}
		} else {
			N1 = KOVDomainSize(t1);
			for (obj1=1: obj1<=N1: obj1++) {
				for (obj2=1: obj2<=N2: obj2++) {
					if (GProperty(t2, obj2, relation_property) ~= obj1) continue;
					if (x == 0) { print (string) RlnGetF(relation, RR_DESCRIPTION), ":^"; x=1; }
					print "  ";
					PrintKindValuePair(t1, obj1);
					print "  >=>  ";
					PrintKindValuePair(t2, obj2);
					print "^";
				}
			}
		}
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Relations.i6t: Show Equivalence
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ RSE_Flip KOV v relation_property x;
	x = GProperty(KOV, v, relation_property); x = -x;
	WriteGProperty(KOV, v, relation_property, x);
];
[ RSE_Set KOV v relation_property;
	if (GProperty(KOV, v, relation_property) < 0) rtrue; rfalse;
];
[ Relation_ShowEquiv relation relation_property obj1 obj2 v c d somegroups t N x;
	print (string) RlnGetF(relation, RR_DESCRIPTION), ":^";
	relation_property = RlnGetF(relation, RR_STORAGE);
	t = KindBaseTerm(RlnGetF(relation, RR_KIND), 0); ! Kind of left term
	N = KOVDomainSize(t);
	if (t == OBJECT_TY) {
		objectloop (obj1 provides relation_property)
			obj1.relation_property = -(obj1.relation_property);
		objectloop (obj1 provides relation_property) {
			if (obj1.relation_property < 0) {
				v = obj1.relation_property; c = 0;
				objectloop (obj2 has workflag2) give obj2 ~workflag2;
				objectloop (obj2 provides relation_property) {
					if (obj2.relation_property == v) {
						give obj2 workflag2;
						obj2.relation_property = -v;
						c++;
					}
				}
				if (c>1) {
					somegroups = true;
					print "  { ";
					WriteListOfMarkedObjects(ENGLISH_BIT);
					print " }^";
				} else obj1.relation_property = v;
			}
		}
		objectloop (obj2 has workflag2) give obj2 ~workflag2;
		c = 0; objectloop (obj1 provides relation_property)
			if (obj1.relation_property < 0) { c++; give obj1 workflag2; }
		if (c == 0) return;
		if (somegroups) print "  and "; else print "  ";
		if (c < 4) { WriteListOfMarkedObjects(ENGLISH_BIT); print " in"; }
		else print c;
		if (c == 1) print " a";
		print " single-member group";
		if (c > 1) print "s";
		print "^";
		objectloop (obj1 provides relation_property)
			if (obj1.relation_property < 0)
				obj1.relation_property = -(obj1.relation_property);
	} else {
		! A slower method, since we have less efficient storage:
		for (obj1 = 1: obj1 <= N: obj1++)
			RSE_Flip(t, obj1, relation_property);
		for (obj1 = 1: obj1 <= N: obj1++) {
			if (RSE_Set(t, obj1, relation_property)) {
				v = GProperty(t, obj1, relation_property);
				c = 0;
				for (obj2 = 1: obj2 <= N: obj2++)
					if (GProperty(t, obj2, relation_property) == v)
						c++;
				if (c>1) {
					somegroups = true;
					print "  {";
					d = 0;
					for (obj2 = 1: obj2 <= N: obj2++) {
						if (GProperty(t, obj2, relation_property) == v) {
							print " "; PrintKindValuePair(t, obj2);
							if (d < c-1) print ","; print " ";
							RSE_Flip(t, obj2, relation_property);
							d++;
						}
					}
					print "}^";
				} else WriteGProperty(t, obj1, relation_property, v);
			}
		}
		objectloop (obj2 has workflag2) give obj2 ~workflag2;
		c = 0;
		for (obj1 = 1: obj1 <= N: obj1++)
			if (RSE_Set(t, obj1, relation_property)) c++;
		if (c == 0) return;
		if (somegroups) print "  and "; else print "  ";
		if (c == 1) print "a"; else print c;
		print " single-member group";
		if (c > 1) print "s";
		print "^";
		for (obj1 = 1: obj1 <= N: obj1++)
			if (RSE_Set(t, obj1, relation_property))
				RSE_Flip(t, obj1, relation_property);
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Relations.i6t: Map Route-Finding
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#ifndef FAST_ROUTE_FINDING;
#ifndef SLOW_ROUTE_FINDING;
#ifdef TARGET_GLULX;
Constant FAST_ROUTE_FINDING;
#ifnot;
Constant SLOW_ROUTE_FINDING;
#endif;
#endif;
#endif;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Relations.i6t: Cache Control
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant NUM_DOORS = 2;
Constant NUM_ROOMS = 74;

Array DoorRoutingViable -> NUM_DOORS+1;

Global map_has_changed = true;
Global last_filter; Global last_use_doors;

[ SignalMapChange; map_has_changed = true; ];

[ MapRouteTo from to filter use_doors count  oy oyi ds;
	if (from == nothing) return nothing;
	if (to == nothing) return nothing;
	if (from == to) return nothing;
	if ((filter) && (filter(from) == 0)) return nothing;
	if ((filter) && (filter(to) == 0)) return nothing;
	if ((last_filter ~= filter) || (last_use_doors ~= use_doors)) map_has_changed = true;
	oyi = 0;
	objectloop (oy has mark_as_room) {
		if ((filter == 0) || (filter(oy))) {
			if (oy.room_index == -1) map_has_changed = true;
			oy.room_index = oyi++;
		} else {
			if (oy.room_index >= 0) map_has_changed = true;
			oy.room_index = -1;
		}
	}
	oyi = 0;
	objectloop (oy ofclass K4_door) {
		ds = false;
		if ((use_doors & 2) ||
			(oy has open) || ((oy has openable) && (oy hasnt locked))) ds = true;
		if (DoorRoutingViable->oyi ~= ds) map_has_changed = true;
		DoorRoutingViable->oyi = ds;
		oyi++;
	}
	if (map_has_changed) {
		#ifdef FAST_ROUTE_FINDING; ComputeFWMatrix(filter, use_doors); #endif;
		map_has_changed = false; last_filter = filter; last_use_doors = use_doors;
	}
	#ifdef FAST_ROUTE_FINDING;
	if (count) return FastCountRouteTo(from, to, filter, use_doors);
	return FastRouteTo(from, to, filter, use_doors);
	#ifnot;
	if (count) return SlowCountRouteTo(from, to, filter, use_doors);
	return SlowRouteTo(from, to, filter, use_doors);
	#endif;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Relations.i6t: Fast Route-Finding
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#ifdef FAST_ROUTE_FINDING;
Array FWMatrix --> NUM_ROOMS*NUM_ROOMS;

[ FastRouteTo from to filter use_doors diri i dir oy;
	if (from == to) return nothing;
	i = (FWMatrix-->(from.room_index*NUM_ROOMS + to.room_index))/No_Directions;
	if (i == 0) return nothing;
	diri = (FWMatrix-->(from.room_index*NUM_ROOMS + to.room_index))%No_Directions;
	i=0; objectloop (dir ofclass K3_direction) {
		if (i == diri) return dir;
		i++;
	}
	return nothing;
];

[ FastCountRouteTo from to filter use_doors  k;
	if (from == to) return 0;
	k = (FWMatrix-->(from.room_index*NUM_ROOMS + to.room_index))/No_Directions;
	if (k == 0) return -1;
	return k;
];

[ ComputeFWMatrix filter use_doors  oy ox oj axy ayj axj dir diri nd row;
	objectloop (oy has mark_as_room) if (oy.room_index >= 0)
		objectloop (ox has mark_as_room) if (ox.room_index >= 0)
			FWMatrix-->(oy.room_index*NUM_ROOMS + ox.room_index) = 0;

	objectloop (oy has mark_as_room) if (oy.room_index >= 0) {
		row = (oy.IK1_Count)*No_Directions;
		for (diri=0: diri<No_Directions: diri++) {
			ox = Map_Storage-->(row+diri);
			if ((ox) && (ox has mark_as_room) && (ox.room_index >= 0)) {
				FWMatrix-->(oy.room_index*NUM_ROOMS + ox.room_index) = No_Directions + diri;
				continue;
			}
			if (use_doors && (ox ofclass K4_door) &&
				((use_doors & 2) || (DoorRoutingViable->(ox.IK4_Count)))) {
				@push location; location = oy;
				ox = ox.door_to();
				@pull location;
				if ((ox) && (ox has mark_as_room) && (ox.room_index >= 0)) {
					FWMatrix-->(oy.room_index*NUM_ROOMS + ox.room_index) = No_Directions + diri;
					continue;
				}
			}
		}	
	}

	objectloop (oy has mark_as_room) if (oy.room_index >= 0)
		objectloop (ox has mark_as_room) if (ox.room_index >= 0) {
			axy = (FWMatrix-->(ox.room_index*NUM_ROOMS + oy.room_index))/No_Directions;
			if (axy > 0)
				objectloop (oj has mark_as_room) if (oj.room_index >= 0) {
					ayj = (FWMatrix-->(oy.room_index*NUM_ROOMS + oj.room_index))/No_Directions;
					if (ayj > 0) {
						!print "Is it faster to go from ", (name) ox, " to ",
						!   (name) oj, " via ", (name) oy, "?^";
						axj = (FWMatrix-->(ox.room_index*NUM_ROOMS + oj.room_index))/
							No_Directions;
						if ((axj == 0) || (axy + ayj < axj)) {
							!print "Yes^";
							FWMatrix-->(ox.room_index*NUM_ROOMS + oj.room_index) =
								(axy + ayj)*No_Directions +
								(FWMatrix-->(ox.room_index*NUM_ROOMS + oy.room_index))%
									No_Directions;
						}
					}
				}
		}
];
#ENDIF;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Relations.i6t: Slow Route-Finding
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#ifndef FAST_ROUTE_FINDING;
[ SlowRouteTo from to filter use_doors  obj dir in_direction progressed sl through_door;
	if (from == nothing) return nothing;
	if (to == nothing) return nothing;
	if (from == to) return nothing;
	objectloop (obj has mark_as_room) obj.vector = 0;
	to.vector = 1;
	!print "Routing from ", (the) from, " to ", (the) to, "^";
	while (true) {
		progressed = false;
		!print "Pass begins^";
		objectloop (obj has mark_as_room)
			if ((filter == 0) || (filter(obj)))
				if (obj.vector == 0)
					objectloop (dir ofclass K3_direction) {
						in_direction = Map_Storage-->((obj.IK1_Count)*No_Directions + dir.IK3_Count);
						if (in_direction == nothing) continue;
						!print (the) obj, " > ", (the) dir, " > ", (the) in_direction, "^";
						if ((in_direction)
							&& (in_direction has mark_as_room)
							&& (in_direction.vector > 0)
							&& ((filter == 0) || (filter(in_direction)))) {
							obj.vector = dir | WORD_HIGHBIT;
							!print "* ", (the) obj, " vector is ", (the) dir, "^";
							progressed = true;
							continue;
						}
						if (use_doors && (in_direction ofclass K4_door) &&
							((use_doors & 2) ||
							 (in_direction has open) ||
							 ((in_direction has openable) && (in_direction hasnt locked)))) {
							sl = location; location = obj;
							through_door = in_direction.door_to();
							location = sl;
							!print "Through door is ", (the) through_door, "^";
							if ((through_door)
								&& (through_door has mark_as_room)
								&& (through_door.vector > 0)
								&& ((filter == 0) || (filter(through_door)))) {
								obj.vector = dir | WORD_HIGHBIT;
								!print "* ", (the) obj, " vector is ", (the) dir, "^";
								progressed = true;
								continue;
							}
						}
					}
		objectloop (obj has mark_as_room) obj.vector = obj.vector &~ WORD_HIGHBIT;
		if (from.vector) return from.vector;
		if (progressed == false) return from.vector;
	}
];

[ SlowCountRouteTo from to filter use_doors obj i;
	if (from == nothing) return -1;
	if (to == nothing) return -1;
	if (from == to) return 0;
	if (from has mark_as_room && to has mark_as_room) {
		obj = MapRouteTo(from,to,filter,use_doors);
		if (obj == nothing) return -1;
		i = 0; obj = from;
		while ((obj ~= to) && (i<NUM_ROOMS)) { i++; obj = MapConnection(obj,obj.vector); }
		return i;
	}
	return -1;
];
#ENDIF;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Relations.i6t: Relation Route-Finding
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant MAX_ROUTE_LENGTH = 286 + 32;

[ RelationRouteTo relation from to count  handler;
	if (count) {
		if (from == nothing) return -1;
		if (to == nothing) return -1;
		if (relation == 0) return -1;
	} else {
		if (from == nothing) return nothing;
		if (to == nothing) return nothing;
		if (relation == 0) return nothing;
	}
	if (from == to) return nothing;
	if (((RlnGetF(relation, RR_PERMISSIONS)) & RELS_ROUTE_FIND) == 0) {
		RunTimeProblem(RTP_ROUTELESS);
		return nothing;
	}
	if (RlnGetF(relation, RR_STORAGE) == 0) return nothing;
	handler = RlnGetF(relation, RR_HANDLER);
	if (count) return handler(relation, RELS_ROUTE_FIND_COUNT, from, to);
	return handler(relation, RELS_ROUTE_FIND, from, to);
];

[ RelFollowVector rv from to  obj i;
	if (rv == nothing) return -1;
	i = 0; obj = from;
	while ((obj ~= to) && (i<=MAX_ROUTE_LENGTH)) { i++; obj = obj.vector; }
	return i;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Relations.i6t: One To Various Route-Finding
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ OtoVRelRouteTo relation_property from to previous;
	while ((to) && (to provides relation_property) && (to.relation_property)) {
		previous = to.relation_property;
		previous.vector = to;
		if (previous == from) return to;
		to = previous;
	}
	return nothing;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Relations.i6t: Various To One Route-Finding
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VtoORelRouteTo relation_property from to next  start;
	start = from;
	while ((from) && (from provides relation_property) && (from.relation_property)) {
		next = from.relation_property;
		from.vector = next;
		if (next == to) return start.vector;
		from = next;
	}
	return nothing;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Relations.i6t: Slow Various To Various Route-Finding
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VtoVRelRouteTo relation from to count obj obj2 related progressed left_ix pr2 i vtov_structure;
	vtov_structure = RlnGetF(relation, RR_STORAGE);
	if (vtov_structure-->VTOVS_CACHE)
		return FastVtoVRelRouteTo(relation, from, to, count);
	left_ix = vtov_structure-->VTOVS_LEFT_INDEX_PROP;
	pr2 = vtov_structure-->VTOVS_RIGHT_INDEX_PROP;
	objectloop (obj ofclass Object && obj provides vector) obj.vector = 0;
	to.vector = 1;
	while (true) {
		progressed = false;
		objectloop (obj ofclass Object && obj provides left_ix)
			if (obj.vector == 0) {
				objectloop (obj2 ofclass Object && obj2 provides pr2 && obj2.vector > 0) {
					if (Relation_TestVtoV(obj, relation, obj2)) {
						obj.vector = obj2 | WORD_HIGHBIT;
						progressed = true;
						continue;
					}
				}
			}
		objectloop (obj ofclass Object && obj provides left_ix)
			obj.vector = obj.vector &~ WORD_HIGHBIT;
		if (from.vector) break;
		if (progressed == false) break;
	}
	if (count) {
		if (from.vector == nothing) return -1;
		i = 0; obj = from;
		while ((obj ~= to) && (i<=MAX_ROUTE_LENGTH)) { i++; obj = obj.vector; }
		return i;
	}
	return from.vector;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Relations.i6t: Fast Various To Various Route-Finding
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FastVtoVRelRouteTo relation from to count
	domainsize cache cache2 left_ix ox oy oj offset axy axj ayj;
	domainsize = RlnGetF(relation, RR_STORAGE)-->2; ! Number of left instances
	left_ix = RlnGetF(relation, RR_STORAGE)-->VTOVS_LEFT_INDEX_PROP;
	if ((from provides left_ix) && (to provides left_ix)) {
		if (domainsize < 256) {
			cache = RlnGetF(relation, RR_STORAGE)-->VTOVS_CACHE;
			cache2 = cache + domainsize*domainsize;
			if (RlnGetF(relation, RR_STORAGE)-->VTOVS_CACHE_BROKEN == true) {
				RlnGetF(relation, RR_STORAGE)-->VTOVS_CACHE_BROKEN = false;
				objectloop (oy provides left_ix)
					objectloop (ox provides left_ix)
						if (Relation_TestVtoV(oy, relation, ox)) {
							offset = ((oy.left_ix)*domainsize + (ox.left_ix));
							cache->offset = 1;
							cache2->offset = ox.left_ix;
						} else {
							offset = ((oy.left_ix)*domainsize + (ox.left_ix));
							cache->offset = 0;
							cache2->offset = 255;
						}
				for (oy=0: oy<domainsize: oy++)
					for (ox=0: ox<domainsize: ox++) {
						axy = cache->(ox*domainsize + oy);
						if (axy > 0)
							for (oj=0: oj<domainsize: oj++) {
								ayj = cache->(oy*domainsize + oj);
								if (ayj > 0) {
									offset = ox*domainsize + oj;
									axj = cache->offset;
									if ((axj == 0) || (axy + ayj < axj)) {
										cache->offset = (axy + ayj);
										cache2->offset = cache2->(ox*domainsize + oy);
									}
								}
							}
					}
			}
			if (count) {
				count = cache->((from.left_ix)*domainsize + (to.left_ix));
				if (count == 0) return -1;
				return count;
			}
			oy = cache2->((from.left_ix)*domainsize + (to.left_ix));
			if (oy < 255)
				objectloop (ox provides left_ix)
					if (ox.left_ix == oy) return ox;
			return nothing;
		} else {
			cache = RlnGetF(relation, RR_STORAGE)-->VTOVS_CACHE;
			cache2 = cache + WORDSIZE*domainsize*domainsize;
			if (RlnGetF(relation, RR_STORAGE)-->VTOVS_CACHE_BROKEN == true) {
				RlnGetF(relation, RR_STORAGE)-->VTOVS_CACHE_BROKEN = false;
				objectloop (oy provides left_ix)
					objectloop (ox provides left_ix)
						if (Relation_TestVtoV(oy, relation, ox)) {
							offset = ((oy.left_ix)*domainsize + (ox.left_ix));
							cache-->offset = 1;
							cache2-->offset = ox;
						} else {
							offset = ((oy.left_ix)*domainsize + (ox.left_ix));
							cache-->offset = 0;
							cache2-->offset = nothing;
						}
				for (oy=0: oy<domainsize: oy++)
					for (ox=0: ox<domainsize: ox++) {
						axy = cache-->(ox*domainsize + oy);
						if (axy > 0)
							for (oj=0: oj<domainsize: oj++) {
								ayj = cache-->(oy*domainsize + oj);
								if (ayj > 0) {
									offset = ox*domainsize + oj;
									axj = cache-->offset;
									if ((axj == 0) || (axy + ayj < axj)) {
										cache-->offset = (axy + ayj);
										cache2-->offset = cache2-->(ox*domainsize + oy);
									}
								}
							}
					}
			}
			if (count) {
				count = cache-->((from.left_ix)*domainsize + (to.left_ix));
				if (count == 0) return -1;
				return count;
			}
			return cache2-->((from.left_ix)*domainsize + (to.left_ix));
		}
	}
	if (count) return -1;
	return nothing;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Relations.i6t: Iterating Relations
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ IterateRelations callback;
	callback(Rel_Record_67);
    callback(Rel_Record_69);
    callback(Rel_Record_71);

];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RTP.i6t: Reporting
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Array RTP_Buffer --> 7;
[ RunTimeProblem n par1 par2 par3 ln file;
	if (RTP_Buffer-->0 == -1) {
		RTP_Buffer-->0 = n; 
		RTP_Buffer-->1 = par1; 
		RTP_Buffer-->2 = par2;
		RTP_Buffer-->3 = par3;
		RTP_Buffer-->4 = ln;
		RTP_Buffer-->5 = file;
	}
	RunTimeProblemShow();
];
[ ClearRTP;
	RTP_Buffer-->0 = -1;
	RTP_Buffer-->6 = false;
];
[ SuspendRTP;
	RTP_Buffer-->6 = true;
];
[ ResumeRTP;
	RTP_Buffer-->6 = false;
];
[ RunTimeProblemShow   n par1 par2 par3 ln file i c;
	if (RTP_Buffer-->0 == -1 or -2) return;
	if (RTP_Buffer-->6) return;

	n = RTP_Buffer-->0; 
	par1 = RTP_Buffer-->1; 
	par2 = RTP_Buffer-->2;
	par3 = RTP_Buffer-->3;
	ln = RTP_Buffer-->4;
	file = RTP_Buffer-->5;
	RTP_Buffer-->0 = -2;

	print "^*** Run-time problem P", n;
	if (ln) {
		print " (at paragraph ", ln, " in ";
		if (file == 0) print "the source text";
		else ShowOneExtension(file);
		print ")";
	}
	print ": ";
	switch(n) {
		RTP_BACKDROP:
			print "Tried to move ", (the) par1, " (a backdrop) to ", (the) par2,
				", which is not a region.^";
		RTP_CANTCHANGE:
			print "Tried to change player to ", (the) par1, ", which is not a person.^";
		RTP_NOEXIT:
		    print "Tried to change ", (the) par2, " exit of ", (the) par1,
		    	", but it didn't seem to have such an exit to change.^";
		RTP_EXITDOOR:
		    print "Tried to change ", (the) par2, " exit of ", (the) par1,
		    	", but it led to a door, not a room.^";
		RTP_IMPREL:
			print "Tried to access an inappropriate relation for ", (the) par1,
				", violating '", (string) RlnGetF(par2, RR_DESCRIPTION), "'.^";
		RTP_TOOMANYRULEBOOKS:
			print "Too many rulebooks in simultaneous use.^";
		RTP_TOOMANYEVENTS:
			print "Too many timed events are going on at once.^";
		RTP_BADPROPERTY:
			print "Tried to access non-existent property for ", (the) par1, ".^";
		RTP_UNPROVIDED:
			print "Since ", (the) par1, " is not allowed the property ~",
					(string) par2, "~, it is against the rules to try to use it.^";
		RTP_UNSET:
			print "Although ", (the) par1, " is allowed to have the property ~",
				(string) par2, "~, no value was ever given, so it can't now be used.^";
		RTP_TOOMANYACTS:
			print "Too many activities are going on at once.^";
		RTP_CANTABANDON:
			print "Tried to abandon an activity which wasn't going on.^";
		RTP_CANTEND:
			print "Tried to end an activity which wasn't going on.^";
		RTP_CANTMOVENOTHING:
			print "You can't move nothing.^";
		RTP_CANTREMOVENOTHING:
			print "You can't remove nothing from play.^";
		RTP_DIVZERO:
			print "You can't divide by zero.^";
		RTP_BADVALUEPROPERTY:
			print "Tried to access property for a value which didn't fit: ",
				"if this were a number it would be ", par1, ".^";
		RTP_NOTBACKDROP:
			print "Tried to move ", (the) par1, " (not a backdrop) to ", (the) par2,
				", which is a region.^";
		RTP_TABLE_NOCOL:
			print "Attempt to look up a non-existent column in the table '",
				(PrintTableName) par1, "'.^";
		RTP_TABLE_NOCORR:
			print "Attempt to look up a non-existent correspondence in the table '",
				(PrintTableName) par1, "'.^";
		RTP_TABLE_NOROW:
			print "Attempt to look up a non-existent row in the table '",
				(PrintTableName) par1, "'.^";
		RTP_TABLE_NOENTRY:
			print "Attempt to look up a non-existent entry at column ", par2,
				", row ", par3, " of the table '", (PrintTableName) par1, "'.^";
		RTP_TABLE_NOTABLE:
			print "Attempt to blank out a row from a non-existent table (value ",
				par1, ").^";
		RTP_TABLE_NOTABLE2:
			print "Attempt to access an entry from a non-existent table.^";
		RTP_TABLE_NOMOREBLANKS:
			print "Attempt to choose a blank row in a table with none left: table '",
				(PrintTableName) par1, "'.^";
		RTP_TABLE_NOROWS:
			print "Attempt to choose a random row in an entirely blank table: table '",
				(PrintTableName) par1, "'.^";
		RTP_TABLE_CANTRUNTHROUGH:
			print "Attempt to repeat through a table in a tricky column order: table '",
				(PrintTableName) par1, "'.^";
		RTP_TABLE_CANTSORT:
			print "Attempt to sort a table whose ordering must remain fixed: table '",
				(PrintTableName) par1, "'.^";
		RTP_TABLE_CANTSAVE:
			print "Attempt to save a table to a file whose data is unstable: table '",
				(PrintTableName) par1, "'.^";
		RTP_TABLE_WONTFIT:
			print "File being read has too many rows or columns to fit into table: table '",
				(PrintTableName) par1, "'.^";
		RTP_TABLE_BADFILE:
			print "File being read is not a previously saved table: table '",
				(PrintTableName) par1, "'.^";
		RTP_NOTINAROOM:
			print "Attempt to test if the current location is '",
				(the) par1, "', which is not a room or region.^";
		RTP_BADTOPIC:
			print "Attempt to see if a snippet of text matches something which
				is not a topic.^";
		RTP_ROUTELESS:
			print "Attempt to find route or count steps through an implicit
				relation.^";
		RTP_PROPOFNOTHING:
			print "Attempt to use a property of the 'nothing' non-object: property ",
				(PrintPropertyName) par2, "^";
		RTP_DECIDEONWRONGKIND:
			print "Attempt to 'decide on V' where V is the wrong kind of object.^";
		RTP_DECIDEONNOTHING:
			print "Attempt to 'decide on nothing'.^";
		RTP_LOWLEVELERROR:
			print "Low level error.^";
		RTP_DONTIGNORETURNSEQUENCE:
			print "Attempt to ignore the turn sequence rules.^";
		RTP_SAYINVALIDSNIPPET:
			print "Attempt to say a snippet value which is currently invalid: words ",
				par1, " to ", par2, ".^";
		RTP_SPLICEINVALIDSNIPPET:
			print "Attempt to splice a snippet value which is currently invalid: words ",
				par1, " to ", par2, ".^";
		RTP_INCLUDEINVALIDSNIPPET:
			print "Attempt to match a snippet value which is currently invalid: words ",
				par1, " to ", par2, ".^";
		RTP_LISTWRITERMEMORY:
			print "The list-writer has run out of memory.^";
		RTP_CANTREMOVEPLAYER:
			print "Attempt to remove the player from play.^";
		RTP_CANTBEOFFSTAGE:
			print "Attempt to move the player off-stage.^";
		RTP_CANTREMOVEDOORS:
			print "Attempt to remove a door from play.^";
		RTP_CANTCHANGEOFFSTAGE:
			print "Attempt to change the player to a person off-stage.^";
		RTP_MSTACKMEMORY:
			print "The memory stack is exhausted.^";
		RTP_TYPECHECK:
			print "Phrase applied to an incompatible kind of value.^";
		RTP_FILEIOERROR:
			print "Error handling external file.^";
		RTP_HEAPERROR:
			print "Memory allocation proved impossible.^";
		RTP_LISTRANGEERROR:
			print "Attempt to use list item which does not exist.^";
		RTP_REGEXPSYNTAXERROR:
			print "Syntax error in regular expression.^";
		RTP_NOGLULXUNICODE:
			print "This interpreter does not support Unicode.^";
		RTP_BACKDROPONLY:
			print "Only backdrops can be moved to multiple places.^";
		RTP_NOTTHING:
			print "Tried to move ", (the) par1, " (not a thing) to ", (the) par2,
				", but only things can move around.^";
		RTP_SCENEHASNTSTARTED:
			print "The scene ", (PrintSceneName) par1,
				" hasn't started, so you can't ask when it did.^";
		RTP_SCENEHASNTENDED:
			print "The scene ", (PrintSceneName) par1,
				" hasn't ended, so you can't ask when it did.^";
		RTP_NEGATIVEROOT:
			print "You can't take the square root of a negative number.^";
		RTP_CANTITERATE:
			print "You can't implicitly repeat through the values of this kind: ",
				"a problem arising from a description which started out here - ~",
				(string) par1, "~.^";
		RTP_WRONGASSIGNEDKIND:
			print "Attempt to set a variable to the wrong kind of object: ",
				"you wrote '", (string) par2, "', which sets the value to ", (the) par1,
				" - but that doesn't have the kind '", (string) par3, "'.^";			
		RTP_RELKINDVIOLATION:
			print "Tried to change a relation for objects with the wrong kinds: ",
				(string) RlnGetF(par3, RR_DESCRIPTION), ", but you tried to ",
				"relate (or unrelate) ", (the) par1, " to ", (the) par2, ".^";
		RTP_CANTMAKEPART:
			print "Tried to make the player part of something: ",
				(the) par1, ".^";
		RTP_TEXTTOKENTOOHARD:
			print "This use of '[text]' is too complicated.^";
		}
	print "^";
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RTP.i6t: Low-Level Errors
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant MAX_TIMERS = 0;
[ RunTimeError n p1 p2;
    #Ifdef DEBUG;
    print "** Library error ", n, " (", p1, ",", p2, ") **^** ";
    switch (n) {
      1:    print "preposition not found (this should not occur)";
      2:    print "Property value not routine or string: ~", (property) p2, "~ of ~", (name) p1,
                  "~ (", p1, ")";
      3:    print "Entry in property list not routine or string: ~", (property) p2, "~ list of ~",
                  (name) p1, "~ (", p1, ")";
      4:    print "Too many timers/daemons are active simultaneously.
                  The limit is the library constant MAX_TIMERS (currently ",
                  MAX_TIMERS, ") and should be increased";
      5:    print "Object ~", (name) p1, "~ has no ~time_left~ property";
      7:    print "The object ~", (name) p1, "~ can only be used as a player object if it has
                  the ~number~ property";
      8:    print "Attempt to take random entry from an empty table array";
      9:    print p1, " is not a valid direction property number";
      10:   print "The player-object is outside the object tree";
      11:   print "The room ~", (name) p1, "~ has no ~description~ property";
      12:   print "Tried to set a non-existent pronoun using SetPronoun";
      13:   print "A 'topic' token can only be followed by a preposition";
      default: print "(unexplained)";
    }
    print " **^";
    #Ifnot;
    print "** Library error ", n, " (", p1, ",", p2, ") **^";
    #Endif; ! DEBUG
    RunTimeProblem(RTP_LOWLEVELERROR);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RTP.i6t: Argument Type Checking Failed
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ArgumentTypeFailed line file;
	RunTimeProblem(RTP_TYPECHECK, 0, 0, 0, line, file);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RTP.i6t: Return Type Checking Failed
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ CheckKindReturned V K;
	if (V ofclass K) return V;
	if (v == nothing) RunTimeProblem(RTP_DECIDEONNOTHING);
	else RunTimeProblem(RTP_DECIDEONWRONGKIND);
	return V;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RTP.i6t: Whether Provides
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ WhetherProvides obj either_or p issue_rtp  off i textual a l;
	if (metaclass(obj) ~= Object) rfalse;
	if (p<0) p = ~p;
	if (either_or) {
		if (p < FBNA_PROP_NUMBER) off = attributed_property_offsets-->p;
		else off = valued_property_offsets-->p;
	} else off = valued_property_offsets-->p;
	if (off<0) {
		if (issue_rtp) RunTimeProblem(RTP_BADPROPERTY, obj);
		rfalse;
	}
	textual = property_metadata-->off; off++;
	
	if (ScanPropertyMetadata(obj, off)) jump PermissionFound;
	if (obj provides KD_Count) {
		l = obj.KD_Count;
		while (l > 0) {
			a = l*2;
			if (ScanPropertyMetadata(KindHierarchy-->a, off)) jump PermissionFound;
			l = KindHierarchy-->(a+1);
		}
	}
	if (issue_rtp) RunTimeProblem(RTP_UNPROVIDED, obj, textual);
	rfalse;

	.PermissionFound;
		if (either_or) rtrue;
		if (obj provides p) rtrue;
		if (issue_rtp) RunTimeProblem(RTP_UNSET, obj, textual);
		rfalse;
];

[ PrintPropertyName  p  off textual;
	if (p<0) p = ~p;
	off = valued_property_offsets-->p;
	textual = property_metadata-->off;
	print (string) textual;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RTP.i6t: Scan Property Metadata
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ScanPropertyMetadata obj off i;
	for (i=off: property_metadata-->i >= 0: i++)
		if (obj == property_metadata-->i) rtrue;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RTP.i6t: Get Either-Or Property
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ GetEitherOrProperty o p;
	if (o == nothing) rfalse;
	if (p<0) p = ~p;
	if (WhetherProvides(o, true, p, false)) {
		if (p<FBNA_PROP_NUMBER) { if (o has p) rtrue; rfalse; }
		if ((o provides p) && (o.p)) rtrue;
	}
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RTP.i6t: Set Either-Or Property
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SetEitherOrProperty o p negate adj;
	if (p<0) { p = ~p; negate = ~negate; }
	if (adj) {
		(adj)(o);
	} else if (WhetherProvides(o, true, p, true)) {
		if (negate) {
			if (p<FBNA_PROP_NUMBER) give o ~p; else o.p = false;
		} else {
			if (p<FBNA_PROP_NUMBER) give o p; else o.p = true;
		}
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RTP.i6t: Value Property
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ GProperty K V pr obj;
	if (K == OBJECT_TY) obj = V; else obj = KOV_representatives-->K;
	if (obj == 0) { RunTimeProblem(RTP_PROPOFNOTHING, obj, pr); rfalse; }
	if (obj provides pr) {
		if (K == OBJECT_TY) {
			if (pr == door_to) return obj.pr();
			if (WhetherProvides(V, false, pr, true)) return obj.pr;
			rfalse;
		}
		if (obj ofclass K0_kind)
			WhetherProvides(V, false, pr, true); ! to force a run-time problem
		if ((V < 1) || (V > obj.value_range)) {
			RunTimeProblem(RTP_BADVALUEPROPERTY); return 0; }
		return (obj.pr)-->(V+COL_HSIZE);
	} else {
		if (obj ofclass K0_kind)
			WhetherProvides(V, false, pr, true); ! to force a run-time problem
	}
    rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RTP.i6t: Write Value Property
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ WriteGProperty K V pr val obj;
	if (K == OBJECT_TY) obj = V; else obj = KOV_representatives-->K;
	if (obj == 0) { RunTimeProblem(RTP_PROPOFNOTHING, obj, pr); rfalse; }
	if (K == OBJECT_TY) {
		if (WhetherProvides(V, false, pr, true)) obj.pr = val;
	} else {
		if ((V < 1) || (V > obj.value_range))
			return RunTimeProblem(RTP_BADVALUEPROPERTY);
		if (obj provides pr) { (obj.pr)-->(V+COL_HSIZE) = val; }
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RTP.i6t: Printing Property Names
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PROPERTY_TY_Say v;
	print "property ", v;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Rulebooks.i6t: Latest Rule Result
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant RS_NEITHER		= 0;
Constant RS_SUCCEEDS	= 1;
Constant RS_FAILS		= 2;

Array latest_rule_result --> 3;

[ RecordRuleOutcome usage rule1 rule2;
	if ((latest_rule_result-->0 == RS_SUCCEEDS or RS_FAILS) &&
		(KOVIsBlockValue(latest_rule_result-->1)))
		BlkValueFree(latest_rule_result-->2);
	if ((usage == RS_SUCCEEDS or RS_FAILS) && (KOVIsBlockValue(rule1)))
		rule2 = BlkValueCopy(BlkValueCreate(rule1), rule2);
	latest_rule_result-->0 = usage;
	latest_rule_result-->1 = rule1;
	latest_rule_result-->2 = rule2;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Rulebooks.i6t: Following
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Global process_rulebook_count; ! Depth of processing recursion
Global debugging_rules = false; ! Are we tracing rule invocations?

[ FollowRulebook rulebook parameter no_paragraph_skips
	rv ss spv;
	ss = self;
	if ((Protect_I7_Arrays-->0 ~= 16339) || (Protect_I7_Arrays-->1 ~= 12345)) {
		print "^^*** Fatal programming error: I7 arrays corrupted ***^^";
		@quit;
	}
	if (parameter) { self = parameter; parameter_object = parameter; }
	spv = parameter_value; parameter_value = parameter;
	! we won't need parameter again, so can reuse it
	parameter = debugging_rules;
	#ifndef MEMORY_ECONOMY;
	if (debugging_rules) {
		DebugRulebooks(rulebook, parameter);
		process_rulebook_count = process_rulebook_count + debugging_rules;
	}
	#endif;
	if ((rulebook >= 0) && (rulebook < NUMBER_RULEBOOKS_CREATED)) {
		rv = rulebooks_array-->rulebook;
		if (rv ~= EMPTY_RULEBOOK) {
			if (rulebook ~= ACTION_PROCESSING_RB) MStack_CreateRBVars(rulebook);
			if (say__p) RulebookParBreak(no_paragraph_skips);
			rv = rv(no_paragraph_skips);
			if (rulebook ~= ACTION_PROCESSING_RB) MStack_DestroyRBVars(rulebook);
		} else {
			rv = 0;
		}
	} else {
		if (say__p) RulebookParBreak(no_paragraph_skips);
		rv = indirect(rulebook);
		if (rv == 2) rv = reason_the_action_failed;
		else if (rv) rv = rulebook;
	}
	if (rv) {
		#ifndef MEMORY_ECONOMY;
		if (debugging_rules) {
			process_rulebook_count = process_rulebook_count - debugging_rules;
			if (process_rulebook_count < 0) process_rulebook_count = 0;
			spaces(2*process_rulebook_count);
	  	    if (latest_rule_result-->0 == RS_SUCCEEDS) print "[stopped: success]^";
	  	    if (latest_rule_result-->0 == RS_FAILS) print "[stopped: fail]^";
		}
		#endif;
	} else {
		if (debugging_rules)
			process_rulebook_count = process_rulebook_count - debugging_rules;
		latest_rule_result-->0 = RS_NEITHER;
	}
	debugging_rules = parameter;
	self = ss; parameter_value = spv;
	return rv;
];

[ RulebookParBreak no_paragraph_skips;
	if ((no_paragraph_skips == false) && (say__pc & PARA_NORULEBOOKBREAKS == 0))
		DivideParagraphPoint();
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Rulebooks.i6t: Specifying Outcomes
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ActRulebookSucceeds rule_id;
	if (rule_id) reason_the_action_failed = rule_id;
	RulebookSucceeds();
];

[ ActRulebookFails rule_id;
	if (rule_id) reason_the_action_failed = rule_id;
	RulebookFails();
];

[ RulebookSucceeds weak_kind value;
	RecordRuleOutcome(RS_SUCCEEDS, weak_kind, value);
];

[ RulebookFails weak_kind value;
	RecordRuleOutcome(RS_FAILS, weak_kind, value);
];

[ RuleHasNoOutcome;
	RecordRuleOutcome(RS_NEITHER, 0, 0);
];

[ SetRulebookOutcome a;
	latest_rule_result-->0 = a;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Rulebooks.i6t: Discovering Outcomes
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ RulebookOutcome a;
	a = latest_rule_result-->0;
	if ((a == RS_FAILS) || (a == RS_SUCCEEDS)) return a;
	return RS_NEITHER;
];

[ RulebookFailed;
	if (latest_rule_result-->0 == RS_FAILS) rtrue; rfalse;
];

[ RulebookSucceeded;
	if (latest_rule_result-->0 == RS_SUCCEEDS) rtrue; rfalse;
];

[ ResultOfRule RB V F K a;
	if (RB) FollowRulebook(RB, V, F);
	a = latest_rule_result-->0;
	if ((a == RS_FAILS) || (a == RS_SUCCEEDS)) {
		a = latest_rule_result-->1;
		if (a) return latest_rule_result-->2;
	}
	if (K) return DefaultValueOfKOV(K);
	return 0;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Rulebooks.i6t: Printing Rule Names
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#IFNDEF MEMORY_ECONOMY;
Array RulebookNames -->
    "Startup rulebook" ! 0
    "Turn sequence rulebook" ! 1
    "Shutdown rulebook" ! 2
    "Scene changing rulebook" ! 3
    "When play begins rulebook" ! 4
    "When play ends rulebook" ! 5
    "When scene begins rulebook" ! 6
    "When scene ends rulebook" ! 7
    "Every turn rulebook" ! 8
    "Action-processing rulebook" ! 9
    "Setting action variables rulebook" ! 10
    "specific action-processing rulebook" ! 11
    "player's action awareness rulebook" ! 12
    "Accessibility rulebook" ! 13
    "Reaching inside rulebook" ! 14
    "Reaching outside rulebook" ! 15
    "Visibility rulebook" ! 16
    "Persuasion rulebook" ! 17
    "Unsuccessful attempt by rulebook" ! 18
    "Before rulebook" ! 19
    "Instead rulebook" ! 20
    "Check rulebook" ! 21
    "Carry out rulebook" ! 22
    "After rulebook" ! 23
    "Report rulebook" ! 24
    "does the player mean rulebook" ! 25
    "when Entire Game begins rulebook" ! 26
    "when Entire Game ends rulebook" ! 27
    "before Printing the name rulebook" ! 28
    "for Printing the name rulebook" ! 29
    "after Printing the name rulebook" ! 30
    "before Printing the plural name rulebook" ! 31
    "for Printing the plural name rulebook" ! 32
    "after Printing the plural name rulebook" ! 33
    "before Printing a number rulebook" ! 34
    "for Printing a number rulebook" ! 35
    "after Printing a number rulebook" ! 36
    "before Printing room description details rulebook" ! 37
    "for Printing room description details rulebook" ! 38
    "after Printing room description details rulebook" ! 39
    "before Printing inventory details rulebook" ! 40
    "for Printing inventory details rulebook" ! 41
    "after Printing inventory details rulebook" ! 42
    "before Listing contents rulebook" ! 43
    "for Listing contents rulebook" ! 44
    "after Listing contents rulebook" ! 45
    "before Grouping together rulebook" ! 46
    "for Grouping together rulebook" ! 47
    "after Grouping together rulebook" ! 48
    "before Writing a paragraph about rulebook" ! 49
    "for Writing a paragraph about rulebook" ! 50
    "after Writing a paragraph about rulebook" ! 51
    "before Listing nondescript items rulebook" ! 52
    "for Listing nondescript items rulebook" ! 53
    "after Listing nondescript items rulebook" ! 54
    "before Printing the name of a dark room rulebook" ! 55
    "for Printing the name of a dark room rulebook" ! 56
    "after Printing the name of a dark room rulebook" ! 57
    "before Printing the description of a dark room rulebook" ! 58
    "for Printing the description of a dark room rulebook" ! 59
    "after Printing the description of a dark room rulebook" ! 60
    "before Printing the announcement of darkness rulebook" ! 61
    "for Printing the announcement of darkness rulebook" ! 62
    "after Printing the announcement of darkness rulebook" ! 63
    "before Printing the announcement of light rulebook" ! 64
    "for Printing the announcement of light rulebook" ! 65
    "after Printing the announcement of light rulebook" ! 66
    "before Printing a refusal to act in the dark rulebook" ! 67
    "for Printing a refusal to act in the dark rulebook" ! 68
    "after Printing a refusal to act in the dark rulebook" ! 69
    "before Constructing the status line rulebook" ! 70
    "for Constructing the status line rulebook" ! 71
    "after Constructing the status line rulebook" ! 72
    "before Printing the banner text rulebook" ! 73
    "for Printing the banner text rulebook" ! 74
    "after Printing the banner text rulebook" ! 75
    "before Reading a command rulebook" ! 76
    "for Reading a command rulebook" ! 77
    "after Reading a command rulebook" ! 78
    "before Deciding the scope rulebook" ! 79
    "for Deciding the scope rulebook" ! 80
    "after Deciding the scope rulebook" ! 81
    "before Deciding the concealed possessions rulebook" ! 82
    "for Deciding the concealed possessions rulebook" ! 83
    "after Deciding the concealed possessions rulebook" ! 84
    "before Deciding whether all includes rulebook" ! 85
    "for Deciding whether all includes rulebook" ! 86
    "after Deciding whether all includes rulebook" ! 87
    "before Clarifying the parser's choice rulebook" ! 88
    "for Clarifying the parser's choice rulebook" ! 89
    "after Clarifying the parser's choice rulebook" ! 90
    "before Asking which do you mean rulebook" ! 91
    "for Asking which do you mean rulebook" ! 92
    "after Asking which do you mean rulebook" ! 93
    "before Printing a parser error rulebook" ! 94
    "for Printing a parser error rulebook" ! 95
    "after Printing a parser error rulebook" ! 96
    "before Supplying a missing noun rulebook" ! 97
    "for Supplying a missing noun rulebook" ! 98
    "after Supplying a missing noun rulebook" ! 99
    "before Supplying a missing second noun rulebook" ! 100
    "for Supplying a missing second noun rulebook" ! 101
    "after Supplying a missing second noun rulebook" ! 102
    "before Implicitly taking rulebook" ! 103
    "for Implicitly taking rulebook" ! 104
    "after Implicitly taking rulebook" ! 105
    "before Starting the virtual machine rulebook" ! 106
    "for Starting the virtual machine rulebook" ! 107
    "after Starting the virtual machine rulebook" ! 108
    "before Amusing a victorious player rulebook" ! 109
    "for Amusing a victorious player rulebook" ! 110
    "after Amusing a victorious player rulebook" ! 111
    "before Printing the player's obituary rulebook" ! 112
    "for Printing the player's obituary rulebook" ! 113
    "after Printing the player's obituary rulebook" ! 114
    "before Handling the final question rulebook" ! 115
    "for Handling the final question rulebook" ! 116
    "after Handling the final question rulebook" ! 117
    "before Printing the locale description rulebook" ! 118
    "for Printing the locale description rulebook" ! 119
    "after Printing the locale description rulebook" ! 120
    "before Choosing notable locale objects rulebook" ! 121
    "for Choosing notable locale objects rulebook" ! 122
    "after Choosing notable locale objects rulebook" ! 123
    "before Printing a locale paragraph about rulebook" ! 124
    "for Printing a locale paragraph about rulebook" ! 125
    "after Printing a locale paragraph about rulebook" ! 126
    "before Issuing the response text rulebook" ! 127
    "for Issuing the response text rulebook" ! 128
    "after Issuing the response text rulebook" ! 129
    "check Taking inventory rulebook" ! 130
    "carry out Taking inventory rulebook" ! 131
    "report Taking inventory rulebook" ! 132
    "check Taking rulebook" ! 133
    "carry out Taking rulebook" ! 134
    "report Taking rulebook" ! 135
    "check Removing it from rulebook" ! 136
    "carry out Removing it from rulebook" ! 137
    "report Removing it from rulebook" ! 138
    "check Dropping rulebook" ! 139
    "carry out Dropping rulebook" ! 140
    "report Dropping rulebook" ! 141
    "check Putting it on rulebook" ! 142
    "carry out Putting it on rulebook" ! 143
    "report Putting it on rulebook" ! 144
    "check Inserting it into rulebook" ! 145
    "carry out Inserting it into rulebook" ! 146
    "report Inserting it into rulebook" ! 147
    "check Eating rulebook" ! 148
    "carry out Eating rulebook" ! 149
    "report Eating rulebook" ! 150
    "check Going rulebook" ! 151
    "carry out Going rulebook" ! 152
    "report Going rulebook" ! 153
    "check Entering rulebook" ! 154
    "carry out Entering rulebook" ! 155
    "report Entering rulebook" ! 156
    "check Exiting rulebook" ! 157
    "carry out Exiting rulebook" ! 158
    "report Exiting rulebook" ! 159
    "check Getting off rulebook" ! 160
    "carry out Getting off rulebook" ! 161
    "report Getting off rulebook" ! 162
    "check Looking rulebook" ! 163
    "carry out Looking rulebook" ! 164
    "report Looking rulebook" ! 165
    "check Examining rulebook" ! 166
    "carry out Examining rulebook" ! 167
    "report Examining rulebook" ! 168
    "check Looking under rulebook" ! 169
    "carry out Looking under rulebook" ! 170
    "report Looking under rulebook" ! 171
    "check Searching rulebook" ! 172
    "carry out Searching rulebook" ! 173
    "report Searching rulebook" ! 174
    "check Consulting it about rulebook" ! 175
    "carry out Consulting it about rulebook" ! 176
    "report Consulting it about rulebook" ! 177
    "check Locking it with rulebook" ! 178
    "carry out Locking it with rulebook" ! 179
    "report Locking it with rulebook" ! 180
    "check Unlocking it with rulebook" ! 181
    "carry out Unlocking it with rulebook" ! 182
    "report Unlocking it with rulebook" ! 183
    "check Switching on rulebook" ! 184
    "carry out Switching on rulebook" ! 185
    "report Switching on rulebook" ! 186
    "check Switching off rulebook" ! 187
    "carry out Switching off rulebook" ! 188
    "report Switching off rulebook" ! 189
    "check Opening rulebook" ! 190
    "carry out Opening rulebook" ! 191
    "report Opening rulebook" ! 192
    "check Closing rulebook" ! 193
    "carry out Closing rulebook" ! 194
    "report Closing rulebook" ! 195
    "check Wearing rulebook" ! 196
    "carry out Wearing rulebook" ! 197
    "report Wearing rulebook" ! 198
    "check Taking off rulebook" ! 199
    "carry out Taking off rulebook" ! 200
    "report Taking off rulebook" ! 201
    "check Giving it to rulebook" ! 202
    "carry out Giving it to rulebook" ! 203
    "report Giving it to rulebook" ! 204
    "check Showing it to rulebook" ! 205
    "carry out Showing it to rulebook" ! 206
    "report Showing it to rulebook" ! 207
    "check Waking rulebook" ! 208
    "carry out Waking rulebook" ! 209
    "report Waking rulebook" ! 210
    "check Throwing it at rulebook" ! 211
    "carry out Throwing it at rulebook" ! 212
    "report Throwing it at rulebook" ! 213
    "check Attacking rulebook" ! 214
    "carry out Attacking rulebook" ! 215
    "report Attacking rulebook" ! 216
    "check Kissing rulebook" ! 217
    "carry out Kissing rulebook" ! 218
    "report Kissing rulebook" ! 219
    "check Answering it that rulebook" ! 220
    "carry out Answering it that rulebook" ! 221
    "report Answering it that rulebook" ! 222
    "check Telling it about rulebook" ! 223
    "carry out Telling it about rulebook" ! 224
    "report Telling it about rulebook" ! 225
    "check Asking it about rulebook" ! 226
    "carry out Asking it about rulebook" ! 227
    "report Asking it about rulebook" ! 228
    "check Asking it for rulebook" ! 229
    "carry out Asking it for rulebook" ! 230
    "report Asking it for rulebook" ! 231
    "check Waiting rulebook" ! 232
    "carry out Waiting rulebook" ! 233
    "report Waiting rulebook" ! 234
    "check Touching rulebook" ! 235
    "carry out Touching rulebook" ! 236
    "report Touching rulebook" ! 237
    "check Waving rulebook" ! 238
    "carry out Waving rulebook" ! 239
    "report Waving rulebook" ! 240
    "check Pulling rulebook" ! 241
    "carry out Pulling rulebook" ! 242
    "report Pulling rulebook" ! 243
    "check Pushing rulebook" ! 244
    "carry out Pushing rulebook" ! 245
    "report Pushing rulebook" ! 246
    "check Turning rulebook" ! 247
    "carry out Turning rulebook" ! 248
    "report Turning rulebook" ! 249
    "check Pushing it to rulebook" ! 250
    "carry out Pushing it to rulebook" ! 251
    "report Pushing it to rulebook" ! 252
    "check Squeezing rulebook" ! 253
    "carry out Squeezing rulebook" ! 254
    "report Squeezing rulebook" ! 255
    "check Saying yes rulebook" ! 256
    "carry out Saying yes rulebook" ! 257
    "report Saying yes rulebook" ! 258
    "check Saying no rulebook" ! 259
    "carry out Saying no rulebook" ! 260
    "report Saying no rulebook" ! 261
    "check Burning rulebook" ! 262
    "carry out Burning rulebook" ! 263
    "report Burning rulebook" ! 264
    "check Waking up rulebook" ! 265
    "carry out Waking up rulebook" ! 266
    "report Waking up rulebook" ! 267
    "check Thinking rulebook" ! 268
    "carry out Thinking rulebook" ! 269
    "report Thinking rulebook" ! 270
    "check Smelling rulebook" ! 271
    "carry out Smelling rulebook" ! 272
    "report Smelling rulebook" ! 273
    "check Listening to rulebook" ! 274
    "carry out Listening to rulebook" ! 275
    "report Listening to rulebook" ! 276
    "check Tasting rulebook" ! 277
    "carry out Tasting rulebook" ! 278
    "report Tasting rulebook" ! 279
    "check Cutting rulebook" ! 280
    "carry out Cutting rulebook" ! 281
    "report Cutting rulebook" ! 282
    "check Jumping rulebook" ! 283
    "carry out Jumping rulebook" ! 284
    "report Jumping rulebook" ! 285
    "check Tying it to rulebook" ! 286
    "carry out Tying it to rulebook" ! 287
    "report Tying it to rulebook" ! 288
    "check Drinking rulebook" ! 289
    "carry out Drinking rulebook" ! 290
    "report Drinking rulebook" ! 291
    "check Saying sorry rulebook" ! 292
    "carry out Saying sorry rulebook" ! 293
    "report Saying sorry rulebook" ! 294
    "check Swinging rulebook" ! 295
    "carry out Swinging rulebook" ! 296
    "report Swinging rulebook" ! 297
    "check Rubbing rulebook" ! 298
    "carry out Rubbing rulebook" ! 299
    "report Rubbing rulebook" ! 300
    "check Setting it to rulebook" ! 301
    "carry out Setting it to rulebook" ! 302
    "report Setting it to rulebook" ! 303
    "check Waving hands rulebook" ! 304
    "carry out Waving hands rulebook" ! 305
    "report Waving hands rulebook" ! 306
    "check Buying rulebook" ! 307
    "carry out Buying rulebook" ! 308
    "report Buying rulebook" ! 309
    "check Climbing rulebook" ! 310
    "carry out Climbing rulebook" ! 311
    "report Climbing rulebook" ! 312
    "check Sleeping rulebook" ! 313
    "carry out Sleeping rulebook" ! 314
    "report Sleeping rulebook" ! 315
    "check Quitting the game rulebook" ! 316
    "carry out Quitting the game rulebook" ! 317
    "report Quitting the game rulebook" ! 318
    "check Saving the game rulebook" ! 319
    "carry out Saving the game rulebook" ! 320
    "report Saving the game rulebook" ! 321
    "check Restoring the game rulebook" ! 322
    "carry out Restoring the game rulebook" ! 323
    "report Restoring the game rulebook" ! 324
    "check Restarting the game rulebook" ! 325
    "carry out Restarting the game rulebook" ! 326
    "report Restarting the game rulebook" ! 327
    "check Verifying the story file rulebook" ! 328
    "carry out Verifying the story file rulebook" ! 329
    "report Verifying the story file rulebook" ! 330
    "check Switching the story transcript on rulebook" ! 331
    "carry out Switching the story transcript on rulebook" ! 332
    "report Switching the story transcript on rulebook" ! 333
    "check Switching the story transcript off rulebook" ! 334
    "carry out Switching the story transcript off rulebook" ! 335
    "report Switching the story transcript off rulebook" ! 336
    "check Requesting the story file version rulebook" ! 337
    "carry out Requesting the story file version rulebook" ! 338
    "report Requesting the story file version rulebook" ! 339
    "check Requesting the score rulebook" ! 340
    "carry out Requesting the score rulebook" ! 341
    "report Requesting the score rulebook" ! 342
    "check Preferring abbreviated room descriptions rulebook" ! 343
    "carry out Preferring abbreviated room descriptions rulebook" ! 344
    "report Preferring abbreviated room descriptions rulebook" ! 345
    "check Preferring unabbreviated room descriptions rulebook" ! 346
    "carry out Preferring unabbreviated room descriptions rulebook" ! 347
    "report Preferring unabbreviated room descriptions rulebook" ! 348
    "check Preferring sometimes abbreviated room descriptions rulebook" ! 349
    "carry out Preferring sometimes abbreviated room descriptions rulebook" ! 350
    "report Preferring sometimes abbreviated room descriptions rulebook" ! 351
    "check Switching score notification on rulebook" ! 352
    "carry out Switching score notification on rulebook" ! 353
    "report Switching score notification on rulebook" ! 354
    "check Switching score notification off rulebook" ! 355
    "carry out Switching score notification off rulebook" ! 356
    "report Switching score notification off rulebook" ! 357
    "check Requesting the pronoun meanings rulebook" ! 358
    "carry out Requesting the pronoun meanings rulebook" ! 359
    "report Requesting the pronoun meanings rulebook" ! 360
    "before Refusing keys rulebook" ! 361
    "for Refusing keys rulebook" ! 362
    "after Refusing keys rulebook" ! 363
    "check Unlocking keylessly rulebook" ! 364
    "carry out Unlocking keylessly rulebook" ! 365
    "report Unlocking keylessly rulebook" ! 366
    "check Locking keylessly rulebook" ! 367
    "carry out Locking keylessly rulebook" ! 368
    "report Locking keylessly rulebook" ! 369
    "before Displaying rulebook" ! 370
    "for Displaying rulebook" ! 371
    "after Displaying rulebook" ! 372
    "before Pausing the game rulebook" ! 373
    "for Pausing the game rulebook" ! 374
    "after Pausing the game rulebook" ! 375
    "check Reading rulebook" ! 376
    "carry out Reading rulebook" ! 377
    "report Reading rulebook" ! 378
    "when chooseYourDestiny begins rulebook" ! 379
    "when chooseYourDestiny ends rulebook" ! 380
    "when gazelleTransformation begins rulebook" ! 381
    "when gazelleTransformation ends rulebook" ! 382
    "when gaggleBecomesHerd begins rulebook" ! 383
    "when gaggleBecomesHerd ends rulebook" ! 384
    "when newsCast begins rulebook" ! 385
    "when newsCast ends rulebook" ! 386
    "when Joining The Zoo begins rulebook" ! 387
    "when Joining The Zoo ends rulebook" ! 388
    "when genieInABottle begins rulebook" ! 389
    "when genieInABottle ends rulebook" ! 390
    "when Exploring Your Office begins rulebook" ! 391
    "when Exploring Your Office ends rulebook" ! 392
    "when Jerked begins rulebook" ! 393
    "when Jerked ends rulebook" ! 394
    "when supplyShopEvent begins rulebook" ! 395
    "when supplyShopEvent ends rulebook" ! 396
    "when Here Girl begins rulebook" ! 397
    "when Here Girl ends rulebook" ! 398
    "when SizeIncrease begins rulebook" ! 399
    "when SizeIncrease ends rulebook" ! 400
    "when dontCroak begins rulebook" ! 401
    "when dontCroak ends rulebook" ! 402
    "when MareTf begins rulebook" ! 403
    "when MareTf ends rulebook" ! 404
    "when SwineOption begins rulebook" ! 405
    "when SwineOption ends rulebook" ! 406
;


#ENDIF; ! MEMORY_ECONOMY

[ RulePrintingRule R p1;
#ifndef MEMORY_ECONOMY;
	if ((R>=0) && (R<NUMBER_RULEBOOKS_CREATED)) {
		print (string) (RulebookNames-->R);
	} else {
        if (R == R_9) { print "declare everything initially unmentioned rule"; return; } ! rule 0
        if (R == R_10) { print "start in the correct scenes rule"; return; } ! rule 1
        if (R == R_11) { print "when play begins stage rule"; return; } ! rule 2
        if (R == R_12) { print "fix baseline scoring rule"; return; } ! rule 3
        if (R == R_13) { print "display banner rule"; return; } ! rule 4
        if (R == R_14) { print "initial room description rule"; return; } ! rule 5
        if (R == R_15) { print "every turn stage rule"; return; } ! rule 6
        if (R == R_18) { print "notify score changes rule"; return; } ! rule 7
        if (R == R_19) { print "when play ends stage rule"; return; } ! rule 8
        if (R == R_20) { print "print player's obituary rule"; return; } ! rule 9
        if (R == R_21) { print "set pronouns from items from multiple object lists rule"; return; } ! rule 10
        if (R == R_22) { print "announce items from multiple object lists rule"; return; } ! rule 11
        if (R == R_23) { print "before stage rule"; return; } ! rule 12
        if (R == R_24) { print "instead stage rule"; return; } ! rule 13
        if (R == R_25) { print "end action-processing in success rule"; return; } ! rule 14
        if (R == R_26) { print "investigate player's awareness before action rule"; return; } ! rule 15
        if (R == R_27) { print "check stage rule"; return; } ! rule 16
        if (R == R_28) { print "carry out stage rule"; return; } ! rule 17
        if (R == R_29) { print "after stage rule"; return; } ! rule 18
        if (R == R_30) { print "investigate player's awareness after action rule"; return; } ! rule 19
        if (R == R_31) { print "report stage rule"; return; } ! rule 20
        if (R == R_33) { print "player aware of his own actions rule"; return; } ! rule 21
        if (R == R_34) { print "player aware of actions by visible actors rule"; return; } ! rule 22
        if (R == R_35) { print "player aware of actions on visible nouns rule"; return; } ! rule 23
        if (R == R_36) { print "player aware of actions on visible second nouns rule"; return; } ! rule 24
        if (R == R_37) { print "can't act in the dark rule"; return; } ! rule 25
        if (R == R_38) { print "very unlikely to mean taking what's already carried rule"; return; } ! rule 26
        if (R == R_65) { print "scene description text rule"; return; } ! rule 27
        if (R == R_66) { print "make named things mentioned rule"; return; } ! rule 28
        if (R == R_67) { print "standard printing the plural name rule"; return; } ! rule 29
        if (R == R_68) { print "standard printing a number of something rule"; return; } ! rule 30
        if (R == R_69) { print "look around once light available rule"; return; } ! rule 31
        if (R == R_70) { print "exclude scenery from take all rule"; return; } ! rule 32
        if (R == R_71) { print "exclude people from take all rule"; return; } ! rule 33
        if (R == R_72) { print "exclude fixed in place things from take all rule"; return; } ! rule 34
        if (R == R_73) { print "exclude people from drop all rule"; return; } ! rule 35
        if (R == R_74) { print "ambient odour rule"; return; } ! rule 36
        if (R == R_75) { print "ambient sound rule"; return; } ! rule 37
        if (R == R_76) { print "block vaguely going rule"; return; } ! rule 38
        if (R == R_77) { print "print the final prompt rule"; return; } ! rule 39
        if (R == R_78) { print "print the final question rule"; return; } ! rule 40
        if (R == R_79) { print "standard respond to final question rule"; return; } ! rule 41
        if (R == R_82) { print "initialise locale description rule"; return; } ! rule 42
        if (R == R_83) { print "find notable locale objects rule"; return; } ! rule 43
        if (R == R_84) { print "interesting locale paragraphs rule"; return; } ! rule 44
        if (R == R_85) { print "you-can-also-see rule"; return; } ! rule 45
        if (R == R_86) { print "standard notable locale objects rule"; return; } ! rule 46
        if (R == R_87) { print "don't mention player's supporter in room descriptions rule"; return; } ! rule 47
        if (R == R_88) { print "don't mention scenery in room descriptions rule"; return; } ! rule 48
        if (R == R_89) { print "don't mention undescribed items in room descriptions rule"; return; } ! rule 49
        if (R == R_90) { print "set pronouns from items in room descriptions rule"; return; } ! rule 50
        if (R == R_91) { print "offer items to writing a paragraph about rule"; return; } ! rule 51
        if (R == R_92) { print "use initial appearance in room descriptions rule"; return; } ! rule 52
        if (R == R_93) { print "initial appearance on supporters rule"; return; } ! rule 53
        if (R == R_95) { print "describe what's on scenery supporters in room descriptions rule"; return; } ! rule 54
        if (R == R_96) { print "print empty inventory rule"; return; } ! rule 55
        if (R == R_97) { print "print standard inventory rule"; return; } ! rule 56
        if (R == R_98) { print "report other people taking inventory rule"; return; } ! rule 57
        if (R == R_99) { print "can't take yourself rule"; return; } ! rule 58
        if (R == R_100) { print "can't take other people rule"; return; } ! rule 59
        if (R == R_101) { print "can't take component parts rule"; return; } ! rule 60
        if (R == R_102) { print "can't take people's possessions rule"; return; } ! rule 61
        if (R == R_103) { print "can't take items out of play rule"; return; } ! rule 62
        if (R == R_104) { print "can't take what you're inside rule"; return; } ! rule 63
        if (R == R_105) { print "can't take what's already taken rule"; return; } ! rule 64
        if (R == R_106) { print "can't take scenery rule"; return; } ! rule 65
        if (R == R_107) { print "can only take things rule"; return; } ! rule 66
        if (R == R_108) { print "can't take what's fixed in place rule"; return; } ! rule 67
        if (R == R_109) { print "use player's holdall to avoid exceeding carrying capacity rule"; return; } ! rule 68
        if (R == R_110) { print "can't exceed carrying capacity rule"; return; } ! rule 69
        if (R == R_111) { print "standard taking rule"; return; } ! rule 70
        if (R == R_112) { print "standard report taking rule"; return; } ! rule 71
        if (R == R_113) { print "can't remove what's not inside rule"; return; } ! rule 72
        if (R == R_114) { print "can't remove from people rule"; return; } ! rule 73
        if (R == R_115) { print "convert remove to take rule"; return; } ! rule 74
        if (R == R_116) { print "can't drop yourself rule"; return; } ! rule 75
        if (R == R_117) { print "can't drop body parts rule"; return; } ! rule 76
        if (R == R_118) { print "can't drop what's already dropped rule"; return; } ! rule 77
        if (R == R_119) { print "can't drop what's not held rule"; return; } ! rule 78
        if (R == R_120) { print "can't drop clothes being worn rule"; return; } ! rule 79
        if (R == R_121) { print "can't drop if this exceeds carrying capacity rule"; return; } ! rule 80
        if (R == R_122) { print "standard dropping rule"; return; } ! rule 81
        if (R == R_123) { print "standard report dropping rule"; return; } ! rule 82
        if (R == R_124) { print "convert put to drop where possible rule"; return; } ! rule 83
        if (R == R_125) { print "can't put what's not held rule"; return; } ! rule 84
        if (R == R_126) { print "can't put something on itself rule"; return; } ! rule 85
        if (R == R_127) { print "can't put onto what's not a supporter rule"; return; } ! rule 86
        if (R == R_128) { print "can't put clothes being worn rule"; return; } ! rule 87
        if (R == R_129) { print "can't put if this exceeds carrying capacity rule"; return; } ! rule 88
        if (R == R_130) { print "standard putting rule"; return; } ! rule 89
        if (R == R_131) { print "concise report putting rule"; return; } ! rule 90
        if (R == R_132) { print "standard report putting rule"; return; } ! rule 91
        if (R == R_133) { print "convert insert to drop where possible rule"; return; } ! rule 92
        if (R == R_134) { print "can't insert what's not held rule"; return; } ! rule 93
        if (R == R_135) { print "can't insert something into itself rule"; return; } ! rule 94
        if (R == R_136) { print "can't insert into closed containers rule"; return; } ! rule 95
        if (R == R_137) { print "can't insert into what's not a container rule"; return; } ! rule 96
        if (R == R_138) { print "can't insert clothes being worn rule"; return; } ! rule 97
        if (R == R_139) { print "can't insert if this exceeds carrying capacity rule"; return; } ! rule 98
        if (R == R_140) { print "standard inserting rule"; return; } ! rule 99
        if (R == R_141) { print "concise report inserting rule"; return; } ! rule 100
        if (R == R_142) { print "standard report inserting rule"; return; } ! rule 101
        if (R == R_143) { print "can't eat unless edible rule"; return; } ! rule 102
        if (R == R_144) { print "can't eat clothing without removing it first rule"; return; } ! rule 103
        if (R == R_145) { print "can't eat other people's food rule"; return; } ! rule 104
        if (R == R_146) { print "can't eat portable food without carrying it rule"; return; } ! rule 105
        if (R == R_147) { print "standard eating rule"; return; } ! rule 106
        if (R == R_148) { print "standard report eating rule"; return; } ! rule 107
        if (R == R_149) { print "standard set going variables rule"; return; } ! rule 108
        if (R == R_150) { print "stand up before going rule"; return; } ! rule 109
        if (R == R_151) { print "can't travel in what's not a vehicle rule"; return; } ! rule 110
        if (R == R_152) { print "can't go through undescribed doors rule"; return; } ! rule 111
        if (R == R_153) { print "can't go through closed doors rule"; return; } ! rule 112
        if (R == R_154) { print "determine map connection rule"; return; } ! rule 113
        if (R == R_155) { print "can't go that way rule"; return; } ! rule 114
        if (R == R_156) { print "move player and vehicle rule"; return; } ! rule 115
        if (R == R_157) { print "move floating objects rule"; return; } ! rule 116
        if (R == R_158) { print "check light in new location rule"; return; } ! rule 117
        if (R == R_159) { print "describe room gone into rule"; return; } ! rule 118
        if (R == R_160) { print "find what to enter rule"; return; } ! rule 119
        if (R == R_161) { print "convert enter door into go rule"; return; } ! rule 120
        if (R == R_162) { print "convert enter compass direction into go rule"; return; } ! rule 121
        if (R == R_163) { print "can't enter what's already entered rule"; return; } ! rule 122
        if (R == R_164) { print "can't enter what's not enterable rule"; return; } ! rule 123
        if (R == R_165) { print "can't enter closed containers rule"; return; } ! rule 124
        if (R == R_166) { print "can't enter if this exceeds carrying capacity rule"; return; } ! rule 125
        if (R == R_167) { print "can't enter something carried rule"; return; } ! rule 126
        if (R == R_168) { print "implicitly pass through other barriers rule"; return; } ! rule 127
        if (R == R_169) { print "standard entering rule"; return; } ! rule 128
        if (R == R_170) { print "standard report entering rule"; return; } ! rule 129
        if (R == R_171) { print "describe contents entered into rule"; return; } ! rule 130
        if (R == R_173) { print "convert exit into go out rule"; return; } ! rule 131
        if (R == R_174) { print "can't exit when not inside anything rule"; return; } ! rule 132
        if (R == R_175) { print "can't exit closed containers rule"; return; } ! rule 133
        if (R == R_176) { print "convert exit into get off rule"; return; } ! rule 134
        if (R == R_177) { print "standard exiting rule"; return; } ! rule 135
        if (R == R_178) { print "standard report exiting rule"; return; } ! rule 136
        if (R == R_179) { print "describe room emerged into rule"; return; } ! rule 137
        if (R == R_180) { print "can't get off things rule"; return; } ! rule 138
        if (R == R_181) { print "standard getting off rule"; return; } ! rule 139
        if (R == R_182) { print "standard report getting off rule"; return; } ! rule 140
        if (R == R_183) { print "describe room stood up into rule"; return; } ! rule 141
        if (R == R_184) { print "determine visibility ceiling rule"; return; } ! rule 142
        if (R == R_185) { print "declare everything unmentioned rule"; return; } ! rule 143
        if (R == R_186) { print "room description heading rule"; return; } ! rule 144
        if (R == R_187) { print "room description body text rule"; return; } ! rule 145
        if (R == R_188) { print "room description paragraphs about objects rule"; return; } ! rule 146
        if (R == R_189) { print "check new arrival rule"; return; } ! rule 147
        if (R == R_190) { print "other people looking rule"; return; } ! rule 148
        if (R == R_191) { print "standard examining rule"; return; } ! rule 149
        if (R == R_192) { print "examine directions rule"; return; } ! rule 150
        if (R == R_193) { print "examine containers rule"; return; } ! rule 151
        if (R == R_194) { print "examine supporters rule"; return; } ! rule 152
        if (R == R_195) { print "examine devices rule"; return; } ! rule 153
        if (R == R_196) { print "examine undescribed things rule"; return; } ! rule 154
        if (R == R_197) { print "report other people examining rule"; return; } ! rule 155
        if (R == R_198) { print "standard looking under rule"; return; } ! rule 156
        if (R == R_199) { print "report other people looking under rule"; return; } ! rule 157
        if (R == R_200) { print "can't search unless container or supporter rule"; return; } ! rule 158
        if (R == R_201) { print "can't search closed opaque containers rule"; return; } ! rule 159
        if (R == R_202) { print "standard search containers rule"; return; } ! rule 160
        if (R == R_203) { print "standard search supporters rule"; return; } ! rule 161
        if (R == R_204) { print "report other people searching rule"; return; } ! rule 162
        if (R == R_205) { print "block consulting rule"; return; } ! rule 163
        if (R == R_206) { print "can't lock without a lock rule"; return; } ! rule 164
        if (R == R_207) { print "can't lock what's already locked rule"; return; } ! rule 165
        if (R == R_208) { print "can't lock what's open rule"; return; } ! rule 166
        if (R == R_209) { print "can't lock without the correct key rule"; return; } ! rule 167
        if (R == R_210) { print "standard locking rule"; return; } ! rule 168
        if (R == R_211) { print "standard report locking rule"; return; } ! rule 169
        if (R == R_212) { print "can't unlock without a lock rule"; return; } ! rule 170
        if (R == R_213) { print "can't unlock what's already unlocked rule"; return; } ! rule 171
        if (R == R_214) { print "can't unlock without the correct key rule"; return; } ! rule 172
        if (R == R_215) { print "standard unlocking rule"; return; } ! rule 173
        if (R == R_216) { print "standard report unlocking rule"; return; } ! rule 174
        if (R == R_217) { print "can't switch on unless switchable rule"; return; } ! rule 175
        if (R == R_218) { print "can't switch on what's already on rule"; return; } ! rule 176
        if (R == R_219) { print "standard switching on rule"; return; } ! rule 177
        if (R == R_220) { print "standard report switching on rule"; return; } ! rule 178
        if (R == R_221) { print "can't switch off unless switchable rule"; return; } ! rule 179
        if (R == R_222) { print "can't switch off what's already off rule"; return; } ! rule 180
        if (R == R_223) { print "standard switching off rule"; return; } ! rule 181
        if (R == R_224) { print "standard report switching off rule"; return; } ! rule 182
        if (R == R_225) { print "can't open unless openable rule"; return; } ! rule 183
        if (R == R_226) { print "can't open what's locked rule"; return; } ! rule 184
        if (R == R_227) { print "can't open what's already open rule"; return; } ! rule 185
        if (R == R_228) { print "standard opening rule"; return; } ! rule 186
        if (R == R_229) { print "reveal any newly visible interior rule"; return; } ! rule 187
        if (R == R_230) { print "standard report opening rule"; return; } ! rule 188
        if (R == R_231) { print "can't close unless openable rule"; return; } ! rule 189
        if (R == R_232) { print "can't close what's already closed rule"; return; } ! rule 190
        if (R == R_233) { print "standard closing rule"; return; } ! rule 191
        if (R == R_234) { print "standard report closing rule"; return; } ! rule 192
        if (R == R_235) { print "can't wear what's not clothing rule"; return; } ! rule 193
        if (R == R_236) { print "can't wear what's not held rule"; return; } ! rule 194
        if (R == R_237) { print "can't wear what's already worn rule"; return; } ! rule 195
        if (R == R_238) { print "standard wearing rule"; return; } ! rule 196
        if (R == R_239) { print "standard report wearing rule"; return; } ! rule 197
        if (R == R_241) { print "can't take off what's not worn rule"; return; } ! rule 198
        if (R == R_242) { print "can't exceed carrying capacity when taking off rule"; return; } ! rule 199
        if (R == R_243) { print "standard taking off rule"; return; } ! rule 200
        if (R == R_244) { print "standard report taking off rule"; return; } ! rule 201
        if (R == R_245) { print "can't give what you haven't got rule"; return; } ! rule 202
        if (R == R_246) { print "can't give to yourself rule"; return; } ! rule 203
        if (R == R_247) { print "can't give to a non-person rule"; return; } ! rule 204
        if (R == R_248) { print "can't give clothes being worn rule"; return; } ! rule 205
        if (R == R_249) { print "block giving rule"; return; } ! rule 206
        if (R == R_250) { print "can't exceed carrying capacity when giving rule"; return; } ! rule 207
        if (R == R_251) { print "standard giving rule"; return; } ! rule 208
        if (R == R_252) { print "standard report giving rule"; return; } ! rule 209
        if (R == R_253) { print "can't show what you haven't got rule"; return; } ! rule 210
        if (R == R_254) { print "convert show to yourself to examine rule"; return; } ! rule 211
        if (R == R_255) { print "block showing rule"; return; } ! rule 212
        if (R == R_256) { print "block waking rule"; return; } ! rule 213
        if (R == R_257) { print "implicitly remove thrown clothing rule"; return; } ! rule 214
        if (R == R_258) { print "futile to throw things at inanimate objects rule"; return; } ! rule 215
        if (R == R_259) { print "block throwing at rule"; return; } ! rule 216
        if (R == R_260) { print "block attacking rule"; return; } ! rule 217
        if (R == R_261) { print "kissing yourself rule"; return; } ! rule 218
        if (R == R_262) { print "block kissing rule"; return; } ! rule 219
        if (R == R_263) { print "block answering rule"; return; } ! rule 220
        if (R == R_264) { print "telling yourself rule"; return; } ! rule 221
        if (R == R_265) { print "block telling rule"; return; } ! rule 222
        if (R == R_266) { print "block asking rule"; return; } ! rule 223
        if (R == R_267) { print "asking yourself for something rule"; return; } ! rule 224
        if (R == R_268) { print "translate asking for to giving rule"; return; } ! rule 225
        if (R == R_269) { print "standard report waiting rule"; return; } ! rule 226
        if (R == R_270) { print "report touching yourself rule"; return; } ! rule 227
        if (R == R_271) { print "report touching other people rule"; return; } ! rule 228
        if (R == R_272) { print "report touching things rule"; return; } ! rule 229
        if (R == R_273) { print "can't wave what's not held rule"; return; } ! rule 230
        if (R == R_274) { print "report waving things rule"; return; } ! rule 231
        if (R == R_275) { print "can't pull what's fixed in place rule"; return; } ! rule 232
        if (R == R_276) { print "can't pull scenery rule"; return; } ! rule 233
        if (R == R_277) { print "can't pull people rule"; return; } ! rule 234
        if (R == R_278) { print "report pulling rule"; return; } ! rule 235
        if (R == R_279) { print "can't push what's fixed in place rule"; return; } ! rule 236
        if (R == R_280) { print "can't push scenery rule"; return; } ! rule 237
        if (R == R_281) { print "can't push people rule"; return; } ! rule 238
        if (R == R_282) { print "report pushing rule"; return; } ! rule 239
        if (R == R_283) { print "can't turn what's fixed in place rule"; return; } ! rule 240
        if (R == R_284) { print "can't turn scenery rule"; return; } ! rule 241
        if (R == R_285) { print "can't turn people rule"; return; } ! rule 242
        if (R == R_286) { print "report turning rule"; return; } ! rule 243
        if (R == R_287) { print "can't push unpushable things rule"; return; } ! rule 244
        if (R == R_288) { print "can't push to non-directions rule"; return; } ! rule 245
        if (R == R_289) { print "can't push vertically rule"; return; } ! rule 246
        if (R == R_290) { print "can't push from within rule"; return; } ! rule 247
        if (R == R_291) { print "standard pushing in directions rule"; return; } ! rule 248
        if (R == R_292) { print "block pushing in directions rule"; return; } ! rule 249
        if (R == R_293) { print "innuendo about squeezing people rule"; return; } ! rule 250
        if (R == R_294) { print "report squeezing rule"; return; } ! rule 251
        if (R == R_295) { print "block saying yes rule"; return; } ! rule 252
        if (R == R_296) { print "block saying no rule"; return; } ! rule 253
        if (R == R_297) { print "block burning rule"; return; } ! rule 254
        if (R == R_298) { print "block waking up rule"; return; } ! rule 255
        if (R == R_299) { print "block thinking rule"; return; } ! rule 256
        if (R == R_300) { print "report smelling rule"; return; } ! rule 257
        if (R == R_301) { print "report listening rule"; return; } ! rule 258
        if (R == R_302) { print "report tasting rule"; return; } ! rule 259
        if (R == R_303) { print "block cutting rule"; return; } ! rule 260
        if (R == R_304) { print "report jumping rule"; return; } ! rule 261
        if (R == R_305) { print "block tying rule"; return; } ! rule 262
        if (R == R_306) { print "block drinking rule"; return; } ! rule 263
        if (R == R_307) { print "block saying sorry rule"; return; } ! rule 264
        if (R == R_308) { print "block swinging rule"; return; } ! rule 265
        if (R == R_309) { print "can't rub another person rule"; return; } ! rule 266
        if (R == R_310) { print "report rubbing rule"; return; } ! rule 267
        if (R == R_311) { print "block setting it to rule"; return; } ! rule 268
        if (R == R_312) { print "report waving hands rule"; return; } ! rule 269
        if (R == R_313) { print "block buying rule"; return; } ! rule 270
        if (R == R_314) { print "block climbing rule"; return; } ! rule 271
        if (R == R_315) { print "block sleeping rule"; return; } ! rule 272
        if (R == R_810) { print "exit descriptions rule"; return; } ! rule 273
        if (R == R_811) { print "opening doors before entering rule"; return; } ! rule 274
        if (R == R_812) { print "closing doors before locking rule"; return; } ! rule 275
        if (R == R_813) { print "closing doors before locking keylessly rule"; return; } ! rule 276
        if (R == R_814) { print "unlocking before opening rule"; return; } ! rule 277
        if (R == R_815) { print "intelligently opening doors rule"; return; } ! rule 278
        if (R == R_816) { print "intelligently closing doors rule"; return; } ! rule 279
        if (R == R_817) { print "intelligently closing keyless doors rule"; return; } ! rule 280
        if (R == R_818) { print "intelligently opening containers rule"; return; } ! rule 281
        if (R == R_819) { print "need a matching key rule"; return; } ! rule 282
        if (R == R_821) { print "standard printing key lack rule"; return; } ! rule 283
        if (R == R_823) { print "must be able to reach the key rule"; return; } ! rule 284
        if (R == R_824) { print "right second rule"; return; } ! rule 285
        if (R == R_825) { print "check keylessly unlocking rule"; return; } ! rule 286
        if (R == R_826) { print "standard keylessly unlocking rule"; return; } ! rule 287
        if (R == R_828) { print "check keylessly locking rule"; return; } ! rule 288
        if (R == R_829) { print "standard keylessly locking rule"; return; } ! rule 289
        if (R == R_831) { print "identify passkeys in inventory rule"; return; } ! rule 290
        if (R == R_832) { print "passkey description rule"; return; } ! rule 291
        if (R == R_833) { print "standard passkey unlocking rule"; return; } ! rule 292
        if (R == R_834) { print "observe someone unlocking rule"; return; } ! rule 293
        if (R == R_835) { print "standard passkey locking rule"; return; } ! rule 294
        if (R == R_836) { print "observe someone locking rule"; return; } ! rule 295
        if (R == R_837) { print "limiting keychains rule"; return; } ! rule 296
        if (R == R_838) { print "keychain-aware carrying requirements rule"; return; } ! rule 297
        if (R == R_839) { print "don't strip keys rule"; return; } ! rule 298
        if (R == R_840) { print "noun autotaking rule"; return; } ! rule 299
        if (R == R_841) { print "second noun autotaking rule"; return; } ! rule 300
        if (R == R_842) { print "must hold the noun rule"; return; } ! rule 301
        if (R == R_843) { print "must hold the second noun rule"; return; } ! rule 302
        if (R == R_844) { print "must have accessible the noun rule"; return; } ! rule 303
        if (R == R_845) { print "must have accessible the second noun rule"; return; } ! rule 304
        if (R == R_892) { print "quit rule"; return; } ! rule 305
        if (R == R_893) { print "move down rule"; return; } ! rule 306
        if (R == R_894) { print "move up rule"; return; } ! rule 307
        if (R == R_895) { print "select rule"; return; } ! rule 308
        if (R == R_899) { print "basic menu contents rule"; return; } ! rule 309
        if (R == R_900) { print "constructing status line while displaying rule"; return; } ! rule 310
        if (R == R_903) { print "hint toggle rule"; return; } ! rule 311
        if (R == R_910) { print "standard pausing the game rule"; return; } ! rule 312
        if (R == LITTLE_USED_DO_NOTHING_R) { print "little-used do nothing rule"; return; } ! rule 313
        if (R == VIRTUAL_MACHINE_STARTUP_R) { print "virtual machine startup rule"; return; } ! rule 314
        if (R == INITIALISE_MEMORY_R) { print "initialise memory rule"; return; } ! rule 315
        if (R == SEED_RANDOM_NUMBER_GENERATOR_R) { print "seed random number generator rule"; return; } ! rule 316
        if (R == UPDATE_CHRONOLOGICAL_RECORDS_R) { print "update chronological records rule"; return; } ! rule 317
        if (R == POSITION_PLAYER_IN_MODEL_R) { print "position player in model world rule"; return; } ! rule 318
        if (R == ADJUST_LIGHT_R) { print "adjust light rule"; return; } ! rule 319
        if (R == ADVANCE_TIME_R) { print "advance time rule"; return; } ! rule 320
        if (R == GENERATE_ACTION_R) { print "generate action rule"; return; } ! rule 321
        if (R == NOTE_OBJECT_ACQUISITIONS_R) { print "note object acquisitions rule"; return; } ! rule 322
        if (R == PARSE_COMMAND_R) { print "parse command rule"; return; } ! rule 323
        if (R == TIMED_EVENTS_R) { print "timed events rule"; return; } ! rule 324
        if (R == RESURRECT_PLAYER_IF_ASKED_R) { print "resurrect player if asked rule"; return; } ! rule 325
        if (R == ASK_FINAL_QUESTION_R) { print "ask the final question rule"; return; } ! rule 326
        if (R == DetectSceneChange) { print "scene change machinery rule"; return; } ! rule 327
        if (R == BASIC_ACCESSIBILITY_R) { print "basic accessibility rule"; return; } ! rule 328
        if (R == BASIC_VISIBILITY_R) { print "basic visibility rule"; return; } ! rule 329
        if (R == CARRYING_REQUIREMENTS_R) { print "carrying requirements rule"; return; } ! rule 330
        if (R == REQUESTED_ACTIONS_REQUIRE_R) { print "requested actions require persuasion rule"; return; } ! rule 331
        if (R == CARRY_OUT_REQUESTED_ACTIONS_R) { print "carry out requested actions rule"; return; } ! rule 332
        if (R == DESCEND_TO_SPECIFIC_ACTION_R) { print "descend to specific action-processing rule"; return; } ! rule 333
        if (R == WORK_OUT_DETAILS_OF_SPECIFIC_R) { print "work out details of specific action rule"; return; } ! rule 334
        if (R == ACCESS_THROUGH_BARRIERS_R) { print "access through barriers rule"; return; } ! rule 335
        if (R == CANT_REACH_INSIDE_CLOSED_R) { print "can't reach inside closed containers rule"; return; } ! rule 336
        if (R == CANT_REACH_INSIDE_ROOMS_R) { print "can't reach inside rooms rule"; return; } ! rule 337
        if (R == CANT_REACH_OUTSIDE_CLOSED_R) { print "can't reach outside closed containers rule"; return; } ! rule 338
        if (R == LIST_WRITER_INTERNAL_R) { print "list writer internal rule"; return; } ! rule 339
        if (R == ACTION_PROCESSING_INTERNAL_R) { print "action processing internal rule"; return; } ! rule 340
        if (R == PARSER_ERROR_INTERNAL_R) { print "parser error internal rule"; return; } ! rule 341
        if (R == PARSER_N_ERROR_INTERNAL_R) { print "parser nothing error internal rule"; return; } ! rule 342
        if (R == DARKNESS_NAME_INTERNAL_R) { print "darkness name internal rule"; return; } ! rule 343
        if (R == PARSER_COMMAND_INTERNAL_R) { print "parser command internal rule"; return; } ! rule 344
        if (R == PARSER_CLARIF_INTERNAL_R) { print "parser clarification internal rule"; return; } ! rule 345
        if (R == YES_OR_NO_QUESTION_INTERNAL_R) { print "yes or no question internal rule"; return; } ! rule 346
        if (R == PRINT_PROTAGONIST_INTERNAL_R) { print "print protagonist internal rule"; return; } ! rule 347
        if (R == STANDARD_NAME_PRINTING_R) { print "standard name printing rule"; return; } ! rule 348
        if (R == STANDARD_CONTENTS_LISTING_R) { print "standard contents listing rule"; return; } ! rule 349
        if (R == STANDARD_IMPLICIT_TAKING_R) { print "standard implicit taking rule"; return; } ! rule 350
        if (R == ENABLE_GLULX_ACCEL_R) { print "enable Glulx acceleration rule"; return; } ! rule 351
        if (R == PRINT_OBITUARY_HEADLINE_R) { print "print obituary headline rule"; return; } ! rule 352
        if (R == PRINT_FINAL_SCORE_R) { print "print final score rule"; return; } ! rule 353
        if (R == DISPLAY_FINAL_STATUS_LINE_R) { print "display final status line rule"; return; } ! rule 354
        if (R == IMMEDIATELY_RESTART_VM_R) { print "immediately restart the VM rule"; return; } ! rule 355
        if (R == IMMEDIATELY_RESTORE_SAVED_R) { print "immediately restore saved game rule"; return; } ! rule 356
        if (R == IMMEDIATELY_QUIT_R) { print "immediately quit rule"; return; } ! rule 357
        if (R == IMMEDIATELY_UNDO_R) { print "immediately undo rule"; return; } ! rule 358
        if (R == READ_FINAL_ANSWER_R) { print "read the final answer rule"; return; } ! rule 359
        if (R == STANDARD_RESPONSE_ISSUING_R) { print "standard issuing the response text rule"; return; } ! rule 360
        if (R == QUIT_THE_GAME_R) { print "quit the game rule"; return; } ! rule 361
        if (R == SAVE_THE_GAME_R) { print "save the game rule"; return; } ! rule 362
        if (R == RESTORE_THE_GAME_R) { print "restore the game rule"; return; } ! rule 363
        if (R == RESTART_THE_GAME_R) { print "restart the game rule"; return; } ! rule 364
        if (R == VERIFY_THE_STORY_FILE_R) { print "verify the story file rule"; return; } ! rule 365
        if (R == SWITCH_TRANSCRIPT_ON_R) { print "switch the story transcript on rule"; return; } ! rule 366
        if (R == SWITCH_TRANSCRIPT_OFF_R) { print "switch the story transcript off rule"; return; } ! rule 367
        if (R == ANNOUNCE_STORY_FILE_VERSION_R) { print "announce the story file version rule"; return; } ! rule 368
        if (R == ANNOUNCE_SCORE_R) { print "announce the score rule"; return; } ! rule 369
        if (R == PREFER_ABBREVIATED_R) { print "prefer abbreviated room descriptions rule"; return; } ! rule 370
        if (R == REP_PREFER_ABBREVIATED_R) { print "standard report preferring abbreviated room descriptions rule"; return; } ! rule 371
        if (R == PREFER_UNABBREVIATED_R) { print "prefer unabbreviated room descriptions rule"; return; } ! rule 372
        if (R == REP_PREFER_UNABBREVIATED_R) { print "standard report preferring unabbreviated room descriptions rule"; return; } ! rule 373
        if (R == PREFER_SOMETIMES_ABBREVIATED_R) { print "prefer sometimes abbreviated room descriptions rule"; return; } ! rule 374
        if (R == REP_PREFER_SOMETIMES_ABBR_R) { print "standard report preferring sometimes abbreviated room descriptions rule"; return; } ! rule 375
        if (R == SWITCH_SCORE_NOTIFY_ON_R) { print "switch score notification on rule"; return; } ! rule 376
        if (R == REP_SWITCH_NOTIFY_ON_R) { print "standard report switching score notification on rule"; return; } ! rule 377
        if (R == SWITCH_SCORE_NOTIFY_OFF_R) { print "switch score notification off rule"; return; } ! rule 378
        if (R == REP_SWITCH_NOTIFY_OFF_R) { print "standard report switching score notification off rule"; return; } ! rule 379
        if (R == ANNOUNCE_PRONOUN_MEANINGS_R) { print "announce the pronoun meanings rule"; return; } ! rule 380
        if (R == R_16) { print "A first turn sequence rule"; return; } ! rule 381
        if (R == R_17) { print "A last turn sequence rule"; return; } ! rule 382
        if (R == R_32) { print "last specific action-processing rule"; return; } ! rule 383
        if (R == R_172) { print "Setting action variables for exiting"; return; } ! rule 384
        if (R == R_240) { print "Does the player mean taking off something worn"; return; } ! rule 385
        if (R == R_827) { print "Check locking it with"; return; } ! rule 386
        if (R == R_846) { print "After printing the name of something ( called the target )"; return; } ! rule 387
        if (R == R_887) { print "Every turn"; return; } ! rule 388
        if (R == R_888) { print "After printing the name of an ambiguously plural thing ( called the suspect )"; return; } ! rule 389
        if (R == R_935) { print "When play begins"; return; } ! rule 390
        if (R == R_936) { print "After reading a command when the gender of the player is unknown"; return; } ! rule 391
        if (R == R_937) { print "Instead of examining the player when the player is female"; return; } ! rule 392
        if (R == R_938) { print "Instead of examining the player when the player is male"; return; } ! rule 393
        if (R == R_939) { print "Every turn when the player is in a cursed room"; return; } ! rule 394
        if (R == R_940) { print "Check reading"; return; } ! rule 395
        if (R == R_941) { print "Carry out reading"; return; } ! rule 396
        if (R == R_942) { print "Rule for printing the banner text"; return; } ! rule 397
        if (R == R_943) { print "Instead of inserting something into the small gold box"; return; } ! rule 398
        if (R == R_944) { print "When chooseYourDestiny begins"; return; } ! rule 399
        if (R == R_945) { print "When chooseYourDestiny ends"; return; } ! rule 400
        if (R == R_947) { print "When gazelleTransformation begins"; return; } ! rule 401
        if (R == R_948) { print "After examining the desk for the first time"; return; } ! rule 402
        if (R == R_949) { print "Instead of searching a closed drawer"; return; } ! rule 403
        if (R == R_950) { print "After opening a drawer when no drawers are explored"; return; } ! rule 404
        if (R == R_951) { print "After opening an unexplored drawer when exactly one drawer is explored"; return; } ! rule 405
        if (R == R_952) { print "After closing a drawer"; return; } ! rule 406
        if (R == R_953) { print "Before opening an unexplored drawer when exactly two drawers are explored"; return; } ! rule 407
        if (R == R_954) { print "Instead of opening the desk when at least one drawer is unexplored"; return; } ! rule 408
        if (R == R_955) { print "Instead of looking under the desk when no drawers are explored"; return; } ! rule 409
        if (R == R_956) { print "Instead of looking under the desk when at least one drawer is unexplored"; return; } ! rule 410
        if (R == R_957) { print "Instead of looking under the desk when all drawers are explored"; return; } ! rule 411
        if (R == R_958) { print "Instead of searching the desk when at least one drawer is unexplored"; return; } ! rule 412
        if (R == R_959) { print "Every turn when the player is in Lackluster Apartments"; return; } ! rule 413
        if (R == R_960) { print "when gaggleBecomesHerd begins"; return; } ! rule 414
        if (R == R_961) { print "when newsCast begins"; return; } ! rule 415
        if (R == R_962) { print "Every turn when the player is in Birds of Paradise"; return; } ! rule 416
        if (R == R_963) { print "When Joining The Zoo begins"; return; } ! rule 417
        if (R == R_964) { print "instead of player taking Bull Horn"; return; } ! rule 418
        if (R == R_965) { print "Every turn when the player is in the Business District"; return; } ! rule 419
        if (R == R_966) { print "When genieInABottle begins"; return; } ! rule 420
        if (R == R_967) { print "instead of player entering Storage Room"; return; } ! rule 421
        if (R == R_969) { print "When Exploring Your Office begins"; return; } ! rule 422
        if (R == R_970) { print "When Jerked begins"; return; } ! rule 423
        if (R == R_971) { print "when supplyShopEvent begins"; return; } ! rule 424
        if (R == R_973) { print "After examining the Mysterious Door"; return; } ! rule 425
        if (R == R_974) { print "After reading a command when the command prompt is ~Please enter the password now. >~"; return; } ! rule 426
        if (R == R_975) { print "After reading a command when the command prompt is ~Would you like to try again? (Yes or No) >~"; return; } ! rule 427
        if (R == R_976) { print "Every turn when the player is in The Long John"; return; } ! rule 428
        if (R == R_978) { print "Every turn when the player is in Palomino Bar n Grill"; return; } ! rule 429
        if (R == R_988) { print "When Here Girl begins"; return; } ! rule 430
        if (R == R_989) { print "When Here Girl ends"; return; } ! rule 431
        if (R == R_993) { print "When SizeIncrease begins"; return; } ! rule 432
        if (R == R_994) { print "When SizeIncrease ends"; return; } ! rule 433
        if (R == R_997) { print "When dontCroak begins"; return; } ! rule 434
        if (R == R_1006) { print "When MareTf begins"; return; } ! rule 435
        if (R == R_1015) { print "When SwineOption begins"; return; } ! rule 436

		print "(nameless rule at address ", R, ")";
	}
#ifnot;
	if ((R>=0) && (R<NUMBER_RULEBOOKS_CREATED)) {
		print "(rulebook ", R, ")";
	} else {
		print "(rule at address ", R, ")";
	}
#endif;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Rulebooks.i6t: Casting
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ RULEBOOK_TY_to_RULE_TY r;
	return r;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Rulebooks.i6t: Debugging
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ DebugRulebooks subs parameter i;
	spaces(2*process_rulebook_count);
	print "[", (RulePrintingRule) subs;
	if (parameter) print " / on O", parameter;
	print "]^";
];

[ DB_Rule R N blocked;
	if (R==0) return;
	print "[Rule ~", (RulePrintingRule) R, "~ ";
	#ifdef NUMBERED_RULES; print "(", N, ") "; #endif;
	if (blocked == false) "applies.]";
	print "does not apply (wrong ", (address) blocked, ").]^";
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Sort.i6t: Storage
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Global I7S_Tab; ! The array to be sorted, which can have almost any format
Global I7S_Col; ! The "column number" in the array, if any
Global I7S_Dir; ! The direction of sorting: ascending (1) or descending (-1)
Global I7S_Swap; ! The current routine for swapping two fields
Global I7S_Comp; ! The current routine for comparing two fields

#ifdef MEASURE_SORT_PERFORMANCE;
Global I7S_CCOUNT; Global I7S_CCOUNT2; Global I7S_XCOUNT; ! For testing only
#endif;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Sort.i6t: Front End
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SetSortDomain swapf compf;
	I7S_Swap = swapf;
	I7S_Comp = compf;
];

[ SortArray tab col dir size test_flag algorithm;
	I7S_Tab = tab;
	I7S_Col = col;
	I7S_Dir = dir;
	#ifdef MEASURE_SORT_PERFORMANCE;
	I7S_CCOUNT = 0;
	I7S_CCOUNT2 = 0;
	I7S_XCOUNT = 0;
	#endif;
	SortRange(0, size, algorithm);
	#ifdef MEASURE_SORT_PERFORMANCE;
	if (test_flag)
		print "Sorted array of size ", size, " with ", I7S_CCOUNT2, "*10000 + ", I7S_CCOUNT,
			" comparisons and ", I7S_XCOUNT, " exchanges^";
	#endif;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Sort.i6t: Sort Range
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SortRange x y algorithm;
	if (y - x < 2) return;
	if (algorithm) {
		(algorithm)(x, y);
	} else {
		InPlaceMergeSortAlgorithm(x, y);
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Sort.i6t: Comparison and Exchange
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ CompareFields x y;
	#ifdef MEASURE_SORT_PERFORMANCE;
	I7S_CCOUNT++;
	if (I7S_CCOUNT == 10000) { I7S_CCOUNT = 0; I7S_CCOUNT2++; }
	#endif;
	return I7S_Dir*I7S_Comp(I7S_Tab, I7S_Col, x+1, y+1, I7S_Dir);
];

[ ExchangeFields x y r;
	#ifdef MEASURE_SORT_PERFORMANCE;
	I7S_XCOUNT++;
	if (I7S_XCOUNT < 0) { print "XO^"; I7S_XCOUNT = 0; }
	#endif;
	r = I7S_Swap(I7S_Tab, x+1, y+1);
	
	return r; 
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Sort.i6t: 4W37 Sort
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ OldSortAlgorithm x y
	f i j;
	if (y - x < 2) return;
	f = true;
	while (f) {
		f = false;
		for (i=x:i<y:i++)
		    for (j=i+1:j<y:j++)
				if (CompareFields(i, j) > 0) {
					ExchangeFields(i, j); f = true; break;
				}
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Sort.i6t: Insertion Sort
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ InsertionSortAlgorithm from to
	i j;
	if (to > from+1) { 
		for (i = from+1: i < to: i++) { 
			for (j = i: j > from: j--) { 
				if (CompareFields(j, j-1) < 0) 
					ExchangeFields(j, j-1);
				else break;
			}
		}
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Sort.i6t: In-Place Mergesort
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ InPlaceMergeSortAlgorithm from to
	middle;
	if (to - from < 12) {
		if (to - from < 2) return;
		InsertionSortAlgorithm(from, to);
		return;
	}
	middle = (from + to)/2; 
	InPlaceMergeSortAlgorithm(from, middle); 
	InPlaceMergeSortAlgorithm(middle, to); 
	IPMS_Merge(from, middle, to, middle-from, to - middle); 
];

[ IPMS_Lower from to val
	len half mid;
	len = to - from;
	while (len > 0) { 
		half = len/2; 
		mid = from + half;
		if (CompareFields(mid, val) < 0) {
			from = mid + 1;
			len = len - half -1; 
		} else len = half;
	}
	return from;
];

[ IPMS_Upper from to val
	len half mid;
	len = to - from;
	while (len > 0) { 
		half = len/2; 
		mid = from + half;
		if (CompareFields(val, mid) < 0)
			len = half;
		else {
			from = mid + 1;
			len = len - half -1; 
		}
	}
	return from;
];

[ IPMS_Reverse from to;
	while (from < to) {
		ExchangeFields(from++, to--);
	}
];

[ IPMS_Rotate from mid to
	n val shift p1 p2;
	if ((from==mid) || (mid==to)) return; 
	IPMS_Reverse(from, mid-1); 
	IPMS_Reverse(mid, to-1); 
	IPMS_Reverse(from, to-1);
];

[ IPMS_Merge from pivot to len1 len2
	first_cut second_cut len11 len22 new_mid;
	if ((len1 == 0) || (len2 == 0)) return; 
	if (len1+len2 == 2) { 
		if (CompareFields(pivot, from) < 0) 
		ExchangeFields(pivot, from); 
		return; 
	}
	if (len1 > len2) { 
		len11 = len1/2; 
		first_cut = from + len11; 
		second_cut = IPMS_Lower(pivot, to, first_cut); 
		len22 = second_cut - pivot; 
	} else { 
		len22 = len2/2; 
		second_cut = pivot + len22; 
		first_cut = IPMS_Upper(from, pivot, second_cut); 
		len11 = first_cut - from; 
	} 
	IPMS_Rotate(first_cut, pivot, second_cut); 
	new_mid = first_cut + len22; 
	IPMS_Merge(from, first_cut, new_mid, len11, len22); 
	IPMS_Merge(new_mid, second_cut, to, len1 - len11, len2 - len22); 
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Format
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant TB_COLUMN_SIGNED      $4000;
Constant TB_COLUMN_TOPIC       $2000;
Constant TB_COLUMN_DONTSORTME  $1000;
Constant TB_COLUMN_NOBLANKBITS $0800;
Constant TB_COLUMN_CANEXCHANGE $0400;
Constant TB_COLUMN_ALLOCATED   $0200;
Constant TB_COLUMN_NUMBER      $01ff; ! Mask to remove upper bit flags

Constant COL_HSIZE 2; ! Column header size: two words (ID/flags, blank bits)


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Find Column
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TableFindCol tab col f i no_cols n;
	no_cols = tab-->0;
	for (i=1: i<=no_cols: i++)
		if (col == ((tab-->i)-->1) & TB_COLUMN_NUMBER) return i;
	if (f) { RunTimeProblem(RTP_TABLE_NOCOL, tab); return 0; }
	return 0;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Number of Rows
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TableRows tab first_col;
	first_col = tab-->1; if (first_col == 0) return 0;
	return (first_col-->0) - COL_HSIZE;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Blanks
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant TABLE_NOVALUE = IMPROBABLE_VALUE;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Masks
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Array CheckTableEntryIsBlank_LU
	->	$$00000001
		$$00000010
		$$00000100
		$$00001000
		$$00010000
		$$00100000
		$$01000000
		$$10000000;
Array CheckTableEntryIsNonBlank_LU
	->	$$11111110
		$$11111101
		$$11111011
		$$11110111
		$$11101111
		$$11011111
		$$10111111
		$$01111111;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Testing Blankness
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ CheckTableEntryIsBlank tab col row i at;
	if (col >= 100) col = TableFindCol(tab, col);
	if (col == 0) rtrue;
	if ((tab-->col)-->(row+COL_HSIZE) ~= TABLE_NOVALUE) {
		print "*** CTEIB on nonblank value ", tab, " ", col, " ", row, " ***^";
	}
	if (((tab-->col)-->1) & TB_COLUMN_NOBLANKBITS) rtrue;
	row--;
	at = ((tab-->col)-->2) + (row/8);
	if ((TB_Blanks->at) & (CheckTableEntryIsBlank_LU->(row%8))) rtrue;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Force Entry Blank
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ForceTableEntryBlank tab col row i at oldv flags;
	if (col >= 100) col = TableFindCol(tab, col);
	if (col == 0) rtrue;
	flags = (tab-->col)-->1;
	oldv = (tab-->col)-->(row+COL_HSIZE);
	if ((flags & TB_COLUMN_ALLOCATED) && (oldv ~= 0 or TABLE_NOVALUE))
		BlkValueFree(oldv);
	(tab-->col)-->(row+COL_HSIZE) = TABLE_NOVALUE;
	if (flags & TB_COLUMN_NOBLANKBITS) return;
	row--;
	at = ((tab-->col)-->2) + (row/8);
	(TB_Blanks->at) = (TB_Blanks->at) | (CheckTableEntryIsBlank_LU->(row%8));
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Force Entry Non-Blank
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ForceTableEntryNonBlank tab col row i at oldv flags tc kov;
	if (col >= 100) col=TableFindCol(tab, col);
	if (col == 0) rtrue;
	if (((tab-->col)-->1) & TB_COLUMN_NOBLANKBITS) return;
	flags = (tab-->col)-->1;
	oldv = (tab-->col)-->(row+COL_HSIZE);
	if ((flags & TB_COLUMN_ALLOCATED) &&
		(oldv == 0 or TABLE_NOVALUE)) {
		kov = UNKNOWN_TY;
		tc = ((tab-->col)-->1) & TB_COLUMN_NUMBER;
		kov = TC_KOV(tc);
		if (kov ~= UNKNOWN_TY) {
			(tab-->col)-->(row+COL_HSIZE) = BlkValueCreate(kov);
		}
	}
	row--;
	at = ((tab-->col)-->2) + (row/8);
	(TB_Blanks->at) = (TB_Blanks->at) & (CheckTableEntryIsNonBlank_LU->(row%8));
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Swapping Blank Bits
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TableSwapBlankBits tab row1 row2 col at1 at2 bit1 bit2;
	if (col >= 100) col=TableFindCol(tab, col);
	if (col == 0) rtrue;
	if (((tab-->col)-->1) & TB_COLUMN_NOBLANKBITS) return;
	row1--;
	at1 = ((tab-->col)-->2) + (row1/8);
	row2--;
	at2 = ((tab-->col)-->2) + (row2/8);
	bit1 = ((TB_Blanks->at1) & (CheckTableEntryIsBlank_LU->(row1%8)));
	bit2 = ((TB_Blanks->at2) & (CheckTableEntryIsBlank_LU->(row2%8)));
	if (bit1) bit1 = true; 
	if (bit2) bit2 = true;
	if (bit1 == bit2) return;
	if (bit1) {
		(TB_Blanks->at1)
			= (TB_Blanks->at1) & (CheckTableEntryIsNonBlank_LU->(row1%8));
		(TB_Blanks->at2)
			= (TB_Blanks->at2) | (CheckTableEntryIsBlank_LU->(row2%8));
	} else {
		(TB_Blanks->at1)
			= (TB_Blanks->at1) | (CheckTableEntryIsBlank_LU->(row1%8));
		(TB_Blanks->at2)
			= (TB_Blanks->at2) & (CheckTableEntryIsNonBlank_LU->(row2%8));
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Moving Blank Bits Down
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TableMoveBlankBitsDown tab row1 row2 col at atp1 bit rx;
	if (col >= 100) col=TableFindCol(tab, col);
	if (col == 0) rtrue;
	if (((tab-->col)-->1) & TB_COLUMN_NOBLANKBITS) return;
	row1--; row2--;
	! Read blank bit for row1:
	at = ((tab-->col)-->2) + (row1/8);
	bit = ((TB_Blanks->at) & (CheckTableEntryIsBlank_LU->(row1%8)));
	if (bit) bit = true;
	! Loop through, setting each blank bit to the next:
	for (rx=row1:rx<row2:rx++) {
		atp1 = ((tab-->col)-->2) + ((rx+1)/8);
		at = ((tab-->col)-->2) + (rx/8);
		if ((TB_Blanks->atp1) & (CheckTableEntryIsBlank_LU->((rx+1)%8))) {
			(TB_Blanks->at)
				= (TB_Blanks->at) | (CheckTableEntryIsBlank_LU->(rx%8));
		} else {
			(TB_Blanks->at)
				= (TB_Blanks->at) & (CheckTableEntryIsNonBlank_LU->(rx%8));
		}
	}
	! Write bit to blank bit for row2:
	at = ((tab-->col)-->2) + (row2/8);
	if (bit) {
		(TB_Blanks->at)
			= (TB_Blanks->at) | (CheckTableEntryIsBlank_LU->(row2%8));
	} else {
		(TB_Blanks->at)
			= (TB_Blanks->at) & (CheckTableEntryIsNonBlank_LU->(row2%8));
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Table Row Corresponding
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TableRowCorr tab col lookup_value lookup_col i j f v;
	if (col >= 100) col=TableFindCol(tab, col, true);
	lookup_col = tab-->col;
	j = lookup_col-->0 - COL_HSIZE;
	if (((tab-->col)-->1) & TB_COLUMN_ALLOCATED) f=1;
	if (f) {
		for (i=1:i<=j:i++) {
			v = lookup_col-->(i+COL_HSIZE);
			if ((v == TABLE_NOVALUE) &&
				(CheckTableEntryIsBlank(tab,col,i))) continue;
			if (BlkValueCompare(v, lookup_value) == 0)
				return i;
		}
	} else {
		for (i=1:i<=j:i++) {
			if ((lookup_value == TABLE_NOVALUE) &&
				(CheckTableEntryIsBlank(tab,col,i))) continue;
			if (lookup_col-->(i+COL_HSIZE) == lookup_value) return i;
		}
	}
	return RunTimeProblem(RTP_TABLE_NOCORR, tab);
];

[ ExistsTableRowCorr tab col entry i k v f kov;
	if (col >= 100) col=TableFindCol(tab, col);
	if (col == 0) rfalse;
	f=0;
	if (((tab-->col)-->1) & TB_COLUMN_TOPIC) f=1;
	else if (((tab-->col)-->1) & TB_COLUMN_ALLOCATED) f=2;
	k = TableRows(tab);
	for (i=1:i<=k:i++) {
		v = (tab-->col)-->(i+COL_HSIZE);
		if ((v == TABLE_NOVALUE) && (CheckTableEntryIsBlank(tab,col,i))) continue;
		switch (f) {
			1: if ((v)(entry/100, entry%100) ~= GPR_FAIL) return i;
			2: if (BlkValueCompare(v, entry) == 0) return i;
			default: if (v == entry) return i;
		}
	}
	! print "Giving up^";
	return 0;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Table Look Up Corresponding Row
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TableLookUpCorr tab col1 col2 lookup_value write_flag write_value cola1 cola2 i j v f;
	if (col1 >= 100) col1=TableFindCol(tab, col1, true);
	if (col2 >= 100) col2=TableFindCol(tab, col2, true);
	cola1 = tab-->col1;
	cola2 = tab-->col2;
	j = cola2-->0;
	f=0;
	if (((tab-->col2)-->1) & TB_COLUMN_ALLOCATED) f=1;
	if (((tab-->col2)-->1) & TB_COLUMN_TOPIC) f=2;
	for (i=1+COL_HSIZE:i<=j:i++) {
		v = cola2-->i;

		if ((v == TABLE_NOVALUE) && (CheckTableEntryIsBlank(tab,col2,i-COL_HSIZE))) continue;
		if (f == 1) {
			if (BlkValueCompare(v, lookup_value) ~= 0) continue;
		} else if (f == 2) {
			if ((v)(lookup_value/100, lookup_value%100) == GPR_FAIL) continue;
		} else {
			if (v ~= lookup_value) continue;
		}
		if (write_flag) {
			if (write_flag == 4) ForceTableEntryBlank(tab,col1,i-COL_HSIZE);
			else ForceTableEntryNonBlank(tab,col1,i-COL_HSIZE);
			switch (write_flag) {
				1: cola1-->i = write_value;
				2: cola1-->i = cola1-->i + write_value;
				3: cola1-->i = cola1-->i - write_value;
				5: return cola1-->i;
			}
			rfalse;
		}
		v = cola1-->i;
		if ((v == TABLE_NOVALUE) &&
			(CheckTableEntryIsBlank(tab,col1,i-COL_HSIZE))) continue;
		return v;
	}
	return RunTimeProblem(RTP_TABLE_NOCORR, tab);
];

[ ExistsTableLookUpCorr tab col1 col2 lookup_value cola1 cola2 i j f;
	if (col1 >= 100) col1=TableFindCol(tab, col1, false);
	if (col2 >= 100) col2=TableFindCol(tab, col2, false);
	if (col1*col2 == 0) rfalse;
	cola1 = tab-->col1; cola2 = tab-->col2;
	j = cola2-->0;
	f=0;
	if (((tab-->col2)-->1) & TB_COLUMN_ALLOCATED) f=1;
	if (((tab-->col2)-->1) & TB_COLUMN_TOPIC) f=2;
	for (i=1+COL_HSIZE:i<=j:i++) {
		if ((cola1-->i == TABLE_NOVALUE) &&
			(CheckTableEntryIsBlank(tab,col1,i-COL_HSIZE))) continue;
		if (f == 1) {
			if (BlkValueCompare(cola2-->i, lookup_value) ~= 0) continue;
		} else if (f == 2) {
			if ((cola2-->i)(lookup_value/100, lookup_value%100) == GPR_FAIL) continue;
		} else {
			if (cola2-->i ~= lookup_value) continue;
		}
		rtrue;
	}
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Table Look Up Entry
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TableLookUpEntry tab col index write_flag write_value v;
	if (tab == 0) return RunTimeProblem(RTP_TABLE_NOTABLE2);
	if (col >= 100) col=TableFindCol(tab, col, true);
	if ((index < 1) || (index > TableRows(tab))) {
		RunTimeProblem(RTP_TABLE_NOROW, tab, index); index = 1;
	}
	if (write_flag) {
		switch(write_flag) {
			1:	ForceTableEntryNonBlank(tab,col,index);
				(tab-->col)-->(index+COL_HSIZE) = write_value;
			2:	ForceTableEntryNonBlank(tab,col,index);
				(tab-->col)-->(index+COL_HSIZE) =
					((tab-->col)-->(index+COL_HSIZE)) + write_value;
			3:	ForceTableEntryNonBlank(tab,col,index);
				(tab-->col)-->(index+COL_HSIZE) =
					((tab-->col)-->(index+COL_HSIZE)) - write_value;
			4:	ForceTableEntryBlank(tab,col,index);
			5:	ForceTableEntryNonBlank(tab,col,index);
				return ((tab-->col)-->(index+COL_HSIZE));
		}
		rfalse;
	}
	v = ((tab-->col)-->(index+COL_HSIZE));
	if ((v == TABLE_NOVALUE) && (CheckTableEntryIsBlank(tab,col,index))) {
		RunTimeProblem(RTP_TABLE_NOENTRY, tab, col, index); rfalse;
	}
	return v;
];

[ ExistsTableLookUpEntry tab col index v;
	if (col >= 100) col=TableFindCol(tab, col);
	if (col == 0) rfalse;
	if ((index<1) || (index > TableRows(tab))) rfalse;
	v = ((tab-->col)-->(index+COL_HSIZE));
	if ((v == TABLE_NOVALUE) && (CheckTableEntryIsBlank(tab,col,index)))
		rfalse;
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Blank Rows
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TableRowIsBlank tab j k;
	for (k=1:k<=tab-->0:k++) {
		if (((tab-->k)-->(j+COL_HSIZE)) ~= TABLE_NOVALUE) rfalse;
		if (CheckTableEntryIsBlank(tab, k, j) == false) rfalse;
	}
	rtrue;
];

[ TableBlankOutRow tab row k;
	if (tab==0) return RunTimeProblem(RTP_TABLE_NOTABLE);
	for (k=1:k<=tab-->0:k++)
		ForceTableEntryBlank(tab, k, row);
];

[ TableBlankOutColumn tab col n k;
	if (tab==0) return RunTimeProblem(RTP_TABLE_NOTABLE);
	n = TableRows(tab);
	for (k=1:k<=n:k++)
		ForceTableEntryBlank(tab, col, k);
];

[ TableBlankOutAll tab n k;
	if (tab==0) return RunTimeProblem(RTP_TABLE_NOTABLE);
	n = TableRows(tab);
	for (k=1:k<=n:k++)
		TableBlankOutRow(tab, k);
];

[ TableBlankRows tab i j c;
	i = TableRows(tab); !print i, " rows^";
	for (j=1:j<=i:j++)
		if (TableRowIsBlank(tab, j)) c++;
	!print c, " blank^";
	return c;
];

[ TableFilledRows tab;
	return TableRows(tab) - TableBlankRows(tab);
];

[ TableBlankRow tab i j;
	i = TableRows(tab);
	for (j=1:j<=i:j++)
		if (TableRowIsBlank(tab, j)) return j;
	RunTimeProblem(RTP_TABLE_NOMOREBLANKS, tab);
	return i;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Random Row
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TableRandomRow tab i j k;
	i = TableRows(tab);
	j = TableFilledRows(tab);
	if (j==0) return RunTimeProblem(RTP_TABLE_NOROWS, tab);
	if (j>1) j = random(j);
	for (k=1:k<=i:k++) {
		if (TableRowIsBlank(tab, k) == false) j--;
		if (j==0) return k;
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Swap Rows
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TableSwapRows tab i j k l v1 v2;
	if (i==j) return;
	l = tab-->0;
	for (k=1:k<=l:k++) {
		v1 = (tab-->k)-->(i+COL_HSIZE);
		v2 = (tab-->k)-->(j+COL_HSIZE);
		(tab-->k)-->(i+COL_HSIZE) = v2;
		(tab-->k)-->(j+COL_HSIZE) = v1;
		if ((v1 == TABLE_NOVALUE) || (v2 == TABLE_NOVALUE))
			TableSwapBlankBits(tab, i, j, k);
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Compare Rows
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TableCompareRows tab col row1 row2 dir val1 val2 bl1 bl2 f;
	if (col >= 100) col=TableFindCol(tab, col, false);
	val1 = (tab-->col)-->(row1+COL_HSIZE);
	val2 = (tab-->col)-->(row2+COL_HSIZE);
	if (val1 == TABLE_NOVALUE) bl1 = CheckTableEntryIsBlank(tab,col,row1);
	if (val2 == TABLE_NOVALUE) bl2 = CheckTableEntryIsBlank(tab,col,row2);
	if ((val1 == val2) && (bl1 == bl2)) {
		if (val1 ~= TABLE_NOVALUE) return 0;
		if (bl1 == false) return 0;
		! The two entries are both blank:
		if (TableRowIsBlank(tab, row1)) {
		    if (TableRowIsBlank(tab, row2)) return 0;
		    return -1*dir;
		}
		if (TableRowIsBlank(tab, row2)) return dir;
		return 0;
	}
	if (bl1) return dir;
	if (bl2) return -1*dir;
	f = ((tab-->col)-->1);
	if (f & TB_COLUMN_ALLOCATED) {
		if (BlkValueCompare(val2, val1) < 0) return 1;
		return -1;
	} else if (f & TB_COLUMN_SIGNED) {
		if (val1 > val2) return 1;
		return -1;
	} else {
		if (UnsignedCompare(val1, val2) > 0) return 1;
		return -1;
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Move Row Down
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TableMoveRowDown tab r1 r2 rx k l m v f;
	if (r1==r2) return;
	l = tab-->0;
	for (k=1:k<=l:k++) {
		f = false;
		m = (tab-->k)-->(r1+COL_HSIZE);
		if (m == TABLE_NOVALUE) f = true;
		for (rx=r1:rx<r2:rx++) {
			v = (tab-->k)-->(rx+COL_HSIZE+1);
			(tab-->k)-->(rx+COL_HSIZE) = v;
			if (v == TABLE_NOVALUE) f = true;
		}
		(tab-->k)-->(r2+COL_HSIZE) = m;
		if (f) TableMoveBlankBitsDown(tab, r1, r2, k);
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Shuffle
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TableShuffle tab i to;
	TableMoveBlanksToBack(tab, 1, TableRows(tab));
	to = TableFilledRows(tab);
	for (i=2:i<=to:i++) TableSwapRows(tab, i, random(i));
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Next Row
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TableNextRow tab col row dir i k val v dv min_dv min_at signed_arithmetic f blk z;
	if (col >= 100) col=TableFindCol(tab, col, false);
	f = ((tab-->col)-->1);
	if (f & TB_COLUMN_ALLOCATED) blk = true;
	signed_arithmetic = f & TB_COLUMN_SIGNED;
	#Iftrue (WORDSIZE == 2);
	if (row == 0) {
		if (signed_arithmetic) {
		    if (dir == 1) val = $8000; else val = $7fff;
		} else {
		    if (dir == 1) val = 0; else val = $ffff;
		}
	} else val = (tab-->col)-->(row+COL_HSIZE);
	if (signed_arithmetic) min_dv = $7fff; else min_dv = $ffff;
	#ifnot; ! WORDSIZE == 4
	if (row == 0) {
		if (signed_arithmetic) {
		    if (dir == 1) val = $80000000; else val = $7fffffff;
		} else {
		    if (dir == 1) val = 0; else val = $ffffffff;
		}
	} else val = (tab-->col)-->(row+COL_HSIZE);
	if (signed_arithmetic) min_dv = $7fffffff; else min_dv = $ffffffff;
	#endif;
	k = TableRows(tab);
	if (dir == 1) {
		for (i=1:i<=k:i++) {
		    v = (tab-->col)-->(i+COL_HSIZE);
		    if ((v == TABLE_NOVALUE) && (CheckTableEntryIsBlank(tab,col,i)))
		    	continue;
		    if (blk) {
		    	dv = v;
				if (row == 0) z = 1; else z = BlkValueCompare(v, val);
				f = (((z > 0) || ((z == 0) && (i > row))) &&
					((min_at == 0) || (BlkValueCompare(v, min_dv) < 0)));
		    } else {
				dv = dir*v;
				if (signed_arithmetic)
				f = (((dv > dir*val) || ((v == val) && (i>row))) &&
					  (dv < min_dv));
				else
				f = (((UnsignedCompare(dv, dir*val) > 0) || ((v == val) && (i>row))) &&
					  (UnsignedCompare(dv, min_dv) < 0));
			}
		    if (f) { min_dv = dv; min_at = i; }
		}
	} else {
		for (i=k:i>=1:i--) {
		    v = (tab-->col)-->(i+COL_HSIZE);
		    if ((v == TABLE_NOVALUE) && (CheckTableEntryIsBlank(tab,col,i)))
		    	continue;
		    if (blk) {
		    	dv = v;
		    	if (row == 0) z = -1; else z = BlkValueCompare(v, val);
				f = (((z < 0) || ((z == 0) && (i < row))) &&
					((min_at == 0) || (BlkValueCompare(v, min_dv) > 0)));
		    } else {
				dv = dir*v;
				if (signed_arithmetic)
				f = (((dv > dir*val) || ((v == val) && (i<row))) &&
					  (dv < min_dv));
				else
				f = (((UnsignedCompare(dv, dir*val) > 0) || ((v == val) && (i<row))) &&
					  (UnsignedCompare(dv, min_dv) < 0));
			}
		    if (f) { min_dv = dv; min_at = i; }
		}
	}
	return min_at;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Move Blanks to Back
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TableMoveBlanksToBack tab fromrow torow i fbl lnbl blc;
	if (torow < fromrow) return;
	fbl = 0; lnbl = 0;
	for (i=fromrow: i<=torow: i++)
		if (TableRowIsBlank(tab, i)) {
			if (fbl == 0) fbl = i;
			blc++;
		} else {
			lnbl = i;
		}
	if ((fbl>0) && (lnbl>0) && (fbl < lnbl)) {
		TableMoveRowDown(tab, fbl, lnbl); ! Move first blank just past last nonblank
		TableMoveBlanksToBack(tab, fbl, lnbl-1);
	}
	return torow-blc; ! Final non-blank row
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Sort
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TableSort tab col dir test_flag algorithm i j k f;
	for (i=1:i<=tab-->0:i++) {
		j = tab-->i; ! Address of column table
		if ((j-->1) & TB_COLUMN_DONTSORTME)
		    return RunTimeProblem(RTP_TABLE_CANTSORT, tab);
	}
	if (col >= 100) col=TableFindCol(tab, col, false);
	k = TableRows(tab);
	k = TableMoveBlanksToBack(tab, 1, k);
	if (test_flag) {
		print "After moving blanks to back:^"; TableColumnDebug(tab, col);
	}

	SetSortDomain(TableSwapRows, TableCompareRows);
	SortArray(tab, col, dir, k, test_flag, algorithm);

	if (test_flag) {
		print "Final state:^"; TableColumnDebug(tab, col);
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Print Table Name
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PrintTableName T;
	switch(T) {
  TheEmptyTable: print "(the empty table)"; return;
  T0_final_question_options: print "Table of Final Question Options"; return;
  T1_locale_priorities: print "Table of Locale Priorities"; return;
  T2_sample_options: print "Table of Sample Options"; return;
  T3_menu_commands: print "Table of Menu Commands"; return;
  T4_shallow_menu_status: print "Table of Shallow Menu Status"; return;
  T5_deep_menu_status: print "Table of Deep Menu Status"; return;
  T6_sample_hints: print "Table of Sample Hints"; return;
  T8_ordinary_status: print "Table of Ordinary Status"; return;
  T9_example_equal_rankings: print "Table of Example Equal Rankings"; return;
  T10_example_ranged_rankings: print "Table of Example Ranged Rankings"; return;

		default: print "** No such table **";
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Print Table to File
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TablePrint tab i j k row col v tc kov;
	for (i=1:i<=tab-->0:i++) {
		j = tab-->i; ! Address of column table
		if (((j-->1) & TB_COLUMN_CANEXCHANGE) == 0)
		    rtrue;
	}
	k = TableRows(tab);
	k = TableMoveBlanksToBack(tab, 1, k);
	print "! ", (PrintTableName) tab, " (", k, ")^";
	for (row=1:row<=k:row++) {
		for (col=1:col<=tab-->0:col++) {
			tc = ((tab-->col)-->1) & TB_COLUMN_NUMBER;
			kov = KindAtomic(TC_KOV(tc));
			if (kov == UNKNOWN_TY) kov = NUMBER_TY;
			v = (tab-->col)-->(row+COL_HSIZE);
			if ((v == TABLE_NOVALUE) && (CheckTableEntryIsBlank(tab,col,row)))
				print "-- ";
			else {
				if (BlkValueWriteToFile(v, kov) == false) print v;
				print " ";
			}
		}
		print "^";
	}
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Read Table from File
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#ifdef TARGET_GLULX;
[ TableRead tab auxf row maxrow col ch v sgn dg j tc kov;
	for (col=1:col<=tab-->0:col++) {
		j = tab-->col; ! Address of column table
		if (((j-->1) & TB_COLUMN_CANEXCHANGE) == 0)
		    return RunTimeProblem(RTP_TABLE_CANTSAVE, tab);
	}
	maxrow = TableRows(tab);
	!print maxrow, " rows available.^";
	for (row=1: row<=maxrow: row++) {
		TableBlankOutRow(tab, row);
	}
	for (row=1: row<=maxrow: row++) {
		!print "Reading row ", row, "^";
		ch = FileIO_GetC(auxf);
		if (ch == '!') {
			while (ch ~= -1 or 10 or 13) ch = FileIO_GetC(auxf);
			while (ch == 10 or 13) ch = FileIO_GetC(auxf);
		}
		for (col=1: col<=tab-->0: col++) {
			if (ch == -1) { row++; jump NoMore; }
			if (ch == 10 or 13) break;
			tc = ((tab-->col)-->1) & TB_COLUMN_NUMBER;
			kov = KindAtomic(TC_KOV(tc));
			if (kov == UNKNOWN_TY) kov = NUMBER_TY;
			!print "tc = ", tc, " kov = ", kov, "^";
			sgn = 1;
			if (ch == '-') {
				ch = FileIO_GetC(auxf);
				if (ch == -1) jump NotTable;
				if (ch == '-') { ch = FileIO_GetC(auxf); jump EntryDone; }
				sgn = -1;
			}
			if (((tab-->col)-->1) & TB_COLUMN_ALLOCATED)
				ForceTableEntryNonBlank(tab, col, row);
			!print "A";
			v = BlkValueReadFromFile(0, 0, -1, kov);
			if (v) {
				if (((tab-->col)-->1) & TB_COLUMN_ALLOCATED)
					v = BlkValueReadFromFile(TableLookUpEntry(tab, col, row),
						auxf, ch, kov);
				else
					v = BlkValueReadFromFile(0, auxf, ch, kov);
				ch = 32;
			} else {
				dg = ch - '0';
				if ((dg < 0) || (dg > 9)) jump NotTable;
				v = dg;
				for (::) {
					ch = FileIO_GetC(auxf);
					dg = ch - '0';
					if ((dg < 0) || (dg > 9)) break;
					v = 10*v + dg;
				}
				v = v*sgn;
			}
			!print "v=", v, " ";
			if (((tab-->col)-->1) & TB_COLUMN_ALLOCATED == 0)
				TableLookUpEntry(tab, col, row, true, v);
			.EntryDone;
			!print "First nd is ", ch, "^";
			while (ch == 9 or 32) ch = FileIO_GetC(auxf);
		}
		while (ch ~= -1 or 10 or 13) {
			if ((ch ~= '-') && (((ch-'0')<0) || ((ch-'0')>9))) jump NotTable;
			if (ch ~= 9 or 32) jump WontFit;
			ch = FileIO_GetC(auxf);
		}
	}
	.NoMore;
	while (ch == 9 or 32 or 10 or 13) ch = FileIO_GetC(auxf);
	if (ch == -1) return;
	.WontFit;
	return RunTimeProblem(RTP_TABLE_WONTFIT, tab);
	.NotTable;
	return RunTimeProblem(RTP_TABLE_BADFILE, tab);
];
#ENDIF; ! TARGET_GLULX


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Print Rank
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PrintRank i j v;
#ifdef RANKING_TABLE;
	ANNOUNCE_SCORE_RM('B');
	j = TableRows(RANKING_TABLE);
	for (i=j:i>=1:i--)
		if (score >= TableLookUpEntry(RANKING_TABLE, 1, i)) {
		    v = TableLookUpEntry(RANKING_TABLE, 2, i);
		    TEXT_TY_Say(v);
		    ".";
		}
#endif;
	".";
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Debugging
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TableColumnDebug tab col k i v tc kov;
	if (col >= 100) col=TableFindCol(tab, col, false);
	k = TableRows(tab);
	tc = ((tab-->col)-->1) & TB_COLUMN_NUMBER;
	kov = TC_KOV(tc);
	for (i=1:i<=k:i++) {
		if (i>1) print ", ";
		v = (tab-->col)-->(i+COL_HSIZE);
		if ((v == TABLE_NOVALUE) && (CheckTableEntryIsBlank(tab,col,i)))
			print "--";
		else {
			PrintKindValuePair(kov, v);
		}
	}
	say__p = 1;
];

[ TableRowDebug tab i col k v tc kov;
	k = TableRows(tab);
	if ((i<1) || (i>k)) "No such row";
	print "(row ", i, ")  |";
	for (col=1: col<=tab-->0: col++) {
		print " ";
		tc = ((tab-->col)-->1) & TB_COLUMN_NUMBER;
		kov = TC_KOV(tc);
		v = (tab-->col)-->(i+COL_HSIZE);
		if ((v == TABLE_NOVALUE) && (CheckTableEntryIsBlank(tab,col,i)))
			print "-- ";
		else {
			PrintKindValuePair(kov, v);
			print " |";
		}
	}
	say__p = 1;
];

[ TableDebug tab i k;
	PrintTableName(tab); print "^";
	k = TableRows(tab);
	for (i=1:i<=k:i++) { TableRowDebug(tab, i); print "^"; }
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: The Core Tree
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ HolderOf o;
	if (InitialSituation-->DONE_INIS == false) return thedark;
	if (o && (o.component_parent)) return o.component_parent;
	if (o && (parent(o))) return parent(o);
	return nothing;
];

[ ParentOf o;
	if (o) o = parent(o);
	return o;
];

[ CoreOf o;
	while (o && (o provides component_parent) && (o.component_parent)) o = o.component_parent;
	return o;
];

[ CoreOfParentOfCoreOf o;
	while (o && (o provides component_parent) && (o.component_parent)) o = o.component_parent;
	if (o) o = parent(o);
	while (o && (o provides component_parent) && (o.component_parent)) o = o.component_parent;
	return o;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Climbing the Core Tree
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LocationOf o;
	if (~~(o ofclass K1_room or K2_thing)) return nothing;
	if (o ofclass K4_door) {
		if (parent(o) == real_location) return real_location;
		return FrontSideOfDoor(o);
	}
	if (o ofclass K7_backdrop) {
		! print "(deciding ", (the) O, " is at ", (the) BackdropLocation(o), ") ";
		return BackdropLocation(o);
	}
	while (o) {
		if (o ofclass K1_room) return o;
		o = CoreOfParentOfCoreOf(o);
	}
	return nothing;
];

[ CommonAncestor o1 o2 i j;
	o1 = CoreOf(o1);
	o2 = CoreOf(o2);
	
	for (i=o1: i: i = CoreOfParentOfCoreOf(i))
		for (j=o2: j: j = CoreOfParentOfCoreOf(j))
			if (j == i) return j;

	return nothing;
];

[ IndirectlyContains o1 o2;
	if ((o1 == nothing) || (o2 == nothing)) rfalse;
	if ((o1 ofclass K1_room) && (o2 ofclass K4_door)) {
		if (o1 == FrontSideOfDoor(o2)) rtrue;
		if (o1 == BackSideOfDoor(o2)) rtrue;
		rfalse;
	}
	if (o2 ofclass K7_backdrop) rfalse;
	for (o2 = HolderOf(o2) : o2 && o2 ~= thedark : o2 = HolderOf(o2)) if (o2 == o1) rtrue;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: To Decide Whether In
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ WhetherIn obj;
	if (obj has enterable) {
		if (IndirectlyContains(obj, player)) rtrue;
		rfalse;
	}
	if (obj ofclass K9_region) return TestRegionalContainment(real_location, obj);
	if (obj ofclass K1_room) {
		if (obj == real_location) rtrue;
		rfalse;
	}
	RunTimeProblem(RTP_NOTINAROOM, obj);
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Containment Relation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ContainerOf A p;
	if (A ofclass K1_room) return A.map_region;
	p = parent(A);
	if (p == nothing) return nothing;
	if (p ofclass K5_container) return p;
	if (p ofclass K1_room) return p;
	if (p ofclass K9_region) return p;
	return nothing;
];

[ TestContainmentRange obj e f;
	if (obj ofclass K9_region) {
		objectloop (f ofclass K1_room && f.map_region == obj)
			if (f > e) return f;
		return nothing;
	}
	if (obj ofclass K5_container or K1_room) {
		if (e == nothing) return child(obj);
		return sibling(e);
	}
	return nothing;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Support Relation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SupporterOf obj p;
	p = parent(obj);
	if (p == nothing) return nothing;
	if (p ofclass K6_supporter) return p;
	return nothing;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Carrying Relation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ CarrierOf obj p;
	p = parent(obj);
	if (p && (p ofclass K8_person) && (obj hasnt worn)) return p;
	return nothing;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Wearing Relation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ WearerOf obj p;
	p = parent(obj);
	if (p && (p ofclass K8_person) && (obj has worn)) return p;
	return nothing;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Having Relation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ OwnerOf obj p;
	p = parent(obj);
	if (p && (p ofclass K8_person)) return p;
	return nothing;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Making Parts
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ MakePart P Of First;
	if (P == player) return RunTimeProblem(RTP_CANTMAKEPART, Of);
	if (parent(P)) remove P; give P ~worn;
	if (Of == nothing) { DetachPart(P); return; }
	if (P.component_parent) DetachPart(P);
	P.component_parent = Of;
	First = Of.component_child;
	Of.component_child = P; P.component_sibling = First;
];

[ DetachPart P From Daddy O;
	Daddy = P.component_parent; P.component_parent = nothing;
	if (Daddy == nothing) { P.component_sibling = nothing; return; }
	if (Daddy.component_child == P) {
		Daddy.component_child = P.component_sibling;
		P.component_sibling = nothing; return;
	}
	for (O = Daddy.component_child: O: O = O.component_sibling)
		if (O.component_sibling == P) {
			O.component_sibling = P.component_sibling;
			P.component_sibling = nothing; return;
		}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Movements
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ MoveObject F T opt going_mode was L;
	if (F == nothing) return RunTimeProblem(RTP_CANTMOVENOTHING);
	if (F ofclass K7_backdrop) {
		if (T ofclass K9_region) {
			give F ~absent; F.found_in = T.regional_found_in;
			if (TestRegionalContainment(LocationOf(player), T)) move F to LocationOf(player);
			else remove F;
			return; }
		if (T == FoundEverywhere) {
			give F ~absent; F.found_in = FoundEverywhere;
			return;
		}
		return RunTimeProblem(RTP_BACKDROP, F, T);
	}
	if (T ofclass K9_region) return RunTimeProblem(RTP_NOTBACKDROP, F, T);
	if (T == FoundEverywhere) return RunTimeProblem(RTP_BACKDROPONLY, F);
	if (~~(F ofclass K2_thing)) return RunTimeProblem(RTP_NOTTHING, F, T);
	if (F has worn) {
		give F ~worn;
		if (F in T) return;
	}
	DetachPart(F);
	if (going_mode == false) {
		if (F == player) { PlayerTo(T, opt); return; }
		if (IndirectlyContains(F, player)) {
			L = LocationOf(T);
			if (L == nothing) return RunTimeProblem(RTP_CANTBEOFFSTAGE);
			if (LocationOf(player) ~= L) {
				was = parent(player);
				move player to real_location;
				move F to T;
				PlayerTo(was, true);
				return;
			}
		}
	}
	move F to T;
];

[ RemoveFromPlay F;
	if (F == nothing) return RunTimeProblem(RTP_CANTREMOVENOTHING);
	if (F == player) return RunTimeProblem(RTP_CANTREMOVEPLAYER);
	if (F ofclass K4_door) return RunTimeProblem(RTP_CANTREMOVEDOORS);
	if (IndirectlyContains(F, player)) return RunTimeProblem(RTP_CANTBEOFFSTAGE);
	give F ~worn; DetachPart(F);
	if (F ofclass K7_backdrop) give F absent;
	remove F;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: On Stage
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ OnStage O set x;
	if (O ofclass K1_room) rfalse;
	if (set < 0) {
		while (metaclass(O) == Object) {
			if (O ofclass K1_room) rtrue;
			if (O ofclass K9_region) rfalse;
			if (O ofclass K4_door) rtrue;
			if (O ofclass K7_backdrop) { if (O has absent) rfalse; rtrue; }
			x = O.component_parent; if (x) { O = x; continue; }
			x = parent(O); if (x) { O = x; continue; }
			rfalse;
		}
	}
	x = OnStage(O, -1);
	if ((x) && (set == false)) RemoveFromPlay(O);
	if ((x == false) && (set)) MoveObject(O, real_location);
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Moving the Player
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PlayerTo newplace flag L;
    L = LocationOf(newplace);
   	if (L == nothing) return RunTimeProblem(RTP_CANTBEOFFSTAGE);
	@push actor; actor = player;
    move player to newplace;
    location = L;
    real_location = location;
    MoveFloatingObjects();
    SilentlyConsiderLight();
    DivideParagraphPoint();
    if (flag == 0) <Look>;
    if (flag == 1) give location visited;
    if (flag == 2) AbbreviatedRoomDescription();
    @pull actor;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Move During Going
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ MoveDuringGoing F T;
	MoveObject(F, T, 0, true);
	if (actor == player) {
		location = LocationOf(player);
		real_location = location;
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Being Everywhere
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FoundEverywhere; rtrue; ];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Testing Everywhere
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BackdropEverywhere O;
	if (O ofclass K7_backdrop) {
		if (O has absent) rfalse;
		if (O.found_in == FoundEverywhere) rtrue;
	}
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Changing the Player
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ChangePlayer obj flag;
	if (~~(obj ofclass K8_person)) return RunTimeProblem(RTP_CANTCHANGE, obj);
	if (~~(OnStage(obj, -1))) return RunTimeProblem(RTP_CANTCHANGEOFFSTAGE, obj);
	if (obj.component_parent) return RunTimeProblem(RTP_CANTMAKEPART, obj);
	if (obj == player) return;

    give player ~concealed;
    if (player has remove_proper) give player ~proper;
    if (player == selfobj) {
    	player.saved_short_name = player.short_name;
    	player.short_name = PRINT_PROTAGONIST_INTERNAL_RM('c');
    }
    player = obj;
    if (player == selfobj) {
    	player.short_name = player.saved_short_name;
    }
    if (player hasnt proper) give player remove_proper; ! when changing out again
    give player concealed proper;

    location = LocationOf(player); real_location = location;
    MoveFloatingObjects();
    SilentlyConsiderLight();
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Floating Objects
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ MoveFloatingObjects toroom i k l m address flag;
	if (toroom == nothing) toroom = real_location;
    if (toroom == nothing) return;
    objectloop (i) {
        address = i.&found_in;
        if (address ~= 0 && i hasnt absent) {
            if (ZRegion(address-->0) == 2) {
                m = address-->0;
                .TestPropositionally;
                if (m.call(toroom) ~= 0) move i to toroom;
                else { if (i in toroom) remove i; }
            } else {
                k = i.#found_in;
                for (l=0 : l<k/WORDSIZE : l++) {
                    m = address-->l;
                    if (ZRegion(m) == 2) jump TestPropositionally;
                    if (m == toroom || m in toroom) {
                        if (i notin toroom) move i to toroom;
                        flag = true;
                    }
                }
                if (flag == false) { if (i in toroom) remove i; }
            }
            if ((i ofclass K4_door) && (parent(i) == nothing)) {
            	move i to ((i.door_to).call());
            }
        }
    }
];

[ MoveBackdrop bd D x address;
	if (~~(bd ofclass K7_backdrop)) return RunTimeProblem(RTP_BACKDROPONLY, bd);
	if (bd.#found_in > WORDSIZE) {
		address = bd.&found_in;
		address-->0 = D;
	} else bd.found_in = D;
	give bd ~absent;
	MoveFloatingObjects();
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Backdrop Location
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BackdropLocation O target address m x i k l r sl;
	if (O has absent) return nothing;
	if ((target == nothing or real_location) && (parent(O) == real_location))
		return real_location;
	address = O.&found_in;
	if (address ~= 0) {
		k = O.#found_in;
		for (l=0 : l<k/WORDSIZE : l++) {
			m = address-->l;
			if (ZRegion(m) == 2) {
				sl = location;
				if (target) {
					location = target;
					r = m.call();
					if (r ~= 0) { location = sl; return target; }
				} else {
					objectloop (x ofclass K1_room) {
						location = x;
						r = m.call();
						if (r ~= 0) { location = sl; return x; }
					}
				}
				location = sl;
			} else {
				if (m ofclass K9_region) {
					objectloop (x ofclass K1_room)
						if (TestRegionalContainment(x, m))
							if (target == nothing or x)
								return x;
				} else {
					if (target == nothing or m) return m;
				}
			}
		}
	}
	return nothing;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Wearing Clothes
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ WearObject X P opt;
	if (X == false) rfalse;
	if (X notin P) MoveObject(X, P, opt);
	give X worn;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Map Connections
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ MapConnection from_room dir
	in_direction through_door;
	if ((from_room ofclass K1_room) && (dir ofclass K3_direction)) {
		in_direction = Map_Storage-->
			((from_room.IK1_Count)*No_Directions + dir.IK3_Count);
		if (in_direction ofclass K1_room) return in_direction;
		if (in_direction ofclass K4_door) {
			@push location;
			location = from_room;
			through_door = in_direction.door_to();
			@pull location;
			if (through_door ofclass K1_room) return through_door;
		}
	}
	return nothing;
];

[ DoorFrom obj dir rv;
	rv = RoomOrDoorFrom(obj, dir);
	if (rv ofclass K4_door) return rv;
	return nothing;
];

[ RoomOrDoorFrom obj dir use_doors in_direction sl through_door;
	if ((obj ofclass K1_room) && (dir ofclass K3_direction)) {
		in_direction = Map_Storage-->
			((obj.IK1_Count)*No_Directions + dir.IK3_Count);
		if (in_direction ofclass K1_room or K4_door) return in_direction;	
	}
	return nothing;
];

[ AssertMapConnection r1 dir r2 in_direction;
	SignalMapChange();
	in_direction = Map_Storage-->
		((r1.IK1_Count)*No_Directions + dir.IK3_Count);
	if ((in_direction == 0) || (in_direction ofclass K1_room)) {
		Map_Storage-->((r1.IK1_Count)*No_Directions + dir.IK3_Count) = r2;
		return;
	}
	if (in_direction ofclass K4_door) {
		RunTimeProblem(RTP_EXITDOOR, r1, dir);
		return;
	}
	RunTimeProblem(RTP_NOEXIT, r1, dir);
];

[ AssertMapUnconnection r1 dir r2 in_direction;
	SignalMapChange();
	in_direction = Map_Storage-->
		((r1.IK1_Count)*No_Directions + dir.IK3_Count);
	if (r1 ofclass K4_door) {
		RunTimeProblem(RTP_EXITDOOR, r1, dir);
		return;
	}
	if (in_direction == r2)
		Map_Storage-->((r1.IK1_Count)*No_Directions + dir.IK3_Count) = 0;
	return;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Adjacency Relation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TestAdjacency R1 R2 i row;
	row = (R1.IK1_Count)*No_Directions;
	for (i=0: i<No_Directions: i++, row++)
		if (Map_Storage-->row == R2) rtrue;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Regional Containment Relation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TestRegionalContainment obj region o;
	if ((obj == nothing) || (region == nothing)) rfalse;
	if (obj ofclass K7_backdrop or K4_door) {
		if (obj has absent) rfalse;
		objectloop (o ofclass K1_room)
			if (TestRegionalContainment(o, region))
				if (BackdropLocation(obj, o))
					rtrue;
		rfalse;
	}
	if (~~(obj ofclass K1_room)) obj = LocationOf(obj);
	if (obj == nothing) rfalse;
	o = obj.map_region;
	while (o) {
		if (o == region) rtrue;
		o = parent(o);
	}
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Doors
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FrontSideOfDoor D; if (~~(D ofclass K4_door)) rfalse;
	if (D provides found_in) return (D.&found_in)-->0; ! Two-sided
	return parent(D); ! One-sided
];

[ BackSideOfDoor D; if (~~(D ofclass K4_door)) rfalse;
	if (D provides found_in) return (D.&found_in)-->1; ! Two-sided
	return nothing; ! One-sided
];

[ OtherSideOfDoor D from_room rv;
	if (D ofclass K4_door) {
		@push location;
		location = LocationOf(from_room);
		rv = D.door_to();
		@pull location;
	}
	return rv;
];

[ DirectionDoorLeadsIn D from_room rv dir;
	if (D ofclass K4_door) {
		@push location;
		location = LocationOf(from_room);
		rv = D.door_dir();
		@pull location;
	}
	return rv;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Visibility Relation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TestVisibility A B;
	if (~~OffersLight(parent(CoreOf(A)))) rfalse;
	if (suppress_scope_loops) rtrue;
	return TestScope(B, A);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Touchability Relation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TestTouchability A B rv;
	if (A ofclass K4_door or K7_backdrop) MoveFloatingObjects(LocationOf(B));
	if (B ofclass K4_door or K7_backdrop) MoveFloatingObjects(LocationOf(A));
	if (TestScope(B,A) == false) rv = true;
	else rv = ObjectIsUntouchable(B, true, A);
	if (A ofclass K4_door or K7_backdrop) MoveFloatingObjects();
	if (rv) rfalse;
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Concealment Relation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TestConcealment A B;
	if (A ofclass K2_thing && B ofclass K2_thing) {
		particular_possession = B;
		if (CarryOutActivity(DECIDING_CONCEALED_POSSESS_ACT, A)) rtrue;
	}
	rfalse;
];



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Parsing Tokens
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====






! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Number.i6t: Understanding
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ DECIMAL_TOKEN wnc wna r n wa wl sign base digit digit_count original_wn group_wn;
	wnc = wn; original_wn = wn; group_wn = wn;

	wn = wnc;
	r = ParseTokenStopped(ELEMENTARY_TT, NUMBER_TOKEN);
	if ((r == GPR_NUMBER) && (parsed_number ~= 10000)) return r;
	wn = wnc;
	wa = WordAddress(wn);
	wl = WordLength(wn);
	sign = 1; base = 10; digit_count = 0;
	if (wa->0 ~= '-' or '$' or '0' or '1' or '2' or '3' or '4'
		or '5' or '6' or '7' or '8' or '9')
		return GPR_FAIL;
	if (wa->0 == '-') { sign = -1; wl--; wa++; }
	if (wl == 0) return GPR_FAIL;
	n = 0;
	while (wl > 0) {
		if (wa->0 >= 'a') digit = wa->0 - 'a' + 10;
		else digit = wa->0 - '0';
		digit_count++;
		switch (base) {
			2:  if (digit_count == 17) return GPR_FAIL;
			10:
				#Iftrue (WORDSIZE == 2);
				if (digit_count == 6) return GPR_FAIL;
				if (digit_count == 5) {
					if (n > 3276) return GPR_FAIL;
					if (n == 3276) {
						if (sign == 1 && digit > 7) return GPR_FAIL;
						if (sign == -1 && digit > 8) return GPR_FAIL;
					}
				}
				#Ifnot; ! i.e., if (WORDSIZE == 4)
				if (digit_count == 11) return GPR_FAIL;
				if (digit_count == 10) {
					if (n > 214748364) return GPR_FAIL;
					if (n == 214748364) {
						if (sign == 1 && digit > 7) return GPR_FAIL;
						if (sign == -1 && digit > 8) return GPR_FAIL;
					}
				}
				#Endif; 
			16: if (digit_count == 5) return GPR_FAIL;
		}
		if (digit >= 0 && digit < base) n = base*n + digit;
		else return GPR_FAIL;
		wl--; wa++;
	}
	parsed_number = n*sign; wn++;
	return GPR_NUMBER;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Number.i6t: Truth states
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TRUTH_STATE_TOKEN original_wn wd;
	original_wn = wn;

	wn = original_wn;
	wd = NextWordStopped();
	if (wd == 'true') { parsed_number = 1; return GPR_NUMBER; }
	if (wd == 'false') { parsed_number = 0; return GPR_NUMBER; }
	wn = original_wn;
	return GPR_FAIL;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Number.i6t: Absolute value
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ NUMBER_TY_Abs x; if (x<0) return -x; return x; ];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RealNumber.i6t: Printing reals
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#Ifdef TARGET_GLULX;

[ REAL_NUMBER_TY_Say fp;
	print (Float) fp;
];

[ REAL_NUMBER_TY_Compare r1 r2;
	@jflt r1 r2 ?less;
	@jfeq r1 r2 0 ?same;
	return 1;
	.same; return 0;
	.less; return -1;
];

[ NUMBER_TY_to_REAL_NUMBER_TY int real; @numtof int real; return real; ];
[ REAL_NUMBER_TY_to_NUMBER_TY real int; @ftonumn real int; return int; ];

[ REAL_NUMBER_TY_Sin in out; @sin in out; return out; ];
[ REAL_NUMBER_TY_Cos in out; @cos in out; return out; ];
[ REAL_NUMBER_TY_Tan in out; @tan in out; return out; ];
[ REAL_NUMBER_TY_Arcsin in out; @asin in out; return out; ];
[ REAL_NUMBER_TY_Arccos in out; @acos in out; return out; ];
[ REAL_NUMBER_TY_Arctan in out; @atan in out; return out; ];

[ REAL_NUMBER_TY_Sinh in tmp out;
	@exp in tmp;
	@fsub M_0 in in;
	@exp in out;
	@fadd tmp out out;
	@fmul out M_HALF out;
	return out;
];

[ REAL_NUMBER_TY_Cosh in tmp out;
	@exp in tmp;
	@fsub M_0 in in;
	@exp in out;
	@fsub tmp out out;
	@fmul out M_HALF out;
	return out;
];

[ REAL_NUMBER_TY_Tanh in tmp out;
	tmp = REAL_NUMBER_TY_Sinh(in);
	in = REAL_NUMBER_TY_Cosh(in);
	@fdiv tmp in out;
	return out;
];

[ REAL_NUMBER_TY_Reciprocal in out; @fdiv M_1 in out; return out; ];
[ REAL_NUMBER_TY_Negate in out; @fsub M_0 in out; return out; ];
[ REAL_NUMBER_TY_Plus x y out; @fadd x y out; return out; ];
[ REAL_NUMBER_TY_Minus x y out; @fsub x y out; return out; ];
[ REAL_NUMBER_TY_Times x y out; @fmul x y out; return out; ];
[ REAL_NUMBER_TY_Divide x y out; @fdiv x y out; return out; ];
[ REAL_NUMBER_TY_Remainder x y r q; @fmod x y r q; return r; ];
[ REAL_NUMBER_TY_Approximate x y quotient out;
	@fdiv x y quotient;
	@fadd quotient M_HALF quotient;
	@floor quotient quotient;
	@fmul quotient y out;
	return out;
];
[ REAL_NUMBER_TY_Root x out; @sqrt x out; return out; ];
[ REAL_NUMBER_TY_Cube_Root x out; @pow x M_THIRD out; return out; ];
[ REAL_NUMBER_TY_Pow x y out; @pow x y out; return out; ];
[ REAL_NUMBER_TY_Exp x out; @exp x out; return out; ];
[ REAL_NUMBER_TY_Log x out; @log x out; return out; ];
[ REAL_NUMBER_TY_BLog x n d out;
	@log x out;
	if (n == 10) d = M_LOG10;
	else {
		@numtof n d;
		@log d d;
	}
	@fdiv out d out;
	return out;
];
[ REAL_NUMBER_TY_Floor x out; @floor x out; return out; ];
[ REAL_NUMBER_TY_Ceiling x out; @ceil x out; return out; ];
[ REAL_NUMBER_TY_Abs x; return x & $7fffffff; ];
[ REAL_NUMBER_TY_Nan x; @jisnan x ?Nan; rfalse; .Nan; rtrue; ];

Constant M_0    = $0;
Constant M_1    = $3F800000;
Constant M_HALF = $3F000000; ! 1/3
Constant M_THIRD = $3EAAAAAB; ! 1/3
Constant M_LOG10 = $40135D8E; ! log(10)
Constant M_N1   = $BF800000; ! -1
Constant M_PI   = $40490FDB;
Constant M_NPI  = $C0490FDB;
Constant M_2PI  = $40C90FDB; ! 2*pi
Constant M_PI2  = $3FC90FDB; ! pi/2
Constant M_NPI2 = $BFC90FDB; 
Constant M_E    = $402DF854;
Constant M_E2   = $40EC7326; ! e^2
Constant M_N0   = $80000000; ! negative zero
Constant M_INF  = $7F800000; ! infinity
Constant M_NINF = $FF800000; ! negative infinity
Constant M_NAN  = $7F800001; ! one of many NaN values
Constant M_NNAN = $FF800001; ! another, with a sign bit

! Floating-point parsing routines.

! Parse a float from a text buffer. Returns a float value, or FLOAT_NAN if
! no value was understood.
!
! The recognized format, if you'll pardon a slightly bastardized regexp
! syntax, is "S?D*(PD*)?(ES?D+)?" where S is a sign character "+" or "-",
! D is a decimal digit "0" to "9", P is a decimal point ".",
! and E is the exponential modifier "E" or "e".
!
! For flexibility, the string "M10^" is also accepted for E, where M is
! "X", "x", "*", or the multiplication sign @{D7}. Optional spaces are
! allowed before and after the M sign. (But only for the "10^" form of
! the exponent, not the "e" form.)
!
! This routine does not try to recognize special names for infinity or NaN,
! but it can return FLOAT_INFINITY or FLOAT_NINFINITY if the exponent is too
! large.
!
! This routine relies on floating-point math. Therefore, the same string
! may parse to slightly different float values on different interpreters!
! Be warned.
!
! If useall is true, this insists on using all len characters from the buffer.
! (It returns FLOAT_NAN if any unrecognized characters are left over.)
! Contrariwise, if useall is false, unused characters at the end of the buffer
! are fine. (But not at the beginning; the float must start at the beginning
! of the buffer.)
! 
[ FloatParse buf len useall
	res ix val ch ten negative intpart fracpart fracdiv
	expon expnegative count;
	
!	print "FloatParse <";
!	for (ix=0: ix<len: ix++) print (char) buf->ix;
!	print ">^";

	if (len == 0)
		return FLOAT_NAN;
		
	ix = 0;
	negative = false;
	intpart = 0;
	fracpart = 0;
	@numtof 10 ten;

	! Sign character (optional)
	ch = buf->ix;
	if (ch == '-') {
		negative = true;
		ix++;
	}
	else if (ch == '+') {
		ix++;
	}

	! Some digits (optional)
	for (count=0 : ix<len : ix++, count++) {
		ch = buf->ix;
		if (ch < '0' || ch > '9')
			break;
		val = (ch - '0');
		@numtof val val;
		@fmul intpart ten intpart;
		@fadd intpart val intpart;
	}

	! Decimal point and more digits (optional)
	if (ix<len && buf->ix == '.') {
		ix++;
		@numtof 1 fracdiv;
		for ( : ix<len : ix++, count++) {
			ch = buf->ix;
			if (ch < '0' || ch > '9')
				break;
			val = (ch - '0');
			@numtof	val val;
			@fmul fracpart ten fracpart;
			@fadd fracpart val fracpart;
			@fmul fracdiv ten fracdiv;
		}
		@fdiv fracpart fracdiv fracpart;
	}

	! If there are no digits before *or* after the decimal point, fail.
	if (count == 0)
		return FLOAT_NAN;

	! Combine the integer and fractional parts.
	@fadd intpart fracpart res;

	! Exponent (optional)
	if (ix<len && buf->ix == 'e' or 'E' or ' ' or '*' or 'x' or 'X' or $D7) {
		if (buf->ix == 'e' or 'E') {
			! no spaces, just the 'e'
			ix++;
			if (ix == len)
				return FLOAT_NAN;
		}
		else {
			! any number of spaces, "*", any number of spaces more, "10^"
			while (ix < len && buf->ix == ' ')
				ix++;
			if (ix == len)
				return FLOAT_NAN;
			if (buf->ix ~= '*' or 'x' or 'X' or $D7)
				return FLOAT_NAN;
			ix++;
			while (ix < len && buf->ix == ' ')
				ix++;
			if (ix == len)
				return FLOAT_NAN;
			if (buf->ix ~= '1')
				return FLOAT_NAN;
			ix++;
			if (buf->ix ~= '0')
				return FLOAT_NAN;
			ix++;
			if (buf->ix ~= $5E)
				return FLOAT_NAN;
			ix++;
		}

		! Sign character (optional)
		expnegative = false;
		ch = buf->ix;
		if (ch == '-') {
			expnegative = true;
			ix++;
		}
		else if (ch == '+') {
			ix++;
		}

		expon = 0;
		! Some digits (mandatory)
		for (count=0 : ix<len : ix++, count++) {
			ch = buf->ix;
			if (ch < '0' || ch > '9')
				break;
			expon = 10*expon + (ch - '0');
		}

		if (count == 0)
			return FLOAT_NAN;

		if (expnegative)
			expon = -expon;

		if (expon) {
			@numtof expon expon;
			@pow ten expon val;
			@fmul res val res;
		}
	}

	if (negative) {
		! set the value's sign bit
		res = $80000000 | res;
	}

	if (useall && ix ~= len)
		return FLOAT_NAN;
	return res;
];

! An I6 grammar routine (GPR) for floats. On success, this returns
! GPR_NUMBER and stores a value in the global parsed_number.
!
! This is quite a nuisance, actually, because "." is a word separator.
! Also, we want to accept command sequences like "type 4. look"! So we
! need to collect a set of words made up of digits, signs, periods, and
! the letter "e", but without any intervening whitespace, and excluding
! a trailing period.
!
! (This will fail to correctly parse "type 4.e", but I think that is a
! small flaw. A player would more likely try "type 4. e" or, really,
! not concatenate commands at all. It will also parse "type 4. on keyboard"
! as two commands, even though "4." is a legitimate float literal.
! Contrariwise, "type 4. x me" will be taken as one command. (Because the "x"
! *could* be a continuation of the float, and I don't back up when it turns
! out not to be.) I don't plan to worry about these cases.)

[ FLOAT_TOKEN buf bufend ix ch firstwd newstart newlen lastchar lastwasdot;
	if (wn > num_words)
		return GPR_FAIL;

	! We're going to collect a set of words. Start with zero words.
	firstwd = wn;
	buf = WordAddress(wn);
	bufend = buf;
	lastchar = 0;

	while (wn <= num_words) {
		newstart = WordAddress(wn);
		if (newstart ~= bufend) {
			! There's whitespace between the previous word and this one.
			! Whitespace is okay around an asterisk...
			if ((lastchar ~= '*' or 'x' or 'X' or $D7)
				&& (newstart->0 ~= '*' or 'x' or 'X' or $D7)) {
				! But around any other character, it's not.
				! Don't include the new word.
				break;
			}
		}
		newlen = WordLength(wn);
		for (ix=0 : ix<newlen : ix++) {
			ch = newstart->ix;
			if (~~((ch >= '0' && ch <= '9')
				|| (ch == '-' or '+' or 'E' or 'e' or '.' or 'x' or 'X' or '*' or $D7 or $5E)))
				break;
		}
		if (ix < newlen) {
			! This word contains an invalid character.
			! Don't include the new word.
			break;
		}
		! Okay, include it.
		bufend = newstart + newlen;
		wn++;
		lastchar = (bufend-1)->0;
		lastwasdot = (newlen == 1 && lastchar == '.');
	}

	if (wn > firstwd && lastwasdot) {
		! Exclude a trailing period.
		wn--;
		bufend--;
	}

	if (wn == firstwd) {
		! No words accepted.
		return GPR_FAIL;
	}

	parsed_number = FloatParse(buf, bufend-buf, true);
	if (parsed_number == FLOAT_NAN)
		return GPR_FAIL;
	return GPR_NUMBER;
];

! Floating-point printing routines. (These are based on code in
! Glulxercise.inf, but modified.)
  
! Print a float. This uses exponential notation ("[-]N.NNNe[+-]NN") if
! the exponent is not between 6 and -4. If it is (that is, if the
! absolute value is near 1.0) then it uses decimal notation ("[-]NNN.NNNNN").
! The precision is the number of digits after the decimal point
! (at least one, no more than eight). The default is five, because
! beyond that rounding errors creep in, and even exactly-represented
! float values are printed with trailing fudgy digits.
! Trailing zeroes are trimmed.
[ Float val prec   pval;
	pval = val & $7FFFFFFF;

	@jz pval ?UseFloatDec;
	@jfge pval $49742400 ?UseFloatExp; ! 1000000.0
	@jflt pval $38D1B717 ?UseFloatExp; ! 0.0001

	.UseFloatDec;
	return FloatDec(val, prec);
	.UseFloatExp;
	return FloatExp(val, prec);
];

Array PowersOfTen --> 1 10 100 1000 10000 100000 1000000 10000000 100000000 1000000000;

! Print a float in exponential notation: "[-]N.NNNe[+-]NN".
! The precision is the number of digits after the decimal point
! (at least one, no more than eight). The default is five, because
! beyond that rounding errors creep in, and even exactly-represented
! float values are printed with trailing fudgy digits.
! Trailing zeroes are trimmed.
[ FloatExp val prec   log10val expo fexpo idig ix pow10;
	if (prec == 0)
		prec = 5;
	if (prec > 8)
		prec = 8;
	pow10 = PowersOfTen --> prec;

	! Knock off the sign bit first.
	if (val & $80000000) {
		@streamchar '-';
		val = val & $7FFFFFFF;
	}
	
	@jisnan val ?IsNan;
	@jisinf val ?IsInf;

	if (val == $0) {
		expo = 0;
		idig = 0;
		jump DoPrint;
	}

	! Take as an example val=123.5, with precision=6. The desired
	! result is "1.23000e+02".
	
	@log val sp;
	@fdiv sp $40135D8E log10val; ! $40135D8E is log(10)
	@floor log10val fexpo;
	@ftonumn fexpo expo;
	! expo is now the exponent (as an integer). For our example, expo=2.

	@fsub log10val fexpo sp;
	@numtof prec sp;
	@fadd sp sp sp;
	@fmul sp $40135D8E sp;
	@exp sp sp;
	! The stack value is now exp((log10val - fexpo + prec) * log(10)).
	! We've shifted the decimal point left by expo digits (so that
	! it's after the first nonzero digit), and then right by prec
	! digits. In our example, that would be 1235000.0.
	@ftonumn sp idig;
	! Round to an integer, and we have 1235000. Notice that this is
	! exactly the digits we want to print (if we stick a decimal point
	! after the first).

	.DoPrint;
	
	if (idig >= 10*pow10) {
		! Rounding errors have left us outside the decimal range of
		! [1.0, 10.0) where we should be. Adjust to the next higher
		! exponent.
		expo++;
		@div idig 10 idig;
	}
	
	! Trim off trailing zeroes, as long as there's at least one digit
	! after the decimal point. (Delete this stanza if you want to
	! keep the trailing zeroes.)
	while (prec > 1) {
		@mod idig 10 sp;
		@jnz sp ?DoneTrimming;
		@div pow10 10 pow10;
		@div idig 10 idig;
		prec--;
	}
	.DoneTrimming;
	
	for (ix=0 : ix<=prec : ix++) {
		@div idig pow10 sp;
		@mod sp 10 sp;
		@streamnum sp;
		if (ix == 0)
			@streamchar '.';
		@div pow10 10 pow10;
	}

	! Print the exponent. There are two conventions coded here: the
	! programmatic ("1.0e+00") and the literary ("1.0 x 10^0").
	#ifndef FLOAT_PROGRAMMING_EXPONENTS;
		PrintMultiplicationSign();
		@streamstr "10";
		@streamchar $5E;
		@streamnum expo;
	#ifnot;
		! Convention is to use at least two digits.
		@streamchar 'e';
		if (expo < 0) {
			@streamchar '-';
			@neg expo expo;
		}
		else {
			@streamchar '+';
		}
		if (expo < 10)
			@streamchar '0';
		@streamnum expo;
	#endif; ! FLOAT_PROGRAMMING_EXPONENTS
	
	rtrue;

	.IsNan;
	PrintNan();
	rtrue;

	.IsInf;
	PrintInfinity();
	rtrue;
];

! Print a float in decimal notation: "[-]NNN.NNNNN".
! The precision is the number of digits after the decimal point
! (at least one, no more than eight). The default is five, because
! beyond that rounding errors creep in, and even exactly-represented
! float values are printed with trailing fudgy digits.
! Trailing zeroes are trimmed.
[ FloatDec val prec   log10val int fint extra0 frac idig ix pow10;
	if (prec == 0)
		prec = 5;
	if (prec > 8)
		prec = 8;
	pow10 = PowersOfTen --> prec;
	
	! Knock off the sign bit first.
	if (val & $80000000) {
		@streamchar '-';
		val = val & $7FFFFFFF;
	}
	
	@jisnan val ?IsNan;
	@jisinf val ?IsInf;

	! Take as an example val=123.5, with precision=6. The desired result
	! is "123.50000".
	
	extra0 = 0;
	@fmod val $3F800000 frac fint; ! $3F800000 is 1.0.
	@ftonumz fint int;
	! This converts the integer part of the value to an integer value;
	! in our example, 123.
	
	if (int == $7FFFFFFF) {
		! Looks like the integer part of the value is bigger than
		! we can store in an int variable. (It could be as large
		! as 3e+38.) We're going to have to use a log function to
		! reduce it by some number of factors of 10, and then pad
		! with zeroes.
		@log fint sp;
		@fdiv sp $40135D8E log10val; ! $40135D8E is log(10)
		@ftonumz log10val extra0;
		@sub extra0 8 extra0;
		! extra0 is the number of zeroes we'll be padding with.
		@numtof extra0 sp;
		@fsub log10val sp sp;
		@fmul sp $40135D8E sp;
		@exp sp sp;
		! The stack value is now exp((log10val - extra0) * log(10)).
		! We've shifted the decimal point far enough left to leave
		! about eight digits, which is all we can print as an integer.
		@ftonumz sp int;
	}

	! Print the integer part.
	@streamnum int;
	for (ix=0 : ix<extra0 : ix++)
		@streamchar '0';

	@streamchar '.';

	! Now we need to print the frac part, which is .5.
	
	@log frac sp;
	@fdiv sp $40135D8E log10val; ! $40135D8E is log(10)
	@numtof prec sp;
	@fadd log10val sp sp;
	@fmul sp $40135D8E sp;
	@exp sp sp;
	! The stack value is now exp((frac + prec) * log(10)).
	! We've shifted the decimal point right by prec
	! digits. In our example, that would be 50000.0.
	@ftonumn sp idig;
	! Round to an integer, and we have 50000. Notice that this is
	! exactly the (post-decimal-point) digits we want to print.

	.DoPrint;
	
	if (idig >= pow10) {
		! Rounding errors have left us outside the decimal range of
		! [0.0, 1.0) where we should be. I'm not sure this is possible,
		! actually, but we'll just adjust downward.
		idig = pow10 - 1;
	}

	! Trim off trailing zeroes, as long as there's at least one digit
	! after the decimal point. (Delete this stanza if you want to
	! keep the trailing zeroes.)
	while (prec > 1) {
		@mod idig 10 sp;
		@jnz sp ?DoneTrimming;
		@div pow10 10 pow10;
		@div idig 10 idig;
		prec--;
	}
	.DoneTrimming;
	
	@div pow10 10 pow10;
	for (ix=0 : ix<prec : ix++) {
		@div idig pow10 sp;
		@mod sp 10 sp;
		@streamnum sp;
		@div pow10 10 pow10;
	}
	rtrue;

	.IsNan;
	PrintNan();
	rtrue;

	.IsInf;
	PrintInfinity();
	rtrue;
];

[ PrintInfinity;
	@streamunichar $221E;
	! @streamstr "Inf";
];

[ PrintNan;
	@streamunichar $26a0;
	! @streamstr "NaN";
];

[ PrintMultiplicationSign;
	print " ";
	@streamunichar $D7;
	print " ";
	! @streamstr " x ";
];

#Ifnot; ! TARGET_GLULX

[ REAL_NUMBER_TY_Say real; print real; ]; ! Needs to exist, but likely never used

[ REAL_NUMBER_TY_Compare r1 r2; return UnsignedCompare(r1, r2); ];

#Endif; ! TARGET_GLULX


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Time.i6t: Rounding
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ RoundOffTime t1 t2;
	if (t1 >= 0) return ((t1+t2/2)/t2)*t2;
	return -((-t1+t2/2)/t2)*t2;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Time.i6t: Conversion To Number
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ NUMBER_TY_to_TIME_TY n;
	n = n%1440;
	if (n < 0) return n + 1440;
	return n;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Time.i6t: Square Root
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SquareRoot num
	op res one;
	op = num;
	if (num < 0) { RunTimeProblem(RTP_NEGATIVEROOT); return 1; }
	! "one" starts at the highest power of four <= the argument.
	for (one = WORD_NEXTTOHIGHBIT: one > op: one = one/4) ;

	while (one ~= 0) {
		! print "Round: op = ", op, " res = ", res, ", res**2 = ", res*res, " one = ", one, " nthb = ", WORD_NEXTTOHIGHBIT, "^";
		if (op >= res + one) {
			op = op - res - one;
			res = res/2 + one;
		} else {
			res = res/2;
		}
		one = one/4;
	}
	! print "Res is ", res, "^";
	return res;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Time.i6t: Cube Root
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ CubeRoot num x y n;
	if (num < 0) x = -SquareRoot(-num); else x = SquareRoot(num);
	for (n=0: (y ~= x) && (n++ < 100): y = x, x = (2*x + num/x/x)/3) ;
	return x;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Time.i6t: Digital Printing
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PrintTimeOfDay t h aop;
	if (t<0) { print "<no time>"; return; }
	if (t >= TWELVE_HOURS) { aop = "pm"; t = t - TWELVE_HOURS; } else aop = "am";
	h = t/ONE_HOUR; if (h==0) h=12;
	print h, ":";
	if (t%ONE_HOUR < 10) print "0"; print t%ONE_HOUR, " ", (string) aop;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Time.i6t: Analogue Printing
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PrintTimeOfDayEnglish t h m dir aop;
	h = (t/ONE_HOUR) % 12; m = t%ONE_HOUR; if (h==0) h=12;
	if (m==0) { print (number) h, " o'clock"; return; }
	dir = "past";
	if (m > HALF_HOUR) { m = ONE_HOUR-m; h = (h+1)%12; if (h==0) h=12; dir = "to"; }
	switch(m) {
		QUARTER_HOUR: print "quarter"; HALF_HOUR: print "half";
		default: print (number) m;
		    if (m%5 ~= 0) {
				if (m == 1) print " minute"; else print " minutes";
		    }
	}
	print " ", (string) dir, " ", (number) h;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Time.i6t: Understanding
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TIME_TOKEN first_word second_word at length flag
	illegal_char offhour hr mn i original_wn;
	original_wn = wn;

	wn = original_wn;
	first_word = NextWordStopped();
	switch (first_word) {
		'midnight': parsed_number = 0; return GPR_NUMBER;
		'midday', 'noon': parsed_number = TWELVE_HOURS;
		return GPR_NUMBER;
	}
	! Next try the format 12:02
	at = WordAddress(wn-1); length = WordLength(wn-1);
	for (i=0: i<length: i++) {
		switch (at->i) {
			':': if (flag == false && i>0 && i<length-1) flag = true;
			else illegal_char = true;
			'0', '1', '2', '3', '4', '5', '6', '7', '8', '9': ;
			default: illegal_char = true;
		}
	}
	if (length < 3 || length > 5 || illegal_char) flag = false;
	if (flag) {
		for (i=0: at->i~=':': i++, hr=hr*10) hr = hr + at->i - '0';
		hr = hr/10;
		for (i++: i<length: i++, mn=mn*10) mn = mn + at->i - '0';
		mn = mn/10;
		second_word = NextWordStopped();
		parsed_number = HoursMinsWordToTime(hr, mn, second_word);
		if (parsed_number == -1) return GPR_FAIL;
		if (second_word ~= 'pm' or 'am') wn--;
		return GPR_NUMBER;
	}
	! Lastly the wordy format
	offhour = -1;
	if (first_word == 'half') offhour = HALF_HOUR;
	if (first_word == 'quarter') offhour = QUARTER_HOUR;
	if (offhour < 0) offhour = TryNumber(wn-1);
	if (offhour < 0 || offhour >= ONE_HOUR) return GPR_FAIL;
	second_word = NextWordStopped();
	switch (second_word) {
		! "six o'clock", "six"
		'o^clock', 'am', 'pm', -1:
			hr = offhour; if (hr > 12) return GPR_FAIL;
		! "quarter to six", "twenty past midnight"
		'to', 'past':
			mn = offhour; hr = TryNumber(wn);
			if (hr <= 0) {
				switch (NextWordStopped()) {
					'noon', 'midday': hr = 12;
					'midnight': hr = 0;
					default: return GPR_FAIL;
				}
			}
			if (hr >= 13) return GPR_FAIL;
			if (second_word == 'to') {
				mn = ONE_HOUR-mn; hr--; if (hr<0) hr=23;
			}
			wn++; second_word = NextWordStopped();
		! "six thirty"
		default:
			hr = offhour; mn = TryNumber(--wn);
			if (mn < 0 || mn >= ONE_HOUR) return GPR_FAIL;
			wn++; second_word = NextWordStopped();
	}
	parsed_number = HoursMinsWordToTime(hr, mn, second_word);
	if (parsed_number < 0) return GPR_FAIL;
	if (second_word ~= 'pm' or 'am' or 'o^clock') wn--;
	return GPR_NUMBER;
];

[ HoursMinsWordToTime hour minute word x;
	if (hour >= 24) return -1;
	if (minute >= ONE_HOUR) return -1;
	x = hour*ONE_HOUR + minute; if (hour >= 13) return x;
	x = x % TWELVE_HOURS; if (word == 'pm') x = x + TWELVE_HOURS;
	if (word ~= 'am' or 'pm' && hour == 12) x = x + TWELVE_HOURS;
	return x;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Time.i6t: Relative Time Token
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ RELATIVE_TIME_TOKEN first_word second_word offhour mult mn original_wn;
	original_wn = wn;
	wn = original_wn;
	
	first_word = NextWordStopped(); wn--;
	if (first_word == 'an' or 'a//') mn=1; else mn=TryNumber(wn);
	
    if (mn == -1000) {
		first_word = NextWordStopped();
		if (first_word == 'half') offhour = HALF_HOUR;
		if (first_word == 'quarter') offhour = QUARTER_HOUR;
		if (offhour > 0) {
			second_word = NextWordStopped();
			if (second_word == 'of') second_word = NextWordStopped();
			if (second_word == 'an') second_word = NextWordStopped();
			if (second_word == 'hour') {
				parsed_number = offhour;
				return GPR_NUMBER;
			}
		}
		return GPR_FAIL;
    }
	wn++;
	
	first_word = NextWordStopped();
	switch (first_word) {
		'minutes', 'minute': mult = 1;
		'hours', 'hour': mult = 60;
		default: return GPR_FAIL;
	}
	parsed_number = mn*mult;
	if (mult == 60) {
		mn=TryNumber(wn);
		if (mn ~= -1000) {
			wn++;
			first_word = NextWordStopped();
			if (first_word == 'minutes' or 'minute')
				parsed_number = parsed_number + mn;
			else wn = wn - 2;
		}
	}
	return GPR_NUMBER;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Time.i6t: During Scene Matching
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ DuringSceneMatching prop sc;
	for (sc=0: sc<NUMBER_SCENES_CREATED: sc++)
		if ((scene_status-->sc == 1) && (prop(sc+1))) rtrue;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Time.i6t: Scene Questions
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SceneUtility sc task;
	if (sc <= 0) return 0;
	if (task == 1 or 2) {
		if (scene_endings-->(sc-1) == 0) return RunTimeProblem(RTP_SCENEHASNTSTARTED, sc);
	} else {
		if (scene_endings-->(sc-1) <= 1) return RunTimeProblem(RTP_SCENEHASNTENDED, sc);
	}
	switch (task) {
		1: return (the_time - scene_started-->(sc-1))%(TWENTY_FOUR_HOURS);
		2: return scene_started-->(sc-1);
		3: return (the_time - scene_ended-->(sc-1))%(TWENTY_FOUR_HOURS);
		4: return scene_ended-->(sc-1);
	}
];

[ Kind_GPR_52 
    original_wn ! internal use only
    group_wn ! internal use only
    v ! internal use only
    w ! internal use only
    rv ! internal use only
    ;
    original_wn = wn;
        if (NextWordStopped() ~= 'male') jump Fail_1;
        parsed_number = I128_masculine;
        return GPR_NUMBER;
        .Fail_1; wn = original_wn;
        if (NextWordStopped() ~= 'man') jump Fail_2;
        parsed_number = I128_masculine;
        return GPR_NUMBER;
        .Fail_2; wn = original_wn;
        if (NextWordStopped() ~= 'm//') jump Fail_3;
        parsed_number = I128_masculine;
        return GPR_NUMBER;
        .Fail_3; wn = original_wn;
        if (NextWordStopped() ~= 'female') jump Fail_4;
        parsed_number = I129_feminine;
        return GPR_NUMBER;
        .Fail_4; wn = original_wn;
        if (NextWordStopped() ~= 'woman') jump Fail_5;
        parsed_number = I129_feminine;
        return GPR_NUMBER;
        .Fail_5; wn = original_wn;
        if (NextWordStopped() ~= 'f//') jump Fail_6;
        parsed_number = I129_feminine;
        return GPR_NUMBER;
        .Fail_6; wn = original_wn;
    wn = original_wn;
    wn = original_wn;if (NextWordStopped() ~= 'masculine') jump Failed_1;
    parsed_number = I128_masculine; return GPR_NUMBER;
    .Failed_1;
    wn = original_wn;if (NextWordStopped() ~= 'feminine') jump Failed_2;
    parsed_number = I129_feminine; return GPR_NUMBER;
    .Failed_2;
    wn = original_wn;if (NextWordStopped() ~= 'unknown') jump Failed_3;
    parsed_number = I130_unknown; return GPR_NUMBER;
    .Failed_3;
    return GPR_FAIL;
];
[ Instance_GPR_52 
    instance ! Implied call parameter
    original_wn ! internal use only
    group_wn ! internal use only
    v ! internal use only
    w ! internal use only
    rv ! internal use only
    ;
    original_wn = wn;
        if (instance == I128_masculine) {
            if (NextWordStopped() ~= 'male') jump Fail_1;
            parsed_number = I128_masculine;
            return GPR_NUMBER;
            .Fail_1; wn = original_wn;
        }
        if (instance == I128_masculine) {
            if (NextWordStopped() ~= 'man') jump Fail_2;
            parsed_number = I128_masculine;
            return GPR_NUMBER;
            .Fail_2; wn = original_wn;
        }
        if (instance == I128_masculine) {
            if (NextWordStopped() ~= 'm//') jump Fail_3;
            parsed_number = I128_masculine;
            return GPR_NUMBER;
            .Fail_3; wn = original_wn;
        }
        if (instance == I129_feminine) {
            if (NextWordStopped() ~= 'female') jump Fail_4;
            parsed_number = I129_feminine;
            return GPR_NUMBER;
            .Fail_4; wn = original_wn;
        }
        if (instance == I129_feminine) {
            if (NextWordStopped() ~= 'woman') jump Fail_5;
            parsed_number = I129_feminine;
            return GPR_NUMBER;
            .Fail_5; wn = original_wn;
        }
        if (instance == I129_feminine) {
            if (NextWordStopped() ~= 'f//') jump Fail_6;
            parsed_number = I129_feminine;
            return GPR_NUMBER;
            .Fail_6; wn = original_wn;
        }
    wn = original_wn;
    if (instance == I128_masculine) {
        wn = original_wn;if (NextWordStopped() ~= 'masculine') jump Failed_4;
        parsed_number = I128_masculine; return GPR_NUMBER;
    }
    .Failed_4;
    if (instance == I129_feminine) {
        wn = original_wn;if (NextWordStopped() ~= 'feminine') jump Failed_5;
        parsed_number = I129_feminine; return GPR_NUMBER;
    }
    .Failed_5;
    if (instance == I130_unknown) {
        wn = original_wn;if (NextWordStopped() ~= 'unknown') jump Failed_6;
        parsed_number = I130_unknown; return GPR_NUMBER;
    }
    .Failed_6;
    return GPR_FAIL;
];



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Text generation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant CV_POS = -1;
Constant CV_NEG = -2;
Constant CV_MODAL = -3;
Constant CV_MEANING = -4;
[ ConjugateVerb_0 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "be";
        2: print "been";
        3: print "being";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: switch (vp) {
                    1: print "am";
                    2: print "are";
                    3: print "is";
                    4: print "are";
                    5: print "are";
                    6: print "are";
                }
                2: switch (vp) {
                    1: print "was";
                    2: print "were";
                    3: print "was";
                    4: print "were";
                    5: print "were";
                    6: print "were";
                }
                3: if (vp == 3) { print "has been"; } else { print "have been"; }
                4: print "had been";
                5: print "will be";
            }
        CV_NEG:
            switch (t) {
                1: switch (vp) {
                    1: print "am not";
                    2: print "are not";
                    3: print "is not";
                    4: print "are not";
                    5: print "are not";
                    6: print "are not";
                }
                2: switch (vp) {
                    1: print "was not";
                    2: print "were not";
                    3: print "was not";
                    4: print "were not";
                    5: print "were not";
                    6: print "were not";
                }
                3: if (vp == 3) { print "has not been"; } else { print "have not been"; }
                4: print "had not been";
                5: print "will not be";
            }
    }
];
[ ConjugateVerb_1 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "auxiliary-have";
        2: print "had";
        3: print "having";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "has"; } else { print "have"; }
                2: print "had";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "has not"; } else { print "have not"; }
                2: print "had not";
            }
    }
];
[ ConjugateVerb_2 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "have";
        2: print "had";
        3: print "having";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_27;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "has"; } else { print "have"; }
                2: print "had";
                3: if (vp == 3) { print "has had"; } else { print "have had"; }
                4: print "had had";
                5: print "will have";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not have"; } else { print "do not have"; }
                2: print "did not have";
                3: if (vp == 3) { print "has not had"; } else { print "have not had"; }
                4: print "had not had";
                5: print "will not have";
            }
    }
];
[ ConjugateVerb_3 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "do";
        2: print "done";
        3: print "doing";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "does"; } else { print "do"; }
                2: print "did";
                3: if (vp == 3) { print "has done"; } else { print "have done"; }
                4: print "had done";
                5: print "will do";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not"; } else { print "do not"; }
                2: print "did not";
                3: if (vp == 3) { print "has not done"; } else { print "have not done"; }
                4: print "had not done";
                5: print "will not do";
            }
    }
];
[ ConjugateVerb_4 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "relate";
        2: print "related";
        3: print "relating";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_3;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "relates"; } else { print "relate"; }
                2: print "related";
                3: if (vp == 3) { print "has related"; } else { print "have related"; }
                4: print "had related";
                5: print "will relate";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not relate"; } else { print "do not relate"; }
                2: print "did not relate";
                3: if (vp == 3) { print "has not related"; } else { print "have not related"; }
                4: print "had not related";
                5: print "will not relate";
            }
    }
];
[ ConjugateVerb_5 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "mean";
        2: print "meant";
        3: print "meaning";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_5;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "means"; } else { print "mean"; }
                2: print "meant";
                3: if (vp == 3) { print "has meant"; } else { print "have meant"; }
                4: print "had meant";
                5: print "will mean";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not mean"; } else { print "do not mean"; }
                2: print "did not mean";
                3: if (vp == 3) { print "has not meant"; } else { print "have not meant"; }
                4: print "had not meant";
                5: print "will not mean";
            }
    }
];
[ ConjugateVerb_6 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "provide";
        2: print "provided";
        3: print "providing";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_1;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "provides"; } else { print "provide"; }
                2: print "provided";
                3: if (vp == 3) { print "has provided"; } else { print "have provided"; }
                4: print "had provided";
                5: print "will provide";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not provide"; } else { print "do not provide"; }
                2: print "did not provide";
                3: if (vp == 3) { print "has not provided"; } else { print "have not provided"; }
                4: print "had not provided";
                5: print "will not provide";
            }
    }
];
[ ConjugateVerb_7 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "contain";
        2: print "contained";
        3: print "containing";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_15;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "contains"; } else { print "contain"; }
                2: print "contained";
                3: if (vp == 3) { print "has contained"; } else { print "have contained"; }
                4: print "had contained";
                5: print "will contain";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not contain"; } else { print "do not contain"; }
                2: print "did not contain";
                3: if (vp == 3) { print "has not contained"; } else { print "have not contained"; }
                4: print "had not contained";
                5: print "will not contain";
            }
    }
];
[ ConjugateVerb_8 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "support";
        2: print "supported";
        3: print "supporting";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_17;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "supports"; } else { print "support"; }
                2: print "supported";
                3: if (vp == 3) { print "has supported"; } else { print "have supported"; }
                4: print "had supported";
                5: print "will support";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not support"; } else { print "do not support"; }
                2: print "did not support";
                3: if (vp == 3) { print "has not supported"; } else { print "have not supported"; }
                4: print "had not supported";
                5: print "will not support";
            }
    }
];
[ ConjugateVerb_9 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "incorporate";
        2: print "incorporated";
        3: print "incorporating";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_19;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "incorporates"; } else { print "incorporate"; }
                2: print "incorporated";
                3: if (vp == 3) { print "has incorporated"; } else { print "have incorporated"; }
                4: print "had incorporated";
                5: print "will incorporate";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not incorporate"; } else { print "do not incorporate"; }
                2: print "did not incorporate";
                3: if (vp == 3) { print "has not incorporated"; } else { print "have not incorporated"; }
                4: print "had not incorporated";
                5: print "will not incorporate";
            }
    }
];
[ ConjugateVerb_10 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "enclose";
        2: print "enclosed";
        3: print "enclosing";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_37;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "encloses"; } else { print "enclose"; }
                2: print "enclosed";
                3: if (vp == 3) { print "has enclosed"; } else { print "have enclosed"; }
                4: print "had enclosed";
                5: print "will enclose";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not enclose"; } else { print "do not enclose"; }
                2: print "did not enclose";
                3: if (vp == 3) { print "has not enclosed"; } else { print "have not enclosed"; }
                4: print "had not enclosed";
                5: print "will not enclose";
            }
    }
];
[ ConjugateVerb_11 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "carry";
        2: print "carried";
        3: print "carrying";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_21;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "carries"; } else { print "carry"; }
                2: print "carried";
                3: if (vp == 3) { print "has carried"; } else { print "have carried"; }
                4: print "had carried";
                5: print "will carry";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not carry"; } else { print "do not carry"; }
                2: print "did not carry";
                3: if (vp == 3) { print "has not carried"; } else { print "have not carried"; }
                4: print "had not carried";
                5: print "will not carry";
            }
    }
];
[ ConjugateVerb_12 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "hold";
        2: print "held";
        3: print "holding";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_23;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "holds"; } else { print "hold"; }
                2: print "held";
                3: if (vp == 3) { print "has held"; } else { print "have held"; }
                4: print "had held";
                5: print "will hold";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not hold"; } else { print "do not hold"; }
                2: print "did not hold";
                3: if (vp == 3) { print "has not held"; } else { print "have not held"; }
                4: print "had not held";
                5: print "will not hold";
            }
    }
];
[ ConjugateVerb_13 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "wear";
        2: print "worn";
        3: print "wearing";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_25;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "wears"; } else { print "wear"; }
                2: print "wore";
                3: if (vp == 3) { print "has worn"; } else { print "have worn"; }
                4: print "had worn";
                5: print "will wear";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not wear"; } else { print "do not wear"; }
                2: print "did not wear";
                3: if (vp == 3) { print "has not worn"; } else { print "have not worn"; }
                4: print "had not worn";
                5: print "will not wear";
            }
    }
];
[ ConjugateVerb_14 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "be able to see";
        2: print "been able to see";
        3: print "being able to see";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_31;
        CV_POS:
            switch (t) {
                1: print "can see";
                2: print "could see";
                3: if (vp == 3) { print "has been able to see"; } else { print "have been able to see"; }
                4: print "had been able to see";
                5: print "will be able to see";
                6: print "see";
                7: print "see";
            }
        CV_NEG:
            switch (t) {
                1: print "cannot see";
                2: print "could not see";
                3: if (vp == 3) { print "has not been able to see"; } else { print "have not been able to see"; }
                4: print "had not been able to see";
                5: print "will not be able to see";
                6: print "see";
                7: print "see";
            }
    }
];
[ ConjugateVerb_15 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "be able to";
        2: print "been able to";
        3: print "being able to";
        CV_MODAL: return true;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: switch (vp) {
                    1: print "can"; if (modal_to) { print " "; modal_to(1); }
                    2: print "can"; if (modal_to) { print " "; modal_to(1); }
                    3: print "can"; if (modal_to) { print " "; modal_to(1); }
                    4: print "can"; if (modal_to) { print " "; modal_to(1); }
                    5: print "can"; if (modal_to) { print " "; modal_to(1); }
                    6: print "can"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "could"; if (modal_to) { print " "; modal_to(1); }
                    2: print "could"; if (modal_to) { print " "; modal_to(1); }
                    3: print "could"; if (modal_to) { print " "; modal_to(1); }
                    4: print "could"; if (modal_to) { print " "; modal_to(1); }
                    5: print "could"; if (modal_to) { print " "; modal_to(1); }
                    6: print "could"; if (modal_to) { print " "; modal_to(1); }
                }
                3: switch (vp) {
                    1: print "have been able to"; if (modal_to) { print " "; modal_to(1); }
                    2: print "have been able to"; if (modal_to) { print " "; modal_to(1); }
                    3: print "has been able to"; if (modal_to) { print " "; modal_to(1); }
                    4: print "have been able to"; if (modal_to) { print " "; modal_to(1); }
                    5: print "have been able to"; if (modal_to) { print " "; modal_to(1); }
                    6: print "have been able to"; if (modal_to) { print " "; modal_to(1); }
                }
                4: switch (vp) {
                    1: print "had been able to"; if (modal_to) { print " "; modal_to(1); }
                    2: print "had been able to"; if (modal_to) { print " "; modal_to(1); }
                    3: print "had been able to"; if (modal_to) { print " "; modal_to(1); }
                    4: print "had been able to"; if (modal_to) { print " "; modal_to(1); }
                    5: print "had been able to"; if (modal_to) { print " "; modal_to(1); }
                    6: print "had been able to"; if (modal_to) { print " "; modal_to(1); }
                }
                5: switch (vp) {
                    1: print "will be able to"; if (modal_to) { print " "; modal_to(1); }
                    2: print "will be able to"; if (modal_to) { print " "; modal_to(1); }
                    3: print "will be able to"; if (modal_to) { print " "; modal_to(1); }
                    4: print "will be able to"; if (modal_to) { print " "; modal_to(1); }
                    5: print "will be able to"; if (modal_to) { print " "; modal_to(1); }
                    6: print "will be able to"; if (modal_to) { print " "; modal_to(1); }
                }
            }
        CV_NEG:
            switch (t) {
                1: switch (vp) {
                    1: print "cannot"; if (modal_to) { print " "; modal_to(1); }
                    2: print "cannot"; if (modal_to) { print " "; modal_to(1); }
                    3: print "cannot"; if (modal_to) { print " "; modal_to(1); }
                    4: print "cannot"; if (modal_to) { print " "; modal_to(1); }
                    5: print "cannot"; if (modal_to) { print " "; modal_to(1); }
                    6: print "cannot"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "could not"; if (modal_to) { print " "; modal_to(1); }
                    2: print "could not"; if (modal_to) { print " "; modal_to(1); }
                    3: print "could not"; if (modal_to) { print " "; modal_to(1); }
                    4: print "could not"; if (modal_to) { print " "; modal_to(1); }
                    5: print "could not"; if (modal_to) { print " "; modal_to(1); }
                    6: print "could not"; if (modal_to) { print " "; modal_to(1); }
                }
                3: switch (vp) {
                    1: print "have not been able to"; if (modal_to) { print " "; modal_to(1); }
                    2: print "have not been able to"; if (modal_to) { print " "; modal_to(1); }
                    3: print "has not been able to"; if (modal_to) { print " "; modal_to(1); }
                    4: print "have not been able to"; if (modal_to) { print " "; modal_to(1); }
                    5: print "have not been able to"; if (modal_to) { print " "; modal_to(1); }
                    6: print "have not been able to"; if (modal_to) { print " "; modal_to(1); }
                }
                4: switch (vp) {
                    1: print "had not been able to"; if (modal_to) { print " "; modal_to(1); }
                    2: print "had not been able to"; if (modal_to) { print " "; modal_to(1); }
                    3: print "had not been able to"; if (modal_to) { print " "; modal_to(1); }
                    4: print "had not been able to"; if (modal_to) { print " "; modal_to(1); }
                    5: print "had not been able to"; if (modal_to) { print " "; modal_to(1); }
                    6: print "had not been able to"; if (modal_to) { print " "; modal_to(1); }
                }
                5: switch (vp) {
                    1: print "will not be able to"; if (modal_to) { print " "; modal_to(1); }
                    2: print "will not be able to"; if (modal_to) { print " "; modal_to(1); }
                    3: print "will not be able to"; if (modal_to) { print " "; modal_to(1); }
                    4: print "will not be able to"; if (modal_to) { print " "; modal_to(1); }
                    5: print "will not be able to"; if (modal_to) { print " "; modal_to(1); }
                    6: print "will not be able to"; if (modal_to) { print " "; modal_to(1); }
                }
            }
    }
];
[ ConjugateVerb_16 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "see";
        2: print "seen";
        3: print "seeing";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "sees"; } else { print "see"; }
                2: print "saw";
                3: if (vp == 3) { print "has seen"; } else { print "have seen"; }
                4: print "had seen";
                5: print "will see";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not see"; } else { print "do not see"; }
                2: print "did not see";
                3: if (vp == 3) { print "has not seen"; } else { print "have not seen"; }
                4: print "had not seen";
                5: print "will not see";
            }
    }
];
[ ConjugateVerb_17 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "be able to touch";
        2: print "been able to touch";
        3: print "being able to touch";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_33;
        CV_POS:
            switch (t) {
                1: print "can touch";
                2: print "could touch";
                3: if (vp == 3) { print "has been able to touch"; } else { print "have been able to touch"; }
                4: print "had been able to touch";
                5: print "will be able to touch";
                6: print "touch";
                7: print "touch";
            }
        CV_NEG:
            switch (t) {
                1: print "cannot touch";
                2: print "could not touch";
                3: if (vp == 3) { print "has not been able to touch"; } else { print "have not been able to touch"; }
                4: print "had not been able to touch";
                5: print "will not be able to touch";
                6: print "touch";
                7: print "touch";
            }
    }
];
[ ConjugateVerb_18 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "touch";
        2: print "touched";
        3: print "touching";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "touches"; } else { print "touch"; }
                2: print "touched";
                3: if (vp == 3) { print "has touched"; } else { print "have touched"; }
                4: print "had touched";
                5: print "will touch";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not touch"; } else { print "do not touch"; }
                2: print "did not touch";
                3: if (vp == 3) { print "has not touched"; } else { print "have not touched"; }
                4: print "had not touched";
                5: print "will not touch";
            }
    }
];
[ ConjugateVerb_19 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "conceal";
        2: print "concealed";
        3: print "concealing";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_35;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "conceals"; } else { print "conceal"; }
                2: print "concealed";
                3: if (vp == 3) { print "has concealed"; } else { print "have concealed"; }
                4: print "had concealed";
                5: print "will conceal";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not conceal"; } else { print "do not conceal"; }
                2: print "did not conceal";
                3: if (vp == 3) { print "has not concealed"; } else { print "have not concealed"; }
                4: print "had not concealed";
                5: print "will not conceal";
            }
    }
];
[ ConjugateVerb_20 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "unlock";
        2: print "unlocked";
        3: print "unlocking";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_69;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "unlocks"; } else { print "unlock"; }
                2: print "unlocked";
                3: if (vp == 3) { print "has unlocked"; } else { print "have unlocked"; }
                4: print "had unlocked";
                5: print "will unlock";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not unlock"; } else { print "do not unlock"; }
                2: print "did not unlock";
                3: if (vp == 3) { print "has not unlocked"; } else { print "have not unlocked"; }
                4: print "had not unlocked";
                5: print "will not unlock";
            }
    }
];
[ ConjugateVerb_21 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "achieve";
        2: print "achieved";
        3: print "achieving";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "achieves"; } else { print "achieve"; }
                2: print "achieved";
                3: if (vp == 3) { print "has achieved"; } else { print "have achieved"; }
                4: print "had achieved";
                5: print "will achieve";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not achieve"; } else { print "do not achieve"; }
                2: print "did not achieve";
                3: if (vp == 3) { print "has not achieved"; } else { print "have not achieved"; }
                4: print "had not achieved";
                5: print "will not achieve";
            }
    }
];
[ ConjugateVerb_22 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "appreciate";
        2: print "appreciated";
        3: print "appreciating";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "appreciates"; } else { print "appreciate"; }
                2: print "appreciated";
                3: if (vp == 3) { print "has appreciated"; } else { print "have appreciated"; }
                4: print "had appreciated";
                5: print "will appreciate";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not appreciate"; } else { print "do not appreciate"; }
                2: print "did not appreciate";
                3: if (vp == 3) { print "has not appreciated"; } else { print "have not appreciated"; }
                4: print "had not appreciated";
                5: print "will not appreciate";
            }
    }
];
[ ConjugateVerb_23 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "arrive";
        2: print "arrived";
        3: print "arriving";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "arrives"; } else { print "arrive"; }
                2: print "arrived";
                3: if (vp == 3) { print "has arrived"; } else { print "have arrived"; }
                4: print "had arrived";
                5: print "will arrive";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not arrive"; } else { print "do not arrive"; }
                2: print "did not arrive";
                3: if (vp == 3) { print "has not arrived"; } else { print "have not arrived"; }
                4: print "had not arrived";
                5: print "will not arrive";
            }
    }
];
[ ConjugateVerb_24 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "care";
        2: print "cared";
        3: print "caring";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "cares"; } else { print "care"; }
                2: print "cared";
                3: if (vp == 3) { print "has cared"; } else { print "have cared"; }
                4: print "had cared";
                5: print "will care";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not care"; } else { print "do not care"; }
                2: print "did not care";
                3: if (vp == 3) { print "has not cared"; } else { print "have not cared"; }
                4: print "had not cared";
                5: print "will not care";
            }
    }
];
[ ConjugateVerb_25 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "close";
        2: print "closed";
        3: print "closing";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "closes"; } else { print "close"; }
                2: print "closed";
                3: if (vp == 3) { print "has closed"; } else { print "have closed"; }
                4: print "had closed";
                5: print "will close";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not close"; } else { print "do not close"; }
                2: print "did not close";
                3: if (vp == 3) { print "has not closed"; } else { print "have not closed"; }
                4: print "had not closed";
                5: print "will not close";
            }
    }
];
[ ConjugateVerb_26 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "die";
        2: print "died";
        3: print "dying";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "dies"; } else { print "die"; }
                2: print "died";
                3: if (vp == 3) { print "has died"; } else { print "have died"; }
                4: print "had died";
                5: print "will die";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not die"; } else { print "do not die"; }
                2: print "did not die";
                3: if (vp == 3) { print "has not died"; } else { print "have not died"; }
                4: print "had not died";
                5: print "will not die";
            }
    }
];
[ ConjugateVerb_27 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "discover";
        2: print "discovered";
        3: print "discovering";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "discovers"; } else { print "discover"; }
                2: print "discovered";
                3: if (vp == 3) { print "has discovered"; } else { print "have discovered"; }
                4: print "had discovered";
                5: print "will discover";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not discover"; } else { print "do not discover"; }
                2: print "did not discover";
                3: if (vp == 3) { print "has not discovered"; } else { print "have not discovered"; }
                4: print "had not discovered";
                5: print "will not discover";
            }
    }
];
[ ConjugateVerb_28 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "drop";
        2: print "dropped";
        3: print "dropping";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "drops"; } else { print "drop"; }
                2: print "dropped";
                3: if (vp == 3) { print "has dropped"; } else { print "have dropped"; }
                4: print "had dropped";
                5: print "will drop";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not drop"; } else { print "do not drop"; }
                2: print "did not drop";
                3: if (vp == 3) { print "has not dropped"; } else { print "have not dropped"; }
                4: print "had not dropped";
                5: print "will not drop";
            }
    }
];
[ ConjugateVerb_29 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "eat";
        2: print "eaten";
        3: print "eating";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "eats"; } else { print "eat"; }
                2: print "ate";
                3: if (vp == 3) { print "has eaten"; } else { print "have eaten"; }
                4: print "had eaten";
                5: print "will eat";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not eat"; } else { print "do not eat"; }
                2: print "did not eat";
                3: if (vp == 3) { print "has not eaten"; } else { print "have not eaten"; }
                4: print "had not eaten";
                5: print "will not eat";
            }
    }
];
[ ConjugateVerb_30 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "feel";
        2: print "felt";
        3: print "feeling";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "feels"; } else { print "feel"; }
                2: print "felt";
                3: if (vp == 3) { print "has felt"; } else { print "have felt"; }
                4: print "had felt";
                5: print "will feel";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not feel"; } else { print "do not feel"; }
                2: print "did not feel";
                3: if (vp == 3) { print "has not felt"; } else { print "have not felt"; }
                4: print "had not felt";
                5: print "will not feel";
            }
    }
];
[ ConjugateVerb_31 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "find";
        2: print "found";
        3: print "finding";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "finds"; } else { print "find"; }
                2: print "found";
                3: if (vp == 3) { print "has found"; } else { print "have found"; }
                4: print "had found";
                5: print "will find";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not find"; } else { print "do not find"; }
                2: print "did not find";
                3: if (vp == 3) { print "has not found"; } else { print "have not found"; }
                4: print "had not found";
                5: print "will not find";
            }
    }
];
[ ConjugateVerb_32 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "get";
        2: print "got";
        3: print "getting";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "gets"; } else { print "get"; }
                2: print "got";
                3: if (vp == 3) { print "has got"; } else { print "have got"; }
                4: print "had got";
                5: print "will get";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not get"; } else { print "do not get"; }
                2: print "did not get";
                3: if (vp == 3) { print "has not got"; } else { print "have not got"; }
                4: print "had not got";
                5: print "will not get";
            }
    }
];
[ ConjugateVerb_33 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "give";
        2: print "given";
        3: print "giving";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "gives"; } else { print "give"; }
                2: print "gave";
                3: if (vp == 3) { print "has given"; } else { print "have given"; }
                4: print "had given";
                5: print "will give";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not give"; } else { print "do not give"; }
                2: print "did not give";
                3: if (vp == 3) { print "has not given"; } else { print "have not given"; }
                4: print "had not given";
                5: print "will not give";
            }
    }
];
[ ConjugateVerb_34 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "go";
        2: print "gone";
        3: print "going";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "goes"; } else { print "go"; }
                2: print "went";
                3: if (vp == 3) { print "has gone"; } else { print "have gone"; }
                4: print "had gone";
                5: print "will go";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not go"; } else { print "do not go"; }
                2: print "did not go";
                3: if (vp == 3) { print "has not gone"; } else { print "have not gone"; }
                4: print "had not gone";
                5: print "will not go";
            }
    }
];
[ ConjugateVerb_35 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "happen";
        2: print "happened";
        3: print "happening";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "happens"; } else { print "happen"; }
                2: print "happened";
                3: if (vp == 3) { print "has happened"; } else { print "have happened"; }
                4: print "had happened";
                5: print "will happen";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not happen"; } else { print "do not happen"; }
                2: print "did not happen";
                3: if (vp == 3) { print "has not happened"; } else { print "have not happened"; }
                4: print "had not happened";
                5: print "will not happen";
            }
    }
];
[ ConjugateVerb_36 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "hear";
        2: print "heard";
        3: print "hearing";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "hears"; } else { print "hear"; }
                2: print "heard";
                3: if (vp == 3) { print "has heard"; } else { print "have heard"; }
                4: print "had heard";
                5: print "will hear";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not hear"; } else { print "do not hear"; }
                2: print "did not hear";
                3: if (vp == 3) { print "has not heard"; } else { print "have not heard"; }
                4: print "had not heard";
                5: print "will not hear";
            }
    }
];
[ ConjugateVerb_37 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "jump";
        2: print "jumped";
        3: print "jumping";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "jumps"; } else { print "jump"; }
                2: print "jumped";
                3: if (vp == 3) { print "has jumped"; } else { print "have jumped"; }
                4: print "had jumped";
                5: print "will jump";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not jump"; } else { print "do not jump"; }
                2: print "did not jump";
                3: if (vp == 3) { print "has not jumped"; } else { print "have not jumped"; }
                4: print "had not jumped";
                5: print "will not jump";
            }
    }
];
[ ConjugateVerb_38 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "lack";
        2: print "lacked";
        3: print "lacking";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "lacks"; } else { print "lack"; }
                2: print "lacked";
                3: if (vp == 3) { print "has lacked"; } else { print "have lacked"; }
                4: print "had lacked";
                5: print "will lack";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not lack"; } else { print "do not lack"; }
                2: print "did not lack";
                3: if (vp == 3) { print "has not lacked"; } else { print "have not lacked"; }
                4: print "had not lacked";
                5: print "will not lack";
            }
    }
];
[ ConjugateVerb_39 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "lead";
        2: print "led";
        3: print "leading";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "leads"; } else { print "lead"; }
                2: print "led";
                3: if (vp == 3) { print "has led"; } else { print "have led"; }
                4: print "had led";
                5: print "will lead";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not lead"; } else { print "do not lead"; }
                2: print "did not lead";
                3: if (vp == 3) { print "has not led"; } else { print "have not led"; }
                4: print "had not led";
                5: print "will not lead";
            }
    }
];
[ ConjugateVerb_40 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "like";
        2: print "liked";
        3: print "liking";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "likes"; } else { print "like"; }
                2: print "liked";
                3: if (vp == 3) { print "has liked"; } else { print "have liked"; }
                4: print "had liked";
                5: print "will like";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not like"; } else { print "do not like"; }
                2: print "did not like";
                3: if (vp == 3) { print "has not liked"; } else { print "have not liked"; }
                4: print "had not liked";
                5: print "will not like";
            }
    }
];
[ ConjugateVerb_41 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "listen";
        2: print "listened";
        3: print "listening";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "listens"; } else { print "listen"; }
                2: print "listened";
                3: if (vp == 3) { print "has listened"; } else { print "have listened"; }
                4: print "had listened";
                5: print "will listen";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not listen"; } else { print "do not listen"; }
                2: print "did not listen";
                3: if (vp == 3) { print "has not listened"; } else { print "have not listened"; }
                4: print "had not listened";
                5: print "will not listen";
            }
    }
];
[ ConjugateVerb_42 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "lock";
        2: print "locked";
        3: print "locking";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "locks"; } else { print "lock"; }
                2: print "locked";
                3: if (vp == 3) { print "has locked"; } else { print "have locked"; }
                4: print "had locked";
                5: print "will lock";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not lock"; } else { print "do not lock"; }
                2: print "did not lock";
                3: if (vp == 3) { print "has not locked"; } else { print "have not locked"; }
                4: print "had not locked";
                5: print "will not lock";
            }
    }
];
[ ConjugateVerb_43 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "look";
        2: print "looked";
        3: print "looking";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "looks"; } else { print "look"; }
                2: print "looked";
                3: if (vp == 3) { print "has looked"; } else { print "have looked"; }
                4: print "had looked";
                5: print "will look";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not look"; } else { print "do not look"; }
                2: print "did not look";
                3: if (vp == 3) { print "has not looked"; } else { print "have not looked"; }
                4: print "had not looked";
                5: print "will not look";
            }
    }
];
[ ConjugateVerb_44 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "need";
        2: print "needed";
        3: print "needing";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "needs"; } else { print "need"; }
                2: print "needed";
                3: if (vp == 3) { print "has needed"; } else { print "have needed"; }
                4: print "had needed";
                5: print "will need";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not need"; } else { print "do not need"; }
                2: print "did not need";
                3: if (vp == 3) { print "has not needed"; } else { print "have not needed"; }
                4: print "had not needed";
                5: print "will not need";
            }
    }
];
[ ConjugateVerb_45 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "open";
        2: print "opened";
        3: print "opening";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "opens"; } else { print "open"; }
                2: print "opened";
                3: if (vp == 3) { print "has opened"; } else { print "have opened"; }
                4: print "had opened";
                5: print "will open";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not open"; } else { print "do not open"; }
                2: print "did not open";
                3: if (vp == 3) { print "has not opened"; } else { print "have not opened"; }
                4: print "had not opened";
                5: print "will not open";
            }
    }
];
[ ConjugateVerb_46 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "pass";
        2: print "passed";
        3: print "passing";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "passes"; } else { print "pass"; }
                2: print "passed";
                3: if (vp == 3) { print "has passed"; } else { print "have passed"; }
                4: print "had passed";
                5: print "will pass";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not pass"; } else { print "do not pass"; }
                2: print "did not pass";
                3: if (vp == 3) { print "has not passed"; } else { print "have not passed"; }
                4: print "had not passed";
                5: print "will not pass";
            }
    }
];
[ ConjugateVerb_47 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "pick";
        2: print "picked";
        3: print "picking";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "picks"; } else { print "pick"; }
                2: print "picked";
                3: if (vp == 3) { print "has picked"; } else { print "have picked"; }
                4: print "had picked";
                5: print "will pick";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not pick"; } else { print "do not pick"; }
                2: print "did not pick";
                3: if (vp == 3) { print "has not picked"; } else { print "have not picked"; }
                4: print "had not picked";
                5: print "will not pick";
            }
    }
];
[ ConjugateVerb_48 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "provoke";
        2: print "provoked";
        3: print "provoking";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "provokes"; } else { print "provoke"; }
                2: print "provoked";
                3: if (vp == 3) { print "has provoked"; } else { print "have provoked"; }
                4: print "had provoked";
                5: print "will provoke";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not provoke"; } else { print "do not provoke"; }
                2: print "did not provoke";
                3: if (vp == 3) { print "has not provoked"; } else { print "have not provoked"; }
                4: print "had not provoked";
                5: print "will not provoke";
            }
    }
];
[ ConjugateVerb_49 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "pull";
        2: print "pulled";
        3: print "pulling";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "pulls"; } else { print "pull"; }
                2: print "pulled";
                3: if (vp == 3) { print "has pulled"; } else { print "have pulled"; }
                4: print "had pulled";
                5: print "will pull";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not pull"; } else { print "do not pull"; }
                2: print "did not pull";
                3: if (vp == 3) { print "has not pulled"; } else { print "have not pulled"; }
                4: print "had not pulled";
                5: print "will not pull";
            }
    }
];
[ ConjugateVerb_50 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "push";
        2: print "pushed";
        3: print "pushing";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "pushes"; } else { print "push"; }
                2: print "pushed";
                3: if (vp == 3) { print "has pushed"; } else { print "have pushed"; }
                4: print "had pushed";
                5: print "will push";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not push"; } else { print "do not push"; }
                2: print "did not push";
                3: if (vp == 3) { print "has not pushed"; } else { print "have not pushed"; }
                4: print "had not pushed";
                5: print "will not push";
            }
    }
];
[ ConjugateVerb_51 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "put";
        2: print "put";
        3: print "putting";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "puts"; } else { print "put"; }
                2: print "put";
                3: if (vp == 3) { print "has put"; } else { print "have put"; }
                4: print "had put";
                5: print "will put";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not put"; } else { print "do not put"; }
                2: print "did not put";
                3: if (vp == 3) { print "has not put"; } else { print "have not put"; }
                4: print "had not put";
                5: print "will not put";
            }
    }
];
[ ConjugateVerb_52 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "rub";
        2: print "rubbed";
        3: print "rubbing";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "rubs"; } else { print "rub"; }
                2: print "rubbed";
                3: if (vp == 3) { print "has rubbed"; } else { print "have rubbed"; }
                4: print "had rubbed";
                5: print "will rub";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not rub"; } else { print "do not rub"; }
                2: print "did not rub";
                3: if (vp == 3) { print "has not rubbed"; } else { print "have not rubbed"; }
                4: print "had not rubbed";
                5: print "will not rub";
            }
    }
];
[ ConjugateVerb_53 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "say";
        2: print "said";
        3: print "saying";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "says"; } else { print "say"; }
                2: print "said";
                3: if (vp == 3) { print "has said"; } else { print "have said"; }
                4: print "had said";
                5: print "will say";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not say"; } else { print "do not say"; }
                2: print "did not say";
                3: if (vp == 3) { print "has not said"; } else { print "have not said"; }
                4: print "had not said";
                5: print "will not say";
            }
    }
];
[ ConjugateVerb_54 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "search";
        2: print "searched";
        3: print "searching";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "searches"; } else { print "search"; }
                2: print "searched";
                3: if (vp == 3) { print "has searched"; } else { print "have searched"; }
                4: print "had searched";
                5: print "will search";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not search"; } else { print "do not search"; }
                2: print "did not search";
                3: if (vp == 3) { print "has not searched"; } else { print "have not searched"; }
                4: print "had not searched";
                5: print "will not search";
            }
    }
];
[ ConjugateVerb_55 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "seem";
        2: print "seemed";
        3: print "seeming";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "seems"; } else { print "seem"; }
                2: print "seemed";
                3: if (vp == 3) { print "has seemed"; } else { print "have seemed"; }
                4: print "had seemed";
                5: print "will seem";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not seem"; } else { print "do not seem"; }
                2: print "did not seem";
                3: if (vp == 3) { print "has not seemed"; } else { print "have not seemed"; }
                4: print "had not seemed";
                5: print "will not seem";
            }
    }
];
[ ConjugateVerb_56 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "set";
        2: print "set";
        3: print "setting";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "sets"; } else { print "set"; }
                2: print "set";
                3: if (vp == 3) { print "has set"; } else { print "have set"; }
                4: print "had set";
                5: print "will set";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not set"; } else { print "do not set"; }
                2: print "did not set";
                3: if (vp == 3) { print "has not set"; } else { print "have not set"; }
                4: print "had not set";
                5: print "will not set";
            }
    }
];
[ ConjugateVerb_57 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "smell";
        2: print "smelled";
        3: print "smelling";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "smells"; } else { print "smell"; }
                2: print "smelled";
                3: if (vp == 3) { print "has smelled"; } else { print "have smelled"; }
                4: print "had smelled";
                5: print "will smell";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not smell"; } else { print "do not smell"; }
                2: print "did not smell";
                3: if (vp == 3) { print "has not smelled"; } else { print "have not smelled"; }
                4: print "had not smelled";
                5: print "will not smell";
            }
    }
];
[ ConjugateVerb_58 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "sniff";
        2: print "sniffed";
        3: print "sniffing";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "sniffs"; } else { print "sniff"; }
                2: print "sniffed";
                3: if (vp == 3) { print "has sniffed"; } else { print "have sniffed"; }
                4: print "had sniffed";
                5: print "will sniff";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not sniff"; } else { print "do not sniff"; }
                2: print "did not sniff";
                3: if (vp == 3) { print "has not sniffed"; } else { print "have not sniffed"; }
                4: print "had not sniffed";
                5: print "will not sniff";
            }
    }
];
[ ConjugateVerb_59 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "squeeze";
        2: print "squeezed";
        3: print "squeezing";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "squeezes"; } else { print "squeeze"; }
                2: print "squeezed";
                3: if (vp == 3) { print "has squeezed"; } else { print "have squeezed"; }
                4: print "had squeezed";
                5: print "will squeeze";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not squeeze"; } else { print "do not squeeze"; }
                2: print "did not squeeze";
                3: if (vp == 3) { print "has not squeezed"; } else { print "have not squeezed"; }
                4: print "had not squeezed";
                5: print "will not squeeze";
            }
    }
];
[ ConjugateVerb_60 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "switch";
        2: print "switched";
        3: print "switching";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "switches"; } else { print "switch"; }
                2: print "switched";
                3: if (vp == 3) { print "has switched"; } else { print "have switched"; }
                4: print "had switched";
                5: print "will switch";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not switch"; } else { print "do not switch"; }
                2: print "did not switch";
                3: if (vp == 3) { print "has not switched"; } else { print "have not switched"; }
                4: print "had not switched";
                5: print "will not switch";
            }
    }
];
[ ConjugateVerb_61 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "take";
        2: print "taken";
        3: print "taking";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "takes"; } else { print "take"; }
                2: print "took";
                3: if (vp == 3) { print "has taken"; } else { print "have taken"; }
                4: print "had taken";
                5: print "will take";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not take"; } else { print "do not take"; }
                2: print "did not take";
                3: if (vp == 3) { print "has not taken"; } else { print "have not taken"; }
                4: print "had not taken";
                5: print "will not take";
            }
    }
];
[ ConjugateVerb_62 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "talk";
        2: print "talked";
        3: print "talking";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "talks"; } else { print "talk"; }
                2: print "talked";
                3: if (vp == 3) { print "has talked"; } else { print "have talked"; }
                4: print "had talked";
                5: print "will talk";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not talk"; } else { print "do not talk"; }
                2: print "did not talk";
                3: if (vp == 3) { print "has not talked"; } else { print "have not talked"; }
                4: print "had not talked";
                5: print "will not talk";
            }
    }
];
[ ConjugateVerb_63 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "taste";
        2: print "tasted";
        3: print "tasting";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "tastes"; } else { print "taste"; }
                2: print "tasted";
                3: if (vp == 3) { print "has tasted"; } else { print "have tasted"; }
                4: print "had tasted";
                5: print "will taste";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not taste"; } else { print "do not taste"; }
                2: print "did not taste";
                3: if (vp == 3) { print "has not tasted"; } else { print "have not tasted"; }
                4: print "had not tasted";
                5: print "will not taste";
            }
    }
];
[ ConjugateVerb_64 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "turn";
        2: print "turned";
        3: print "turning";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "turns"; } else { print "turn"; }
                2: print "turned";
                3: if (vp == 3) { print "has turned"; } else { print "have turned"; }
                4: print "had turned";
                5: print "will turn";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not turn"; } else { print "do not turn"; }
                2: print "did not turn";
                3: if (vp == 3) { print "has not turned"; } else { print "have not turned"; }
                4: print "had not turned";
                5: print "will not turn";
            }
    }
];
[ ConjugateVerb_65 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "wait";
        2: print "waited";
        3: print "waiting";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "waits"; } else { print "wait"; }
                2: print "waited";
                3: if (vp == 3) { print "has waited"; } else { print "have waited"; }
                4: print "had waited";
                5: print "will wait";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not wait"; } else { print "do not wait"; }
                2: print "did not wait";
                3: if (vp == 3) { print "has not waited"; } else { print "have not waited"; }
                4: print "had not waited";
                5: print "will not wait";
            }
    }
];
[ ConjugateVerb_66 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "wave";
        2: print "waved";
        3: print "waving";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "waves"; } else { print "wave"; }
                2: print "waved";
                3: if (vp == 3) { print "has waved"; } else { print "have waved"; }
                4: print "had waved";
                5: print "will wave";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not wave"; } else { print "do not wave"; }
                2: print "did not wave";
                3: if (vp == 3) { print "has not waved"; } else { print "have not waved"; }
                4: print "had not waved";
                5: print "will not wave";
            }
    }
];
[ ConjugateVerb_67 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "win";
        2: print "won";
        3: print "winning";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "wins"; } else { print "win"; }
                2: print "won";
                3: if (vp == 3) { print "has won"; } else { print "have won"; }
                4: print "had won";
                5: print "will win";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not win"; } else { print "do not win"; }
                2: print "did not win";
                3: if (vp == 3) { print "has not won"; } else { print "have not won"; }
                4: print "had not won";
                5: print "will not win";
            }
    }
];
[ ConjugateVerb_68 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "could";
        2: print "coulded";
        3: print "coulding";
        CV_MODAL: return true;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: switch (vp) {
                    1: print "could"; if (modal_to) { print " "; modal_to(1); }
                    2: print "could"; if (modal_to) { print " "; modal_to(1); }
                    3: print "could"; if (modal_to) { print " "; modal_to(1); }
                    4: print "could"; if (modal_to) { print " "; modal_to(1); }
                    5: print "could"; if (modal_to) { print " "; modal_to(1); }
                    6: print "could"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "could have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "could have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "could have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "could have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "could have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "could have"; if (modal_to) { print " "; modal_to(2); }
                }
                3: switch (vp) {
                    1: print "could have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "could have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "could have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "could have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "could have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "could have"; if (modal_to) { print " "; modal_to(2); }
                }
                4: switch (vp) {
                    1: print "could have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "could have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "could have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "could have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "could have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "could have"; if (modal_to) { print " "; modal_to(2); }
                }
                5: switch (vp) {
                    1: print "could"; if (modal_to) { print " "; modal_to(1); }
                    2: print "could"; if (modal_to) { print " "; modal_to(1); }
                    3: print "could"; if (modal_to) { print " "; modal_to(1); }
                    4: print "could"; if (modal_to) { print " "; modal_to(1); }
                    5: print "could"; if (modal_to) { print " "; modal_to(1); }
                    6: print "could"; if (modal_to) { print " "; modal_to(1); }
                }
            }
        CV_NEG:
            switch (t) {
                1: switch (vp) {
                    1: print "could not"; if (modal_to) { print " "; modal_to(1); }
                    2: print "could not"; if (modal_to) { print " "; modal_to(1); }
                    3: print "could not"; if (modal_to) { print " "; modal_to(1); }
                    4: print "could not"; if (modal_to) { print " "; modal_to(1); }
                    5: print "could not"; if (modal_to) { print " "; modal_to(1); }
                    6: print "could not"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "could not have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "could not have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "could not have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "could not have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "could not have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "could not have"; if (modal_to) { print " "; modal_to(2); }
                }
                3: switch (vp) {
                    1: print "could not have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "could not have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "could not have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "could not have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "could not have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "could not have"; if (modal_to) { print " "; modal_to(2); }
                }
                4: switch (vp) {
                    1: print "could not have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "could not have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "could not have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "could not have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "could not have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "could not have"; if (modal_to) { print " "; modal_to(2); }
                }
                5: switch (vp) {
                    1: print "could not"; if (modal_to) { print " "; modal_to(1); }
                    2: print "could not"; if (modal_to) { print " "; modal_to(1); }
                    3: print "could not"; if (modal_to) { print " "; modal_to(1); }
                    4: print "could not"; if (modal_to) { print " "; modal_to(1); }
                    5: print "could not"; if (modal_to) { print " "; modal_to(1); }
                    6: print "could not"; if (modal_to) { print " "; modal_to(1); }
                }
            }
    }
];
[ ConjugateVerb_69 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "may";
        2: print "mayed";
        3: print "maying";
        CV_MODAL: return true;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: switch (vp) {
                    1: print "may"; if (modal_to) { print " "; modal_to(1); }
                    2: print "may"; if (modal_to) { print " "; modal_to(1); }
                    3: print "may"; if (modal_to) { print " "; modal_to(1); }
                    4: print "may"; if (modal_to) { print " "; modal_to(1); }
                    5: print "may"; if (modal_to) { print " "; modal_to(1); }
                    6: print "may"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "may have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "may have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "may have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "may have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "may have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "may have"; if (modal_to) { print " "; modal_to(2); }
                }
                3: switch (vp) {
                    1: print "may have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "may have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "may have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "may have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "may have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "may have"; if (modal_to) { print " "; modal_to(2); }
                }
                4: switch (vp) {
                    1: print "may have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "may have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "may have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "may have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "may have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "may have"; if (modal_to) { print " "; modal_to(2); }
                }
                5: switch (vp) {
                    1: print "may"; if (modal_to) { print " "; modal_to(1); }
                    2: print "may"; if (modal_to) { print " "; modal_to(1); }
                    3: print "may"; if (modal_to) { print " "; modal_to(1); }
                    4: print "may"; if (modal_to) { print " "; modal_to(1); }
                    5: print "may"; if (modal_to) { print " "; modal_to(1); }
                    6: print "may"; if (modal_to) { print " "; modal_to(1); }
                }
            }
        CV_NEG:
            switch (t) {
                1: switch (vp) {
                    1: print "may not"; if (modal_to) { print " "; modal_to(1); }
                    2: print "may not"; if (modal_to) { print " "; modal_to(1); }
                    3: print "may not"; if (modal_to) { print " "; modal_to(1); }
                    4: print "may not"; if (modal_to) { print " "; modal_to(1); }
                    5: print "may not"; if (modal_to) { print " "; modal_to(1); }
                    6: print "may not"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "may not have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "may not have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "may not have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "may not have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "may not have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "may not have"; if (modal_to) { print " "; modal_to(2); }
                }
                3: switch (vp) {
                    1: print "may not have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "may not have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "may not have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "may not have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "may not have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "may not have"; if (modal_to) { print " "; modal_to(2); }
                }
                4: switch (vp) {
                    1: print "may not have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "may not have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "may not have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "may not have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "may not have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "may not have"; if (modal_to) { print " "; modal_to(2); }
                }
                5: switch (vp) {
                    1: print "may not"; if (modal_to) { print " "; modal_to(1); }
                    2: print "may not"; if (modal_to) { print " "; modal_to(1); }
                    3: print "may not"; if (modal_to) { print " "; modal_to(1); }
                    4: print "may not"; if (modal_to) { print " "; modal_to(1); }
                    5: print "may not"; if (modal_to) { print " "; modal_to(1); }
                    6: print "may not"; if (modal_to) { print " "; modal_to(1); }
                }
            }
    }
];
[ ConjugateVerb_70 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "might";
        2: print "mighted";
        3: print "mighting";
        CV_MODAL: return true;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: switch (vp) {
                    1: print "might"; if (modal_to) { print " "; modal_to(1); }
                    2: print "might"; if (modal_to) { print " "; modal_to(1); }
                    3: print "might"; if (modal_to) { print " "; modal_to(1); }
                    4: print "might"; if (modal_to) { print " "; modal_to(1); }
                    5: print "might"; if (modal_to) { print " "; modal_to(1); }
                    6: print "might"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "might have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "might have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "might have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "might have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "might have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "might have"; if (modal_to) { print " "; modal_to(2); }
                }
                3: switch (vp) {
                    1: print "might have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "might have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "might have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "might have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "might have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "might have"; if (modal_to) { print " "; modal_to(2); }
                }
                4: switch (vp) {
                    1: print "might have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "might have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "might have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "might have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "might have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "might have"; if (modal_to) { print " "; modal_to(2); }
                }
                5: switch (vp) {
                    1: print "might"; if (modal_to) { print " "; modal_to(1); }
                    2: print "might"; if (modal_to) { print " "; modal_to(1); }
                    3: print "might"; if (modal_to) { print " "; modal_to(1); }
                    4: print "might"; if (modal_to) { print " "; modal_to(1); }
                    5: print "might"; if (modal_to) { print " "; modal_to(1); }
                    6: print "might"; if (modal_to) { print " "; modal_to(1); }
                }
            }
        CV_NEG:
            switch (t) {
                1: switch (vp) {
                    1: print "might not"; if (modal_to) { print " "; modal_to(1); }
                    2: print "might not"; if (modal_to) { print " "; modal_to(1); }
                    3: print "might not"; if (modal_to) { print " "; modal_to(1); }
                    4: print "might not"; if (modal_to) { print " "; modal_to(1); }
                    5: print "might not"; if (modal_to) { print " "; modal_to(1); }
                    6: print "might not"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "might not have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "might not have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "might not have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "might not have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "might not have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "might not have"; if (modal_to) { print " "; modal_to(2); }
                }
                3: switch (vp) {
                    1: print "might not have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "might not have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "might not have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "might not have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "might not have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "might not have"; if (modal_to) { print " "; modal_to(2); }
                }
                4: switch (vp) {
                    1: print "might not have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "might not have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "might not have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "might not have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "might not have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "might not have"; if (modal_to) { print " "; modal_to(2); }
                }
                5: switch (vp) {
                    1: print "might not"; if (modal_to) { print " "; modal_to(1); }
                    2: print "might not"; if (modal_to) { print " "; modal_to(1); }
                    3: print "might not"; if (modal_to) { print " "; modal_to(1); }
                    4: print "might not"; if (modal_to) { print " "; modal_to(1); }
                    5: print "might not"; if (modal_to) { print " "; modal_to(1); }
                    6: print "might not"; if (modal_to) { print " "; modal_to(1); }
                }
            }
    }
];
[ ConjugateVerb_71 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "must";
        2: print "musted";
        3: print "musting";
        CV_MODAL: return true;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: switch (vp) {
                    1: print "must"; if (modal_to) { print " "; modal_to(1); }
                    2: print "must"; if (modal_to) { print " "; modal_to(1); }
                    3: print "must"; if (modal_to) { print " "; modal_to(1); }
                    4: print "must"; if (modal_to) { print " "; modal_to(1); }
                    5: print "must"; if (modal_to) { print " "; modal_to(1); }
                    6: print "must"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "must have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "must have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "must have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "must have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "must have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "must have"; if (modal_to) { print " "; modal_to(2); }
                }
                3: switch (vp) {
                    1: print "must have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "must have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "must have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "must have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "must have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "must have"; if (modal_to) { print " "; modal_to(2); }
                }
                4: switch (vp) {
                    1: print "must have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "must have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "must have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "must have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "must have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "must have"; if (modal_to) { print " "; modal_to(2); }
                }
                5: switch (vp) {
                    1: print "must"; if (modal_to) { print " "; modal_to(1); }
                    2: print "must"; if (modal_to) { print " "; modal_to(1); }
                    3: print "must"; if (modal_to) { print " "; modal_to(1); }
                    4: print "must"; if (modal_to) { print " "; modal_to(1); }
                    5: print "must"; if (modal_to) { print " "; modal_to(1); }
                    6: print "must"; if (modal_to) { print " "; modal_to(1); }
                }
            }
        CV_NEG:
            switch (t) {
                1: switch (vp) {
                    1: print "must not"; if (modal_to) { print " "; modal_to(1); }
                    2: print "must not"; if (modal_to) { print " "; modal_to(1); }
                    3: print "must not"; if (modal_to) { print " "; modal_to(1); }
                    4: print "must not"; if (modal_to) { print " "; modal_to(1); }
                    5: print "must not"; if (modal_to) { print " "; modal_to(1); }
                    6: print "must not"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "must not have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "must not have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "must not have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "must not have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "must not have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "must not have"; if (modal_to) { print " "; modal_to(2); }
                }
                3: switch (vp) {
                    1: print "must not have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "must not have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "must not have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "must not have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "must not have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "must not have"; if (modal_to) { print " "; modal_to(2); }
                }
                4: switch (vp) {
                    1: print "must not have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "must not have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "must not have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "must not have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "must not have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "must not have"; if (modal_to) { print " "; modal_to(2); }
                }
                5: switch (vp) {
                    1: print "must not"; if (modal_to) { print " "; modal_to(1); }
                    2: print "must not"; if (modal_to) { print " "; modal_to(1); }
                    3: print "must not"; if (modal_to) { print " "; modal_to(1); }
                    4: print "must not"; if (modal_to) { print " "; modal_to(1); }
                    5: print "must not"; if (modal_to) { print " "; modal_to(1); }
                    6: print "must not"; if (modal_to) { print " "; modal_to(1); }
                }
            }
    }
];
[ ConjugateVerb_72 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "should";
        2: print "shoulded";
        3: print "shoulding";
        CV_MODAL: return true;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: switch (vp) {
                    1: print "should"; if (modal_to) { print " "; modal_to(1); }
                    2: print "should"; if (modal_to) { print " "; modal_to(1); }
                    3: print "should"; if (modal_to) { print " "; modal_to(1); }
                    4: print "should"; if (modal_to) { print " "; modal_to(1); }
                    5: print "should"; if (modal_to) { print " "; modal_to(1); }
                    6: print "should"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "should have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "should have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "should have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "should have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "should have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "should have"; if (modal_to) { print " "; modal_to(2); }
                }
                3: switch (vp) {
                    1: print "should have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "should have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "should have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "should have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "should have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "should have"; if (modal_to) { print " "; modal_to(2); }
                }
                4: switch (vp) {
                    1: print "should have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "should have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "should have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "should have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "should have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "should have"; if (modal_to) { print " "; modal_to(2); }
                }
                5: switch (vp) {
                    1: print "should"; if (modal_to) { print " "; modal_to(1); }
                    2: print "should"; if (modal_to) { print " "; modal_to(1); }
                    3: print "should"; if (modal_to) { print " "; modal_to(1); }
                    4: print "should"; if (modal_to) { print " "; modal_to(1); }
                    5: print "should"; if (modal_to) { print " "; modal_to(1); }
                    6: print "should"; if (modal_to) { print " "; modal_to(1); }
                }
            }
        CV_NEG:
            switch (t) {
                1: switch (vp) {
                    1: print "should not"; if (modal_to) { print " "; modal_to(1); }
                    2: print "should not"; if (modal_to) { print " "; modal_to(1); }
                    3: print "should not"; if (modal_to) { print " "; modal_to(1); }
                    4: print "should not"; if (modal_to) { print " "; modal_to(1); }
                    5: print "should not"; if (modal_to) { print " "; modal_to(1); }
                    6: print "should not"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "should not have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "should not have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "should not have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "should not have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "should not have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "should not have"; if (modal_to) { print " "; modal_to(2); }
                }
                3: switch (vp) {
                    1: print "should not have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "should not have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "should not have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "should not have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "should not have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "should not have"; if (modal_to) { print " "; modal_to(2); }
                }
                4: switch (vp) {
                    1: print "should not have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "should not have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "should not have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "should not have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "should not have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "should not have"; if (modal_to) { print " "; modal_to(2); }
                }
                5: switch (vp) {
                    1: print "should not"; if (modal_to) { print " "; modal_to(1); }
                    2: print "should not"; if (modal_to) { print " "; modal_to(1); }
                    3: print "should not"; if (modal_to) { print " "; modal_to(1); }
                    4: print "should not"; if (modal_to) { print " "; modal_to(1); }
                    5: print "should not"; if (modal_to) { print " "; modal_to(1); }
                    6: print "should not"; if (modal_to) { print " "; modal_to(1); }
                }
            }
    }
];
[ ConjugateVerb_73 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "would";
        2: print "woulded";
        3: print "woulding";
        CV_MODAL: return true;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: switch (vp) {
                    1: print "would"; if (modal_to) { print " "; modal_to(1); }
                    2: print "would"; if (modal_to) { print " "; modal_to(1); }
                    3: print "would"; if (modal_to) { print " "; modal_to(1); }
                    4: print "would"; if (modal_to) { print " "; modal_to(1); }
                    5: print "would"; if (modal_to) { print " "; modal_to(1); }
                    6: print "would"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "would have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "would have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "would have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "would have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "would have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "would have"; if (modal_to) { print " "; modal_to(2); }
                }
                3: switch (vp) {
                    1: print "would have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "would have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "would have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "would have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "would have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "would have"; if (modal_to) { print " "; modal_to(2); }
                }
                4: switch (vp) {
                    1: print "would have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "would have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "would have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "would have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "would have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "would have"; if (modal_to) { print " "; modal_to(2); }
                }
                5: switch (vp) {
                    1: print "would"; if (modal_to) { print " "; modal_to(1); }
                    2: print "would"; if (modal_to) { print " "; modal_to(1); }
                    3: print "would"; if (modal_to) { print " "; modal_to(1); }
                    4: print "would"; if (modal_to) { print " "; modal_to(1); }
                    5: print "would"; if (modal_to) { print " "; modal_to(1); }
                    6: print "would"; if (modal_to) { print " "; modal_to(1); }
                }
            }
        CV_NEG:
            switch (t) {
                1: switch (vp) {
                    1: print "would not"; if (modal_to) { print " "; modal_to(1); }
                    2: print "would not"; if (modal_to) { print " "; modal_to(1); }
                    3: print "would not"; if (modal_to) { print " "; modal_to(1); }
                    4: print "would not"; if (modal_to) { print " "; modal_to(1); }
                    5: print "would not"; if (modal_to) { print " "; modal_to(1); }
                    6: print "would not"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "would not have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "would not have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "would not have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "would not have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "would not have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "would not have"; if (modal_to) { print " "; modal_to(2); }
                }
                3: switch (vp) {
                    1: print "would not have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "would not have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "would not have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "would not have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "would not have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "would not have"; if (modal_to) { print " "; modal_to(2); }
                }
                4: switch (vp) {
                    1: print "would not have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "would not have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "would not have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "would not have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "would not have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "would not have"; if (modal_to) { print " "; modal_to(2); }
                }
                5: switch (vp) {
                    1: print "would not"; if (modal_to) { print " "; modal_to(1); }
                    2: print "would not"; if (modal_to) { print " "; modal_to(1); }
                    3: print "would not"; if (modal_to) { print " "; modal_to(1); }
                    4: print "would not"; if (modal_to) { print " "; modal_to(1); }
                    5: print "would not"; if (modal_to) { print " "; modal_to(1); }
                    6: print "would not"; if (modal_to) { print " "; modal_to(1); }
                }
            }
    }
];
[ ConjugateVerb_74 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "'re";
        2: print " been";
        3: print " being";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: switch (vp) {
                    1: print "'m";
                    2: print "'re";
                    3: print "'s";
                    4: print "'re";
                    5: print "'re";
                    6: print "'re";
                }
                2: switch (vp) {
                    1: print " was";
                    2: print " were";
                    3: print " was";
                    4: print " were";
                    5: print " were";
                    6: print " were";
                }
                3: if (vp == 3) { print "'s been"; } else { print "'ve been"; }
                4: print "'d been";
                5: print "'ll be";
            }
        CV_NEG:
            switch (t) {
                1: switch (vp) {
                    1: print "'m not";
                    2: print "'re not";
                    3: print "'s not";
                    4: print "'re not";
                    5: print "'re not";
                    6: print "'re not";
                }
                2: switch (vp) {
                    1: print " wasn't";
                    2: print " weren't";
                    3: print " wasn't";
                    4: print " weren't";
                    5: print " weren't";
                    6: print " weren't";
                }
                3: if (vp == 3) { print "'s not been"; } else { print "'ve not been"; }
                4: print "'d not been";
                5: print "'ll not be";
            }
    }
];
[ ConjugateVerb_75 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "'ve";
        2: print " had";
        3: print " having";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "'s"; } else { print "'ve"; }
                2: print " had";
                3: if (vp == 3) { print "'s had"; } else { print "'ve had"; }
                4: print "'d had";
                5: print "'ll have";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "'s not"; } else { print "'ve not"; }
                2: print " hadn't";
                3: if (vp == 3) { print "'s not had"; } else { print "'ve not had"; }
                4: print "'d not had";
                5: print "'ll not have";
            }
    }
];
[ ConjugateVerb_76 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "aren't";
        2: print "aren'ted";
        3: print "aren'ting";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: switch (vp) {
                    1: print "am not";
                    2: print "aren't";
                    3: print "isn't";
                    4: print "aren't";
                    5: print "aren't";
                    6: print "aren't";
                }
                2: switch (vp) {
                    1: print "wasn't";
                    2: print "weren't";
                    3: print "wasn't";
                    4: print "weren't";
                    5: print "weren't";
                    6: print "weren't";
                }
                3: if (vp == 3) { print "hasn't been"; } else { print "haven't been"; }
                4: print "hadn't been";
                5: print "won't be";
            }
        CV_NEG:
            switch (t) {
            }
    }
];
[ ConjugateVerb_77 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "can't";
        2: print "can'ted";
        3: print "can'ting";
        CV_MODAL: return true;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: switch (vp) {
                    1: print "can't"; if (modal_to) { print " "; modal_to(1); }
                    2: print "can't"; if (modal_to) { print " "; modal_to(1); }
                    3: print "can't"; if (modal_to) { print " "; modal_to(1); }
                    4: print "can't"; if (modal_to) { print " "; modal_to(1); }
                    5: print "can't"; if (modal_to) { print " "; modal_to(1); }
                    6: print "can't"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "couldn't"; if (modal_to) { print " "; modal_to(1); }
                    2: print "couldn't"; if (modal_to) { print " "; modal_to(1); }
                    3: print "couldn't"; if (modal_to) { print " "; modal_to(1); }
                    4: print "couldn't"; if (modal_to) { print " "; modal_to(1); }
                    5: print "couldn't"; if (modal_to) { print " "; modal_to(1); }
                    6: print "couldn't"; if (modal_to) { print " "; modal_to(1); }
                }
                3: switch (vp) {
                    1: print "haven't been able to"; if (modal_to) { print " "; modal_to(1); }
                    2: print "haven't been able to"; if (modal_to) { print " "; modal_to(1); }
                    3: print "hasn't been able to"; if (modal_to) { print " "; modal_to(1); }
                    4: print "haven't been able to"; if (modal_to) { print " "; modal_to(1); }
                    5: print "haven't been able to"; if (modal_to) { print " "; modal_to(1); }
                    6: print "haven't been able to"; if (modal_to) { print " "; modal_to(1); }
                }
                4: switch (vp) {
                    1: print "hadn't been able to"; if (modal_to) { print " "; modal_to(1); }
                    2: print "hadn't been able to"; if (modal_to) { print " "; modal_to(1); }
                    3: print "hadn't been able to"; if (modal_to) { print " "; modal_to(1); }
                    4: print "hadn't been able to"; if (modal_to) { print " "; modal_to(1); }
                    5: print "hadn't been able to"; if (modal_to) { print " "; modal_to(1); }
                    6: print "hadn't been able to"; if (modal_to) { print " "; modal_to(1); }
                }
                5: switch (vp) {
                    1: print "won't be able to"; if (modal_to) { print " "; modal_to(1); }
                    2: print "won't be able to"; if (modal_to) { print " "; modal_to(1); }
                    3: print "won't be able to"; if (modal_to) { print " "; modal_to(1); }
                    4: print "won't be able to"; if (modal_to) { print " "; modal_to(1); }
                    5: print "won't be able to"; if (modal_to) { print " "; modal_to(1); }
                    6: print "won't be able to"; if (modal_to) { print " "; modal_to(1); }
                }
            }
        CV_NEG:
            switch (t) {
            }
    }
];
[ ConjugateVerb_78 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "haven't";
        2: print "haven'ted";
        3: print "haven'ting";
        CV_MODAL: return true;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: switch (vp) {
                    1: print "haven't"; if (modal_to) { print " "; modal_to(1); }
                    2: print "haven't"; if (modal_to) { print " "; modal_to(1); }
                    3: print "hasn't"; if (modal_to) { print " "; modal_to(1); }
                    4: print "haven't"; if (modal_to) { print " "; modal_to(1); }
                    5: print "haven't"; if (modal_to) { print " "; modal_to(1); }
                    6: print "haven't"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "hadn't"; if (modal_to) { print " "; modal_to(2); }
                    2: print "hadn't"; if (modal_to) { print " "; modal_to(2); }
                    3: print "hadn't"; if (modal_to) { print " "; modal_to(2); }
                    4: print "hadn't"; if (modal_to) { print " "; modal_to(2); }
                    5: print "hadn't"; if (modal_to) { print " "; modal_to(2); }
                    6: print "hadn't"; if (modal_to) { print " "; modal_to(2); }
                }
                3: switch (vp) {
                    1: print "hadn't"; if (modal_to) { print " "; modal_to(2); }
                    2: print "hadn't"; if (modal_to) { print " "; modal_to(2); }
                    3: print "hadn't"; if (modal_to) { print " "; modal_to(2); }
                    4: print "hadn't"; if (modal_to) { print " "; modal_to(2); }
                    5: print "hadn't"; if (modal_to) { print " "; modal_to(2); }
                    6: print "hadn't"; if (modal_to) { print " "; modal_to(2); }
                }
                4: switch (vp) {
                    1: print "hadn't"; if (modal_to) { print " "; modal_to(2); }
                    2: print "hadn't"; if (modal_to) { print " "; modal_to(2); }
                    3: print "hadn't"; if (modal_to) { print " "; modal_to(2); }
                    4: print "hadn't"; if (modal_to) { print " "; modal_to(2); }
                    5: print "hadn't"; if (modal_to) { print " "; modal_to(2); }
                    6: print "hadn't"; if (modal_to) { print " "; modal_to(2); }
                }
                5: switch (vp) {
                    1: print "won't have"; if (modal_to) { print " "; modal_to(1); }
                    2: print "won't have"; if (modal_to) { print " "; modal_to(1); }
                    3: print "won't have"; if (modal_to) { print " "; modal_to(1); }
                    4: print "won't have"; if (modal_to) { print " "; modal_to(1); }
                    5: print "won't have"; if (modal_to) { print " "; modal_to(1); }
                    6: print "won't have"; if (modal_to) { print " "; modal_to(1); }
                }
            }
        CV_NEG:
            switch (t) {
            }
    }
];
[ ConjugateVerb_79 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "don't";
        2: print "don'ted";
        3: print "don'ting";
        CV_MODAL: return true;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: switch (vp) {
                    1: print "don't"; if (modal_to) { print " "; modal_to(1); }
                    2: print "don't"; if (modal_to) { print " "; modal_to(1); }
                    3: print "doesn't"; if (modal_to) { print " "; modal_to(1); }
                    4: print "don't"; if (modal_to) { print " "; modal_to(1); }
                    5: print "don't"; if (modal_to) { print " "; modal_to(1); }
                    6: print "don't"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "didn't"; if (modal_to) { print " "; modal_to(2); }
                    2: print "didn't"; if (modal_to) { print " "; modal_to(2); }
                    3: print "didn't"; if (modal_to) { print " "; modal_to(2); }
                    4: print "didn't"; if (modal_to) { print " "; modal_to(2); }
                    5: print "didn't"; if (modal_to) { print " "; modal_to(2); }
                    6: print "didn't"; if (modal_to) { print " "; modal_to(2); }
                }
                3: switch (vp) {
                    1: print "didn't"; if (modal_to) { print " "; modal_to(2); }
                    2: print "didn't"; if (modal_to) { print " "; modal_to(2); }
                    3: print "didn't"; if (modal_to) { print " "; modal_to(2); }
                    4: print "didn't"; if (modal_to) { print " "; modal_to(2); }
                    5: print "didn't"; if (modal_to) { print " "; modal_to(2); }
                    6: print "didn't"; if (modal_to) { print " "; modal_to(2); }
                }
                4: switch (vp) {
                    1: print "didn't"; if (modal_to) { print " "; modal_to(2); }
                    2: print "didn't"; if (modal_to) { print " "; modal_to(2); }
                    3: print "didn't"; if (modal_to) { print " "; modal_to(2); }
                    4: print "didn't"; if (modal_to) { print " "; modal_to(2); }
                    5: print "didn't"; if (modal_to) { print " "; modal_to(2); }
                    6: print "didn't"; if (modal_to) { print " "; modal_to(2); }
                }
                5: switch (vp) {
                    1: print "won't"; if (modal_to) { print " "; modal_to(1); }
                    2: print "won't"; if (modal_to) { print " "; modal_to(1); }
                    3: print "won't"; if (modal_to) { print " "; modal_to(1); }
                    4: print "won't"; if (modal_to) { print " "; modal_to(1); }
                    5: print "won't"; if (modal_to) { print " "; modal_to(1); }
                    6: print "won't"; if (modal_to) { print " "; modal_to(1); }
                }
            }
        CV_NEG:
            switch (t) {
            }
    }
];
[ ConjugateVerb_80 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "mustn't";
        2: print "mustn'ted";
        3: print "mustn'ting";
        CV_MODAL: return true;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: switch (vp) {
                    1: print "mustn't"; if (modal_to) { print " "; modal_to(1); }
                    2: print "mustn't"; if (modal_to) { print " "; modal_to(1); }
                    3: print "mustn't"; if (modal_to) { print " "; modal_to(1); }
                    4: print "mustn't"; if (modal_to) { print " "; modal_to(1); }
                    5: print "mustn't"; if (modal_to) { print " "; modal_to(1); }
                    6: print "mustn't"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "mustn't have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "mustn't have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "mustn't have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "mustn't have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "mustn't have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "mustn't have"; if (modal_to) { print " "; modal_to(2); }
                }
                3: switch (vp) {
                    1: print "mustn't have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "mustn't have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "mustn't have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "mustn't have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "mustn't have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "mustn't have"; if (modal_to) { print " "; modal_to(2); }
                }
                4: switch (vp) {
                    1: print "mustn't have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "mustn't have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "mustn't have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "mustn't have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "mustn't have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "mustn't have"; if (modal_to) { print " "; modal_to(2); }
                }
                5: switch (vp) {
                    1: print "mustn't"; if (modal_to) { print " "; modal_to(1); }
                    2: print "mustn't"; if (modal_to) { print " "; modal_to(1); }
                    3: print "mustn't"; if (modal_to) { print " "; modal_to(1); }
                    4: print "mustn't"; if (modal_to) { print " "; modal_to(1); }
                    5: print "mustn't"; if (modal_to) { print " "; modal_to(1); }
                    6: print "mustn't"; if (modal_to) { print " "; modal_to(1); }
                }
            }
        CV_NEG:
            switch (t) {
            }
    }
];
[ ConjugateVerb_81 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "mightn't";
        2: print "mightn'ted";
        3: print "mightn'ting";
        CV_MODAL: return true;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: switch (vp) {
                    1: print "mightn't"; if (modal_to) { print " "; modal_to(1); }
                    2: print "mightn't"; if (modal_to) { print " "; modal_to(1); }
                    3: print "mightn't"; if (modal_to) { print " "; modal_to(1); }
                    4: print "mightn't"; if (modal_to) { print " "; modal_to(1); }
                    5: print "mightn't"; if (modal_to) { print " "; modal_to(1); }
                    6: print "mightn't"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "mightn't have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "mightn't have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "mightn't have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "mightn't have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "mightn't have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "mightn't have"; if (modal_to) { print " "; modal_to(2); }
                }
                3: switch (vp) {
                    1: print "mightn't have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "mightn't have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "mightn't have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "mightn't have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "mightn't have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "mightn't have"; if (modal_to) { print " "; modal_to(2); }
                }
                4: switch (vp) {
                    1: print "mightn't have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "mightn't have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "mightn't have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "mightn't have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "mightn't have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "mightn't have"; if (modal_to) { print " "; modal_to(2); }
                }
                5: switch (vp) {
                    1: print "mightn't"; if (modal_to) { print " "; modal_to(1); }
                    2: print "mightn't"; if (modal_to) { print " "; modal_to(1); }
                    3: print "mightn't"; if (modal_to) { print " "; modal_to(1); }
                    4: print "mightn't"; if (modal_to) { print " "; modal_to(1); }
                    5: print "mightn't"; if (modal_to) { print " "; modal_to(1); }
                    6: print "mightn't"; if (modal_to) { print " "; modal_to(1); }
                }
            }
        CV_NEG:
            switch (t) {
            }
    }
];
[ ConjugateVerb_82 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "mayn't";
        2: print "mayn'ted";
        3: print "mayn'ting";
        CV_MODAL: return true;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: switch (vp) {
                    1: print "mayn't"; if (modal_to) { print " "; modal_to(1); }
                    2: print "mayn't"; if (modal_to) { print " "; modal_to(1); }
                    3: print "mayn't"; if (modal_to) { print " "; modal_to(1); }
                    4: print "mayn't"; if (modal_to) { print " "; modal_to(1); }
                    5: print "mayn't"; if (modal_to) { print " "; modal_to(1); }
                    6: print "mayn't"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "mayn't have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "mayn't have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "mayn't have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "mayn't have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "mayn't have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "mayn't have"; if (modal_to) { print " "; modal_to(2); }
                }
                3: switch (vp) {
                    1: print "mayn't have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "mayn't have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "mayn't have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "mayn't have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "mayn't have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "mayn't have"; if (modal_to) { print " "; modal_to(2); }
                }
                4: switch (vp) {
                    1: print "mayn't have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "mayn't have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "mayn't have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "mayn't have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "mayn't have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "mayn't have"; if (modal_to) { print " "; modal_to(2); }
                }
                5: switch (vp) {
                    1: print "mayn't"; if (modal_to) { print " "; modal_to(1); }
                    2: print "mayn't"; if (modal_to) { print " "; modal_to(1); }
                    3: print "mayn't"; if (modal_to) { print " "; modal_to(1); }
                    4: print "mayn't"; if (modal_to) { print " "; modal_to(1); }
                    5: print "mayn't"; if (modal_to) { print " "; modal_to(1); }
                    6: print "mayn't"; if (modal_to) { print " "; modal_to(1); }
                }
            }
        CV_NEG:
            switch (t) {
            }
    }
];
[ ConjugateVerb_83 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "wouldn't";
        2: print "wouldn'ted";
        3: print "wouldn'ting";
        CV_MODAL: return true;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: switch (vp) {
                    1: print "wouldn't"; if (modal_to) { print " "; modal_to(1); }
                    2: print "wouldn't"; if (modal_to) { print " "; modal_to(1); }
                    3: print "wouldn't"; if (modal_to) { print " "; modal_to(1); }
                    4: print "wouldn't"; if (modal_to) { print " "; modal_to(1); }
                    5: print "wouldn't"; if (modal_to) { print " "; modal_to(1); }
                    6: print "wouldn't"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "wouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "wouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "wouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "wouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "wouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "wouldn't have"; if (modal_to) { print " "; modal_to(2); }
                }
                3: switch (vp) {
                    1: print "wouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "wouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "wouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "wouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "wouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "wouldn't have"; if (modal_to) { print " "; modal_to(2); }
                }
                4: switch (vp) {
                    1: print "wouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "wouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "wouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "wouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "wouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "wouldn't have"; if (modal_to) { print " "; modal_to(2); }
                }
                5: switch (vp) {
                    1: print "wouldn't"; if (modal_to) { print " "; modal_to(1); }
                    2: print "wouldn't"; if (modal_to) { print " "; modal_to(1); }
                    3: print "wouldn't"; if (modal_to) { print " "; modal_to(1); }
                    4: print "wouldn't"; if (modal_to) { print " "; modal_to(1); }
                    5: print "wouldn't"; if (modal_to) { print " "; modal_to(1); }
                    6: print "wouldn't"; if (modal_to) { print " "; modal_to(1); }
                }
            }
        CV_NEG:
            switch (t) {
            }
    }
];
[ ConjugateVerb_84 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "couldn't";
        2: print "couldn'ted";
        3: print "couldn'ting";
        CV_MODAL: return true;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: switch (vp) {
                    1: print "couldn't"; if (modal_to) { print " "; modal_to(1); }
                    2: print "couldn't"; if (modal_to) { print " "; modal_to(1); }
                    3: print "couldn't"; if (modal_to) { print " "; modal_to(1); }
                    4: print "couldn't"; if (modal_to) { print " "; modal_to(1); }
                    5: print "couldn't"; if (modal_to) { print " "; modal_to(1); }
                    6: print "couldn't"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "couldn't have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "couldn't have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "couldn't have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "couldn't have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "couldn't have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "couldn't have"; if (modal_to) { print " "; modal_to(2); }
                }
                3: switch (vp) {
                    1: print "couldn't have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "couldn't have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "couldn't have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "couldn't have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "couldn't have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "couldn't have"; if (modal_to) { print " "; modal_to(2); }
                }
                4: switch (vp) {
                    1: print "couldn't have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "couldn't have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "couldn't have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "couldn't have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "couldn't have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "couldn't have"; if (modal_to) { print " "; modal_to(2); }
                }
                5: switch (vp) {
                    1: print "couldn't"; if (modal_to) { print " "; modal_to(1); }
                    2: print "couldn't"; if (modal_to) { print " "; modal_to(1); }
                    3: print "couldn't"; if (modal_to) { print " "; modal_to(1); }
                    4: print "couldn't"; if (modal_to) { print " "; modal_to(1); }
                    5: print "couldn't"; if (modal_to) { print " "; modal_to(1); }
                    6: print "couldn't"; if (modal_to) { print " "; modal_to(1); }
                }
            }
        CV_NEG:
            switch (t) {
            }
    }
];
[ ConjugateVerb_85 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "shouldn't";
        2: print "shouldn'ted";
        3: print "shouldn'ting";
        CV_MODAL: return true;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: switch (vp) {
                    1: print "shouldn't"; if (modal_to) { print " "; modal_to(1); }
                    2: print "shouldn't"; if (modal_to) { print " "; modal_to(1); }
                    3: print "shouldn't"; if (modal_to) { print " "; modal_to(1); }
                    4: print "shouldn't"; if (modal_to) { print " "; modal_to(1); }
                    5: print "shouldn't"; if (modal_to) { print " "; modal_to(1); }
                    6: print "shouldn't"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "shouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "shouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "shouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "shouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "shouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "shouldn't have"; if (modal_to) { print " "; modal_to(2); }
                }
                3: switch (vp) {
                    1: print "shouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "shouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "shouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "shouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "shouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "shouldn't have"; if (modal_to) { print " "; modal_to(2); }
                }
                4: switch (vp) {
                    1: print "shouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "shouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "shouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "shouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "shouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "shouldn't have"; if (modal_to) { print " "; modal_to(2); }
                }
                5: switch (vp) {
                    1: print "shouldn't"; if (modal_to) { print " "; modal_to(1); }
                    2: print "shouldn't"; if (modal_to) { print " "; modal_to(1); }
                    3: print "shouldn't"; if (modal_to) { print " "; modal_to(1); }
                    4: print "shouldn't"; if (modal_to) { print " "; modal_to(1); }
                    5: print "shouldn't"; if (modal_to) { print " "; modal_to(1); }
                    6: print "shouldn't"; if (modal_to) { print " "; modal_to(1); }
                }
            }
        CV_NEG:
            switch (t) {
            }
    }
];
[ ConjugateVerb_86 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "won't";
        2: print "won'ted";
        3: print "won'ting";
        CV_MODAL: return true;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: switch (vp) {
                    1: print "won't"; if (modal_to) { print " "; modal_to(1); }
                    2: print "won't"; if (modal_to) { print " "; modal_to(1); }
                    3: print "won't"; if (modal_to) { print " "; modal_to(1); }
                    4: print "won't"; if (modal_to) { print " "; modal_to(1); }
                    5: print "won't"; if (modal_to) { print " "; modal_to(1); }
                    6: print "won't"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "wouldn't"; if (modal_to) { print " "; modal_to(2); }
                    2: print "wouldn't"; if (modal_to) { print " "; modal_to(2); }
                    3: print "wouldn't"; if (modal_to) { print " "; modal_to(2); }
                    4: print "wouldn't"; if (modal_to) { print " "; modal_to(2); }
                    5: print "wouldn't"; if (modal_to) { print " "; modal_to(2); }
                    6: print "wouldn't"; if (modal_to) { print " "; modal_to(2); }
                }
                3: switch (vp) {
                    1: print "wouldn't"; if (modal_to) { print " "; modal_to(2); }
                    2: print "wouldn't"; if (modal_to) { print " "; modal_to(2); }
                    3: print "wouldn't"; if (modal_to) { print " "; modal_to(2); }
                    4: print "wouldn't"; if (modal_to) { print " "; modal_to(2); }
                    5: print "wouldn't"; if (modal_to) { print " "; modal_to(2); }
                    6: print "wouldn't"; if (modal_to) { print " "; modal_to(2); }
                }
                4: switch (vp) {
                    1: print "wouldn't"; if (modal_to) { print " "; modal_to(2); }
                    2: print "wouldn't"; if (modal_to) { print " "; modal_to(2); }
                    3: print "wouldn't"; if (modal_to) { print " "; modal_to(2); }
                    4: print "wouldn't"; if (modal_to) { print " "; modal_to(2); }
                    5: print "wouldn't"; if (modal_to) { print " "; modal_to(2); }
                    6: print "wouldn't"; if (modal_to) { print " "; modal_to(2); }
                }
                5: switch (vp) {
                    1: print "won't"; if (modal_to) { print " "; modal_to(1); }
                    2: print "won't"; if (modal_to) { print " "; modal_to(1); }
                    3: print "won't"; if (modal_to) { print " "; modal_to(1); }
                    4: print "won't"; if (modal_to) { print " "; modal_to(1); }
                    5: print "won't"; if (modal_to) { print " "; modal_to(1); }
                    6: print "won't"; if (modal_to) { print " "; modal_to(1); }
                }
            }
        CV_NEG:
            switch (t) {
            }
    }
];
[ ConjugateVerb_87 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "fit";
        2: print "fitted";
        3: print "fitting";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "fits"; } else { print "fit"; }
                2: print "fitted";
                3: if (vp == 3) { print "has fitted"; } else { print "have fitted"; }
                4: print "had fitted";
                5: print "will fit";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not fit"; } else { print "do not fit"; }
                2: print "did not fit";
                3: if (vp == 3) { print "has not fitted"; } else { print "have not fitted"; }
                4: print "had not fitted";
                5: print "will not fit";
            }
    }
];
[ ConjugateVerb_88 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "unbolt";
        2: print "unbolted";
        3: print "unbolting";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_71;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "unbolts"; } else { print "unbolt"; }
                2: print "unbolted";
                3: if (vp == 3) { print "has unbolted"; } else { print "have unbolted"; }
                4: print "had unbolted";
                5: print "will unbolt";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not unbolt"; } else { print "do not unbolt"; }
                2: print "did not unbolt";
                3: if (vp == 3) { print "has not unbolted"; } else { print "have not unbolted"; }
                4: print "had not unbolted";
                5: print "will not unbolt";
            }
    }
];
Array TableOfVerbs --> ConjugateVerb_0 ConjugateVerb_2 ConjugateVerb_3 ConjugateVerb_4 ConjugateVerb_5 ConjugateVerb_6 ConjugateVerb_7 ConjugateVerb_8 ConjugateVerb_9 ConjugateVerb_10 ConjugateVerb_11 ConjugateVerb_12 ConjugateVerb_13 ConjugateVerb_14 ConjugateVerb_15 ConjugateVerb_16 ConjugateVerb_17 ConjugateVerb_18 ConjugateVerb_19 ConjugateVerb_20 ConjugateVerb_21 ConjugateVerb_22 ConjugateVerb_23 ConjugateVerb_24 ConjugateVerb_25 ConjugateVerb_26 ConjugateVerb_27 ConjugateVerb_28 ConjugateVerb_29 ConjugateVerb_30 ConjugateVerb_31 ConjugateVerb_32 ConjugateVerb_33 ConjugateVerb_34 ConjugateVerb_35 ConjugateVerb_36 ConjugateVerb_37 ConjugateVerb_38 ConjugateVerb_39 ConjugateVerb_40 ConjugateVerb_41 ConjugateVerb_42 ConjugateVerb_43 ConjugateVerb_44 ConjugateVerb_45 ConjugateVerb_46 ConjugateVerb_47 ConjugateVerb_48 ConjugateVerb_49 ConjugateVerb_50 ConjugateVerb_51 ConjugateVerb_52 ConjugateVerb_53 ConjugateVerb_54 ConjugateVerb_55 ConjugateVerb_56 ConjugateVerb_57 ConjugateVerb_58 ConjugateVerb_59 ConjugateVerb_60 ConjugateVerb_61 ConjugateVerb_62 ConjugateVerb_63 ConjugateVerb_64 ConjugateVerb_65 ConjugateVerb_66 ConjugateVerb_67 ConjugateVerb_68 ConjugateVerb_69 ConjugateVerb_70 ConjugateVerb_71 ConjugateVerb_72 ConjugateVerb_73 ConjugateVerb_87 ConjugateVerb_88 0;




! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Testing commands
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#IFDEF DEBUG;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tests.i6t: Abstract Command
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ XAbstractSub;
    if (XTestMove(noun, second)) return;
    move noun to second;
    "[Abstracted.]";
];

[ XTestMove obj dest;
    if (obj <= InformLibrary) "[Can't move ", (name) obj, ": it's a system object.]";
    if (obj.component_parent) "[Can't move ", (name) obj, ": it's part of ",
        (the) obj.component_parent, ".]";
    while (dest) {
        if (dest == obj) "[Can't move ", (name) obj, ": it would contain itself.]";
        dest = CoreOfParentOfCoreOf(dest);
    }
    rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tests.i6t: Actions Command
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ActionsOnSub; trace_actions = 1; say__p = 1; "Actions listing on."; ];
[ ActionsOffSub; trace_actions = 0; say__p = 1; "Actions listing off."; ];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tests.i6t: Gonear Command
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ GonearSub;
	PlayerTo(LocationOf(noun));
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tests.i6t: Purloin Command
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ XPurloinSub;
    if (XTestMove(noun, player)) return;
    move noun to player; give noun moved ~concealed;
    say__p = 1;
    "[Purloined.]";
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tests.i6t: Random Command
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PredictableSub;
    VM_Seed_RNG(-100);
    say__p = 1;
    "[Random number generator now predictable.]";
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tests.i6t: Relations Command
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ShowRelationsSub;
   IterateRelations(ShowOneRelation);
];

[ ShowOneRelation rel;
	if ((RlnGetF(rel, RR_PERMISSIONS)) & (RELS_SHOW)) {
		(RlnGetF(rel, RR_HANDLER))(rel, RELS_SHOW);
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tests.i6t: Responses Command
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Global suppress_text_substitution = false;
[ ShowResponsesSub a i j reg wd set_mode;
	if (NO_RESPONSES == 0) "There are no lettered responses.";
	wn = 2;
	if (NextWordStopped() == 'now') set_mode = 1; else wn--;
	if (NextWordStopped() == 'set') set_mode = 2; else wn--;
	wd = NextWordStopped(); wn--;
	if (wd == 'all') reg = 0;
	else {
		reg = -1;
		if (wd ~= -1) reg = TryNumber(wn);
		if (reg < 0) {
			say__p = 1;
   			print ">--> The following sets of responses are available:^";
			print "    RESPONSES ALL^";
		}
	}
	for (a=0, i=1, j=0: ResponseDivisions-->a: a=a+3, i++) {
		if (ResponseDivisions-->a ~= EMPTY_TEXT_PACKED) j++;
		if ((reg == 0) || (reg == j)) {
			if (ResponseDivisions-->a ~= EMPTY_TEXT_PACKED) {
				if (set_mode) {
					print "[", (string) ResponseDivisions-->a, "]^";
				} else {
					print (string) ResponseDivisions-->a, ":^";
				}
			}
			ShowResponsesRange(ResponseDivisions-->(a+1), ResponseDivisions-->(a+2), set_mode);
		}
		if (reg < 0) {
			if (ResponseDivisions-->a ~= EMPTY_TEXT_PACKED) {
				print "    RESPONSES ", j, ": ", (string) ResponseDivisions-->a, "^";
			}
		}
	}
];

[ ShowResponsesRange from to set_mode i;
	say__p = 1;
	for (i=from: i<=to: i++) {
		switch (set_mode) {
			1: print "now ";
			2: ;
			0: print "    ";
		}
		print (PrintResponse) i;
		switch (set_mode) {
			1: print " is ";
			2: print " is ";
			0: print ": ";
		}
		suppress_text_substitution = true;
		CarryOutActivity(PRINTING_RESPONSE_ACT, i);
		suppress_text_substitution = false;
		switch (set_mode) {
			1: print ";";
			2: print ".";
		}
		print "^";
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tests.i6t: Rules Command
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ RulesOnSub;
	debug_rules = 1; say__p = 1;
	"Rules tracing now switched on. Type ~rules off~ to switch it off again,
	 or ~rules all~ to include even rules which do not apply.";
];
[ RulesAllSub;
	debug_rules = 2; say__p = 1;
	"Rules tracing now switched to ~all~. Type ~rules off~ to switch it off again.";
];
[ RulesOffSub;
	debug_rules = 0; say__p = 1;
	"Rules tracing now switched off. Type ~rules~ to switch it on again.";
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tests.i6t: Scenes Command
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ScenesOnSub;
	debug_scenes = 1;
	ShowSceneStatus(); say__p = 1;
	"(Scene monitoring now switched on. Type ~scenes off~ to switch it off again.)";
];
[ ScenesOffSub;
	debug_scenes = 0; say__p = 1;
	"(Scene monitoring now switched off. Type ~scenes~ to switch it on again.)";
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tests.i6t: Scope Command
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Global x_scope_count;
[ ScopeSub;
    x_scope_count = 0;
    LoopOverScope(Print_ScL, noun);
    if (x_scope_count == 0) "Nothing is in scope.";
];
[ Print_ScL obj; print_ret ++x_scope_count, ": ", (a) obj, " (", obj, ")"; ];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tests.i6t: Showheap Command
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ShowHeapSub;
	HeapDebug();
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tests.i6t: ShowMe Command
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ShowMeSub t_0 na;
	t_0 = noun;
 	if (noun == nothing) noun = real_location;
 	if (ShowMeRecursively(noun, 0, (noun == real_location))) {
 		if (noun == real_location)
			print "* denotes things which are not in scope^";
	}
 	if (t_0 ofclass K2_thing) {
 		print "location:"; ShowRLocation(noun, true); print "^";
 	}
 	if (t_0) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(pluralname)) && (t_0  has pluralname)) { if (na++ > 0) print ", "; print "plural-named"; }
    if ((AllowInShowme(pluralname)) && (t_0  hasnt pluralname)) { if (na++ > 0) print ", "; print "singular-named"; }
    if ((AllowInShowme(proper)) && (t_0  has proper)) { if (na++ > 0) print ", "; print "proper-named"; }
    if ((AllowInShowme(proper)) && (t_0  hasnt proper)) { if (na++ > 0) print ", "; print "improper-named"; }
    if ((AllowInShowme(ambigpluralname)) && (t_0  has ambigpluralname)) { if (na++ > 0) print ", "; print "ambiguously plural"; }
    if ((AllowInShowme(ambigpluralname)) && (t_0  hasnt ambigpluralname)) { if (na++ > 0) print ", "; print "ordinarily enumerated"; }
}
if (t_0 ofclass K1_room) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(light)) && (t_0  has light)) { if (na++ > 0) print ", "; print "lighted"; }
    if ((AllowInShowme(light)) && (t_0  hasnt light)) { if (na++ > 0) print ", "; print "dark"; }
    if ((AllowInShowme(visited)) && (t_0  has visited)) { if (na++ > 0) print ", "; print "visited"; }
    if ((AllowInShowme(visited)) && (t_0  hasnt visited)) { if (na++ > 0) print ", "; print "unvisited"; }
    if ((AllowInShowme(p65_cursed)) && (t_0  has p65_cursed)) { if (na++ > 0) print ", "; print "cursed"; }
    if ((AllowInShowme(p65_cursed)) && (t_0  hasnt p65_cursed)) { if (na++ > 0) print ", "; print "uncursed"; }
    if ((AllowInShowme(p67_indoors)) && (t_0  has p67_indoors)) { if (na++ > 0) print ", "; print "indoors"; }
    if ((AllowInShowme(p67_indoors)) && (t_0  hasnt p67_indoors)) { if (na++ > 0) print ", "; print "outdoors"; }
}
if (t_0 ofclass K2_thing) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(light)) && (t_0  has light)) { if (na++ > 0) print ", "; print "lit"; }
    if ((AllowInShowme(light)) && (t_0  hasnt light)) { if (na++ > 0) print ", "; print "unlit"; }
    if ((AllowInShowme(edible)) && (t_0  has edible)) { if (na++ > 0) print ", "; print "edible"; }
    if ((AllowInShowme(edible)) && (t_0  hasnt edible)) { if (na++ > 0) print ", "; print "inedible"; }
    if ((AllowInShowme(static)) && (t_0  has static)) { if (na++ > 0) print ", "; print "fixed in place"; }
    if ((AllowInShowme(static)) && (t_0  hasnt static)) { if (na++ > 0) print ", "; print "portable"; }
    if ((AllowInShowme(scenery)) && (t_0  has scenery)) { if (na++ > 0) print ", "; print "scenery"; }
    if ((AllowInShowme(clothing)) && (t_0  has clothing)) { if (na++ > 0) print ", "; print "wearable"; }
    if ((AllowInShowme(pushable)) && (t_0  has pushable)) { if (na++ > 0) print ", "; print "pushable between rooms"; }
    if ((AllowInShowme(moved)) && (t_0  has moved)) { if (na++ > 0) print ", "; print "handled"; }
    if ((AllowInShowme(concealed)) && (t_0  hasnt concealed)) { if (na++ > 0) print ", "; print "described"; }
    if ((AllowInShowme(concealed)) && (t_0  has concealed)) { if (na++ > 0) print ", "; print "undescribed"; }
    if ((AllowInShowme(workflag)) && (t_0  has workflag)) { if (na++ > 0) print ", "; print "marked for listing"; }
    if ((AllowInShowme(workflag)) && (t_0  hasnt workflag)) { if (na++ > 0) print ", "; print "unmarked for listing"; }
    if ((AllowInShowme(mentioned)) && (t_0  has mentioned)) { if (na++ > 0) print ", "; print "mentioned"; }
    if ((AllowInShowme(mentioned)) && (t_0  hasnt mentioned)) { if (na++ > 0) print ", "; print "unmentioned"; }
    if ((AllowInShowme(female)) && (t_0  has female)) { if (na++ > 0) print ", "; print "female"; }
    if ((AllowInShowme(male)) && (t_0  has male)) { if (na++ > 0) print ", "; print "male"; }
    if ((AllowInShowme(neuter)) && (t_0  has neuter)) { if (na++ > 0) print ", "; print "neuter"; }
    if ((AllowInShowme(p63_distant)) && (t_0  has p63_distant)) { if (na++ > 0) print ", "; print "distant"; }
    if ((AllowInShowme(p63_distant)) && (t_0  hasnt p63_distant)) { if (na++ > 0) print ", "; print "near"; }
}
if (t_0 ofclass K3_direction) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(workflag)) && (t_0  has workflag)) { if (na++ > 0) print ", "; print "marked for listing"; }
    if ((AllowInShowme(workflag)) && (t_0  hasnt workflag)) { if (na++ > 0) print ", "; print "unmarked for listing"; }
}
if (t_0 ofclass K4_door) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(open)) && (t_0  has open)) { if (na++ > 0) print ", "; print "open"; }
    if ((AllowInShowme(open)) && (t_0  hasnt open)) { if (na++ > 0) print ", "; print "closed"; }
    if ((AllowInShowme(openable)) && (t_0  has openable)) { if (na++ > 0) print ", "; print "openable"; }
    if ((AllowInShowme(openable)) && (t_0  hasnt openable)) { if (na++ > 0) print ", "; print "unopenable"; }
    if ((AllowInShowme(lockable)) && (t_0  has lockable)) { if (na++ > 0) print ", "; print "lockable"; }
    if ((AllowInShowme(locked)) && (t_0  has locked)) { if (na++ > 0) print ", "; print "locked"; }
    if ((AllowInShowme(locked)) && (t_0  hasnt locked)) { if (na++ > 0) print ", "; print "unlocked"; }
}
if (t_0 ofclass K5_container) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(enterable)) && (t_0  has enterable)) { if (na++ > 0) print ", "; print "enterable"; }
    if ((AllowInShowme(transparent)) && (t_0  hasnt transparent)) { if (na++ > 0) print ", "; print "opaque"; }
    if ((AllowInShowme(transparent)) && (t_0  has transparent)) { if (na++ > 0) print ", "; print "transparent"; }
    if ((AllowInShowme(open)) && (t_0  has open)) { if (na++ > 0) print ", "; print "open"; }
    if ((AllowInShowme(open)) && (t_0  hasnt open)) { if (na++ > 0) print ", "; print "closed"; }
    if ((AllowInShowme(openable)) && (t_0  has openable)) { if (na++ > 0) print ", "; print "openable"; }
    if ((AllowInShowme(openable)) && (t_0  hasnt openable)) { if (na++ > 0) print ", "; print "unopenable"; }
    if ((AllowInShowme(lockable)) && (t_0  has lockable)) { if (na++ > 0) print ", "; print "lockable"; }
    if ((AllowInShowme(locked)) && (t_0  has locked)) { if (na++ > 0) print ", "; print "locked"; }
    if ((AllowInShowme(locked)) && (t_0  hasnt locked)) { if (na++ > 0) print ", "; print "unlocked"; }
}
if (t_0 ofclass K6_supporter) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(enterable)) && (t_0  has enterable)) { if (na++ > 0) print ", "; print "enterable"; }
}
if (t_0 ofclass K13_device) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(on)) && (t_0  has on)) { if (na++ > 0) print ", "; print "switched on"; }
    if ((AllowInShowme(on)) && (t_0  hasnt on)) { if (na++ > 0) print ", "; print "switched off"; }
}
if (t_0 ofclass K23_drawer) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(p69_explored)) && (t_0  has p69_explored)) { if (na++ > 0) print ", "; print "explored"; }
    if ((AllowInShowme(p69_explored)) && (t_0  hasnt p69_explored)) { if (na++ > 0) print ", "; print "unexplored"; }
}
if (t_0) {if (na > 0) { na = 0; print "^"; }
    print "list grouping key: "; if (TEXT_TY_Compare(GProperty(OBJECT_TY, t_0, list_together), EMPTY_TEXT_VALUE) == 0) print "none^"; else print "~", (TEXT_TY_Say) GProperty(OBJECT_TY, t_0, list_together), "~", "^";
    print "printed name: "; if (TEXT_TY_Compare(GProperty(OBJECT_TY, t_0, short_name), EMPTY_TEXT_VALUE) == 0) print "none^"; else print "~", (TEXT_TY_Say) GProperty(OBJECT_TY, t_0, short_name), "~", "^";
    print "printed plural name: "; if (TEXT_TY_Compare(GProperty(OBJECT_TY, t_0, plural), EMPTY_TEXT_VALUE) == 0) print "none^"; else print "~", (TEXT_TY_Say) GProperty(OBJECT_TY, t_0, plural), "~", "^";
    print "indefinite article: "; if (TEXT_TY_Compare(GProperty(OBJECT_TY, t_0, article), EMPTY_TEXT_VALUE) == 0) print "none^"; else print "~", (TEXT_TY_Say) GProperty(OBJECT_TY, t_0, article), "~", "^";
}
if (t_0 ofclass K1_room) {if (na > 0) { na = 0; print "^"; }
    print "description: "; if (TEXT_TY_Compare(GProperty(OBJECT_TY, t_0, description), EMPTY_TEXT_VALUE) == 0) print "none^"; else print "~", (TEXT_TY_Say) GProperty(OBJECT_TY, t_0, description), "~", "^";
    if (GProperty(OBJECT_TY, t_0, map_region)) { print "map region: "; print (PrintShortName) GProperty(OBJECT_TY, t_0, map_region), "^";
    }
}
if (t_0 ofclass K2_thing) {if (na > 0) { na = 0; print "^"; }
    print "description: "; if (TEXT_TY_Compare(GProperty(OBJECT_TY, t_0, description), EMPTY_TEXT_VALUE) == 0) print "none^"; else print "~", (TEXT_TY_Say) GProperty(OBJECT_TY, t_0, description), "~", "^";
    print "initial appearance: "; if (TEXT_TY_Compare(GProperty(OBJECT_TY, t_0, initial), EMPTY_TEXT_VALUE) == 0) print "none^"; else print "~", (TEXT_TY_Say) GProperty(OBJECT_TY, t_0, initial), "~", "^";
    if (GProperty(OBJECT_TY, t_0, with_key)) { print "matching key: "; print (PrintShortName) GProperty(OBJECT_TY, t_0, with_key), "^";
    }
    print "reading-material: "; if (TEXT_TY_Compare(GProperty(OBJECT_TY, t_0, p15_reading_material), EMPTY_TEXT_VALUE) == 0) print "none^"; else print "~", (TEXT_TY_Say) GProperty(OBJECT_TY, t_0, p15_reading_material), "~", "^";
}
if (t_0 ofclass K3_direction) {if (na > 0) { na = 0; print "^"; }
    if (GProperty(OBJECT_TY, t_0, p10_opposite)) { print "opposite: "; print (PrintShortName) GProperty(OBJECT_TY, t_0, p10_opposite), "^";
    }
}
if (t_0 ofclass K4_door) {if (na > 0) { na = 0; print "^"; }
    if (GProperty(OBJECT_TY, t_0, door_to)) { print "other side: "; print (PrintShortName) GProperty(OBJECT_TY, t_0, door_to), "^";
    }
}
if (t_0 ofclass K5_container) {if (na > 0) { na = 0; print "^"; }
    print "carrying capacity: "; print (DecimalNumber) GProperty(OBJECT_TY, t_0, capacity), "^";
}
if (t_0 ofclass K6_supporter) {if (na > 0) { na = 0; print "^"; }
    print "carrying capacity: "; print (DecimalNumber) GProperty(OBJECT_TY, t_0, capacity), "^";
}
if (t_0 ofclass K8_person) {if (na > 0) { na = 0; print "^"; }
    print "carrying capacity: "; print (DecimalNumber) GProperty(OBJECT_TY, t_0, capacity), "^";
    print "gender: "; print (T68) GProperty(OBJECT_TY, t_0, p62_gender), "^";
}

];

[ ShowRLocation obj top;
	if (obj ofclass K1_room) return;
	print " ";
	if (parent(obj)) {
		if (obj has worn) print "worn by ";
		else {
			if (parent(obj) has animate) print "carried by ";
			if (parent(obj) has container) print "in ";
			if (parent(obj) ofclass K1_room) print "in ";
			if (parent(obj) has supporter) print "on ";
		}
		print (the) parent(obj);
		ShowRLocation(parent(obj));
	} else {
		if (obj.component_parent) {
			if (top == false) print ", which is ";
			print "part of ", (the) obj.component_parent;
			ShowRLocation(obj.component_parent);
		}
		else print "out of play";
	}
];

[ ShowMeRecursively obj depth f c i k;
	spaces(2*depth);
	if (f && (depth > 0) && (TestScope(obj, player) == false)) { print "*"; c = true; }
	print (name) obj;
	if (depth > 0) {
		if (obj.component_parent) print " (part of ", (name) obj.component_parent, ")";
		if (obj has worn) print " (worn)";
	}
	if (obj provides KD_Count) {
		k = KindHierarchy-->((obj.KD_Count)*2);
		if ((k ~= K2_thing) || (depth==0)) {
			print " - ";
			if (k == K4_door or K5_container) {
				if (obj has transparent) print "transparent ";
				if (obj has locked) print "locked ";
				else if (obj has open) print "open ";
				else print "closed ";
			}
			print (I7_Kind_Name) k;
		}
	}
	print "^";
	if (obj.component_child) c = c | ShowMeRecursively(obj.component_child, depth+2, f);
	if ((depth>0) && (obj.component_sibling))
		c = c | ShowMeRecursively(obj.component_sibling, depth, f);
	if (child(obj)) c = c | ShowMeRecursively(child(obj), depth+2, f);
	if ((depth>0) && (sibling(obj))) c = c | ShowMeRecursively(sibling(obj), depth, f);
	return c;
];

[ AllowInShowme pr;
	if (pr == workflag or concealed or mentioned) rfalse;
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tests.i6t: Showverb Command
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ShowVerbSub address lines meta i x;
	wn = 2; x = NextWordStopped();
    if (x == 0 || ((x->#dict_par1) & 1) == 0)
        "Try typing ~showverb~ and then the name of a verb.";
    meta = ((x->#dict_par1) & 2)/2;
    i = DictionaryWordToVerbNum(x);
    address = VM_CommandTableAddress(i);
    lines = address->0;
    address++;
    print "Verb ";
    if (meta) print "meta ";
    VM_PrintCommandWords(i);
    new_line;
    if (lines == 0) print "has no grammar lines.^";
    for (: lines>0 : lines--) {
        address = UnpackGrammarLine(address);
        print "    "; DebugGrammarLine(); new_line;
    }
    ParaContent();
];

[ DebugGrammarLine pcount;
    print " * ";
    for (: line_token-->pcount ~= ENDIT_TOKEN : pcount++) {
        if ((line_token-->pcount)->0 & $10) print "/ ";
        print (DebugToken) line_token-->pcount, " ";
    }
    print "-> ", (DebugAction) action_to_be;
    if (action_reversed) print " reverse";
];

[ DebugToken token;
    AnalyseToken(token);
    switch (found_ttype) {
      ILLEGAL_TT:
        print "<illegal token number ", token, ">";
      ELEMENTARY_TT:
        switch (found_tdata) {
          NOUN_TOKEN:           print "noun";
          HELD_TOKEN:           print "held";
          MULTI_TOKEN:          print "multi";
          MULTIHELD_TOKEN:      print "multiheld";
          MULTIEXCEPT_TOKEN:    print "multiexcept";
          MULTIINSIDE_TOKEN:    print "multiinside";
          CREATURE_TOKEN:       print "creature";
          SPECIAL_TOKEN:        print "special";
          NUMBER_TOKEN:         print "number";
          TOPIC_TOKEN:          print "topic";
          ENDIT_TOKEN:          print "END";
        }
      PREPOSITION_TT:
        print "'", (address) found_tdata, "'";
      ROUTINE_FILTER_TT:
        print "noun=Routine(", found_tdata, ")";
      ATTR_FILTER_TT:
        print (DebugAttribute) found_tdata;
      SCOPE_TT:
        print "scope=Routine(", found_tdata, ")";
      GPR_TT:
        print "Routine(", found_tdata, ")";
    }
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tests.i6t: Test Command
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#Iftrue (0 > 0);

[ TestScriptSub;
	switch(special_word) {

	default:
		print ">--> The following tests are available:^";

	}
];

#ifdef TARGET_GLULX;
Constant TEST_STACK_SIZE = 128;
#ifnot;
Constant TEST_STACK_SIZE = 48;
#endif;

Array test_stack --> TEST_STACK_SIZE;
Global test_sp = 0;
[ TestStart T R l k;
	if (test_sp >= TEST_STACK_SIZE) ">--> Testing too many levels deep";
	test_stack-->test_sp = T;
	test_stack-->(test_sp+1) = 0;
	test_stack-->(test_sp+3) = l;
	test_sp = test_sp + 4;
	if ((R-->0) && (R-->0 ~= real_location)) {
	     print "(first moving to ", (name) R-->0, ")^";
	     PlayerTo(R-->0, 1);
	}
	k=1;
	while (R-->k) {
	    if (R-->k notin player) {
	        print "(first acquiring ", (the) R-->k, ")^";
	        move R-->k to player;
	    }
	    k++;
	}
	print "(Testing.)^"; say__p = 1;
];
[ TestKeyboardPrimitive a_buffer a_table p i j l spaced ch;
	if (test_sp == 0) {
	    test_stack-->2 = 1;
	    return VM_ReadKeyboard(a_buffer, a_table);
	}
	else {
	    p = test_stack-->(test_sp-4);
	    i = test_stack-->(test_sp-3);
	    l = test_stack-->(test_sp-1);
	    print "[";
	    print test_stack-->2;
	    print "] ";
	    test_stack-->2 = test_stack-->2 + 1;
	    style bold;
	    while ((i < l) && (p->i ~= '/')) {
	    	ch = p->i;
	        if (spaced || (ch ~= ' ')) {
	        	if ((p->i == '[') && (p->(i+1) == '/') && (p->(i+2) == ']')) {
	        		ch = '/'; i = i+2;
	        	}
	            a_buffer->(j+WORDSIZE) = ch;
	            print (char) ch;
	            i++; j++;
	            spaced = true;
	        } else i++;
	    }
	    style roman;
	    print "^";
	    #ifdef TARGET_ZCODE;
	    a_buffer->1 = j;
	    #ifnot; ! TARGET_GLULX
	    a_buffer-->0 = j;
	    #endif;
	    VM_Tokenise(a_buffer, a_table);
	    if (p->i == '/') i++;
	    if (i >= l) {
	        test_sp = test_sp - 4;
	    } else test_stack-->(test_sp-3) = i;
	}
];

#IFNOT;

[ TestScriptSub;
	">--> No test scripts exist for this game.";
];

#ENDIF;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tests.i6t: Trace Command
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TraceOnSub; parser_trace=1; say__p = 1; "[Trace on.]"; ];

[ TraceLevelSub;
    parser_trace = parsed_number; say__p = 1;
    print "[Parser tracing set to level ", parser_trace, ".]^";
];

[ TraceOffSub; parser_trace=0; say__p = 1; "Trace off."; ];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tests.i6t: Tree Command
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ XTreeSub i;
    if (noun == 0) {
        objectloop (i)
            if (i ofclass Object && parent(i) == 0) XObj(i);
    }
    else XObj(noun,1);
];

[ XObj obj f;
    if (parent(obj) == 0) print (name) obj; else print (a) obj;
    print " (", obj, ") ";
    if (f == 1 && parent(obj) ~= 0)
        print "(in ", (name) parent(obj), " ", parent(obj), ")";
    new_line;
    if (child(obj) == 0) rtrue;
    if (obj == Class)
        WriteListFrom(child(obj), NEWLINE_BIT+INDENT_BIT+ALWAYS_BIT+NOARTICLE_BIT, 1);
    else
        WriteListFrom(child(obj), NEWLINE_BIT+INDENT_BIT+ALWAYS_BIT+FULLINV_BIT, 1);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tests.i6t: Grammar
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ testcommandnoun obj o2;
	switch (scope_stage) {
		1: rtrue; ! allow multiple objects
		2: objectloop (obj)
        	if ((obj ofclass Object) && (obj provides KD_Count))
            	PlaceInScope(obj, true);
        3: print "There seems to be no such object anywhere in the model world.^";
    }
];

Verb meta 'abstract'

    * scope=testcommandnoun 'to' scope=testcommandnoun -> XAbstract;
Verb meta 'actions'

    *                                           -> ActionsOn
    * 'on'                                      -> ActionsOn
    * 'off'                                     -> ActionsOff;
Verb meta 'gonear'

    * scope=testcommandnoun                     -> Gonear;
Verb meta 'purloin'

    * scope=testcommandnoun                     -> XPurloin;
Verb meta 'random'

    *                                           -> Predictable;
Verb meta 'relations'

	*                                           -> ShowRelations;
Verb meta 'responses'

	*                                           -> ShowResponses
	* special                                   -> ShowResponses
	* 'now' special                             -> ShowResponses
	* 'set' special                             -> ShowResponses;
Verb meta 'rules'

	*                                           -> RulesOn
	* 'all'                                     -> RulesAll
	* 'on'                                      -> RulesOn
	* 'off'                                     -> RulesOff;
Verb meta 'scenes'

	*                                           -> ScenesOn
	* 'on'                                      -> ScenesOn
	* 'off'                                     -> ScenesOff;
Verb meta 'scope'

    *                                           -> Scope
    * scope=testcommandnoun                     -> Scope;
Verb meta 'showheap'

	*                                           -> ShowHeap;
Verb meta 'showme'

	*                                           -> ShowMe
	* scope=testcommandnoun                     -> ShowMe;
Verb meta 'showverb'

    * special                                   -> Showverb;
Verb meta 'test'

	*                                           -> TestScript
	* special                                   -> TestScript;
Verb meta 'trace'

    *                                           -> TraceOn
    * number                                    -> TraceLevel
    * 'on'                                      -> TraceOn
    * 'off'                                     -> TraceOff;
Verb meta 'tree'

    *                                           -> XTree
    * scope=testcommandnoun                     -> XTree;

[ InternalTestCases ;
    ];

#ENDIF; ! DEBUG


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: I6 Inclusions
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

! "Include (- ... -)" inclusions with no specified position appear here.


	[ CheckDPMR result sinp1 sinp2 rv;
		sinp1 = inp1; sinp2 = inp2; inp1 = noun; inp2 = second;
		rv = FollowRulebook( 25 );
		inp1 = sinp1; inp2 = sinp2;
		if ((rv) && RulebookSucceeded()) {
			result = ResultOfRule();
			if (result == RBNO_6 ) return 4;
			if (result == RBNO_7 ) return 3;
			if (result == RBNO_8 ) return 2;
			if (result == RBNO_9 ) return 1;
			if (result == RBNO_10 ) return 0;
		}
		return 2;
	];

[ LITTLE_USED_DO_NOTHING_R; rfalse; ];


[ PlugPlural obj;
	SetPronoun('them', obj);
	SetPronoun('it', obj);
];



! Wait for a safe non navigating key. The user might press Down/PgDn or use the mouse scroll wheel to scroll a page of text, so we will stop those key codes from continuing.
[ KeyPause key; 
	while ( 1 )
	{
		key = VM_KeyChar();
		#Ifdef TARGET_ZCODE;
		if ( key == 63 or 129 or 130 or 132 )
		{
			continue;
		}
		#Ifnot; ! TARGET_GLULX
		if ( key == -4 or -5 or -10 or -11 or -12 or -13 )
		{
			continue;
		}
		#Endif; ! TARGET_
		rfalse;
	}
];

[ SPACEPause i;
	while (i ~= 13 or 31 or 32)
	{
		i = VM_KeyChar();	
	}
];

! No longer used but included just in case
[ GetKey;
	return VM_KeyChar(); 
];



[ CenterPrint str depth i j len;
	font off;
	i = VM_ScreenWidth();
	len = TEXT_TY_CharacterLength(str);
	if (len > 63) len = 63;
	j = (i-len)/2 - 1;
	VM_MoveCursorInStatusLine(depth, j);
	print (I7_string) str; 
	font on;
];

[ CenterPrintComplex str i j len;
	font off;
	print "^"; 
	i = VM_ScreenWidth();
	len = TEXT_TY_CharacterLength(str);
	if (len > 63) len = 63;
	j = (i-len)/2 - 1;
	spaces j;
	print (I7_string) str; 
	font on;
];



[ I7ScreenHeight i screen_height;
	i = 0->32;
	if (screen_height == 0 or 255) screen_height = 18;
	screen_height = screen_height - 7;
	return screen_height;
];

 

[ DeepStatus depth i screen_width;
    VM_StatusLineHeight(depth);
    screen_width = VM_ScreenWidth();
    #ifdef TARGET_GLULX;
        VM_ClearScreen(1);
    #ifnot;
        style reverse;
        for (i=1:i<depth+1:i++)
        {
             @set_cursor i 1;
             spaces(screen_width);
        } 
    #endif;
]; 

[ I7VM_MoveCursorInStatusLine depth;
	VM_MoveCursorInStatusLine(depth, 1);
];

[ RightAlign depth screen_width o n;
	screen_width = VM_ScreenWidth(); 
	n = (Global_Vars-->22);
	o = screen_width - n;
	VM_MoveCursorInStatusLine(depth, o);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Entries in constant lists
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====





! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: To Phrases
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


! Request 0: phrase nothing -> nothing
! to say walkingTheDog:
[ PHR_982_r0  ;
    ! [1: say ~Walking down the street, you take a second to look up and enjoy the beauty of the day. Lawns being mowed, pool parties in random back yards, a woman walking her dog. As you smile and^^wave, you notice a small black patch she is walking unknowingly towards, a Weird Logo blazened in the middle of it.^^'Watch outt!' You try to warn her, but you are too late. Stepping in the circle.... nothing happens. Well shit you're just a weirdo now. You shake your head and turn to go, moving on to others things.^^You pivot as soon as you hear the first bark, expecting the worst. Yep, the women has a reddish pink mist all around her, just standing there not moving.[pause_clear]~]
    say__p=1;ParaContent(); print "Walking down the street, you take a second to look up and enjoy the beauty of the day. Lawns being mowed, pool parties in random back yards, a woman walking her dog. As you smile and^^wave, you notice a small black patch she is walking unknowingly towards, a Weird Logo blazened in the middle of it.^^~Watch outt!~ You try to warn her, but you are too late. Stepping in the circle.... nothing happens. Well shit you're just a weirdo now. You shake your head and turn to go, moving on to others things.^^You pivot as soon as you hear the first bark, expecting the worst. Yep, the women has a reddish pink mist all around her, just standing there not moving."; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say394; .L_SayX394;
    ! [2: say ~SNAP, a loud sharp sound and the mist is gone, the woman looking around in wonderment. You gulp, knowing something's coming. In the matter of a second, tests start popping one by one out of her chest, straining her shirt.^^She pleads for help, the change happening too fast for her to recognize what's happening to her. A ragged cry of 'OH GOD MY PUSSSSY' whips out of her lengthening muzzle as a tail sprouts out her furry ass. Her dog, a big German shepherd, jumps her, eating out her morphing vagina, sometimes running his warm tongue up to her sensitive asshole.^^The woman, still confused, whimpers as she cums before she can even catch her breathe, the trembling of her human pussy squelching into the spasms of German shepherd bitch in heat.^^You, as with everyone else, just run. You take one look back to see the poor woman being raped by her dog, her tongue hanging out as he knots in her.~]
    say__p=1;ParaContent(); print "SNAP, a loud sharp sound and the mist is gone, the woman looking around in wonderment. You gulp, knowing something's coming. In the matter of a second, tests start popping one by one out of her chest, straining her shirt.^^She pleads for help, the change happening too fast for her to recognize what's happening to her. A ragged cry of ~OH GOD MY PUSSSSY~ whips out of her lengthening muzzle as a tail sprouts out her furry ass. Her dog, a big German shepherd, jumps her, eating out her morphing vagina, sometimes running his warm tongue up to her sensitive asshole.^^The woman, still confused, whimpers as she cums before she can even catch her breathe, the trembling of her human pussy squelching into the spasms of German shepherd bitch in heat.^^You, as with everyone else, just run. You take one look back to see the poor woman being raped by her dog, her tongue hanging out as he knots in her."; new_line; .L_Say395; .L_SayX395;
    rfalse;
];
! Request 1: phrase nothing -> nothing
! to say eggLayer:
[ PHR_981_r1  ;
    ! [1: say ~You search Birds of Paradise, looking for any sign of a Coven. As you go from booth to booth, a raised echoing voice surprises you, making you duck down. After a little you can tell its two different people, coming from the kitchen area, absorbed in their own conversation.^^Maybe you should you check it out?^^You sneak into the back, around the serving counter and peek your head in from the bar entrance. The whole kitchen looks like a post apocalyptic zone of destruction, with priceless pans from the expensive restaurant thrown all over.^^It looks like a man and a woman are the ones who were talking. Though not just that, you realize as the man falls to the ground cowering from the woman. And just the she speaks out in a high clear voice full of cruelty, 'Thought you would hide from me little birdie? I told you I was hungry and you run. Pathetic'.^^The man seems to be absolutely terrified of the woman, his voice trembling as he whimpers 'pleaase don't eat me..' Her heartless laugh rings out, surprising you with the spite in it. Damn this woman as evil as shit.[pause_clear]~]
    say__p=1;ParaContent(); print "You search Birds of Paradise, looking for any sign of a Coven. As you go from booth to booth, a raised echoing voice surprises you, making you duck down. After a little you can tell its two different people, coming from the kitchen area, absorbed in their own conversation.^^Maybe you should you check it out?^^You sneak into the back, around the serving counter and peek your head in from the bar entrance. The whole kitchen looks like a post apocalyptic zone of destruction, with priceless pans from the expensive restaurant thrown all over.^^It looks like a man and a woman are the ones who were talking. Though not just that, you realize as the man falls to the ground cowering from the woman. And just the she speaks out in a high clear voice full of cruelty, ~Thought you would hide from me little birdie? I told you I was hungry and you run. Pathetic~.^^The man seems to be absolutely terrified of the woman, his voice trembling as he whimpers ~pleaase don't eat me..~ Her heartless laugh rings out, surprising you with the spite in it. Damn this woman as evil as shit."; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say396; .L_SayX396;
    ! [2: say ~'Im not going to eat you, birdie.' Says the apparent witch to the cowering man, much to his relief. 'i want you to make my meal for me' she finishes, cackling at the look on his face as it changes from relief to realized horror.^^The blast of magic nearly knocks you from your hiding area, the force of it is incredible. Recovering, you peek back around to see the witch standing above.. A copy of herself? The witch copy on the ground screams and begins to cry as the standing woman cackles in delight. 'why did you do this?'^^The former man whimpers, begging for an answer to this madness. The spellcaster finished her maniacal laughter and simply replied 'youll know soon enough, birdie' before disappearing in a POOF, smoke whisping where she used to stand.^^The former man sat there sniffling and crying, her beautiful face covered with tears. She tried to stand up, using the nearby sink for support before stopping with her hand on her new thin stomach.^^'ooo' she moans in some obvious discomfort, 'owww what the fuck?!'[pause_clear]~]
    say__p=1;ParaContent(); print "~Im not going to eat you, birdie.~ Says the apparent witch to the cowering man, much to his relief. ~i want you to make my meal for me~ she finishes, cackling at the look on his face as it changes from relief to realized horror.^^The blast of magic nearly knocks you from your hiding area, the force of it is incredible. Recovering, you peek back around to see the witch standing above.. A copy of herself? The witch copy on the ground screams and begins to cry as the standing woman cackles in delight. ~why did you do this?~^^The former man whimpers, begging for an answer to this madness. The spellcaster finished her maniacal laughter and simply replied ~youll know soon enough, birdie~ before disappearing in a POOF, smoke whisping where she used to stand.^^The former man sat there sniffling and crying, her beautiful face covered with tears. She tried to stand up, using the nearby sink for support before stopping with her hand on her new thin stomach.^^~ooo~ she moans in some obvious discomfort, ~owww what the fuck?!~"; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say397; .L_SayX397;
    ! [3: say ~As you look on, not wanting to risk revealing yourself, she starts to stumble a bit, her expression showing that her thoughts were very much only on whatever she was feeling.^^You can hear her stomach rumbling from where you stand. 'Oh nooo' her beautiful lips trembling through the words as reaches a hand under her copied dress to her nether regions. She suddenly rips her panties down, and squats as best she can as if she can't hold it in anymore.^^Her almost sexually charged scream isn't as shocking to you as the egg that slowly emerges from under her dress, making wet squelching noises as she eases to the ground so it doesn't break when it falls out. 'OHHHHHHH' her second scream echoes through the empty restaurant again as she lays another egg, and then a third.^^After it all seems to be over, she turns to see her pile of smooth white eggs glistening where she laid them, bursting immediately into tears at the sight.^^'whhyyy is this *sob* hap haapp BUCCAWWWWW'. Her face freezes, completely stunned at the loud chicken noise she just made. BUCAW BUCCAWWWW, another two rip out of her as she falls face forward, her knees resting on the ground so that her ass is sticking straight up in the air.^^You can see the changed mans new wet pussy sitting under a cute little asshole as more sobbing clucks come from in front. You cover your mouth in horror as her vagina begins to widen, the crying woman's moans serving as a warning to what was about to happen.^^From the gaping hole something white begins to appear, stretching the pussy more and more as the egg emerges from the new womens love canal.[pause_clear]~]
    say__p=1;ParaContent(); print "As you look on, not wanting to risk revealing yourself, she starts to stumble a bit, her expression showing that her thoughts were very much only on whatever she was feeling.^^You can hear her stomach rumbling from where you stand. ~Oh nooo~ her beautiful lips trembling through the words as reaches a hand under her copied dress to her nether regions. She suddenly rips her panties down, and squats as best she can as if she can't hold it in anymore.^^Her almost sexually charged scream isn't as shocking to you as the egg that slowly emerges from under her dress, making wet squelching noises as she eases to the ground so it doesn't break when it falls out. ~OHHHHHHH~ her second scream echoes through the empty restaurant again as she lays another egg, and then a third.^^After it all seems to be over, she turns to see her pile of smooth white eggs glistening where she laid them, bursting immediately into tears at the sight.^^~whhyyy is this *sob* hap haapp BUCCAWWWWW~. Her face freezes, completely stunned at the loud chicken noise she just made. BUCAW BUCCAWWWW, another two rip out of her as she falls face forward, her knees resting on the ground so that her ass is sticking straight up in the air.^^You can see the changed mans new wet pussy sitting under a cute little asshole as more sobbing clucks come from in front. You cover your mouth in horror as her vagina begins to widen, the crying woman's moans serving as a warning to what was about to happen.^^From the gaping hole something white begins to appear, stretching the pussy more and more as the egg emerges from the new womens love canal."; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say398; .L_SayX398;
    ! [4: say ~'Pleaseee' she sobs pitifully 'i don't want to be a chickennn BUCAWWW'. You can see a hand emerge between her thighs, bending at the wrist to frantically rub her clit. Feathers sprout all over her as she rubs herself frustrated and beyond eager to ease her pleasure.^^Soon her fingers seem to become clumsier, turning into the ends of her flightless wings. 'BUCAWWW' her face turning, tears streaking down it, to see yet another leg splurt out of her birth canal. A beak slowly pushes itself out of her mouth, her eyes rolling in frantic motion, her mind slipping into complete simplicity. With one last BUCAWW, the chicken woman seized in an obvious orgasm, so lost in it she laid two eggs and chicken shit sprayed out of her no longer human asshole.^^The witch reappeared with another sudden POOOF, grabbed the eggs and smiled at the hen, still losing the last features of her humanity. With a wave of her wand, a brief bolt of magic and then another poof, the witch disappeared for good, and the hen squatted there, spraying endless eggs out of her pussy and asshole. Jeez, what a cruel torture.. You should be sure to stay clear of any witches. None of them seem sane.~]
    say__p=1;ParaContent(); print "~Pleaseee~ she sobs pitifully ~i don't want to be a chickennn BUCAWWW~. You can see a hand emerge between her thighs, bending at the wrist to frantically rub her clit. Feathers sprout all over her as she rubs herself frustrated and beyond eager to ease her pleasure.^^Soon her fingers seem to become clumsier, turning into the ends of her flightless wings. ~BUCAWWW~ her face turning, tears streaking down it, to see yet another leg splurt out of her birth canal. A beak slowly pushes itself out of her mouth, her eyes rolling in frantic motion, her mind slipping into complete simplicity. With one last BUCAWW, the chicken woman seized in an obvious orgasm, so lost in it she laid two eggs and chicken shit sprayed out of her no longer human asshole.^^The witch reappeared with another sudden POOOF, grabbed the eggs and smiled at the hen, still losing the last features of her humanity. With a wave of her wand, a brief bolt of magic and then another poof, the witch disappeared for good, and the hen squatted there, spraying endless eggs out of her pussy and asshole. Jeez, what a cruel torture.. You should be sure to stay clear of any witches. None of them seem sane."; new_line; .L_Say399; .L_SayX399;
    rfalse;
];
! Request 2: phrase nothing -> nothing
! to say becomeFemaleGoat:
[ PHR_1003_r2  ;
    ! [1: say ~Walking down the street, a store catches your eye. Ms Magnolias Body Enhancement Center.. Huh. You had been down this street recently and coulda sworn that the store hadnt been there. [pause_clear]Do you check it out?~]
    say__p=1;ParaContent(); print "Walking down the street, a store catches your eye. Ms Magnolias Body Enhancement Center.. Huh. You had been down this street recently and coulda sworn that the store hadnt been there. ";ParaContent(); (PHR_928_r9 ());ParaContent(); print "Do you check it out?"; new_line; .L_Say400; .L_SayX400;
    ! [2: if player consents begin]
    if ((YesOrNo())){
        ! [3: say ~Walking through the front door, you are surprised to see how busy this place is. All over are patients and nurses, talking about their options as far as breast or penis enhancement. A cheery squat middle aged woman comes running up to you as soon as you walk.^^'Howdy there! Looking to make some changes today? Its okay, there's nothing to be ashamed of!'~]
        say__p=1;ParaContent(); print "Walking through the front door, you are surprised to see how busy this place is. All over are patients and nurses, talking about their options as far as breast or penis enhancement. A cheery squat middle aged woman comes running up to you as soon as you walk.^^~Howdy there! Looking to make some changes today? Its okay, there's nothing to be ashamed of!~"; new_line; .L_Say401; .L_SayX401;
        ! [4: if player is female begin]
        if ((((Adj_81_t1_v10(player))))){
            ! [5: say ~You shrug, not really knowing what this place is. Looking around, you can see a line waiting to enter a door that's closed to the public. They seem excited and happy, chatting amongst themselves about whatever it was they were participating in.^^'I.. Umm I have no clue why Im here, I just wanted to check it out.' You say to the woman, shrugging again and turning to leave.^^The last thing you feel is the needle penetrating your skin, your world spinning into darkness.^^When you wake up, you can see you're in a rather plain room that's chocked full of others. In fact, you notice a lot of them as the ones who were waiting to enter that room. Your mind still a bit fuzzy, you stumble to your feet, trying to regain your composure.^^'Hey, you okay lady?'. A skinny Latina woman stands next to you, her beautiful face in a wide smile. 'My names Mary! What's yours?' She extends her arm to help you up. 'Damn, you fall asleep? We weren't waiting that long, haha!' You shake your head, 'No. No, this isn't right, I tried to leave and...' You trail off, trying to remember anything after that.^^Your thoughts are interrupted by a loud *CRSSSHH* as a intercom system turns on, a voice echoing through it, 'howdy folks! I know you've been waiting a while but its gonna be worth it. I know you guys are feelin a bit unhappy with the size of your.. *ahem* male parts, and females I know you're feelin the same about your.. Uhh.. Breasts. But that's why you're here, and that's why we made Ms Magnolias Fast Acting Treatment. To help you! So ready yourself, you're about to find the new you!' [pause_clear]~]
            say__p=1;ParaContent(); print "You shrug, not really knowing what this place is. Looking around, you can see a line waiting to enter a door that's closed to the public. They seem excited and happy, chatting amongst themselves about whatever it was they were participating in.^^~I.. Umm I have no clue why Im here, I just wanted to check it out.~ You say to the woman, shrugging again and turning to leave.^^The last thing you feel is the needle penetrating your skin, your world spinning into darkness.^^When you wake up, you can see you're in a rather plain room that's chocked full of others. In fact, you notice a lot of them as the ones who were waiting to enter that room. Your mind still a bit fuzzy, you stumble to your feet, trying to regain your composure.^^~Hey, you okay lady?~. A skinny Latina woman stands next to you, her beautiful face in a wide smile. ~My names Mary! What's yours?~ She extends her arm to help you up. ~Damn, you fall asleep? We weren't waiting that long, haha!~ You shake your head, ~No. No, this isn't right, I tried to leave and...~ You trail off, trying to remember anything after that.^^Your thoughts are interrupted by a loud *CRSSSHH* as a intercom system turns on, a voice echoing through it, ~howdy folks! I know you've been waiting a while but its gonna be worth it. I know you guys are feelin a bit unhappy with the size of your.. *ahem* male parts, and females I know you're feelin the same about your.. Uhh.. Breasts. But that's why you're here, and that's why we made Ms Magnolias Fast Acting Treatment. To help you! So ready yourself, you're about to find the new you!~ ";ParaContent(); (PHR_928_r9 ()); .L_Say402; .L_SayX402;
            ! [6: end if]
            }

        ! [7: say ~Before you can react, smoke starts billowing into the room, and the crowd cheers. The smoke quickly spreads through it, most people embracing it with open arms.^^When it encompasses you, it dawns on you that its not smoke, but the chemical that this store makes to help these people. Soon you can hardly see more then a foot in front of you, the last person you see being the pretty Latina woman, smiling and practically jumping with excitement.^^The smoke covers you, its presence seeming like a warm blanket enveloping you in contentness. God you feel so good about this choice! Your previous cup size, but as you sit there, you feel your breasts growing, pushing your bra to the limit and bringing a wide smile to your face.^^You brought your hands up to grab your boobs, and jiggled them with excitement! Wooo you are going to be swarming with guys now.^^Mmmm and thinking of guys you felt goo,that little arch in your back coming to life as you thought very naughty thoughts. Man this stuff does feel good,its got you all hot.. And 'mmmmm' you say, just now noticing you had moved your hand down to rub that spot of your jeans that served guard over your pussy.[pause_clear]You could practically smell your lust is was so strong, desperately rubbing your little clit and feeling the resulting shockwaves shoot through you. 'Oh ohhhh OH!' your moans elevating themselves to screams of pleasure as you cum harder then you ever have before, rolling around on your back in ecstacy.^^You cant believe it.. But you're still horny, even more so then before, starting your frustrated rubbing yet again, and pulling your other hand up to your enormous busom to see if that will help. You notice your nipples are incredibly sensitive and much longer now too.. Weird.^^You try to be careful with them in the hopes of not pushing your sensitive nipples too far.. But that's not helping. In fact, the harder your pinch the better they feel, so you just clamp down on one.^^And a massive squirt of white liquid flies out, making your jaw drop. You stop completely, other then the hand that's fingering yourself, to stare at the milk you've just coaxed out.then the hand that's fingering yourself, to stare at the milk you've just coaxed out. 'Oh my god...' You whimper, not knowing what to think. Your large breasts start getting sore, the feeling of them generating milk something you've never experienced before.^^The soreness is too much, you have to milk yourself. Latching a hand on one again, your other hand still tirelessly rubbing your pussy, you begin to ease your hand softly and slowly massaging your breast, finally pinching the nipple slightly. *SQUIRRRR* A massive amount of milk flies out of your breast, landing on the floor in front of you. It relieved some soreness and felt really good combined with you going to town on your clit.[pause_clear] ~]
        say__p=1;ParaContent(); print "Before you can react, smoke starts billowing into the room, and the crowd cheers. The smoke quickly spreads through it, most people embracing it with open arms.^^When it encompasses you, it dawns on you that its not smoke, but the chemical that this store makes to help these people. Soon you can hardly see more then a foot in front of you, the last person you see being the pretty Latina woman, smiling and practically jumping with excitement.^^The smoke covers you, its presence seeming like a warm blanket enveloping you in contentness. God you feel so good about this choice! Your previous cup size, but as you sit there, you feel your breasts growing, pushing your bra to the limit and bringing a wide smile to your face.^^You brought your hands up to grab your boobs, and jiggled them with excitement! Wooo you are going to be swarming with guys now.^^Mmmm and thinking of guys you felt goo,that little arch in your back coming to life as you thought very naughty thoughts. Man this stuff does feel good,its got you all hot.. And ~mmmmm~ you say, just now noticing you had moved your hand down to rub that spot of your jeans that served guard over your pussy."; new_line;ParaContent(); (PHR_928_r9 ());ParaContent(); print "You could practically smell your lust is was so strong, desperately rubbing your little clit and feeling the resulting shockwaves shoot through you. ~Oh ohhhh OH!~ your moans elevating themselves to screams of pleasure as you cum harder then you ever have before, rolling around on your back in ecstacy.^^You cant believe it.. But you're still horny, even more so then before, starting your frustrated rubbing yet again, and pulling your other hand up to your enormous busom to see if that will help. You notice your nipples are incredibly sensitive and much longer now too.. Weird.^^You try to be careful with them in the hopes of not pushing your sensitive nipples too far.. But that's not helping. In fact, the harder your pinch the better they feel, so you just clamp down on one.^^And a massive squirt of white liquid flies out, making your jaw drop. You stop completely, other then the hand that's fingering yourself, to stare at the milk you've just coaxed out.then the hand that's fingering yourself, to stare at the milk you've just coaxed out. ~Oh my god...~ You whimper, not knowing what to think. Your large breasts start getting sore, the feeling of them generating milk something you've never experienced before.^^The soreness is too much, you have to milk yourself. Latching a hand on one again, your other hand still tirelessly rubbing your pussy, you begin to ease your hand softly and slowly massaging your breast, finally pinching the nipple slightly. *SQUIRRRR* A massive amount of milk flies out of your breast, landing on the floor in front of you. It relieved some soreness and felt really good combined with you going to town on your clit."; new_line;ParaContent(); (PHR_928_r9 ());ParaContent(); print " "; .L_Say403; .L_SayX403;
        ! [8: say ~So you continued, using pleasure to try to relieve the pressure. Wait. You stopped, a figure in the smoke right in front of you. It was on all fours, and it looked like it was sniffing the ground where your milk first landed. As you squinted your eyes, enough smoke cleared to make out the figure. It was Mary, her soft Latina skin coming into view as she sits there on all fours.. Lapping up your milk. Noticing you as well, she turns to you, a look of desperation on her face. 'Whats.. What's happening to me?!'.^^'I... don't know, I don't know what is happening to any of us.' you stumble in response, the feeling of pleasure still shooting through your body from your clit stimulation.  You notice Mary is staring right at your hand in your pants as you do it, a weird look on her face.^^'Crap, I'm sorry, I don't know what I was doing,' you stammered, blushing deeply, but unable to take your hand away.  Mary walked over and ripped your hand out of your pants, causing you to jump, little squirts of milk shooting from your breasts. But what she did next caught you even more off guard.^^She unbuttoned the top of your jean shorts, pulled the zipper down and shoved her face down there, the feeling of a warm wet tongue exploring your pussy lips causing you to gasp with pleasure. 'WHOA WAIIII WHOOOOOAAA' you moan, needing to be penetrated, and desperately rubbing your massive mammary glands.~]
        say__p=1;ParaContent(); print "So you continued, using pleasure to try to relieve the pressure. Wait. You stopped, a figure in the smoke right in front of you. It was on all fours, and it looked like it was sniffing the ground where your milk first landed. As you squinted your eyes, enough smoke cleared to make out the figure. It was Mary, her soft Latina skin coming into view as she sits there on all fours.. Lapping up your milk. Noticing you as well, she turns to you, a look of desperation on her face. ~Whats.. What's happening to me?!~.^^~I... don't know, I don't know what is happening to any of us.~ you stumble in response, the feeling of pleasure still shooting through your body from your clit stimulation.  You notice Mary is staring right at your hand in your pants as you do it, a weird look on her face.^^~Crap, I'm sorry, I don't know what I was doing,~ you stammered, blushing deeply, but unable to take your hand away.  Mary walked over and ripped your hand out of your pants, causing you to jump, little squirts of milk shooting from your breasts. But what she did next caught you even more off guard.^^She unbuttoned the top of your jean shorts, pulled the zipper down and shoved her face down there, the feeling of a warm wet tongue exploring your pussy lips causing you to gasp with pleasure. ~WHOA WAIIII WHOOOOOAAA~ you moan, needing to be penetrated, and desperately rubbing your massive mammary glands."; new_line; .L_Say404; .L_SayX404;
        ! [9: otherwise]
        } else {

        ! [10: say ~You shrug, figuring this town is always changing anyway.~]
        say__p=1;ParaContent(); print "You shrug, figuring this town is always changing anyway."; new_line; .L_Say405; .L_SayX405;
        ! [11: end if]
        }

        rfalse;
];
! Request 3: phrase nothing -> nothing
! to say Captured:
[ PHR_977_r3  ;
    ! [1: say ~One turns to see you, shit!^^'HEY STOP THERE!' Plants shoot out of the ground, holding your feet to the ground.  Suddenly the crowd starts thinning in front of you, disappearing into nonexistence until just one remains.^^Well one, and what the illusions were looking at.. A poor woman.  The short haired girl has dyed hair, the color of blue, and is crying with all four of her limbs held to the ground with vines as well. The robed figure pulls back her hood to reveal... some sort of deer woman?^^What the hell is this?[pause_clear]~]
    say__p=1;ParaContent(); print "One turns to see you, shit!^^~HEY STOP THERE!~ Plants shoot out of the ground, holding your feet to the ground.  Suddenly the crowd starts thinning in front of you, disappearing into nonexistence until just one remains.^^Well one, and what the illusions were looking at.. A poor woman.  The short haired girl has dyed hair, the color of blue, and is crying with all four of her limbs held to the ground with vines as well. The robed figure pulls back her hood to reveal... some sort of deer woman?^^What the hell is this?"; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say406; .L_SayX406;
    ! [2: say ~The deer woman opens her muzzle and starts her speech, 'This young woman thought she could hit one of my friends that was crossing the road and keep driving.^^'Jennifer' here thinks she is above us.  But she's going to be the perfect replacement, and very much one of us.  And I think you'll enjoy joining her.. she'll need a mate to give her a fawn to raise.^^With this statement the girl lets out a loud sob, struggling to escape the vines with no hope. 'Please I'll do anything I don't want to be an animal' she begs the witch, who just ignores her. [pause_clear]~]
    say__p=1;ParaContent(); print "The deer woman opens her muzzle and starts her speech, ~This young woman thought she could hit one of my friends that was crossing the road and keep driving.^^~Jennifer~ here thinks she is above us.  But she's going to be the perfect replacement, and very much one of us.  And I think you'll enjoy joining her.. she'll need a mate to give her a fawn to raise.^^With this statement the girl lets out a loud sob, struggling to escape the vines with no hope. ~Please I'll do anything I don't want to be an animal~ she begs the witch, who just ignores her. ";ParaContent(); (PHR_928_r9 ()); .L_Say407; .L_SayX407;
    ! [3: say ~Suddenly the vines extend, grabbing onto your arms and guiding you through the air til you are on all fours behind the poor girl.  Shes trying to crane her head to see what is happening, but a vine sprouts out from underneath her and turns her head forward. Oh crap... this isn't good.~]
    say__p=1;ParaContent(); print "Suddenly the vines extend, grabbing onto your arms and guiding you through the air til you are on all fours behind the poor girl.  Shes trying to crane her head to see what is happening, but a vine sprouts out from underneath her and turns her head forward. Oh crap... this isn't good."; new_line; .L_Say408; .L_SayX408;
    ! [4: say ~The sound of a car outside passing comes as a unexpected savior.  The witch freezes in the light beams as it drives past.  This is your chance to escape, or try to just 'ride' this out.  Do you want to escape?~]
    say__p=1;ParaContent(); print "The sound of a car outside passing comes as a unexpected savior.  The witch freezes in the light beams as it drives past.  This is your chance to escape, or try to just ~ride~ this out.  Do you want to escape?"; new_line; .L_Say409; .L_SayX409;
    ! [5: if player consents begin]
    if ((YesOrNo())){
        ! [6: say becomedoe]
        say__p=1;ParaContent(); (PHR_984_r126 ()); .L_Say410; .L_SayX410;
        ! [7: otherwise]
        } else {

        ! [8: say becomestag]
        say__p=1;ParaContent(); (PHR_983_r125 ()); .L_Say411; .L_SayX411;
        ! [9: end if]
        }

        rfalse;
];
! Request 4: phrase nothing -> nothing
! to say courtneysRevenge:
[ PHR_979_r4  ;
    ! [1: say ~[pause_clear]Courtney is sitting at the bar.  Courtney.  Goddamnit, you had forgotten that another friend of yours had told you one of your ex's bought this place. Which was surprisingly empty, enough that Courtney of course turns and looks at you when you walk in.~]
    say__p=1;ParaContent(); (PHR_928_r9 ());ParaContent(); print "Courtney is sitting at the bar.  Courtney.  Goddamnit, you had forgotten that another friend of yours had told you one of your ex's bought this place. Which was surprisingly empty, enough that Courtney of course turns and looks at you when you walk in."; new_line; .L_Say412; .L_SayX412;
    ! [2: say ~Courtney smirks 'I sent all the others that came to my corral, but I guess the herd was missing one.' before just turning and pulling down her jean shorts.~]
    say__p=1;ParaContent(); print "Courtney smirks ~I sent all the others that came to my corral, but I guess the herd was missing one.~ before just turning and pulling down her jean shorts."; new_line; .L_Say413; .L_SayX413;
    ! [3: say becomebreedingstallion]
    say__p=1;ParaContent(); (PHR_1007_r134 ()); .L_Say414; .L_SayX414;
    rfalse;
];
! Request 5: phrase nothing -> nothing
! to say becomeBull:
[ PHR_985_r5  I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_6();
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_6 ;
    ! [1: say ~The mistress frowned, her face showing you that you had picked correctly. 'Interesting human.. that was a wise choice, and for that you shall be rewarded greatly.'  She yanked on another lasso, its existence only becoming apparent to you now.^^Tied to the end was the still changing underwitch, her beautiful face featuring a darkening nose, two large cow ears sticking out of her head and a massive utter swinging below her massive tits.  'This cow will serve as the milking device, your cum flooding her pussy and making her your pregnant mate.'[paragraph break]'Wait what?!' was all you could say before you felt a stirring in the back of your pants.  You could feel something grow out of your spine, almost as if it was growing longer.  The tingling of a new tail terrified and excited you.  'Helppp moooo!' the underwitch uttered, a glance at her showing a tail of her own, and a twisting changing pussy underneath. [pause_clear]^^You could see her face grow red with humiliation as it moved closer to her cute little butthole, which was growing larger and more cowlike by the moment.  Her pussy was massive, and it seemed to be calling you, enticing you to come take it.  The lasso fell from you as you felt your pants break open, a massive erection, one that was much larger then you had ever had before, poured forth.^^The underwitches jaw dropped, her terrified eyes unable to break away from your dick as it change, growing thicker, longer and more bull like at considerable speed.[pause_clear]~]
    say__p=1;ParaContent(); print "The mistress frowned, her face showing you that you had picked correctly. ~Interesting human.. that was a wise choice, and for that you shall be rewarded greatly.~  She yanked on another lasso, its existence only becoming apparent to you now.^^Tied to the end was the still changing underwitch, her beautiful face featuring a darkening nose, two large cow ears sticking out of her head and a massive utter swinging below her massive tits.  ~This cow will serve as the milking device, your cum flooding her pussy and making her your pregnant mate.~";ParaContent(); DivideParagraphPoint(); new_line;ParaContent(); print "~Wait what?!~ was all you could say before you felt a stirring in the back of your pants.  You could feel something grow out of your spine, almost as if it was growing longer.  The tingling of a new tail terrified and excited you.  ~Helppp moooo!~ the underwitch uttered, a glance at her showing a tail of her own, and a twisting changing pussy underneath. ";ParaContent(); (PHR_928_r9 ());ParaContent(); print "^^You could see her face grow red with humiliation as it moved closer to her cute little butthole, which was growing larger and more cowlike by the moment.  Her pussy was massive, and it seemed to be calling you, enticing you to come take it.  The lasso fell from you as you felt your pants break open, a massive erection, one that was much larger then you had ever had before, poured forth.^^The underwitches jaw dropped, her terrified eyes unable to break away from your dick as it change, growing thicker, longer and more bull like at considerable speed."; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say415; .L_SayX415;
    ! [2: say ~'No.. you can't, we don't want this!' The underwitch seemed to regain some of her human ability to speak as she begged you to back off.  But the her smell was too much.  You felt your balls drop from your now ripping underwear and pants, you shirt exploding off your chest as you began to lose your ability to organize any complex thought.^^All you could think about, as you fell to all fours, was the feeling of thrusting into a submissive mate and claiming a health dairy cow as your own.^^The mistress had left her lasso still restraining her, making it easy for you to shove her down, and climb on top of her, lining up the monstrosity that was your new dick.. a bulls dick.. to penetrate her. The underwitch twist your head to catch your eyes one last time, her face showing that she was fighting between keep her humanity and the allure of being mated with.  [pause_clear]^^'Moooeerrrrrr' came out your bellowing cry of conquest as you shoved into her slick pussy. You thrust and thrust and with each one felt the gasping girl under you grow larger and more cow-like.  Her soft cries soon her only quiet lows, your snorts drowning them out.^^She began to twist under you and make confused moo's as your massive balls slapped against her utter with your force, her cries growing in deep crescendo until... Until you could feel her cow pussy clench around your cock, her obvious orgasm making her moo in humiliation and shiver under you in pleasure.^^With that sign, you released inside her, your final pumps forceful and determined.  The feeling of your bull cum splattering out of your massive dick and deep inside her, both of your minds finally slipping away into mindless bliss, was glorious. .~]
    say__p=1;ParaContent(); print "~No.. you can't, we don't want this!~ The underwitch seemed to regain some of her human ability to speak as she begged you to back off.  But the her smell was too much.  You felt your balls drop from your now ripping underwear and pants, you shirt exploding off your chest as you began to lose your ability to organize any complex thought.^^All you could think about, as you fell to all fours, was the feeling of thrusting into a submissive mate and claiming a health dairy cow as your own.^^The mistress had left her lasso still restraining her, making it easy for you to shove her down, and climb on top of her, lining up the monstrosity that was your new dick.. a bulls dick.. to penetrate her. The underwitch twist your head to catch your eyes one last time, her face showing that she was fighting between keep her humanity and the allure of being mated with.  ";ParaContent(); (PHR_928_r9 ());ParaContent(); print "^^~Moooeerrrrrr~ came out your bellowing cry of conquest as you shoved into her slick pussy. You thrust and thrust and with each one felt the gasping girl under you grow larger and more cow-like.  Her soft cries soon her only quiet lows, your snorts drowning them out.^^She began to twist under you and make confused moo's as your massive balls slapped against her utter with your force, her cries growing in deep crescendo until... Until you could feel her cow pussy clench around your cock, her obvious orgasm making her moo in humiliation and shiver under you in pleasure.^^With that sign, you released inside her, your final pumps forceful and determined.  The feeling of your bull cum splattering out of your massive dick and deep inside her, both of your minds finally slipping away into mindless bliss, was glorious. ."; new_line; .L_Say416; .L_SayX416;
    ! [3: end the story saying ~[bold type]Game Over.  [italic type]'Mess With the Bull And You'll Get The Horns'  [roman type]Male Human to Bull.~]
    deadflag=(TEXT_TY_ExpandIfPerishable(I7SFRAME,TX_S_477)); story_complete=false;
    rfalse;
];
! Request 6: phrase nothing -> nothing
! to say storageRoomChance:
[ PHR_968_r6  ;
    ! [1: say ~Do you want to try your chances and just run in?~]
    say__p=1;ParaContent(); print "Do you want to try your chances and just run in?"; new_line; .L_Say417; .L_SayX417;
    ! [2: if the player consents begin]
    if ((YesOrNo())){
        ! [3: say ~You're smarter then these witches think.  You know that something fishy is going on in this back room and you won't take it anymore.  'I WONT TAKE THIS ANYMORE!!' you yell as you kick in the door.~]
        say__p=1;ParaContent(); print "You're smarter then these witches think.  You know that something fishy is going on in this back room and you won't take it anymore.  ~I WONT TAKE THIS ANYMORE!!~ you yell as you kick in the door."; new_line; .L_Say418; .L_SayX418;
        ! [4: say preswineoption]
        say__p=1;ParaContent(); (PHR_1008_r135 ()); .L_Say419; .L_SayX419;
        ! [5: otherwise]
        } else {

        ! [6: say ~Trixie grabs you by the ear and throws you out back.~]
        say__p=1;ParaContent(); print "Trixie grabs you by the ear and throws you out back."; new_line; .L_Say420; .L_SayX420;
        ! [7: move player to back entrance]
        MoveObject(player, I319_back_entrance, 0, false);
        ! [8: end if]
        }

        rfalse;
];
! From "Plurality" by Emily Short
! Request 7: phrase thing -> nothing
! To mark ( target - a thing ) in output:
[ PHR_847_r7  
    t_0 ! Call parameter 'target': thing
    ;
    ! [1: if the target acts plural or target is the player , mark-future-plural]
    if ((((PHR_850_r77 (t_0)))) || (((t_0 == player)))) { say__n = 1; }
    ! [2: otherwise mark-future-singular]
    else { say__n = 29; }
    ! [3: now the prior named noun is the target]
    (Global_Vars-->15) = t_0;
    rfalse;
];
! From "Basic Screen Effects" by Emily Short
! Request 8: phrase table name -> nothing
! To fill the/-- status bar/line with ( selected table - a table-name ):
[ PHR_921_r8  
    t_0 ! Call parameter 'selected table': table name
I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_7(t_0);
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_7 
    t_0 ! Call parameter 'selected table': table name
    tmp_0 ! Let/loop value, e.g., '__n': number
    tmp_1 ! Let/loop value, e.g., '__index': number
    tmp_2 ! Let/loop value, e.g., '?-1,-1?'(deallocated by end of phrase)
    tmp_3 ! Let/loop value, e.g., '?-1,-1?'(deallocated by end of phrase)
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    ! [1: let __n be the number of rows in the selected table]

    		tmp_0 = TableRows(t_0);
    ! [2: deepen status line to __n rows]
    DeepStatus(tmp_0);
    ! [3: let __index be 1]

    		tmp_1 = 1;
    ! [4: repeat through selected table begin]
    @push ct_0; @push ct_1;
    		for (tmp_2=t_0, tmp_3=1, ct_0=tmp_2, ct_1=tmp_3:
    			tmp_3<=TableRows(tmp_2):
    			tmp_3++, ct_0=tmp_2, ct_1=tmp_3)
    			if (TableRowIsBlank(ct_0, ct_1)==false){
        ! [5: move cursor to __index]
        I7VM_MoveCursorInStatusLine(tmp_1);
        ! [6: if there is left entry begin]
        if (((ExistsTableLookUpEntry(ct_0,113,ct_1)))){
            ! [7: say ~[left entry]~]
            say__p=1;ParaContent(); print (TEXT_TY_Say) TableLookUpEntry(ct_0,113,ct_1); .L_Say421; .L_SayX421;
            ! [8: end if]
            }

        ! [9: if there is central entry begin]
        if (((ExistsTableLookUpEntry(ct_0,114,ct_1)))){
            ! [10: center central entry at row __index]
            CenterPrint(BlkValueCopy(I7SFRAME, TableLookUpEntry(ct_0,114,ct_1)), tmp_1);
            ! [11: end if]
            }

        ! [12: if there is right entry begin]
        if (((ExistsTableLookUpEntry(ct_0,115,ct_1)))){
            ! [13: right align cursor to __index]
            RightAlign(tmp_1);
            ! [14: say ~[right entry]~]
            say__p=1;ParaContent(); print (TEXT_TY_Say) TableLookUpEntry(ct_0,115,ct_1); .L_Say422; .L_SayX422;
            ! [15: end if]
            }

        ! [16: increase __index by 1]
        tmp_1 = tmp_1 + 1;;
        ! [17: end repeat]
        }
        @pull ct_1; @pull ct_0;
        rfalse;
];
! From "Useful Functions" by ShadowChaser
! Request 9: phrase nothing -> nothing
! To say pause_clear:
[ PHR_928_r9  ;
    ! [1: pause_clear]
    (PHR_926_r117 ());
    rfalse;
];
! From the Standard Rules
! Request 10: phrase (object, number) -> nothing
! To set the/-- locale priority of ( O - an object ) to ( N - a number ):
[ PHR_81_r10  
    t_0 ! Call parameter 'O': object
    t_1 ! Call parameter 'N': number
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    ! [1: if o is a thing begin]
    if (((t_0 ofclass K2_thing))){
        ! [2: if n <= 0 , now o is mentioned]
        if (((t_1 <= 0))) { (Adj_69_t2_v10(t_0)); }
        ! [3: if there is a notable-object of o in the table of locale priorities begin]
        if (((ExistsTableLookUpCorr(T1_locale_priorities,105,105,t_0)))){
            ! [4: choose row with a notable-object of o in the table of locale priorities]
            ct_0 = T1_locale_priorities; ct_1 = TableRowCorr(ct_0, 105, t_0);
            ! [5: if n <= 0 , blank out the whole row]
            if (((t_1 <= 0))) { TableBlankOutRow(ct_0, ct_1); }
            ! [6: otherwise now the locale description priority entry is n]
            else { TableLookUpEntry(ct_0,106,ct_1,1,t_1); }
            ! [7: otherwise]
            } else {

            ! [8: if n is greater than 0 begin]
            if (((t_1 > 0))){
                ! [9: choose a blank row in the table of locale priorities]
                ct_0 = T1_locale_priorities; ct_1 = TableBlankRow(ct_0);
                ! [10: now the notable-object entry is o]
                TableLookUpEntry(ct_0,105,ct_1,1,t_0);
                ! [11: now the locale description priority entry is n]
                TableLookUpEntry(ct_0,106,ct_1,1,t_1);
                ! [12: end if]
                }

            ! [13: end if]
            }

        ! [14: end if]
        }

        rfalse;
];
! From the Standard Rules
! Request 11: phrase object -> nothing
! To describe locale for ( O - object ):
[ PHR_80_r11  
    t_0 ! Call parameter 'O': object
    ;
    ! [1: carry out the printing the locale description activity with o]
    CarryOutActivity(V30_printing_the_locale_desc, t_0);
    rfalse;
];
! From "Menus" by Emily Short
! Request 12: phrase nothing -> nothing
! To show menu contents:
[ PHR_898_r12  I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_8();
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_8 
    tmp_0 ! Let/loop value, e.g., 'temporary depth': number
    tmp_1 ! Let/loop value, e.g., 'temporary menu': table name
    tmp_2 ! Let/loop value, e.g., 'temporary title': text
    tmp_3 ! Let/loop value, e.g., '__x': number
    tmp_4 ! Let/loop value, e.g., '__index': number
    tmp_5 ! Let/loop value, e.g., '?-1,-1?'(deallocated by end of phrase)
    tmp_6 ! Let/loop value, e.g., '?-1,-1?'(deallocated by end of phrase)
    tmp_7 ! Let/loop value, e.g., '?-1,-1?'(deallocated by end of phrase)
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    ! [1: increase the menu depth by 1]
    (Global_Vars-->16) = (Global_Vars-->16) + 1;;
    ! [2: let temporary depth be the menu depth]

    		tmp_0 = (Global_Vars-->16);
    ! [3: let temporary menu be the current menu]

    		tmp_1 = (Global_Vars-->19);
    ! [4: let temporary title be the current menu title]
    tmp_2 = I7SFRAME; 
    		BlkValueCopy(tmp_2, (Global_Vars-->18));
    ! [5: let __x be 0]

    		tmp_3 = 0;
    ! [6: let __index be 0]

    		tmp_4 = 0;
    ! [7: while __index is not 1 begin]
    while (((~~((tmp_4 == 1))))){
        ! [8: now the current menu is the temporary menu]
        (Global_Vars-->19) = tmp_1;
        ! [9: let __n be 0]

        		tmp_5 = 0;
        ! [10: repeat through current menu begin]
        @push ct_0; @push ct_1;
        		for (tmp_6=(Global_Vars-->19), tmp_7=1, ct_0=tmp_6, ct_1=tmp_7:
        			tmp_7<=TableRows(tmp_6):
        			tmp_7++, ct_0=tmp_6, ct_1=tmp_7)
        			if (TableRowIsBlank(ct_0, ct_1)==false){
            ! [11: increase __n by 1]
            tmp_5 = tmp_5 + 1;;
            ! [12: if title entry is current menu title , now current menu selection is __n]
            if ((( BlkValueCompare(TableLookUpEntry(ct_0,107,ct_1), (Global_Vars-->18)) == 0))) { (Global_Vars-->20) = tmp_5; }
            ! [13: end repeat]
            }
            @pull ct_1; @pull ct_0;
        ! [14: now the current menu title is the temporary title]
        BlkValueCopy((Global_Vars-->18), tmp_2);
        ! [15: reprint current menu]
        (PHR_897_r29 ((Global_Vars-->19)));
        ! [16: let __x be the chosen letter]
        tmp_3 = VM_KeyChar();
        ! [17: if __x is a number listed in the table of menu commands begin]
        if (((true) && ((ct_1=ExistsTableRowCorr(ct_0=T3_menu_commands,111,tmp_3))))){
            ! [18: follow the effect entry]
            FollowRulebook(TableLookUpEntry(ct_0,112,ct_1));
            ! [19: if temporary depth > menu depth begin]
            if (((tmp_0 > (Global_Vars-->16)))){
                ! [20: now __index is 1]
                tmp_4 = 1;
                ! [21: end if]
                }

            ! [22: end if]
            }

        ! [23: end while]
        }

        rfalse;
];
! Request 13: phrase nothing -> nothing
! to say witchConversation:
[ PHR_946_r13  ;
    ! [1: say ~[paragraph break]^^[bold type]**BAM**[roman type]^^Before your brain can even process what is happening, a massive explosion of magic happens right in front of you, knocking you to your back with the force.^^'INTRUDER, LAY DOWN MY ARTIFACT' the sound, decibels above what any normal human could project, nearly blows your damn ears out.  Figuring she must mean the Wand, you throw it to the ground, raising your hands up after as if you were surrendering.[pause_clear]^^'INTRUDER, LAY IT DOWN OR FACE MY WRATH' You have no idea how to react, so you do what you've always done best and curl into the fetal position.  The massive sound ceases, and the smoke clears, whisking off to nothingness. [pause_clear]~]
    say__p=1;ParaContent(); DivideParagraphPoint(); new_line;ParaContent(); print "^^";ParaContent(); style bold;ParaContent(); print "**BAM**";ParaContent(); style roman;ParaContent(); print "^^Before your brain can even process what is happening, a massive explosion of magic happens right in front of you, knocking you to your back with the force.^^~INTRUDER, LAY DOWN MY ARTIFACT~ the sound, decibels above what any normal human could project, nearly blows your damn ears out.  Figuring she must mean the Wand, you throw it to the ground, raising your hands up after as if you were surrendering."; new_line;ParaContent(); (PHR_928_r9 ());ParaContent(); print "^^~INTRUDER, LAY IT DOWN OR FACE MY WRATH~ You have no idea how to react, so you do what you've always done best and curl into the fetal position.  The massive sound ceases, and the smoke clears, whisking off to nothingness. ";ParaContent(); (PHR_928_r9 ()); .L_Say423; .L_SayX423;
    ! [2: say ~Still shivering, you peek your eyes out from around your arm.  A woman stands there, clad in dark robes, her features beyond beautiful.^^'What is your name, mortal?' the question flows of her lips like notes rippling on a harp. You stutter your name in response, hardly knowing what the hell is happening.^^'You have my artifact, young one' she says. 'I am the protector of this magical realm, the Mistress of the Dog.  I am one of several who rule this magical realm, among my fellow justicars The Mistress of the Elephant, the Bull, and the Zebra. I have come to despise my sisters though, as being their protector I am always watching over them.. and in the time I have guarded them they have grown restless and violent.^^Today is the End Day, the day in which their hate for mankind is spilling over.  You do not know this but you are that which is Chosen, one who carries the Artifact.'^^**CRACK**^^With a snap of her fingers, a box appears in your hands.  'Wha... what is this?' you ask in wonderment.[pause_clear]~]
    say__p=1;ParaContent(); print "Still shivering, you peek your eyes out from around your arm.  A woman stands there, clad in dark robes, her features beyond beautiful.^^~What is your name, mortal?~ the question flows of her lips like notes rippling on a harp. You stutter your name in response, hardly knowing what the hell is happening.^^~You have my artifact, young one~ she says. ~I am the protector of this magical realm, the Mistress of the Dog.  I am one of several who rule this magical realm, among my fellow justicars The Mistress of the Elephant, the Bull, and the Zebra. I have come to despise my sisters though, as being their protector I am always watching over them.. and in the time I have guarded them they have grown restless and violent.^^Today is the End Day, the day in which their hate for mankind is spilling over.  You do not know this but you are that which is Chosen, one who carries the Artifact.~^^**CRACK**^^With a snap of her fingers, a box appears in your hands.  ~Wha... what is this?~ you ask in wonderment."; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say424; .L_SayX424;
    ! [3: say ~With a kind smile, she answers 'This is the Artifact, child.  It is your kinds only hope in saving your physical world from my sisters and their minions.  You must collect the wands of their covens, place them in the Artifact and then find the ancient device that will remove our world from yours.^^'Where is it?!' you cry, beginning to get distressed about her extremely high expectations of you.^^Shaking her head she responds 'I do not know, none who hold a wand of power can know that'.  Well. This is sounding kinda difficult.[pause_clear]^^'OO! That reminds me!' she says, snapping her fingers again.  The wand you had previously thrown on the ground rises, slowly moving through the air towards you before coming to a stop and hovering a foot from your box.^^'Take my wand, The Wand of The Dog, and place it in the box, sealing my magic.  Hurry now! There is not much time! You must find the other three and then dispose of them!' you nod, terrified at the prospect, but still snatch the wand out of the air and throw it in your box.^^Looking up, the beautiful witch is smiling at you and fading away into nothingness...^^Well, fuck guess you gotta save the world.~]
    say__p=1;ParaContent(); print "With a kind smile, she answers ~This is the Artifact, child.  It is your kinds only hope in saving your physical world from my sisters and their minions.  You must collect the wands of their covens, place them in the Artifact and then find the ancient device that will remove our world from yours.^^~Where is it?!~ you cry, beginning to get distressed about her extremely high expectations of you.^^Shaking her head she responds ~I do not know, none who hold a wand of power can know that~.  Well. This is sounding kinda difficult."; new_line;ParaContent(); (PHR_928_r9 ());ParaContent(); print "^^~OO! That reminds me!~ she says, snapping her fingers again.  The wand you had previously thrown on the ground rises, slowly moving through the air towards you before coming to a stop and hovering a foot from your box.^^~Take my wand, The Wand of The Dog, and place it in the box, sealing my magic.  Hurry now! There is not much time! You must find the other three and then dispose of them!~ you nod, terrified at the prospect, but still snatch the wand out of the air and throw it in your box.^^Looking up, the beautiful witch is smiling at you and fading away into nothingness...^^Well, fuck guess you gotta save the world."; new_line; .L_Say425; .L_SayX425;
    ! [4: move the witch to temp]
    MoveObject(I157_witch, I137_temp, 0, false);
    ! [5: now the wand is in the small gold box]
    MoveObject(I154_wand,I138_small_gold_box);
    ! [6: now fulfill your destiny is unlocked]
    (Adj_80_t2_v10(I155_fulfill_your_destiny));
    rfalse;
];
! Request 14: phrase nothing -> nothing
! to say goodBitch:
[ PHR_987_r14  I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_9();
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_9 ;
    ! [1: if player is male begin]
    if ((((Adj_82_t1_v10(player))))){
        ! [2: say ~The witch smiles mischeviously, walking towards you slowly and seductively.  You fall back, a churning uneasy feeling in your stomach that increases with each step she takes.  No matter how fast you backpeddle, you can't seem to get your eyes off her, and she seems to gain on you with each back step.^^'Stay stay..away' you stutter as she finally reaches you.  Her lips are so soft on your own, on your neck, and her hands carress you.  Her softness is glorious and causes you to let you guard down ever so slightly.~]
        say__p=1;ParaContent(); print "The witch smiles mischeviously, walking towards you slowly and seductively.  You fall back, a churning uneasy feeling in your stomach that increases with each step she takes.  No matter how fast you backpeddle, you can't seem to get your eyes off her, and she seems to gain on you with each back step.^^~Stay stay..away~ you stutter as she finally reaches you.  Her lips are so soft on your own, on your neck, and her hands carress you.  Her softness is glorious and causes you to let you guard down ever so slightly."; new_line; .L_Say426; .L_SayX426;
        ! [3: say ~You find yourself becoming increasingly aroused as she strips your clothes and gear from your body, intent on reaching the prize underneath. Her eyes seem to be wild with lust, or something worse as she removes your clothing.  Her tongue seems to fall out of her mouth as she begins panting.^^'What the fuck?!' you say in shock as fur starts to spread up from her robes and along her face. She smiles as much of a human smile as she can, before her snout grows out, leaving her to whimper.  'What is this?' you yell, frozen in terror under the former witch, who is quickly becoming a husky.^^You see a tail lift up her robe, her body snapping and cracking until she was on all fours instead of a humanoid.  Using her new teeth she rips off her robe with her teeth, letting it fall down to the ground around her.^^'Uhhh' is all you can think to say at the scene in front of you.  Looking at you, she gives you what seems to be a dog wink, before bending down and SLURRRP.  You gasp at the feeling of her tongue lapping at your cock, quickly bringing it to an erection.~]
        say__p=1;ParaContent(); print "You find yourself becoming increasingly aroused as she strips your clothes and gear from your body, intent on reaching the prize underneath. Her eyes seem to be wild with lust, or something worse as she removes your clothing.  Her tongue seems to fall out of her mouth as she begins panting.^^~What the fuck?!~ you say in shock as fur starts to spread up from her robes and along her face. She smiles as much of a human smile as she can, before her snout grows out, leaving her to whimper.  ~What is this?~ you yell, frozen in terror under the former witch, who is quickly becoming a husky.^^You see a tail lift up her robe, her body snapping and cracking until she was on all fours instead of a humanoid.  Using her new teeth she rips off her robe with her teeth, letting it fall down to the ground around her.^^~Uhhh~ is all you can think to say at the scene in front of you.  Looking at you, she gives you what seems to be a dog wink, before bending down and SLURRRP.  You gasp at the feeling of her tongue lapping at your cock, quickly bringing it to an erection."; new_line; .L_Say427; .L_SayX427;
        ! [4: say ~Once she's satisfied that you're as ready as she is, the retriever moves to bring her needy slit into position over your erect meat and slowly lowers herself onto you with a whimpering yip. As she raises and lowers herself against you, you find yourself slipping into a lust filled haze, lost in the pleasure this sexy canine is forcing on you.^^Before long you feel yourself approaching your peak as the retriever quickens her pace, but just before you climax she reaches it first, howling in pleasure as she convulses above you, pushing you over the edge you fill her needy body with your seed.~]
        say__p=1;ParaContent(); print "Once she's satisfied that you're as ready as she is, the retriever moves to bring her needy slit into position over your erect meat and slowly lowers herself onto you with a whimpering yip. As she raises and lowers herself against you, you find yourself slipping into a lust filled haze, lost in the pleasure this sexy canine is forcing on you.^^Before long you feel yourself approaching your peak as the retriever quickens her pace, but just before you climax she reaches it first, howling in pleasure as she convulses above you, pushing you over the edge you fill her needy body with your seed."; new_line; .L_Say428; .L_SayX428;
        ! [5: say ~Afterwards, she collapses atop you, almost as exhausted as you are, the two of you lay there for some time lost in the afterglow of the weirdest orgasm you have ever had in your life, before she raises herself off your, running her belly contently as she pads away to a short distance and turns to stare at you.[pause_clear]~]
        say__p=1;ParaContent(); print "Afterwards, she collapses atop you, almost as exhausted as you are, the two of you lay there for some time lost in the afterglow of the weirdest orgasm you have ever had in your life, before she raises herself off your, running her belly contently as she pads away to a short distance and turns to stare at you."; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say429; .L_SayX429;
        ! [6: say ~'What?' you ask, confused at her apparent expectation. 'OOO OWW' you yell, a weird cramp shooting through your genitals.  You quickly look down at the chubby cock you have, still covered with the husky witches juices to see.. it pulling inside of you, disappearing.  'Wha.. noo.. noooo.. NOO!' you yell, shocked to hear your voice increasing in pitch every second.^^You hear a squelch down where your precious dick used to be, and look back down to a very wet and needy pussy, its lips changing even further to become as spaded and doglike as the husky that just fucked you.^^Dog teats pop all over your chest, and your cries for help turn into desperate yips.  It's going to take a while to get used to your new tongue as well, as you can hardly keep from drooling.  A sad whimper escapes your snout as you feel yourself forced onto all fours by the magic, your pussy throbbing with need.~]
        say__p=1;ParaContent(); print "~What?~ you ask, confused at her apparent expectation. ~OOO OWW~ you yell, a weird cramp shooting through your genitals.  You quickly look down at the chubby cock you have, still covered with the husky witches juices to see.. it pulling inside of you, disappearing.  ~Wha.. noo.. noooo.. NOO!~ you yell, shocked to hear your voice increasing in pitch every second.^^You hear a squelch down where your precious dick used to be, and look back down to a very wet and needy pussy, its lips changing even further to become as spaded and doglike as the husky that just fucked you.^^Dog teats pop all over your chest, and your cries for help turn into desperate yips.  It's going to take a while to get used to your new tongue as well, as you can hardly keep from drooling.  A sad whimper escapes your snout as you feel yourself forced onto all fours by the magic, your pussy throbbing with need."; new_line; .L_Say430; .L_SayX430;
        ! [7: say ~And then the cold wet nose shoved its way between your ass cheeks. 'Eeeeeeeek!!!' you gasped, trying to twist around you to see what it was.  For a brief second you could feel hot breath pant below the intruding nose, followed by... 'OHHH goddd  fffuccccckkk' you moaned as the tongue lapped at your new folds, introducing you to what it was like to be eaten out.^^After a few moments of mindblowing pleasure enrapturing you in bliss, you finally found the ability to glance behind you, groaning at the sight of the changed witch forcing her muzzle in between your wide thighs making you feel weird.  Certainly worried, kinda bad but daammn also kinda hot.^^'Please stop, you can't do thisss' you halfheatedly beg the witch, the slurping sound of dog tongue against you chubby pussy stopping only to allow her to growl 'I'm going to give you pups bitch, so you might as well enjoy the experience.'[pause_clear]~]
        say__p=1;ParaContent(); print "And then the cold wet nose shoved its way between your ass cheeks. ~Eeeeeeeek!!!~ you gasped, trying to twist around you to see what it was.  For a brief second you could feel hot breath pant below the intruding nose, followed by... ~OHHH goddd  fffuccccckkk~ you moaned as the tongue lapped at your new folds, introducing you to what it was like to be eaten out.^^After a few moments of mindblowing pleasure enrapturing you in bliss, you finally found the ability to glance behind you, groaning at the sight of the changed witch forcing her muzzle in between your wide thighs making you feel weird.  Certainly worried, kinda bad but daammn also kinda hot.^^~Please stop, you can't do thisss~ you halfheatedly beg the witch, the slurping sound of dog tongue against you chubby pussy stopping only to allow her to growl ~I'm going to give you pups bitch, so you might as well enjoy the experience.~"; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say431; .L_SayX431;
        ! [8: say ~And then you cum as a woman, you pussy trembling between your womanly thighs.^^'AAAIIIIIIIIIIIIIIII' the orgasm is 1000 times more intense and seemingly longer then any thing you had felt as a male.   You grab two of yours teats and pinch in a orgasming convulsion, surprising yourself at the contributing shocks to your orgasm.^^It finally slows to the normal pleasure of a male dog shoving his tongue in your bitch pussy, occasionally reach up to clean out your tiny girl asshole as you whimper like a good girl.^^'You're ready' comes the growl from behind you, the witch suddenly jumping on your fur covered back.  Your stunned at whats about to happen, as well as the plethora of changes that have been happening to your body without you knowing.[pause_clear]~]
        say__p=1;ParaContent(); print "And then you cum as a woman, you pussy trembling between your womanly thighs.^^~AAAIIIIIIIIIIIIIIII~ the orgasm is 1000 times more intense and seemingly longer then any thing you had felt as a male.   You grab two of yours teats and pinch in a orgasming convulsion, surprising yourself at the contributing shocks to your orgasm.^^It finally slows to the normal pleasure of a male dog shoving his tongue in your bitch pussy, occasionally reach up to clean out your tiny girl asshole as you whimper like a good girl.^^~You're ready~ comes the growl from behind you, the witch suddenly jumping on your fur covered back.  Your stunned at whats about to happen, as well as the plethora of changes that have been happening to your body without you knowing."; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say432; .L_SayX432;
        ! [9: say ~You freeze instinctively when you feel the clench of the witches canine teeth on the back of your neck as she lines up the thrusts hard into you. You plead in complete pleasure, not sure why as well, as the male dog pounds into you.^^Your body twists and changes underneath him, the squelching of your husky pussy coupled with the instinctual thoughts to mate serenading all your thought patterns with pleasure.^^'I *POUND*.. want ..*POUND* to be your bitch' you say, struggling with the human words with your changed mouth and the pounding of your love hole.   And then he cums in you, making you howl for the first time as your pussy has a glorious second orgasm, spraying dog cum out around the growing knot.^^You feel like an idiot, shivering in physical pleasure, as you realize you were just turned into a girl and fucked into a female dog. Your mind is slipping into the thoughts of birthing pups... And you're a bitch.~]
        say__p=1;ParaContent(); print "You freeze instinctively when you feel the clench of the witches canine teeth on the back of your neck as she lines up the thrusts hard into you. You plead in complete pleasure, not sure why as well, as the male dog pounds into you.^^Your body twists and changes underneath him, the squelching of your husky pussy coupled with the instinctual thoughts to mate serenading all your thought patterns with pleasure.^^~I *POUND*.. want ..*POUND* to be your bitch~ you say, struggling with the human words with your changed mouth and the pounding of your love hole.   And then he cums in you, making you howl for the first time as your pussy has a glorious second orgasm, spraying dog cum out around the growing knot.^^You feel like an idiot, shivering in physical pleasure, as you realize you were just turned into a girl and fucked into a female dog. Your mind is slipping into the thoughts of birthing pups... And you're a bitch."; new_line; .L_Say433; .L_SayX433;
        ! [10: end the story saying ~[bold type]Game Over.  [italic type]'Good girl!'  [roman type]Male Human to Female Dog.~]
        deadflag=(TEXT_TY_ExpandIfPerishable(I7SFRAME,TX_S_478)); story_complete=false;
        ! [11: otherwise]
        } else {

        ! [12: say femaledog]
        say__p=1;ParaContent(); (PHR_990_r128 ()); .L_Say434; .L_SayX434;
        ! [13: end if]
        }

        rfalse;
];
! Request 15: phrase nothing -> nothing
! to say randomGazelle:
[ PHR_980_r15  ;
    ! [1: say ~The cute blonde paramedic rushed to the mans side, his convulsions becoming more and more excessive. A look of worry showed on her beautiful face as she felt for his pulse.^^'Goddamnit' she muttered under her breath apparently unaware of you and the rest of the crowd watching. She grabbed the collar of his dress shirt and ripped it open, it obvious she was going to attempt chest compression. [paragraph break] What she saw there made everyone gasp.^^Tawny brown and blonde fur was spreading across his broadening chest as he twisted in uncontrollable seizures brought on by his transformation. A scream rang out from the crowd, dispersing all but those too frozen to move, their eyes fixed on the disturbing scene. The paramedic just sat there with her mouth wide open at the disease she had no idea how to treat. '..Sir?' She stuttered, standing up and slowly backing away. His eyes flew open, his pupils rolling in terrifying fashion. [pause_clear]~]
    say__p=1;ParaContent(); print "The cute blonde paramedic rushed to the mans side, his convulsions becoming more and more excessive. A look of worry showed on her beautiful face as she felt for his pulse.^^~Goddamnit~ she muttered under her breath apparently unaware of you and the rest of the crowd watching. She grabbed the collar of his dress shirt and ripped it open, it obvious she was going to attempt chest compression. ";ParaContent(); DivideParagraphPoint(); new_line;ParaContent(); print " What she saw there made everyone gasp.^^Tawny brown and blonde fur was spreading across his broadening chest as he twisted in uncontrollable seizures brought on by his transformation. A scream rang out from the crowd, dispersing all but those too frozen to move, their eyes fixed on the disturbing scene. The paramedic just sat there with her mouth wide open at the disease she had no idea how to treat. ~..Sir?~ She stuttered, standing up and slowly backing away. His eyes flew open, his pupils rolling in terrifying fashion. ";ParaContent(); (PHR_928_r9 ()); .L_Say435; .L_SayX435;
    ! [2: say ~The pretty paramedic girl screamed and turned to run when the man reached out his hand and snagged her leg midstep. She tugged futilely, crying in terror.^^You had to do something. Looking around for some possible comrades for a rescue effort, you are astonished to see everyone else had turned tail and fled. Determined to do some good (especially when a cute girl needed some saving), you turn back around and start forming a plan. [paragraph break] 'Noo.. No.. Stop please', the sad sound coming from the girl.^^And then you realize its too late. During that time the mans 'hand' that was pinning the poor woman's foot to the ground was hardening, its fingers pulling together and changing hues to a dark keratin. And the change had spread. [pause_clear]~]
    say__p=1;ParaContent(); print "The pretty paramedic girl screamed and turned to run when the man reached out his hand and snagged her leg midstep. She tugged futilely, crying in terror.^^You had to do something. Looking around for some possible comrades for a rescue effort, you are astonished to see everyone else had turned tail and fled. Determined to do some good (especially when a cute girl needed some saving), you turn back around and start forming a plan. ";ParaContent(); DivideParagraphPoint(); new_line;ParaContent(); print " ~Noo.. No.. Stop please~, the sad sound coming from the girl.^^And then you realize its too late. During that time the mans ~hand~ that was pinning the poor woman's foot to the ground was hardening, its fingers pulling together and changing hues to a dark keratin. And the change had spread. ";ParaContent(); (PHR_928_r9 ()); .L_Say436; .L_SayX436;
    ! [3: say ~All the color was leaving the cute young paramedics face as she saw fur sprout out of her leg, a pitiful whimper of fear escaping her mouth.^^The man slowly crawled to his knees, and realizing you were still just standing out in the open, you duck behind a mailbox that's nearby, peeking around it to see what's happening. [paragraph break]As the man rises, the remnants of his shirt fall to his feet, his pants looking like they'll soon follow. Then you spot something, a flash of red as the man stands. You shake your head as you realize what it is. Finally up and standing as best he can, the mans pants can no longer contain his growing penis. And its certainly no longer human..^^Its shaft is longer and thinner, with a thick animalistic sheath around it. [paragraph break]The poor woman is still standing there, shivering in fear and shock. Her uniform starts to lift in the back, a small tuft of a tail lifting out and wriggling about. 'Ohh I feel weirddd' she moaned pulling at her new cute tail sticking out of her ass. She seemed more interested in the changes now instead of being of them.[pause_clear]~]
    say__p=1;ParaContent(); print "All the color was leaving the cute young paramedics face as she saw fur sprout out of her leg, a pitiful whimper of fear escaping her mouth.^^The man slowly crawled to his knees, and realizing you were still just standing out in the open, you duck behind a mailbox that's nearby, peeking around it to see what's happening. ";ParaContent(); DivideParagraphPoint(); new_line;ParaContent(); print "As the man rises, the remnants of his shirt fall to his feet, his pants looking like they'll soon follow. Then you spot something, a flash of red as the man stands. You shake your head as you realize what it is. Finally up and standing as best he can, the mans pants can no longer contain his growing penis. And its certainly no longer human..^^Its shaft is longer and thinner, with a thick animalistic sheath around it. ";ParaContent(); DivideParagraphPoint(); new_line;ParaContent(); print "The poor woman is still standing there, shivering in fear and shock. Her uniform starts to lift in the back, a small tuft of a tail lifting out and wriggling about. ~Ohh I feel weirddd~ she moaned pulling at her new cute tail sticking out of her ass. She seemed more interested in the changes now instead of being of them."; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say437; .L_SayX437;
    ! [4: say ~The original victim seemed to be more interested in something else, raising his nose (which was slowly extending into some sort of muzzle) to the air and sniffing, trying to find the source of the scent. Turning to try to catch a glimpse of her tail, the paramedic seemed completely caught up in her own changes enough to miss what you now knew to be impending doom.^^'Ellie' was her name, you could see her name tag now as she finally caught a glimpse of her tail, and even cuter with a fluffy tail sticking out her backside. [paragraph break]But you had seen this kind of stuff before, and knew that magic at play here and all over the city had only one ending.^^Suddenly Ellie let out a moan, two horns slowly growing out of the top of her head. She seemed more concerned with something else though.. And you knew the final parts of the spell were coming into play. Her ass was pushing the limits of her suit, breaking open to reveal her furry cervine back side. The man, almost completely a male gazelle by now, knew he was about to claim a mate and started moving into position.^^Ellies pussy was visible by all, her shame twisting and morphing into a thick black gazelle vagina, pushing up close to her asshole, which was also changing. 'Oh my goddd' she moaned, her animal heat taking over her mind, helping complete the metamorphosis from adorable paramedic to mindless gazelle doe in heat[pause_clear].~]
    say__p=1;ParaContent(); print "The original victim seemed to be more interested in something else, raising his nose (which was slowly extending into some sort of muzzle) to the air and sniffing, trying to find the source of the scent. Turning to try to catch a glimpse of her tail, the paramedic seemed completely caught up in her own changes enough to miss what you now knew to be impending doom.^^~Ellie~ was her name, you could see her name tag now as she finally caught a glimpse of her tail, and even cuter with a fluffy tail sticking out her backside. ";ParaContent(); DivideParagraphPoint(); new_line;ParaContent(); print "But you had seen this kind of stuff before, and knew that magic at play here and all over the city had only one ending.^^Suddenly Ellie let out a moan, two horns slowly growing out of the top of her head. She seemed more concerned with something else though.. And you knew the final parts of the spell were coming into play. Her ass was pushing the limits of her suit, breaking open to reveal her furry cervine back side. The man, almost completely a male gazelle by now, knew he was about to claim a mate and started moving into position.^^Ellies pussy was visible by all, her shame twisting and morphing into a thick black gazelle vagina, pushing up close to her asshole, which was also changing. ~Oh my goddd~ she moaned, her animal heat taking over her mind, helping complete the metamorphosis from adorable paramedic to mindless gazelle doe in heat";ParaContent(); (PHR_928_r9 ());ParaContent(); print "."; new_line; .L_Say438; .L_SayX438;
    ! [5: if player is female begin]
    if ((((Adj_81_t1_v10(player))))){
        ! [6: say ~You watch as she is claimed, the act something you can't seem to take your eyes off of.  The way she is submitting to the male... her little cries of lust, whoa.  Okay, you need to watch yourself, thats weird thinking going on there.^^Then the male spots you, having cum in poor Ellie. He climbs off his mate, her tongue still sticking out of her mouth as she pants, out of breath because the fucking.  The male gazelle is coming over to you, sniffing the air for... what?  Hes getting rather close... maybe you should go.. Do you really want to stay?~]
        say__p=1;ParaContent(); print "You watch as she is claimed, the act something you can't seem to take your eyes off of.  The way she is submitting to the male... her little cries of lust, whoa.  Okay, you need to watch yourself, thats weird thinking going on there.^^Then the male spots you, having cum in poor Ellie. He climbs off his mate, her tongue still sticking out of her mouth as she pants, out of breath because the fucking.  The male gazelle is coming over to you, sniffing the air for... what?  Hes getting rather close... maybe you should go.. Do you really want to stay?"; new_line; .L_Say439; .L_SayX439;
        ! [7: if player consents begin]
        if ((YesOrNo())){
            ! [8: say ~You can't think what to do, frozen like a deer in headlights.  He's getting closer, nose still sniffing until hes a inch away from your trembling face.^^*SLURRRRRRRRP*^^He just taking a big lick, planting it right on the right side of your face.  '...HAHAAHAAAA whew' you breathe a sigh of relief, the gazelles eyes opening a bit in anticipation, the loud sound of your relieved laughter putting him on edge.^^You aren't that bad, just a victim of a spell, right? you ask, before blushing.  You just embarrassed yourself... this is that man that was crying in pain, why are you talking to him like hes a mean cat you finally had the courage to talk to?^^'I... uhhh.. sorry. What can I do to help?' you ask the former man, scratching his head.  He leans against it, obviously enjoying the comfort.  You scratch under his chin to try to ease the stress he probably is stuck feeling, being an animal now.  You keep petting and scratching the churrring male gazelle, his stag like body a contrast to his obvious relaxed state.  You lean in close, hugging him. His fur brushes against your face, feeling soft and warm.^^And it smells good and clean too!  It smells really good, actually. You take your head off his haunch, sniffing the air now like he was before.  Man that smells good, like clean laundry?  Or like just cooked food? No it wasn't either... it was something you swear you had smelled before.^^You let your nose do the talking, turning around and looking around you to see what could be that good.  You look left and right, under you and around, eventually turning to run face first into it.^^The gazelles cock, still veiny and ready to claim mates.  You gag at first, but the smell is making you feel 'Goooooood', you moan, saying your thought out loan.  You lean forward cautiously and muzzle his dick, its smell glorious.  The only thought going through your head is of pleasuring it. Before you even know it, you're running your tongue up and down its impressive length, wiggling over to position yourself in front of it.^^Your eyes flutter as you think about how lucky Ellie was, hoping you can get as lucky.  Slowly you take into your mouth, running your soft lips down its shaft til it hits the back of your throat.  You are burning with a desire you cannot control, moaning mindlessly as you orally pleasure the male gazelle.~]
            say__p=1;ParaContent(); print "You can't think what to do, frozen like a deer in headlights.  He's getting closer, nose still sniffing until hes a inch away from your trembling face.^^*SLURRRRRRRRP*^^He just taking a big lick, planting it right on the right side of your face.  ~...HAHAAHAAAA whew~ you breathe a sigh of relief, the gazelles eyes opening a bit in anticipation, the loud sound of your relieved laughter putting him on edge.^^You aren't that bad, just a victim of a spell, right? you ask, before blushing.  You just embarrassed yourself... this is that man that was crying in pain, why are you talking to him like hes a mean cat you finally had the courage to talk to?^^~I... uhhh.. sorry. What can I do to help?~ you ask the former man, scratching his head.  He leans against it, obviously enjoying the comfort.  You scratch under his chin to try to ease the stress he probably is stuck feeling, being an animal now.  You keep petting and scratching the churrring male gazelle, his stag like body a contrast to his obvious relaxed state.  You lean in close, hugging him. His fur brushes against your face, feeling soft and warm.^^And it smells good and clean too!  It smells really good, actually. You take your head off his haunch, sniffing the air now like he was before.  Man that smells good, like clean laundry?  Or like just cooked food? No it wasn't either... it was something you swear you had smelled before.^^You let your nose do the talking, turning around and looking around you to see what could be that good.  You look left and right, under you and around, eventually turning to run face first into it.^^The gazelles cock, still veiny and ready to claim mates.  You gag at first, but the smell is making you feel ~Goooooood~, you moan, saying your thought out loan.  You lean forward cautiously and muzzle his dick, its smell glorious.  The only thought going through your head is of pleasuring it. Before you even know it, you're running your tongue up and down its impressive length, wiggling over to position yourself in front of it.^^Your eyes flutter as you think about how lucky Ellie was, hoping you can get as lucky.  Slowly you take into your mouth, running your soft lips down its shaft til it hits the back of your throat.  You are burning with a desire you cannot control, moaning mindlessly as you orally pleasure the male gazelle."; new_line; .L_Say440; .L_SayX440;
            ! [9: end if]
            }

        ! [10: otherwise]
        } else {

        ! [11: say ~It may be best you get out of here, the former girl known as Ellie only seems interested in rutting now.~]
        say__p=1;ParaContent(); print "It may be best you get out of here, the former girl known as Ellie only seems interested in rutting now."; new_line; .L_Say441; .L_SayX441;
        ! [12: end if]
        }

        rfalse;
];
! Request 16: phrase nothing -> nothing
! to say suckedIntoMare:
[ PHR_1018_r16  I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_10();
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_10 ;
    ! [1: say ~But you can't seem to move your legs, the feeling of magic seeping over you.  You watch the mares as they go from running about in terror and sexual frustration to quietly settling down, either their fate becoming easier to accept with time, or their minds fading into nothing but a female horses.^^To think what a simple life, being on a pasture, wild and free....^^[pause_clear]^^..................^^[pause_clear]^^...........^^You snap back out of your day dreams of life as a horse, realizing what you were doing. As you turn to go, you take one last look at the small herd as they also part ways by running away to the nearby field.[pause_clear]~]
    say__p=1;ParaContent(); print "But you can't seem to move your legs, the feeling of magic seeping over you.  You watch the mares as they go from running about in terror and sexual frustration to quietly settling down, either their fate becoming easier to accept with time, or their minds fading into nothing but a female horses.^^To think what a simple life, being on a pasture, wild and free....^^";ParaContent(); (PHR_928_r9 ());ParaContent(); print "^^..................^^";ParaContent(); (PHR_928_r9 ());ParaContent(); print "^^...........^^You snap back out of your day dreams of life as a horse, realizing what you were doing. As you turn to go, you take one last look at the small herd as they also part ways by running away to the nearby field."; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say442; .L_SayX442;
    ! [2: say ~You make it five feet before you realize something is wrong.  You feel a bit embarrassed to show any reaction to the public... but something is wrong with your.. pussy?  Or at least it feels like its different, or something is.^^You hurry off to the nearby Mall, running into the restrooms.  Theres a line for the stalls but you push past them to the front, saying you are having a serious emergency at the scoffing crowd.  God, this line is taking forever, its not helping your anxiety.^^Finally, after what seems like a year, a stall opens, and you run in, slamming the door shut.  Luckily the mall features stalls with a mirror, so that can help you see what the hell happened. [pause_clear]~]
    say__p=1;ParaContent(); print "You make it five feet before you realize something is wrong.  You feel a bit embarrassed to show any reaction to the public... but something is wrong with your.. pussy?  Or at least it feels like its different, or something is.^^You hurry off to the nearby Mall, running into the restrooms.  Theres a line for the stalls but you push past them to the front, saying you are having a serious emergency at the scoffing crowd.  God, this line is taking forever, its not helping your anxiety.^^Finally, after what seems like a year, a stall opens, and you run in, slamming the door shut.  Luckily the mall features stalls with a mirror, so that can help you see what the hell happened. ";ParaContent(); (PHR_928_r9 ()); .L_Say443; .L_SayX443;
    ! [3: say ~You pull down your jeans, and already gasp at whats different.. you can see the changes through your panties.  With your trembling hands, you pull down your cute cotton panties to reveal your changed pussy.^^It's fat lipped, much fuller, and far from a soft pink color anymore.  It black, and massive.. and hard to see. Turning around and spreading your small cheeks some you can see that it's moved farther back to meet with your asshole... which has also changed.  Into a donut like shape.^^'FUCK!' you yell, absolutely horrified to see your genitals have changed into a mares. You just break down crying, not knowing what to do. Finally you stop, taking another look at the gross pussy wedged in between your thighs before reaching down to pull your pants and underwear back up.^^Composing yourself and turning to leave the bathroom to go to a doctor, you can feel a burst of magic feelings shoot through you. 'Nooooo...' you moan as you wonder what it could be now.^^Sighing and looking at yourself... you've got no idea what happened.  Deciding its best to look, you pull your pants down again, frustrated as hell.[pause_clear]~]
    say__p=1;ParaContent(); print "You pull down your jeans, and already gasp at whats different.. you can see the changes through your panties.  With your trembling hands, you pull down your cute cotton panties to reveal your changed pussy.^^It's fat lipped, much fuller, and far from a soft pink color anymore.  It black, and massive.. and hard to see. Turning around and spreading your small cheeks some you can see that it's moved farther back to meet with your asshole... which has also changed.  Into a donut like shape.^^~FUCK!~ you yell, absolutely horrified to see your genitals have changed into a mares. You just break down crying, not knowing what to do. Finally you stop, taking another look at the gross pussy wedged in between your thighs before reaching down to pull your pants and underwear back up.^^Composing yourself and turning to leave the bathroom to go to a doctor, you can feel a burst of magic feelings shoot through you. ~Nooooo...~ you moan as you wonder what it could be now.^^Sighing and looking at yourself... you've got no idea what happened.  Deciding its best to look, you pull your pants down again, frustrated as hell."; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say444; .L_SayX444;
    ! [4: say ~Annnnnnd you have a pretty blonde mare tail now.  You can feel the tears welling up again, not able to believe it when you look in the mirror and see essentially an ass that a stallion would want to fuck, not a human.^^The second the word stallion goes through your mind you let out an involuntary moan, heat spreading through you.  'Oh goddddd' you whimper, your pussy suddenly slick with your own juices.  Using one hand to spread your cheeks a bit, you use your other to feel your new thick mare lips, pleasuring yourself with just a minor touch.^^Wait... 'FUCK!' you yell again, catching yourself and seeing your face go beet red in the mirror.  You are humiliated and scared at how you lost control there... like you were in heat.  You've got to get out of here and find help immediately.^^Pulling your pants back up and sprinting out of the bathroom to the weird looks from the still very present line, you flee the mall.  Your doctor is in uptown but you can make it if you run.[pause_clear]~]
    say__p=1;ParaContent(); print "Annnnnnd you have a pretty blonde mare tail now.  You can feel the tears welling up again, not able to believe it when you look in the mirror and see essentially an ass that a stallion would want to fuck, not a human.^^The second the word stallion goes through your mind you let out an involuntary moan, heat spreading through you.  ~Oh goddddd~ you whimper, your pussy suddenly slick with your own juices.  Using one hand to spread your cheeks a bit, you use your other to feel your new thick mare lips, pleasuring yourself with just a minor touch.^^Wait... ~FUCK!~ you yell again, catching yourself and seeing your face go beet red in the mirror.  You are humiliated and scared at how you lost control there... like you were in heat.  You've got to get out of here and find help immediately.^^Pulling your pants back up and sprinting out of the bathroom to the weird looks from the still very present line, you flee the mall.  Your doctor is in uptown but you can make it if you run."; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say445; .L_SayX445;
    ! [5: say ~As you sprint, tears starting to well up again at the thought of joining the group of girls that lost their humanity, you can feel the magic hit again.  The tingling of it washing over you is stronger this time, and you have to stop its so bad.  As you hunch over you can feel lower belly expand, soft flesh balloon out to look like a mammary gland.^^Long dark nipples sprout out of it, pushing against your shirt and rubbing their sensitive ends against the fabric.  You have teets now. Mare teets.  And the feeling of them rubbing against your shirt is driving you crazy.  You can feel your tail lift in your pants, the wetness under it winking like a mares pussy.^^'Why?!' you begin to cry, so humiliated and confused.  You can feel your tail lift out of your pants and all the way up.. and a stream of urine spray out of you.  You have never been more disgusted, the urine smelling different then normal and very strong.^^Like a mares pheromone laden urine, something female horses do to attract males when they desperately need to be fucked.^^And you feel like you need to... or you don't... you DON'T KNOW ANYMORE!  Scared and confused you turn and run off into the field where the other mares disappeared to, the feeling of walking on 2 legs becoming harder and harder.^^You fall on all fours, looking behind you to see you lost your pants a long time ago when your ass expanded to that of a mares.^^'NooooWWHIINNNNNNNNIII' your cry of desperation is that of a mares. You can't even talk anymore, it's over.  You can feel your pussy still winking and clasping, desperate for a males penetration, and you feel your mind slip.  Trying to think of your family and friends, you can't even recall your past life, and can't think of anything other then being fucked til you're pregnant.~]
    say__p=1;ParaContent(); print "As you sprint, tears starting to well up again at the thought of joining the group of girls that lost their humanity, you can feel the magic hit again.  The tingling of it washing over you is stronger this time, and you have to stop its so bad.  As you hunch over you can feel lower belly expand, soft flesh balloon out to look like a mammary gland.^^Long dark nipples sprout out of it, pushing against your shirt and rubbing their sensitive ends against the fabric.  You have teets now. Mare teets.  And the feeling of them rubbing against your shirt is driving you crazy.  You can feel your tail lift in your pants, the wetness under it winking like a mares pussy.^^~Why?!~ you begin to cry, so humiliated and confused.  You can feel your tail lift out of your pants and all the way up.. and a stream of urine spray out of you.  You have never been more disgusted, the urine smelling different then normal and very strong.^^Like a mares pheromone laden urine, something female horses do to attract males when they desperately need to be fucked.^^And you feel like you need to... or you don't... you DON'T KNOW ANYMORE!  Scared and confused you turn and run off into the field where the other mares disappeared to, the feeling of walking on 2 legs becoming harder and harder.^^You fall on all fours, looking behind you to see you lost your pants a long time ago when your ass expanded to that of a mares.^^~NooooWWHIINNNNNNNNIII~ your cry of desperation is that of a mares. You can't even talk anymore, it's over.  You can feel your pussy still winking and clasping, desperate for a males penetration, and you feel your mind slip.  Trying to think of your family and friends, you can't even recall your past life, and can't think of anything other then being fucked til you're pregnant."; new_line; .L_Say446; .L_SayX446;
    ! [6: end the story saying ~[bold type]Game Over.  [italic type]'Joining The Herd'  [roman type]Female Human to Breeding Mare.~]
    deadflag=(TEXT_TY_ExpandIfPerishable(I7SFRAME,TX_S_479)); story_complete=false;
    rfalse;
];
! Request 17: phrase nothing -> nothing
! to say minotaurScene:
[ PHR_995_r17  ;
    ! [1: say ~Having finally conquered the parking labyrinth, it seemed like absolute chaos on the screen, showing people yelling and screaming in fear as they ran around.  The reporter in the field, young Tammy Watz, was worriedly reporting the disaster around her.^^'Ummm.. that's right Tom, things are absolutely crazy down here.  Our van pulled up to a reported gas leak and a poor citizen near us just started oinking violently.  In a few minutes he was nothing but an animal, and a sex-crazed one at that'. [paragraph break] Gasps come to life all around you as the scene turns wrong.  Tammy, still blathering at the screen about the surrounding chaos, was standing under the shadow of what appeared to be a... a damn... minotaur?  Flared nostrils and all. And flared.. wow that's a massive dick.  The minotaurs bovine penis sat upright, a foot long at least.  His searching nostrils sniffed the air, slowly moving down towards the still oblivious Tammies rear.^^'Yes, Tom they are definitely animals now.. OH GOD WHAAAA', Tammy shouted as the entranced Minotaur had moved his muzzle under Tammies skirt, making her very much aware of the monstrosity behind her.. and his apparent 'interest' in her. Her sudden shock grew as a great cow tongue began to lap at her soft lips, still hidden under her skirt.[pause_clear]~]
    say__p=1;ParaContent(); print "Having finally conquered the parking labyrinth, it seemed like absolute chaos on the screen, showing people yelling and screaming in fear as they ran around.  The reporter in the field, young Tammy Watz, was worriedly reporting the disaster around her.^^~Ummm.. that's right Tom, things are absolutely crazy down here.  Our van pulled up to a reported gas leak and a poor citizen near us just started oinking violently.  In a few minutes he was nothing but an animal, and a sex-crazed one at that~. ";ParaContent(); DivideParagraphPoint(); new_line;ParaContent(); print " Gasps come to life all around you as the scene turns wrong.  Tammy, still blathering at the screen about the surrounding chaos, was standing under the shadow of what appeared to be a... a damn... minotaur?  Flared nostrils and all. And flared.. wow that's a massive dick.  The minotaurs bovine penis sat upright, a foot long at least.  His searching nostrils sniffed the air, slowly moving down towards the still oblivious Tammies rear.^^~Yes, Tom they are definitely animals now.. OH GOD WHAAAA~, Tammy shouted as the entranced Minotaur had moved his muzzle under Tammies skirt, making her very much aware of the monstrosity behind her.. and his apparent ~interest~ in her. Her sudden shock grew as a great cow tongue began to lap at her soft lips, still hidden under her skirt."; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say447; .L_SayX447;
    ! [2: say ~Tammie lets out a yelp, trying to force her skirt back down and knocking the minotaur in his muzzle.  The camera falls to the ground as the cameraman must've just run for it.  It's sideways but you can still what it happening.^^Tammie breaks free and starts to run away the best she can in heels.  'WHAT THE FUUUCK?!' she yells as she apparently doesn't care about her broadcast anymore.  Only when she looks down, confused and frustrated, do you realize she was never wearing heels.^^Her shoes pop and explode from the inside as her feet are completely keratin now, nothing but cow hooves.[paragraph break] By now the minotaur has certainly recovered, and was moving in with the look of lust plastered on his face.  You can see the enormous erection he has being knocked side to side by his giant steps.  Tammie notices it to, and tries to crawl her way away, her breasts swelling, the nipples just bursting through her tight dress, showing the whole world they are nothing but utters now.[pause_clear]~]
    say__p=1;ParaContent(); print "Tammie lets out a yelp, trying to force her skirt back down and knocking the minotaur in his muzzle.  The camera falls to the ground as the cameraman must've just run for it.  It's sideways but you can still what it happening.^^Tammie breaks free and starts to run away the best she can in heels.  ~WHAT THE FUUUCK?!~ she yells as she apparently doesn't care about her broadcast anymore.  Only when she looks down, confused and frustrated, do you realize she was never wearing heels.^^Her shoes pop and explode from the inside as her feet are completely keratin now, nothing but cow hooves.";ParaContent(); DivideParagraphPoint(); new_line;ParaContent(); print " By now the minotaur has certainly recovered, and was moving in with the look of lust plastered on his face.  You can see the enormous erection he has being knocked side to side by his giant steps.  Tammie notices it to, and tries to crawl her way away, her breasts swelling, the nipples just bursting through her tight dress, showing the whole world they are nothing but utters now."; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say448; .L_SayX448;
    ! [3: say ~Her jaw drops as the minotaurs nostrils contract and expand, right next to her plumping rump, taking in the smell of her pussy.  He shoves his head under her dress rim for a second time, the sound of lapping playing over the TV.  'OHHHHhhhhhh' Tammie groans as her body changes to accomodate mating with a bull.  Her ass grows past the dresses ability to restrain it, and it begins to rip all the way up her back, her panties holding on in a tight band.  You can see the huge bull tongue penetrating her slimy pussy with each lick, a small tail pushing its way out of the end of her spine.  [paragraph break] 'HELP MOOOOeeeeeOOO' she begs as her pussy grows fatter and larger, her human one replaced by a dairy cows.  'Pllleeease' she begs the camera, 'I don't want to be a..' her statement is cut short by the minotaur falling on her back and thrusting forward, the sound of the spit covered pussy being penetrated so loud it plays clearly over the TV.^^'Moooooooo' Tammie the cow cries in obvious pleasure before the shot cuts to black.  The different colored bars pop onto the screen with a loud ringing tone, the broadcast finally being cut by the probably shellshocked technicians at the studio.~]
    say__p=1;ParaContent(); print "Her jaw drops as the minotaurs nostrils contract and expand, right next to her plumping rump, taking in the smell of her pussy.  He shoves his head under her dress rim for a second time, the sound of lapping playing over the TV.  ~OHHHHhhhhhh~ Tammie groans as her body changes to accomodate mating with a bull.  Her ass grows past the dresses ability to restrain it, and it begins to rip all the way up her back, her panties holding on in a tight band.  You can see the huge bull tongue penetrating her slimy pussy with each lick, a small tail pushing its way out of the end of her spine.  ";ParaContent(); DivideParagraphPoint(); new_line;ParaContent(); print " ~HELP MOOOOeeeeeOOO~ she begs as her pussy grows fatter and larger, her human one replaced by a dairy cows.  ~Pllleeease~ she begs the camera, ~I don't want to be a..~ her statement is cut short by the minotaur falling on her back and thrusting forward, the sound of the spit covered pussy being penetrated so loud it plays clearly over the TV.^^~Moooooooo~ Tammie the cow cries in obvious pleasure before the shot cuts to black.  The different colored bars pop onto the screen with a loud ringing tone, the broadcast finally being cut by the probably shellshocked technicians at the studio."; new_line; .L_Say449; .L_SayX449;
    rfalse;
];
! Request 18: phrase nothing -> nothing
! to say becomeFemaleGiraffe:
[ PHR_1001_r18  I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_11();
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_11 ;
    ! [1: say ~You step through the portal, a slight burning feeling washing across your body as you do.^^'Caroline!' A voice yells. 'wake up, come on we are putting on the show for Christ sakes'.  You look around, flustered and trying to get a sense of your surroundings. 'Caroline! Quit daydreaming!' The voice echoes again, this time you can recognize it coming from your right..  You wheel around to see a woman beckoning at what must only be you, as you can now see now the other humans on the other side of bars along the entire clearing to the left.^^'Wha? me.. whats wrong with my voice?' you gasp, looking down to see that you have breasts?  Cute little B-cups in a light blue shirt, with jean shorts below, showing off your long tan legs.  You have what looks like a safari hat on and a nametag that says Caroline on it.^^Oh fuck. You must've changed places with someone.. obviously a young woman.. when you took the portal.  Your friend, or fellow safari adventurer or whatever was going on, was a few feet away, striding towards you and... SMACK! [pause_clear] ~]
    say__p=1;ParaContent(); print "You step through the portal, a slight burning feeling washing across your body as you do.^^~Caroline!~ A voice yells. ~wake up, come on we are putting on the show for Christ sakes~.  You look around, flustered and trying to get a sense of your surroundings. ~Caroline! Quit daydreaming!~ The voice echoes again, this time you can recognize it coming from your right..  You wheel around to see a woman beckoning at what must only be you, as you can now see now the other humans on the other side of bars along the entire clearing to the left.^^~Wha? me.. whats wrong with my voice?~ you gasp, looking down to see that you have breasts?  Cute little B-cups in a light blue shirt, with jean shorts below, showing off your long tan legs.  You have what looks like a safari hat on and a nametag that says Caroline on it.^^Oh fuck. You must've changed places with someone.. obviously a young woman.. when you took the portal.  Your friend, or fellow safari adventurer or whatever was going on, was a few feet away, striding towards you and... SMACK! ";ParaContent(); (PHR_928_r9 ());ParaContent(); print " "; .L_Say450; .L_SayX450;
    ! [2: say ~She smacked you across your face, a teasing smile on her lips. 'Come on, girl' you said, looking deep in your eyes, 'we gotta feed the giraffes, the whole crowd is here to see it...  heh, I think I know what you are thinking about but come on.'^^She turned after a flirty wink as it all came together in your head.  You must be in some sort of zoo, as one of the zookeepers, and this was definitely your lover?  Definitely.  The way you looked at you.  Sweet!!!! Hot lesbians! you think to yourself, beginning to trudge after her, thinking about her awesome ass.^^That's when a few giraffes strode around the corner, to the gasping amusement of the crowd.  Cameras started snapping immediately. Everything must've been fine though, as your lover, whatever her name is, turned around and waved back at the crowd confidently.  You glanced quickly at 'Amys' badge just to learn your sexy lesbian lovepieces name in case anything.. happened.[pause_clear]~]
    say__p=1;ParaContent(); print "She smacked you across your face, a teasing smile on her lips. ~Come on, girl~ you said, looking deep in your eyes, ~we gotta feed the giraffes, the whole crowd is here to see it...  heh, I think I know what you are thinking about but come on.~^^She turned after a flirty wink as it all came together in your head.  You must be in some sort of zoo, as one of the zookeepers, and this was definitely your lover?  Definitely.  The way you looked at you.  Sweet!!!! Hot lesbians! you think to yourself, beginning to trudge after her, thinking about her awesome ass.^^That's when a few giraffes strode around the corner, to the gasping amusement of the crowd.  Cameras started snapping immediately. Everything must've been fine though, as your lover, whatever her name is, turned around and waved back at the crowd confidently.  You glanced quickly at ~Amys~ badge just to learn your sexy lesbian lovepieces name in case anything.. happened."; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say451; .L_SayX451;
    ! [3: say ~'Caroline!' Amys whisper wakes you from your thoughts of her naked body being at your whim.  'Oh.. uh yeah shit, what we gonna do?' you ask, also trying to keep it at a whisper.  You don't want to start acting like a crazy person in front of a crowd.^^Amy looks frustrated by your weird reactions, her pretty face scrunched in a scowl as she retorts 'Goddamnit keep your mind on whats at hand.. we gotta give the crowd the show of feeding the dumb beasts, and do damn good job of sneakly injecting the late releasing pheromones in them so we don't have to come back tonight. We've done it a hundred times before, whats wrong with you?'[pause_clear]^^You look down into your pouch, finding a tiny syringe, labeled GIR-PHER-0316.  'Sorry, I know what we're doing'.  You apology was kind of true... you know you're gonna have to inject these giant beasts with this serum, easy easy.  'You feed em I'll inject em' you say.  Amy nods in agreement, fulling a food pouch out of her zookeepers bag.  You pull the serum out, trying to be subtle.  Maybe you can go along with this and you and Amy can have some fun later..^^Taking the safety cap off the serum as Amy starts to introduce the crowd to the giraffes through a microphone headset, you walk over near her to the haunch of the first giraffe.  You hardly meet the haunches of the giant slender beast, the impressive height something you had never seen before in an animal.[pause_clear]~]
    say__p=1;ParaContent(); print "~Caroline!~ Amys whisper wakes you from your thoughts of her naked body being at your whim.  ~Oh.. uh yeah shit, what we gonna do?~ you ask, also trying to keep it at a whisper.  You don't want to start acting like a crazy person in front of a crowd.^^Amy looks frustrated by your weird reactions, her pretty face scrunched in a scowl as she retorts ~Goddamnit keep your mind on whats at hand.. we gotta give the crowd the show of feeding the dumb beasts, and do damn good job of sneakly injecting the late releasing pheromones in them so we don't have to come back tonight. We've done it a hundred times before, whats wrong with you?~"; new_line;ParaContent(); (PHR_928_r9 ());ParaContent(); print "^^You look down into your pouch, finding a tiny syringe, labeled GIR-PHER-0316.  ~Sorry, I know what we're doing~.  You apology was kind of true... you know you're gonna have to inject these giant beasts with this serum, easy easy.  ~You feed em I'll inject em~ you say.  Amy nods in agreement, fulling a food pouch out of her zookeepers bag.  You pull the serum out, trying to be subtle.  Maybe you can go along with this and you and Amy can have some fun later..^^Taking the safety cap off the serum as Amy starts to introduce the crowd to the giraffes through a microphone headset, you walk over near her to the haunch of the first giraffe.  You hardly meet the haunches of the giant slender beast, the impressive height something you had never seen before in an animal."; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say452; .L_SayX452;
    ! [4: say ~The giraffe senses your uneasiness.. or maybe something else. Fuck you gotta do this now, Amy is reciting her lines but staring at you with that one scowl.  Grabbing the needle, you pull it back Pulp Fiction style and thrust it forward.  The giraffe makes some sort of bellow in surprise and bucks, smacking your hand and the syrine right out of it... and into Amys shoulder.[pause_clear]~]
    say__p=1;ParaContent(); print "The giraffe senses your uneasiness.. or maybe something else. Fuck you gotta do this now, Amy is reciting her lines but staring at you with that one scowl.  Grabbing the needle, you pull it back Pulp Fiction style and thrust it forward.  The giraffe makes some sort of bellow in surprise and bucks, smacking your hand and the syrine right out of it... and into Amys shoulder."; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say453; .L_SayX453;
    ! [5: say ~'OW FUCK' she yells in response, pulling it out immediately and throwing it to the ground in frustration. 'WHAT THE FUCK?!' she yells at you.  But you aren't paying attention.  You are sitting there with your mouth open at the sight of fur sprouting out of her shoulder. 'Ugh I feel weird..' she says, rubbing her arm and gasping out loud at the feeling of growing fur.^^'NOOO!'^^The giraffes scatter, and the crowd is murmuring in confusion.  You are just staring at Amy, trying to apologize, as she starts moaning and holding her stomach.  Her hand moves down to her crouch, and her moans grow deeper as small horns form on her head.  'Caroline I feel sooooo good' she bellows, staring at you in a very.. dominant way.[pause_clear]~]
    say__p=1;ParaContent(); print "~OW FUCK~ she yells in response, pulling it out immediately and throwing it to the ground in frustration. ~WHAT THE FUCK?!~ she yells at you.  But you aren't paying attention.  You are sitting there with your mouth open at the sight of fur sprouting out of her shoulder. ~Ugh I feel weird..~ she says, rubbing her arm and gasping out loud at the feeling of growing fur.^^~NOOO!~^^The giraffes scatter, and the crowd is murmuring in confusion.  You are just staring at Amy, trying to apologize, as she starts moaning and holding her stomach.  Her hand moves down to her crouch, and her moans grow deeper as small horns form on her head.  ~Caroline I feel sooooo good~ she bellows, staring at you in a very.. dominant way."; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say454; .L_SayX454;
    ! [6: say ~'Don't worry Amy' is all you can say.  But you don't mean it, you have no idea where you are let alone how to fix this. And HOLY SHIT... you can't believe what you are seeing.  Her former hands (now hooves) frantically fumbling with the area, a massive sheathed giraffe dick explodes out her pants, precum leaking out and falling to the ground.^^Amy seems to have forgotten anything else but the need of getting off, her lengthening arms frantically rubbing her new phallus.  You have no idea what to do, but running is sounding good about now.^^Right when you think that, Amy leaps forward and shoves you down to your knees. 'YOU DID THIS, NOW HELP!' her almost animal demand echoing through your ears.  You try to struggle despite your small frame, but its no use.  Amys almost half bull giraffe by now and sexcrazed, and she holds you down, throbbing dick proding your face.  It finds your pursed female lips, and you try to hold them shut as best you can. [pause_clear]~]
    say__p=1;ParaContent(); print "~Don't worry Amy~ is all you can say.  But you don't mean it, you have no idea where you are let alone how to fix this. And HOLY SHIT... you can't believe what you are seeing.  Her former hands (now hooves) frantically fumbling with the area, a massive sheathed giraffe dick explodes out her pants, precum leaking out and falling to the ground.^^Amy seems to have forgotten anything else but the need of getting off, her lengthening arms frantically rubbing her new phallus.  You have no idea what to do, but running is sounding good about now.^^Right when you think that, Amy leaps forward and shoves you down to your knees. ~YOU DID THIS, NOW HELP!~ her almost animal demand echoing through your ears.  You try to struggle despite your small frame, but its no use.  Amys almost half bull giraffe by now and sexcrazed, and she holds you down, throbbing dick proding your face.  It finds your pursed female lips, and you try to hold them shut as best you can. ";ParaContent(); (PHR_928_r9 ()); .L_Say455; .L_SayX455;
    ! [7: say ~You can't hold it for long.. you have to do something. You try to get out something to bring her to her senses but she just shoves her giraffe dick in your mouth the instant you open it. 'FLFURRRRFFFFFF' is all you can say as she fucks your throat.  Tears stream down your throat as you get face fucked, the tourists just standing in shock.^^But then you felt something.  Wetness in your nether regions.  Were you getting turned on?  A earsplitting bellow exploded from Amy as she continued her steady thrusts.  She must be really enjoying the feeling of having a dick, and pounding into your throat.^^All you can do is gag and stay there squatting on the ground being raped by your increasingly bull-giraffe lover.  The thought sends a quick tingle of pleasure through the wetness in your pants, the surprise of it allowing a 'mmmm' to escape the lips that are tight wrapped around the giraffe cock.[pause_clear]~]
    say__p=1;ParaContent(); print "You can't hold it for long.. you have to do something. You try to get out something to bring her to her senses but she just shoves her giraffe dick in your mouth the instant you open it. ~FLFURRRRFFFFFF~ is all you can say as she fucks your throat.  Tears stream down your throat as you get face fucked, the tourists just standing in shock.^^But then you felt something.  Wetness in your nether regions.  Were you getting turned on?  A earsplitting bellow exploded from Amy as she continued her steady thrusts.  She must be really enjoying the feeling of having a dick, and pounding into your throat.^^All you can do is gag and stay there squatting on the ground being raped by your increasingly bull-giraffe lover.  The thought sends a quick tingle of pleasure through the wetness in your pants, the surprise of it allowing a ~mmmm~ to escape the lips that are tight wrapped around the giraffe cock."; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say456; .L_SayX456;
    ! [8: say ~God there it was again.. 'MmmmmMMM' you say, confused by the pleasure, but certainly not disliking it.  You couldn't believe that you were getting turned on by the thought of being raped by a giraffe, especially as a woman.. but you couldn't help it.^^It just felt natural.  You felt your finger exploring the area below you, fumbling for a way into your khakis.  Finding the zipper, you pulled it down, grabbing your panties (and noticing that Caroline was definitely someone who shaved) and pulling them to the side to touch your warm lips.^^You had been with a woman before, and it felt much like when you pleasured them with your curious fingers, but this was something else.  You felt like a agent of reproduction, your hands teasing your unknown, unexplored area, causing the natural lube your body was creating to cover your hands, proof of your extreme need.^^Your male mind.. hell your human mind.. was struggling and fighting a losing battle.  Unknown to you, the quality of the throat fucking you were getting began to return itself, your lips rubbing and moving with the large cock as you got more into it.^^You other hand went down to cup your bull giraffe lovers impressive testicles, softly massaging them.  Amy, now almost half a giraffe, and a male one at that, suddenly tensed with the increased encouragement and smell of your attraction.^^You could feel the balls shake in your hands with a final thrust as your throat was gifted her massive amount of animal cum, all the way down it and into your stomach.  'Mmmmmm' the sound sneaking out of your mouth again, your attraction to this mate driving you nuts.[pause_clear]~]
    say__p=1;ParaContent(); print "God there it was again.. ~MmmmmMMM~ you say, confused by the pleasure, but certainly not disliking it.  You couldn't believe that you were getting turned on by the thought of being raped by a giraffe, especially as a woman.. but you couldn't help it.^^It just felt natural.  You felt your finger exploring the area below you, fumbling for a way into your khakis.  Finding the zipper, you pulled it down, grabbing your panties (and noticing that Caroline was definitely someone who shaved) and pulling them to the side to touch your warm lips.^^You had been with a woman before, and it felt much like when you pleasured them with your curious fingers, but this was something else.  You felt like a agent of reproduction, your hands teasing your unknown, unexplored area, causing the natural lube your body was creating to cover your hands, proof of your extreme need.^^Your male mind.. hell your human mind.. was struggling and fighting a losing battle.  Unknown to you, the quality of the throat fucking you were getting began to return itself, your lips rubbing and moving with the large cock as you got more into it.^^You other hand went down to cup your bull giraffe lovers impressive testicles, softly massaging them.  Amy, now almost half a giraffe, and a male one at that, suddenly tensed with the increased encouragement and smell of your attraction.^^You could feel the balls shake in your hands with a final thrust as your throat was gifted her massive amount of animal cum, all the way down it and into your stomach.  ~Mmmmmm~ the sound sneaking out of your mouth again, your attraction to this mate driving you nuts."; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say457; .L_SayX457;
    ! [9: say ~The you realized what you just did.  And you fall to ground, disgusted beyond belief at yourself, the thought of the massive amount of giraffe cum sitting in your stomach making you feel queasy.  You try to think what you have to do to get out of this nightmare of lust...^^Taking a deep breath you stand up and wheel around, marching across the habitat to what appears to be an exit near the gaping mouthed tourists.  But as you stride, trying to keep yourself composed, your stomach start to growl, a slow soreness spreading from it.  Soon you can hardly walk, stopping to hold your stomach.  That cum may be turning you too, you think in a panic, terrified of the thought of it moving through you, turning you into a female giraffe.  But if that's true that must mean your mouth..^^And as if it was right on cue.. your tongue falls out of your mouth.  No, not out, its just draped down, a bluelish color.  Just like the other giraffes, specifically a still changing Amy.  Which, where is she?  Turning around you can see her walking after you still, her body still changing into a dominant fuck machine.^^Your stomach gurgles again, bringing the feeling of heat to your loins with it. 'Oooooo nooo' you moan, the thought of being pushed over, cheeks spread and fucked like an animal exciting you.  Your pants seem like they hardly fit, and your sexy zookeeper ass, the same ass you definitely did not start the day with, seems to be growing.^^The pain your tight pants are causing is unbearable too.  You have to take them off.  'OW OW OWW' you yelp as they split before you even can, wide long hips with tan and white giraffes fur popping out of them.  You start to scream, trying to run away from your imminent change.^^'NOOOO I don't wanna be a giraffe!' you screamed as your body changes again, a short tail with a small poof of fur on the end extending out of your widening ass.  The cum is changing you, and its changing from the inside... 'UGHHH' you groan as you feel your organs change, your pussy screaming for you to be mounted.[pause_clear]~]
    say__p=1;ParaContent(); print "The you realized what you just did.  And you fall to ground, disgusted beyond belief at yourself, the thought of the massive amount of giraffe cum sitting in your stomach making you feel queasy.  You try to think what you have to do to get out of this nightmare of lust...^^Taking a deep breath you stand up and wheel around, marching across the habitat to what appears to be an exit near the gaping mouthed tourists.  But as you stride, trying to keep yourself composed, your stomach start to growl, a slow soreness spreading from it.  Soon you can hardly walk, stopping to hold your stomach.  That cum may be turning you too, you think in a panic, terrified of the thought of it moving through you, turning you into a female giraffe.  But if that's true that must mean your mouth..^^And as if it was right on cue.. your tongue falls out of your mouth.  No, not out, its just draped down, a bluelish color.  Just like the other giraffes, specifically a still changing Amy.  Which, where is she?  Turning around you can see her walking after you still, her body still changing into a dominant fuck machine.^^Your stomach gurgles again, bringing the feeling of heat to your loins with it. ~Oooooo nooo~ you moan, the thought of being pushed over, cheeks spread and fucked like an animal exciting you.  Your pants seem like they hardly fit, and your sexy zookeeper ass, the same ass you definitely did not start the day with, seems to be growing.^^The pain your tight pants are causing is unbearable too.  You have to take them off.  ~OW OW OWW~ you yelp as they split before you even can, wide long hips with tan and white giraffes fur popping out of them.  You start to scream, trying to run away from your imminent change.^^~NOOOO I don't wanna be a giraffe!~ you screamed as your body changes again, a short tail with a small poof of fur on the end extending out of your widening ass.  The cum is changing you, and its changing from the inside... ~UGHHH~ you groan as you feel your organs change, your pussy screaming for you to be mounted."; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say458; .L_SayX458;
    ! [10: say ~Suddenly you can feel your tail raise, and the absolutely humiliated you drops a large pile of manure. Just another sign you will be an animal soon. 'FAAAAAAAHHH' your attempt at human speech just comes out as a giraffe bellow.  Your mind is racing as your back starts forcing you down onto all fours.^^And then you are saved.  Just floating away from it all, hopefully back to where you first stepped through that portal.  But then you stop, and you realize everything still feels just as... insanely sensitive as it did before.  Fuck, your giraffe neck just grew in, you are still there and very much in heat. 'FAAAAAHHHH' you try to scream, the humiliating feeling of your pussy twisting and growing fatter between your thighs driving you nuts with lust.  [pause_clear]~]
    say__p=1;ParaContent(); print "Suddenly you can feel your tail raise, and the absolutely humiliated you drops a large pile of manure. Just another sign you will be an animal soon. ~FAAAAAAAHHH~ your attempt at human speech just comes out as a giraffe bellow.  Your mind is racing as your back starts forcing you down onto all fours.^^And then you are saved.  Just floating away from it all, hopefully back to where you first stepped through that portal.  But then you stop, and you realize everything still feels just as... insanely sensitive as it did before.  Fuck, your giraffe neck just grew in, you are still there and very much in heat. ~FAAAAAHHHH~ you try to scream, the humiliating feeling of your pussy twisting and growing fatter between your thighs driving you nuts with lust.  ";ParaContent(); (PHR_928_r9 ()); .L_Say459; .L_SayX459;
    ! [11: say ~Trying to fight your increasingly simple urges, all you could think was 'Ohgodohpleaseohgodohplease I can't be fucked into a giraffe.' But your body wanted everything different, your fertile pussy made bare by the lifting of your tail, pheromones driving Amy crazy as she mounted you.^^You cried with pleasure and grief as she... or he plunged into you, and pinned your simple body down, taking you as you came on his cock like the female submissive mate you were. So much for lesbian sex.~]
    say__p=1;ParaContent(); print "Trying to fight your increasingly simple urges, all you could think was ~Ohgodohpleaseohgodohplease I can't be fucked into a giraffe.~ But your body wanted everything different, your fertile pussy made bare by the lifting of your tail, pheromones driving Amy crazy as she mounted you.^^You cried with pleasure and grief as she... or he plunged into you, and pinned your simple body down, taking you as you came on his cock like the female submissive mate you were. So much for lesbian sex."; new_line; .L_Say460; .L_SayX460;
    ! [12: end the story saying ~[bold type]Game Over.  [italic type]'Ummm... Lesbian Giraffes?!'  [roman type]Male Human to Female Giraffe.~]
    deadflag=(TEXT_TY_ExpandIfPerishable(I7SFRAME,TX_S_480)); story_complete=false;
    rfalse;
];
! Request 19: phrase nothing -> nothing
! to say becomeFemaleCamel:
[ PHR_1000_r19  I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_12();
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_12 ;
    ! [1: say ~Turning over vases and checking paintings for secret compartments, you've almost given up hope for finding any cool artifacts back here.  Turning to just go look in the front display case again, you knock over some sort of lamp with your clumsiness, turning to find..^^HOOOOOOLY SHIT.^^'A freakin genie lamp!' you shout in hope that what you think just happened did.  You grab the lamp and rub it without waiting..And to your complete astonishment, your efforts are rewarded. [pause_clear]~]
    say__p=1;ParaContent(); print "Turning over vases and checking paintings for secret compartments, you've almost given up hope for finding any cool artifacts back here.  Turning to just go look in the front display case again, you knock over some sort of lamp with your clumsiness, turning to find..^^HOOOOOOLY SHIT.^^~A freakin genie lamp!~ you shout in hope that what you think just happened did.  You grab the lamp and rub it without waiting..And to your complete astonishment, your efforts are rewarded. ";ParaContent(); (PHR_928_r9 ()); .L_Say461; .L_SayX461;
    ! [2: say ~A genie, grinning eerily and floating above the stream of smoke from his lamp, hovers above you.  'Hello master.' came the twisting introduction, already having you in an uneasy state.  'You can call me Sirthrarth, and I'm here to make your wildest dreams come true!'  Staring at the genie warily, you shake your head in disbelief, not believing this is as good as it appears for a second.^^'What is your wish, master?'~]
    say__p=1;ParaContent(); print "A genie, grinning eerily and floating above the stream of smoke from his lamp, hovers above you.  ~Hello master.~ came the twisting introduction, already having you in an uneasy state.  ~You can call me Sirthrarth, and I'm here to make your wildest dreams come true!~  Staring at the genie warily, you shake your head in disbelief, not believing this is as good as it appears for a second.^^~What is your wish, master?~"; new_line; .L_Say462; .L_SayX462;
    ! [3: say ~'I... I want to be a hero!', you say, figuring that was a solid enough statement that the genie wouldn't 'accidentally' screw you over in some ironic way.'^^The genie smiles and waves his arms, a scabbard appearing at your side, and a small red hat appearing on your head, you clothes turning into robes. [pause_clear]^^'NO! FUCKING STOP THIS SHIT! Fucking genies are just like how they are in film, I want the fucking opposite of what you are going to do, asshole,' You yell, knowing he was going to do something total bullshit.  Frowning then shrugging, waving his arms again, your changes stopping.[pause_clear]~]
    say__p=1;ParaContent(); print "~I... I want to be a hero!~, you say, figuring that was a solid enough statement that the genie wouldn't ~accidentally~ screw you over in some ironic way.~^^The genie smiles and waves his arms, a scabbard appearing at your side, and a small red hat appearing on your head, you clothes turning into robes. ";ParaContent(); (PHR_928_r9 ());ParaContent(); print "^^~NO! FUCKING STOP THIS SHIT! Fucking genies are just like how they are in film, I want the fucking opposite of what you are going to do, asshole,~ You yell, knowing he was going to do something total bullshit.  Frowning then shrugging, waving his arms again, your changes stopping."; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say463; .L_SayX463;
    ! [4: say ~You are just about to breathe a sigh of relief when your robes turn into a flowing dress, your skin turning darker, like a deep brown. 'Na---' you break into coughing as your adams apple shrinks, your face losing its facial hair, your waist shrinking, a really weird sucking feeling where your dick was.. and your hair flowing down as your breasts grow in, the nipple growing as well and sticking against your dress.~]
    say__p=1;ParaContent(); print "You are just about to breathe a sigh of relief when your robes turn into a flowing dress, your skin turning darker, like a deep brown. ~Na---~ you break into coughing as your adams apple shrinks, your face losing its facial hair, your waist shrinking, a really weird sucking feeling where your dick was.. and your hair flowing down as your breasts grow in, the nipple growing as well and sticking against your dress."; new_line; .L_Say464; .L_SayX464;
    ! [5: say ~WHAT THE FUCK?' you yell, really damn pissed at genies and unsurprised a high pitched but female voice had come out.  You run over to a dusty mirror to see what he had done.^^'I'm fucking Princess Jasmine?! From Aladdin?!' you scream at the genie, regreting you ever stepped in here. 'Can you at least help me with one goddamn wish?' Oh crap, your frustration has screwed you over again.  The genie smiles, knowing your third was just said, and waves his arms before disappearing with a poof.^^Sitting in the air is a disembodied dildo, floating like... it was fucking magic.  The dildo shoots through the air, faster then anything you had ever seen, shooting behind you and up under your dress. 'Oh this is just bullshit,' you snort defiantly.  You feel the warmth of a spell hit your new ummm... Jasmine parts and a flash of pink light from under your dress.  And you are instantly swamped with extreme horniness. 'You made me horny, asshole?' you squeal, arching your back subconciously as your sensitive nipples rubbed against your dress.[pause_clear]^^Biting your lip, you feel the dildo rubbing your soft camel toe, your new panties the only thing between it and your new sex.  'Oh!' the feminine gasp escaping your mouth, your mind melting with the pleasure that the simple rubbing is causing you. You look at the soft brown skin of your arms, the womanly curve of your waist, and the long shaved thinness of your legs.^^'Plleaaase, I don't want to be your toy' you whimper, feeling the dildo stop and begin to pull back.  All of a sudden, magical hands pull the panties to the side, and the dildo launches forward, penetrating you. 'AHHH OHHH MY GODDDD' you sputter at the feeling of the dildo pulling in and out of you, your magical lover fucking your new body harder then you expected.[pause_clear] ~]
    say__p=1;ParaContent(); print "WHAT THE FUCK?~ you yell, really damn pissed at genies and unsurprised a high pitched but female voice had come out.  You run over to a dusty mirror to see what he had done.^^~I'm fucking Princess Jasmine?! From Aladdin?!~ you scream at the genie, regreting you ever stepped in here. ~Can you at least help me with one goddamn wish?~ Oh crap, your frustration has screwed you over again.  The genie smiles, knowing your third was just said, and waves his arms before disappearing with a poof.^^Sitting in the air is a disembodied dildo, floating like... it was fucking magic.  The dildo shoots through the air, faster then anything you had ever seen, shooting behind you and up under your dress. ~Oh this is just bullshit,~ you snort defiantly.  You feel the warmth of a spell hit your new ummm... Jasmine parts and a flash of pink light from under your dress.  And you are instantly swamped with extreme horniness. ~You made me horny, asshole?~ you squeal, arching your back subconciously as your sensitive nipples rubbed against your dress."; new_line;ParaContent(); (PHR_928_r9 ());ParaContent(); print "^^Biting your lip, you feel the dildo rubbing your soft camel toe, your new panties the only thing between it and your new sex.  ~Oh!~ the feminine gasp escaping your mouth, your mind melting with the pleasure that the simple rubbing is causing you. You look at the soft brown skin of your arms, the womanly curve of your waist, and the long shaved thinness of your legs.^^~Plleaaase, I don't want to be your toy~ you whimper, feeling the dildo stop and begin to pull back.  All of a sudden, magical hands pull the panties to the side, and the dildo launches forward, penetrating you. ~AHHH OHHH MY GODDDD~ you sputter at the feeling of the dildo pulling in and out of you, your magical lover fucking your new body harder then you expected."; new_line;ParaContent(); (PHR_928_r9 ());ParaContent(); print " "; .L_Say465; .L_SayX465;
    ! [6: say ~Even more humiliating is the genie laughing and pointing out 'Looks like you don't dislike it that much... you're starting to push back against it, slut'.  'Mmmfff' is all you can say in response, your hands teasing and pinching your own breasts. God the genie is making you his Disney princess bitch!^^A beautiful princess... with soft brown skin, long legs and a hourglass shape, your small pear shaped ass jiggling with the repeating penetration of the dildo, your brown nipples erect with the feeling of being alived and being fucked.  'FUCK!' you yell, realized the genie is waving his arms still, his spells apparently changing your thoughts.^^'HaHAAAAA' he laughs, zipping around mischeviously, and apparently very happy with himself.  Breaking into a sneer once again, he asks himself, pretending to be deep in thought 'Hmmm how to humiliate you even more?'[pause_clear]~]
    say__p=1;ParaContent(); print "Even more humiliating is the genie laughing and pointing out ~Looks like you don't dislike it that much... you're starting to push back against it, slut~.  ~Mmmfff~ is all you can say in response, your hands teasing and pinching your own breasts. God the genie is making you his Disney princess bitch!^^A beautiful princess... with soft brown skin, long legs and a hourglass shape, your small pear shaped ass jiggling with the repeating penetration of the dildo, your brown nipples erect with the feeling of being alived and being fucked.  ~FUCK!~ you yell, realized the genie is waving his arms still, his spells apparently changing your thoughts.^^~HaHAAAAA~ he laughs, zipping around mischeviously, and apparently very happy with himself.  Breaking into a sneer once again, he asks himself, pretending to be deep in thought ~Hmmm how to humiliate you even more?~"; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say466; .L_SayX466;
    ! [7: say ~'Oh I know!' he says, snapping his fingers.  Your clothes are gone, your thin, slightly sweaty arabian skin showing.  You can see the fluster of the dildo still banging you, tirelessly working to fuck you silly.  'Hows teets sound?' the genie asks, smacking his hands together.  'Noo..' your voice trails off as your stomach explodes forward, brown breasts growing just over the smooth curve down to your busy vagina.  The nipples keep growing, expanding til they are long skinny animal teets.^^'Whattt are youuuu doiiing' you slurring your question as your tongue changes.  'Why don't you see for yourself!' he answers, summoning a huge mirror into existence right in front of you.  One of the most beautiful women you have ever seen is sitting on the other side... you.^^And besides the gab in between her thighs being taken up by a magical dildo pounding away, her body is changing big time.  The teets below her start to leak small amounts of milk as tan fur grows all over her.  You watch as her beautiful face grows fur and long ears, a tongue falling out of her mouth with the first signs of her growing muzzle.  You are watching yourself turn into a damn camel.[pause_clear]~]
    say__p=1;ParaContent(); print "~Oh I know!~ he says, snapping his fingers.  Your clothes are gone, your thin, slightly sweaty arabian skin showing.  You can see the fluster of the dildo still banging you, tirelessly working to fuck you silly.  ~Hows teets sound?~ the genie asks, smacking his hands together.  ~Noo..~ your voice trails off as your stomach explodes forward, brown breasts growing just over the smooth curve down to your busy vagina.  The nipples keep growing, expanding til they are long skinny animal teets.^^~Whattt are youuuu doiiing~ you slurring your question as your tongue changes.  ~Why don't you see for yourself!~ he answers, summoning a huge mirror into existence right in front of you.  One of the most beautiful women you have ever seen is sitting on the other side... you.^^And besides the gab in between her thighs being taken up by a magical dildo pounding away, her body is changing big time.  The teets below her start to leak small amounts of milk as tan fur grows all over her.  You watch as her beautiful face grows fur and long ears, a tongue falling out of her mouth with the first signs of her growing muzzle.  You are watching yourself turn into a damn camel."; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say467; .L_SayX467;
    ! [8: say ~Your feet started to cramp, like your boots had shrunk three sizes.  You reached down to remove your heels, but your hands couldn't seem to grasp the laces.  The pain was increasing in your feet as you fumble with the laces, a ripping sound making you jump.  The soft silk fabric was tearing.  Your boots weren't shrinking...  Your feet were swelling.^^You couldn't believe your eyes as your now enormous toes burst free from the material.  Now free from your heels your feet didn't hurt as much, but your feet continued to grow.  You stared in disbelief as your two middle toes and the last two toes on your foot swelled and merged together.^^^You try to stand but only fell to your knees.  Pushing yourself up, you noticed that your fingers were swelling as well.  Forming your once dainty fingers into short, stubby toes.^^By this time your arms and legs ached like you just ran a marathon while carrying lead weights in both hands.  The aching soon turned to a tugging sensation.  A dull ache also began to emanate from your back.   'PLEASE I DONT WANT TO BE AN ANIMAL' you screamed at the still sneering genie.[pause_clear] ~]
    say__p=1;ParaContent(); print "Your feet started to cramp, like your boots had shrunk three sizes.  You reached down to remove your heels, but your hands couldn't seem to grasp the laces.  The pain was increasing in your feet as you fumble with the laces, a ripping sound making you jump.  The soft silk fabric was tearing.  Your boots weren't shrinking...  Your feet were swelling.^^You couldn't believe your eyes as your now enormous toes burst free from the material.  Now free from your heels your feet didn't hurt as much, but your feet continued to grow.  You stared in disbelief as your two middle toes and the last two toes on your foot swelled and merged together.^^^You try to stand but only fell to your knees.  Pushing yourself up, you noticed that your fingers were swelling as well.  Forming your once dainty fingers into short, stubby toes.^^By this time your arms and legs ached like you just ran a marathon while carrying lead weights in both hands.  The aching soon turned to a tugging sensation.  A dull ache also began to emanate from your back.   ~PLEASE I DONT WANT TO BE AN ANIMAL~ you screamed at the still sneering genie."; new_line;ParaContent(); (PHR_928_r9 ());ParaContent(); print " "; .L_Say468; .L_SayX468;
    ! [9: say ~You quiet down and stare in stunned silence as your arms and legs begin to elongate.  Closing your teary eyes, you prayed that it would stop.  Four loud snaps shook you from your prayers.  At first you thought the noises were gunshots, some sort of hero (hell maybe Aladin) coming to save your pretty indian butt, but to your dismay, you realized that your elbows and knees had reversed their normal direction.^^Weakly, you raised an arm and flexed the now foreign appendage.  You stare at your arm as it bent in the opposite direction than it should.^^Fur continued to sprout from your misshapen features.  Short, thick, dark brown hair was growing all over your body.  Even though you was soon covered in fur, you were oddly cool.^^The ache in your back had spread down to your tailbone and up to your neck, and it seemed almost too much pain to take.  No matter how you tried to turn, it persisted.  More ripping sounds made you look around quickly.  The ripping sound was coming from the fabric around your now enormous hips and shoulders.  [pause_clear] ~]
    say__p=1;ParaContent(); print "You quiet down and stare in stunned silence as your arms and legs begin to elongate.  Closing your teary eyes, you prayed that it would stop.  Four loud snaps shook you from your prayers.  At first you thought the noises were gunshots, some sort of hero (hell maybe Aladin) coming to save your pretty indian butt, but to your dismay, you realized that your elbows and knees had reversed their normal direction.^^Weakly, you raised an arm and flexed the now foreign appendage.  You stare at your arm as it bent in the opposite direction than it should.^^Fur continued to sprout from your misshapen features.  Short, thick, dark brown hair was growing all over your body.  Even though you was soon covered in fur, you were oddly cool.^^The ache in your back had spread down to your tailbone and up to your neck, and it seemed almost too much pain to take.  No matter how you tried to turn, it persisted.  More ripping sounds made you look around quickly.  The ripping sound was coming from the fabric around your now enormous hips and shoulders.  ";ParaContent(); (PHR_928_r9 ());ParaContent(); print " "; .L_Say469; .L_SayX469;
    ! [10: say ~It felt like your entire body was swelling.  You tried to peer over your shoulders at your back, but something was blocking your view.  It was your shirt.  But that was impossible; you were standing on all fours.  Your shirt should be hanging down, not up.^^The ache in your neck was intense, and you wanted to rub your neck but knew that was impossible.  So you did the only thing you could, straining your neck as hard as you could forward to try and ease the pain. Your neck started to feel better, so you stretched more.  After four more really good stretches, you realized why it felt so good.  your muscles weren't stretching, your neck was, now looking like it was over two feet long.^^How can this be,' you think to yourself, 'this is impossible.'   With your now elongated neck, you could now easily see over your shirt.  What you saw made your jaw drop.  The ragged material of your shirt hung limply off an enormous hump.  Then something flashed behind you.  Looking back at your immense ass trying to see what moved, you tremble in confusion as no matter how hard you look, nothing is there..[pause_clear] ~]
    say__p=1;ParaContent(); print "It felt like your entire body was swelling.  You tried to peer over your shoulders at your back, but something was blocking your view.  It was your shirt.  But that was impossible; you were standing on all fours.  Your shirt should be hanging down, not up.^^The ache in your neck was intense, and you wanted to rub your neck but knew that was impossible.  So you did the only thing you could, straining your neck as hard as you could forward to try and ease the pain. Your neck started to feel better, so you stretched more.  After four more really good stretches, you realized why it felt so good.  your muscles weren't stretching, your neck was, now looking like it was over two feet long.^^How can this be,~ you think to yourself, ~this is impossible.~   With your now elongated neck, you could now easily see over your shirt.  What you saw made your jaw drop.  The ragged material of your shirt hung limply off an enormous hump.  Then something flashed behind you.  Looking back at your immense ass trying to see what moved, you tremble in confusion as no matter how hard you look, nothing is there.."; new_line;ParaContent(); (PHR_928_r9 ());ParaContent(); print " "; .L_Say470; .L_SayX470;
    ! [11: say ~As you continued to stare at your backside, two more loud cracks made your jump.  Your butt looked thinner now for some reason.  In a gasp of shock, you realized that both your hips and shoulders had snapped inside your body.  Twisting them to more comfortably hold your new bulk.^^Something flashed behind your again.   What IS that?  you wondered.  The object swished again behind you.  It was then that you realized that you was looking at your new tail.  With a little concentration you was able to swing it from side to side.^^When you raised it straight up in the air, a loud blast emanated from your ass. You just farted, once a man, then a realistic version of a Disney princess, humbled into a disgusting camel.  A great stench arose from behind you that made your flinch.  Even the genie seemed a bit grossed out, or he was just covering his mouth to hold back his mocking laughter.[pause_clear] ~]
    say__p=1;ParaContent(); print "As you continued to stare at your backside, two more loud cracks made your jump.  Your butt looked thinner now for some reason.  In a gasp of shock, you realized that both your hips and shoulders had snapped inside your body.  Twisting them to more comfortably hold your new bulk.^^Something flashed behind your again.   What IS that?  you wondered.  The object swished again behind you.  It was then that you realized that you was looking at your new tail.  With a little concentration you was able to swing it from side to side.^^When you raised it straight up in the air, a loud blast emanated from your ass. You just farted, once a man, then a realistic version of a Disney princess, humbled into a disgusting camel.  A great stench arose from behind you that made your flinch.  Even the genie seemed a bit grossed out, or he was just covering his mouth to hold back his mocking laughter."; new_line;ParaContent(); (PHR_928_r9 ());ParaContent(); print " "; .L_Say471; .L_SayX471;
    ! [12: say ~You try to scream, but can't, as your lips are heavy and not responding the way they should.  You clearly saw that your lips were strangely swollen and sagging.   Wait a minute,  you thought.   I shouldn t be able to see my lips like this.   Then you noticed your nose, it too looked swollen, but flat.  You could see your jaw extend away from your face.^^The loose skin of your lips now pulled tighter against your jaw.  Your teeth jutted out from under your split front lip.   So much for the clean even teeth of a princess, you think to yourself.^^A strange shadow descended upon you misshapen features.  You couldn t quite see what it was.  Stumbling as best you could on your new legs, you went to peer at your reflection in the pool of water.  Wait a pool of water?  You let out a camel snort of disbelief as you've been whisked away to what appears to be a oasis in the middle of the sahara.^^Looking back at your from the water was the face of a camel with dirty, blonde hair.  You look around frantically hoping that it wasn't you that was looking back at you from the waters reflection.  But it was, the reflection showing you that you were only an animal now.[pause_clear] ~]
    say__p=1;ParaContent(); print "You try to scream, but can't, as your lips are heavy and not responding the way they should.  You clearly saw that your lips were strangely swollen and sagging.   Wait a minute,  you thought.   I shouldn t be able to see my lips like this.   Then you noticed your nose, it too looked swollen, but flat.  You could see your jaw extend away from your face.^^The loose skin of your lips now pulled tighter against your jaw.  Your teeth jutted out from under your split front lip.   So much for the clean even teeth of a princess, you think to yourself.^^A strange shadow descended upon you misshapen features.  You couldn t quite see what it was.  Stumbling as best you could on your new legs, you went to peer at your reflection in the pool of water.  Wait a pool of water?  You let out a camel snort of disbelief as you've been whisked away to what appears to be a oasis in the middle of the sahara.^^Looking back at your from the water was the face of a camel with dirty, blonde hair.  You look around frantically hoping that it wasn't you that was looking back at you from the waters reflection.  But it was, the reflection showing you that you were only an animal now."; new_line;ParaContent(); (PHR_928_r9 ());ParaContent(); print " "; .L_Say472; .L_SayX472;
    ! [13: say ~You stood as straight up as you could and began to look yourself over, hoping to see something of your lost humanity.  All you saw were the tatters of what used to be your clothing.^^You even tried to scream in despair, but all that came out of your long mouth was what sounded like a long, low belch.  You wanted to cry, but the tears wouldn t come from your eyes.  That would waste water. Wait, why did you think that?^^'What do I do now?', trying to form a plan in your mind.  A low grunt from your right made your realize you weren't alone.  The genie had summoned another camel? Then the camel winked at you, a familiar sneer appearing on his face.  He was the camel now...What did he want?^^As if in response, the former genie, now camel, crossed behind you and shoved his snout in your backside, sniffing at your reshaped vagina.  Subconsciously, your tail rose as a musky smell emanated from your new reproductive organs.   What the hell am I doing?  you scream at yourself.[pause_clear] ~]
    say__p=1;ParaContent(); print "You stood as straight up as you could and began to look yourself over, hoping to see something of your lost humanity.  All you saw were the tatters of what used to be your clothing.^^You even tried to scream in despair, but all that came out of your long mouth was what sounded like a long, low belch.  You wanted to cry, but the tears wouldn t come from your eyes.  That would waste water. Wait, why did you think that?^^~What do I do now?~, trying to form a plan in your mind.  A low grunt from your right made your realize you weren't alone.  The genie had summoned another camel? Then the camel winked at you, a familiar sneer appearing on his face.  He was the camel now...What did he want?^^As if in response, the former genie, now camel, crossed behind you and shoved his snout in your backside, sniffing at your reshaped vagina.  Subconsciously, your tail rose as a musky smell emanated from your new reproductive organs.   What the hell am I doing?  you scream at yourself."; new_line;ParaContent(); (PHR_928_r9 ());ParaContent(); print " "; .L_Say473; .L_SayX473;
    ! [14: say ~You looked behind you at the male camel and noticed its long penis emerge from the folds of skin between its long hind legs.  You couldn t look anymore, knowing what was about to happen.  You squeezed your eyes shut as hard as you possibly could.^^With a loud grunt, the male camel mounted you.  His heavy weight threatening to crush your back legs.  The males penis quickly found your moist vagina and was thrust roughly inside.  You stretched your neck in pain.  A loud throaty growl reverberated from yourmouth.^^The camel's penis was so huge; it felt like it would rip your in two.  With a final thrust, the male spurted his seed inside you, fertilizing your eggs. To your relief, the mating was quick and the male jumped off.~]
    say__p=1;ParaContent(); print "You looked behind you at the male camel and noticed its long penis emerge from the folds of skin between its long hind legs.  You couldn t look anymore, knowing what was about to happen.  You squeezed your eyes shut as hard as you possibly could.^^With a loud grunt, the male camel mounted you.  His heavy weight threatening to crush your back legs.  The males penis quickly found your moist vagina and was thrust roughly inside.  You stretched your neck in pain.  A loud throaty growl reverberated from yourmouth.^^The camel's penis was so huge; it felt like it would rip your in two.  With a final thrust, the male spurted his seed inside you, fertilizing your eggs. To your relief, the mating was quick and the male jumped off."; new_line; .L_Say474; .L_SayX474;
    ! [15: end the story saying ~[bold type]Game Over.  [italic type]'Dont Spit'  [roman type]Male Human to Female Camel.~]
    deadflag=(TEXT_TY_ExpandIfPerishable(I7SFRAME,TX_S_481)); story_complete=false;
    rfalse;
];
! Request 20: phrase nothing -> nothing
! to say talkWithMeredith:
[ PHR_1020_r20  ;
    ! [1: say ~Ah, where you work. As you walked in you could see the familiar desks in your small downtown office, the darkness of the office tranquil and quiet. Finally some peace from the chaos outside. You run over to your desk, switching on your computer..^^*BAM*^^The noise of something falling echoes from the room over, its unexpected volume causing you to jump and warily take cover behind your desk. A voice echoes from the room, 'Get out of here, thief! Find your own place!' Wait a second.. You know that voice. '..Meredith?' You ask. The cute intern pokes her head around the corner, her blonde hair streaming down her shoulders. 'Oh thank god its you..' she says, visibly relieved. She runs over to hug you, trembling still. 'Have you been hiding here?!' You ask, amazed.[pause_clear]~]
    say__p=1;ParaContent(); print "Ah, where you work. As you walked in you could see the familiar desks in your small downtown office, the darkness of the office tranquil and quiet. Finally some peace from the chaos outside. You run over to your desk, switching on your computer..^^*BAM*^^The noise of something falling echoes from the room over, its unexpected volume causing you to jump and warily take cover behind your desk. A voice echoes from the room, ~Get out of here, thief! Find your own place!~ Wait a second.. You know that voice. ~..Meredith?~ You ask. The cute intern pokes her head around the corner, her blonde hair streaming down her shoulders. ~Oh thank god its you..~ she says, visibly relieved. She runs over to hug you, trembling still. ~Have you been hiding here?!~ You ask, amazed."; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say475; .L_SayX475;
    ! [2: say ~'Yeah.. Its been rough. I came in today to finish some work, and when I was leaving the building I saw some sort of woman.. Attack a man. She turned him into a damn pig and then started going down the street turning others into various animals, it was horrible!'. You can see the exhaustion on her pretty face. 'i barely escaped myself, ran back up here and hid. I tried to call the cops, but they said it was happening everywhere!'. She started sobbing, tucking her head into the crook of your arm. 'Hey its okay', trying to comfort her, 'i made it all the way here just fine, we can get out of here.' She pulled back, shaking her head 'No.. That's not it.. I umm.. Didn't really completely escape the women..' She broke down sobbing again, her trembling hand moving down to the bottom of her sweater. 'please don't laugh' she begged you, her voice still trembling, tears rolling down her beautiful face. You nodded, trying to keep as reassuring of a face as you could.~]
    say__p=1;ParaContent(); print "~Yeah.. Its been rough. I came in today to finish some work, and when I was leaving the building I saw some sort of woman.. Attack a man. She turned him into a damn pig and then started going down the street turning others into various animals, it was horrible!~. You can see the exhaustion on her pretty face. ~i barely escaped myself, ran back up here and hid. I tried to call the cops, but they said it was happening everywhere!~. She started sobbing, tucking her head into the crook of your arm. ~Hey its okay~, trying to comfort her, ~i made it all the way here just fine, we can get out of here.~ She pulled back, shaking her head ~No.. That's not it.. I umm.. Didn't really completely escape the women..~ She broke down sobbing again, her trembling hand moving down to the bottom of her sweater. ~please don't laugh~ she begged you, her voice still trembling, tears rolling down her beautiful face. You nodded, trying to keep as reassuring of a face as you could."; new_line; .L_Say476; .L_SayX476;
    ! [3: if a random chance of 1 in 3 succeeds , say meredithdog]
    if (((GenerateRandomNumber(1, 3) <= 1))) { say__p=1;ParaContent(); (PHR_1024_r145 ()); .L_Say477; .L_SayX477; }
    ! [4: otherwise say meredithelse]
    else { say__p=1;ParaContent(); (PHR_1021_r142 ()); .L_Say478; .L_SayX478; }
    rfalse;
];
! Request 21: phrase nothing -> nothing
! to say becomeHog:
[ PHR_1016_r21  ;
    ! [1: say ~You dive into the meal in front of you, fulfilling your intense hunger by chowing down on all the junk food.~]
    say__p=1;ParaContent(); print "You dive into the meal in front of you, fulfilling your intense hunger by chowing down on all the junk food."; new_line; .L_Say479; .L_SayX479;
    rfalse;
];
! Request 22: phrase nothing -> nothing
! to say cutTripwire:
[ PHR_972_r22  ;
    ! [1: say ~There are three wires in front of you, one in red, one in green, and one in blue.  You gotta think fast before you set it off, which wires do you cut?~]
    say__p=1;ParaContent(); print "There are three wires in front of you, one in red, one in green, and one in blue.  You gotta think fast before you set it off, which wires do you cut?"; new_line; .L_Say480; .L_SayX480;
    ! [2: if the player consents begin]
    if ((YesOrNo())){
        ! [3: say ~The supply room was empty.  What a waste... you wonder where you would be if you had set off that trip wire.~]
        say__p=1;ParaContent(); print "The supply room was empty.  What a waste... you wonder where you would be if you had set off that trip wire."; new_line; .L_Say481; .L_SayX481;
        ! [4: otherwise]
        } else {

        ! [5: say ~The alarm goes off... and no one comes.  You sigh a breath of relief and turn back to the supply room.^^SNAP!  A twig snaps behind you, scaring the shit outta you.  You swing around to see...~]
        say__p=1;ParaContent(); print "The alarm goes off... and no one comes.  You sigh a breath of relief and turn back to the supply room.^^SNAP!  A twig snaps behind you, scaring the shit outta you.  You swing around to see..."; new_line; .L_Say482; .L_SayX482;
        ! [6: say becomefemaleskunk]
        say__p=1;ParaContent(); (PHR_999_r131 ()); .L_Say483; .L_SayX483;
        ! [7: end if]
        }

        rfalse;
];
! Request 23: phrase nothing -> nothing
! to say becomeFeralElephant:
[ PHR_992_r23  I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_13();
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_13 ;
    ! [1: say ~As the chanting grows louder, you can feel your body stir unnaturally.  Your penis, seemingly chosing the most annoying time to do so, swells with blood, soon fully erect and pressing against the front of your jeans.^^Well this is a rather good feeling, you think, overwhelmed with pleasure.  Images of beautiful women shoot through your mind (well... even more then usual), the thought of the female form showering you with wondrous amounts of dopamine and pleasure.^^You can't think of anything else, actually.  God.. if only your girlfriend was here, you would love to eat her warm pussy out, shoving your nose into her asshole as you orally pleasure her.  The thought of her in estrus, her large pussy ready to accomodate your mischevious trunk..^^'Wait, what?!' you say outside, realizing you had just imagined your girlfriend as a beautiful elephant mate.  Shaking your head, your try to shove the weird thoughts aside, thinking it must have just been reading the word 'elephant' so much since entering this coven.[pause_clear]~]
    say__p=1;ParaContent(); print "As the chanting grows louder, you can feel your body stir unnaturally.  Your penis, seemingly chosing the most annoying time to do so, swells with blood, soon fully erect and pressing against the front of your jeans.^^Well this is a rather good feeling, you think, overwhelmed with pleasure.  Images of beautiful women shoot through your mind (well... even more then usual), the thought of the female form showering you with wondrous amounts of dopamine and pleasure.^^You can't think of anything else, actually.  God.. if only your girlfriend was here, you would love to eat her warm pussy out, shoving your nose into her asshole as you orally pleasure her.  The thought of her in estrus, her large pussy ready to accomodate your mischevious trunk..^^~Wait, what?!~ you say outside, realizing you had just imagined your girlfriend as a beautiful elephant mate.  Shaking your head, your try to shove the weird thoughts aside, thinking it must have just been reading the word ~elephant~ so much since entering this coven."; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say484; .L_SayX484;
    ! [2: say ~You shift uncomfortably as your dick is pressing harder and harder against the front of your pants, making you curse with frustration.  Your only choice is to pull down your pants, yanking your underwear with them to free up... Oh my god.^^You expected to see your average sized, healthy colored dick... but its changed completely. It's erection is still wrinkly, and as you reach down to touch it you realize a sheath was beginning to form around it.  An animal sheath.^^You haven't ever seen the dick of bull elephant, and frankly never wanted to.. but it appears you will be seeing one soon.  Well.. fuck, the thought the herald of anxiety at the thought of being nothing more then an animal.  You feel pleasure shoot through you, a groan uncontrollably slipping through your lips.^^Looking down you can see it because your hands had been feeling, touching, stroking your transforming penis.  Like they had a mind of their own.  The sheath has almost covered the entire length of your, its hue moving to a dark grey.^^'Noo... please' you moan in desperation as your balls swell, close to completing your unwilling transformation into the animal this coven has made their worshipped entity.[pause_clear]~]
    say__p=1;ParaContent(); print "You shift uncomfortably as your dick is pressing harder and harder against the front of your pants, making you curse with frustration.  Your only choice is to pull down your pants, yanking your underwear with them to free up... Oh my god.^^You expected to see your average sized, healthy colored dick... but its changed completely. It's erection is still wrinkly, and as you reach down to touch it you realize a sheath was beginning to form around it.  An animal sheath.^^You haven't ever seen the dick of bull elephant, and frankly never wanted to.. but it appears you will be seeing one soon.  Well.. fuck, the thought the herald of anxiety at the thought of being nothing more then an animal.  You feel pleasure shoot through you, a groan uncontrollably slipping through your lips.^^Looking down you can see it because your hands had been feeling, touching, stroking your transforming penis.  Like they had a mind of their own.  The sheath has almost covered the entire length of your, its hue moving to a dark grey.^^~Noo... please~ you moan in desperation as your balls swell, close to completing your unwilling transformation into the animal this coven has made their worshipped entity."; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say485; .L_SayX485;
    ! [3: say ~You can hear voices... chanting?  Are the witches in here with you doing this?  In desperation you wheel around, searching for some source of this terrifying magic.As you do, the chanting increases in pace and volume, accelerating your change.^^Your body grows, a stringy tail dropping out behind you, your shirt ripping off you as you grow bloated and huge.  You can feel your tail smacking your ass, its purpose to swat flies away like the elephants you saw at the zoo as a kid.^^Your sheath sucks up onto your stomach, attaching itself to your torso as your posture is trying to force you on all fours.  You can feel it stir, the thoughts of female elephants creeping itself back into your thoughts, an erection soon sprouting out of you.^^And its enormous, the top splirting out a small amount of precum in ancticipation.'Noooeeeeeeerrrfffff' you try to whimper, turning into a bellow as your face sprouts out in front of you, your nose lengthening into trunk and your ears growing mammoth in scale.~]
    say__p=1;ParaContent(); print "You can hear voices... chanting?  Are the witches in here with you doing this?  In desperation you wheel around, searching for some source of this terrifying magic.As you do, the chanting increases in pace and volume, accelerating your change.^^Your body grows, a stringy tail dropping out behind you, your shirt ripping off you as you grow bloated and huge.  You can feel your tail smacking your ass, its purpose to swat flies away like the elephants you saw at the zoo as a kid.^^Your sheath sucks up onto your stomach, attaching itself to your torso as your posture is trying to force you on all fours.  You can feel it stir, the thoughts of female elephants creeping itself back into your thoughts, an erection soon sprouting out of you.^^And its enormous, the top splirting out a small amount of precum in ancticipation.~Noooeeeeeeerrrfffff~ you try to whimper, turning into a bellow as your face sprouts out in front of you, your nose lengthening into trunk and your ears growing mammoth in scale."; new_line; .L_Say486; .L_SayX486;
    ! [4: say ~You can't help but fall on all fours, your mind racing to try to find a way out from ending up as a bull elephant for the rest of your life.  Oh god what are you going to do? You can't be an animal, and definitely not a fat ugly elephant.^^You snort out of your new trunk in frustration as your fingers disappear into giant clubbed hooves, the feeling of your tail brushing your enormous scrotum becoming more and more normal.  Your mind must be slipping, so you try to remember everything you can.  Your girlfriend, your life, how you got here.^^It starts to slow though, thoughts of the warm pussies of beautiful female elephants trickling into your mind, stirring your elephantine erection even more, bringing you to a sudden spasm as you nearly lose your vision with so much pleasure, the sound of elephant cum splattering the concrete realizing you are fighting a losing battle.^^NOOOO fuck this you can ERRRRRRFFF, the sound of a bull elephant bellowing out of your mouth.  You gotta stay human, you gottttaaa errrrrrrrfffffffffFFFFFFFFFF your thoughts can't stay togeth-rrr gottta fuucccckk GOTTA FUCKKKKERRRFFFFFFFFF.~]
    say__p=1;ParaContent(); print "You can't help but fall on all fours, your mind racing to try to find a way out from ending up as a bull elephant for the rest of your life.  Oh god what are you going to do? You can't be an animal, and definitely not a fat ugly elephant.^^You snort out of your new trunk in frustration as your fingers disappear into giant clubbed hooves, the feeling of your tail brushing your enormous scrotum becoming more and more normal.  Your mind must be slipping, so you try to remember everything you can.  Your girlfriend, your life, how you got here.^^It starts to slow though, thoughts of the warm pussies of beautiful female elephants trickling into your mind, stirring your elephantine erection even more, bringing you to a sudden spasm as you nearly lose your vision with so much pleasure, the sound of elephant cum splattering the concrete realizing you are fighting a losing battle.^^NOOOO fuck this you can ERRRRRRFFF, the sound of a bull elephant bellowing out of your mouth.  You gotta stay human, you gottttaaa errrrrrrrfffffffffFFFFFFFFFF your thoughts can't stay togeth-rrr gottta fuucccckk GOTTA FUCKKKKERRRFFFFFFFFF."; new_line; .L_Say487; .L_SayX487;
    ! [5: end the story saying ~A massive amount of manure splurts out of your new fat elephant ass, your personality gone forever, wiped away completely by your new urges to mate and impregnate all the females you can find.^^[bold type]Game Over.  [italic type]'Size Increase'  [roman type]Male Human to Bull Elephant.~]
    deadflag=(TEXT_TY_ExpandIfPerishable(I7SFRAME,TX_S_482)); story_complete=false;
    rfalse;
];
! Request 24: phrase nothing -> nothing
! to say becomeFemaleFrog:
[ PHR_996_r24  I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_14();
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_14 ;
    ! [1: say ~Reaching down to touch it, you sense you are being watched.  You turn to find a rather.. busty woman in a dark corset and skirt standing there, her lips smacking as she apparently is chewing on some gum.^^'You dare touch something so sacred?!' her scream raining down on you in terrifying measure.  Then she begins to laugh, continuing to chew on her gum and blowing a large bubble.  'I'm just kidding, young'in.' she says, even though she looks to be only a little older then you.  'Though, about it being sacred.' she continued, 'but I will be honest with you, Im going to turn you into a frog, so get ready to birth some children, froggie!'[pause_clear].~]
    say__p=1;ParaContent(); print "Reaching down to touch it, you sense you are being watched.  You turn to find a rather.. busty woman in a dark corset and skirt standing there, her lips smacking as she apparently is chewing on some gum.^^~You dare touch something so sacred?!~ her scream raining down on you in terrifying measure.  Then she begins to laugh, continuing to chew on her gum and blowing a large bubble.  ~I'm just kidding, young'in.~ she says, even though she looks to be only a little older then you.  ~Though, about it being sacred.~ she continued, ~but I will be honest with you, Im going to turn you into a frog, so get ready to birth some children, froggie!~"; new_line;ParaContent(); (PHR_928_r9 ());ParaContent(); print "."; new_line; .L_Say488; .L_SayX488;
    ! [2: if player is male begin]
    if ((((Adj_82_t1_v10(player))))){
        ! [3: say ~Absolutely terrified and baffled by the sight, you are brought back into reality by the voice of Courtney screaming for your help.  Twisting about in stumbling astounded fashion, you can see the formally-human shape of Becca thrusting on top of a prostrate Courtney.^^Beccas beautiful face now sported bulging eyes, while her groin area featured a slimy appendage being forcefully shoved against Courtneys jeans.  What can you do?  How do you even proceed? is all your mind is grasping at, as your stomach rumbles.^^And rumbles, and PLOP! The sound is nearly as disturbing as the feeling.  You scream as your realize that your pride and joy, or well... dick and balls... have sucked up into you in a instant.  Your male mind desperately tries to grasp at what could be happening, as pleasure emanates from whatever resides in your pants now.^^Fuck it, nothing matters more then the change that's happening, the single thought wiping all others from your mind.  You rip down your shorts to witness the proud presence of a... pussy?^^Ohhhh nooooo you begin to think before the quaking of your new genitalia surprises you, it's apparent hacking and heaving growing stronger at the same rate as the shots of pleasure wiring through you.  In one last heave, your new lusty hole spreads open...[pause_clear]~]
        say__p=1;ParaContent(); print "Absolutely terrified and baffled by the sight, you are brought back into reality by the voice of Courtney screaming for your help.  Twisting about in stumbling astounded fashion, you can see the formally-human shape of Becca thrusting on top of a prostrate Courtney.^^Beccas beautiful face now sported bulging eyes, while her groin area featured a slimy appendage being forcefully shoved against Courtneys jeans.  What can you do?  How do you even proceed? is all your mind is grasping at, as your stomach rumbles.^^And rumbles, and PLOP! The sound is nearly as disturbing as the feeling.  You scream as your realize that your pride and joy, or well... dick and balls... have sucked up into you in a instant.  Your male mind desperately tries to grasp at what could be happening, as pleasure emanates from whatever resides in your pants now.^^Fuck it, nothing matters more then the change that's happening, the single thought wiping all others from your mind.  You rip down your shorts to witness the proud presence of a... pussy?^^Ohhhh nooooo you begin to think before the quaking of your new genitalia surprises you, it's apparent hacking and heaving growing stronger at the same rate as the shots of pleasure wiring through you.  In one last heave, your new lusty hole spreads open..."; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say489; .L_SayX489;
        ! [4: say ~'Ohhhhhhh' you squeak in a surprisingly feminine gasp.  'What's happening to meeee?'  Your breasts are so sensitive, the nipples sticking out against your shirt.^^Wait what, you have breasts now?!  And at that moment your gaping feminine hole spews out a massive amount of small clear spheres, forcing a mindblowing orgasm on your sensitive new body.^^A frog clutch.  You had just spewed a frog clutch onto the ground from your new... body.  Which was still changing, and soooo so sensitive.  Suddenl you couldn't stop thinking about yourself.. and males. And letting them crawl on you and pounding your tight frog puss- 'WHOA' you croaked, shocked by Beccas presence shoving you down to the ground and breaking your trance.^^She.. he was on you in a second, shoving your face into the ground and what must be a finger into each hole your squelching holes.[pause_clear]~]
        say__p=1;ParaContent(); print "~Ohhhhhhh~ you squeak in a surprisingly feminine gasp.  ~What's happening to meeee?~  Your breasts are so sensitive, the nipples sticking out against your shirt.^^Wait what, you have breasts now?!  And at that moment your gaping feminine hole spews out a massive amount of small clear spheres, forcing a mindblowing orgasm on your sensitive new body.^^A frog clutch.  You had just spewed a frog clutch onto the ground from your new... body.  Which was still changing, and soooo so sensitive.  Suddenl you couldn't stop thinking about yourself.. and males. And letting them crawl on you and pounding your tight frog puss- ~WHOA~ you croaked, shocked by Beccas presence shoving you down to the ground and breaking your trance.^^She.. he was on you in a second, shoving your face into the ground and what must be a finger into each hole your squelching holes."; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say490; .L_SayX490;
        ! [5: say ~You have never been more humiliated in your life.  Becca was fingerfucking you like mad, your new frog pussy spewing all sorts of juices as you cried and moaned in uncontrollable lust.  'Please...' you begged her, pleading for her to stop, and not sure you really meant it.  Little did you know that it was the last thing you were going to say as a human.^^'RIBBITTTT' your throat convulsed unexpectedly.  Oh god oh fuck, your mind racing, I have to do something.  The floor was rushing up to meet you though, your only option to bend your legs, stick your ass out and catch yourself with your hands.^^And there you sat, with a girl pleasuring your new animal love hole, you on the ground LIKE a frog, and feeling a lot like one as well.  'RIBBBBBIT' you croaked again as your stomach rumbled, a familiar feeling coming to you again.^^Becca was just able to move her hand before you birthed another pile of spawn, your pussy making a noticeable PLBBBBBBPPPLPPPPP noise as it shuddered with a massive orgasm.  You sat there, eyes out to the side of your head, the finishing changes happening as you kept orgasming beyond belief.^^The last thought through your head was one of wishing you were something more graceful then a breeding frog.. but it was lost as Becca shoved her fist back into your hole, wiping your humanity from your mind, and sealing your fate as a female frog forever.~]
        say__p=1;ParaContent(); print "You have never been more humiliated in your life.  Becca was fingerfucking you like mad, your new frog pussy spewing all sorts of juices as you cried and moaned in uncontrollable lust.  ~Please...~ you begged her, pleading for her to stop, and not sure you really meant it.  Little did you know that it was the last thing you were going to say as a human.^^~RIBBITTTT~ your throat convulsed unexpectedly.  Oh god oh fuck, your mind racing, I have to do something.  The floor was rushing up to meet you though, your only option to bend your legs, stick your ass out and catch yourself with your hands.^^And there you sat, with a girl pleasuring your new animal love hole, you on the ground LIKE a frog, and feeling a lot like one as well.  ~RIBBBBBIT~ you croaked again as your stomach rumbled, a familiar feeling coming to you again.^^Becca was just able to move her hand before you birthed another pile of spawn, your pussy making a noticeable PLBBBBBBPPPLPPPPP noise as it shuddered with a massive orgasm.  You sat there, eyes out to the side of your head, the finishing changes happening as you kept orgasming beyond belief.^^The last thought through your head was one of wishing you were something more graceful then a breeding frog.. but it was lost as Becca shoved her fist back into your hole, wiping your humanity from your mind, and sealing your fate as a female frog forever."; new_line; .L_Say491; .L_SayX491;
        ! [6: end the story saying ~[bold type]Game Over.  [italic type]'PLBBBBBPPPP'  [roman type]Male Human to Female Frog.~]
        deadflag=(TEXT_TY_ExpandIfPerishable(I7SFRAME,TX_S_483)); story_complete=false;
        ! [7: otherwise]
        } else {

        ! [8: say femaletofrog]
        say__p=1;ParaContent(); (PHR_998_r130 ()); .L_Say492; .L_SayX492;
        ! [9: end if]
        }

        rfalse;
];
! Request 25: phrase nothing -> nothing
! to say becomeBayMare:
[ PHR_1005_r25  I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_15();
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_15 ;
    ! [1: say ~You look down at Becky, her body marked with all sorts of whip marks.  Your eyes scan her beautiful body, wondering what horrors happened to her.. until you see her face.  Her eyes aren't meeting yours.  Instead, they are staring up at her captor, full of adoration and love.  She must've been brainwashed.. some sort of Stockholm syndrome.. good god.[paragraph break]'HEY!' Becky gasped, ripping your attention away from your evaluation of her.  'You got here at just the right time!  This beautiful woman was showing me an awesome magic show, referencing the sneering captor above her.  'That's right, dear' the woman replies, her eyes transfixed on you.^^'I'm... in the wrong place, I was looking for a friends house, my apologies' you stammer, terrified by her look.  You try to turn to go, but your feet seem to have something else in mind as they stay planted to the ground.[pause_clear]~]
    say__p=1;ParaContent(); print "You look down at Becky, her body marked with all sorts of whip marks.  Your eyes scan her beautiful body, wondering what horrors happened to her.. until you see her face.  Her eyes aren't meeting yours.  Instead, they are staring up at her captor, full of adoration and love.  She must've been brainwashed.. some sort of Stockholm syndrome.. good god.";ParaContent(); DivideParagraphPoint(); new_line;ParaContent(); print "~HEY!~ Becky gasped, ripping your attention away from your evaluation of her.  ~You got here at just the right time!  This beautiful woman was showing me an awesome magic show, referencing the sneering captor above her.  ~That's right, dear~ the woman replies, her eyes transfixed on you.^^~I'm... in the wrong place, I was looking for a friends house, my apologies~ you stammer, terrified by her look.  You try to turn to go, but your feet seem to have something else in mind as they stay planted to the ground."; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say493; .L_SayX493;
    ! [2: say ~'I uhh.. Whoa' you mutter, trying whatever you can to keep your mind off of the plump pussies of submissive females being... Damn.  Something wasn't right.  You usually like this transformation stuff, ya know, in stories and pictures every once in a while, but you felt like your mind was stuck on it, at like the worst possible time for it to be..  And it felt... good.~]
    say__p=1;ParaContent(); print "~I uhh.. Whoa~ you mutter, trying whatever you can to keep your mind off of the plump pussies of submissive females being... Damn.  Something wasn't right.  You usually like this transformation stuff, ya know, in stories and pictures every once in a while, but you felt like your mind was stuck on it, at like the worst possible time for it to be..  And it felt... good."; new_line; .L_Say494; .L_SayX494;
    ! [3: say ~'Hellllo, silly!' Becky remarks, snapping her fingers in front of your eyes.  She was incredibly close to you now, her body so close to rubbing against the needy bulge in your pants.  The cage she was in is nowhere to be seen, it apparently disappearing into thin air at the whim of the sorceress in front of you. As your eyes stare blankly back at her inquisitive, cute face your mind wanders to thoughts of rutting again.^^Brought on by that smell... the smell that pervades your nostrils, strips you of any logical... and MMMMPH! There it is again, you think to yourself as another waft of it hits you, smelling like something... exciting. It wasn't til then that you notice Becky has stopped talking, and is standing there with a weird look on her face.~]
    say__p=1;ParaContent(); print "~Hellllo, silly!~ Becky remarks, snapping her fingers in front of your eyes.  She was incredibly close to you now, her body so close to rubbing against the needy bulge in your pants.  The cage she was in is nowhere to be seen, it apparently disappearing into thin air at the whim of the sorceress in front of you. As your eyes stare blankly back at her inquisitive, cute face your mind wanders to thoughts of rutting again.^^Brought on by that smell... the smell that pervades your nostrils, strips you of any logical... and MMMMPH! There it is again, you think to yourself as another waft of it hits you, smelling like something... exciting. It wasn't til then that you notice Becky has stopped talking, and is standing there with a weird look on her face."; new_line; .L_Say495; .L_SayX495;
    ! [4: say ~She stops, meeting your vision.^^'Do you smell that?', Becky asks, her eyes starting to flutter weirdly, drilling into you.  'Yeah... yeah I smell it to,' you answers, 'do you know where it's coming from?  Or what it is?  It smells... warm, gooood, stroong'.  Your last words draw out unexpectedly, a host of weird feelings suddenly invading your body.  The warmth of the smell seemed to translate to your nether regions, your stirring dick swarming with intense heat.^^You squirm in your pants, Becky's interrogating gaze seeming to piece you as she scans your body.  'Umm... whoa I feel' you started to say, cut short by the feeling of your chest expanding.  'AHHHH!' your mind races, no longer caring about Becky watching as you reach under your shirt to grab.. breasts?^^An involuntary moan slips out of your mouth as your hands grasp soft, growing flesh inside of your shirt, your new boobs sending tingles and shocks down your spine in guilty pleasure.~]
    say__p=1;ParaContent(); print "She stops, meeting your vision.^^~Do you smell that?~, Becky asks, her eyes starting to flutter weirdly, drilling into you.  ~Yeah... yeah I smell it to,~ you answers, ~do you know where it's coming from?  Or what it is?  It smells... warm, gooood, stroong~.  Your last words draw out unexpectedly, a host of weird feelings suddenly invading your body.  The warmth of the smell seemed to translate to your nether regions, your stirring dick swarming with intense heat.^^You squirm in your pants, Becky's interrogating gaze seeming to piece you as she scans your body.  ~Umm... whoa I feel~ you started to say, cut short by the feeling of your chest expanding.  ~AHHHH!~ your mind races, no longer caring about Becky watching as you reach under your shirt to grab.. breasts?^^An involuntary moan slips out of your mouth as your hands grasp soft, growing flesh inside of your shirt, your new boobs sending tingles and shocks down your spine in guilty pleasure."; new_line; .L_Say496; .L_SayX496;
    ! [5: say ~[pause_clear] 'I.. uhmp... help...', you manage to mutter, your back  beginning to slightly arch as you fingers find where the shockingly good feelings were originating.  You're not avoiding it though.. even though you know what it is.^^Your hands are in fact encouraging the feeling, kneeding your nipples.  You haven't experienced these feelings before, the incredible shocks making it really damn hard to think.^^Wait.. that weird smell seemingly overwhelming now, the realization snapping you back into reality.  Looking around, you can see the witch leaning against the wall, entertained by what was happening, and Becky... well Becky was still right there, staring you down with the strangest look on her face.  And you?  Well you're sitting here with your hands practically milking your new lovepillows.^^Suddenly, you feel your nipples grow in between your mischevious fingers, expanding to meet the sex of the flesh around them. Changing from a mans to a womans and still growing, the hue of the nipples reaching a dark brown from the pink they were before.[paragraph break] 'Yeah,' Becky says, making you jump.^^You keep forgetting she was in the room, your changes keep taking up your though patterns. 'Yeah, what?' you halfheartedly utter, your focus on the now tightening feeling in your waist, and the never ending stream of pleasurable tingles from milking your now C-Cup breasts.  'It's you.', Becky says with force, drawing in close to you.^^'You are the smell..', her breath slamming into you as she seems unnaturally close, practically on you.  But the breathing becomes the least of your worries as you notice the prodding object below you, moving in unison to her thrusts. [paragraph break] You have no idea why when you looked down and saw the bulge her new cock was causing in her pants... why you felt excited and something similar to the tingles your breast kneeding had given you...^^But your attention is once again quickly whisked away.  When you notice your cock is quite the opposite of the building phallus in Beckys strained pants.  In fact, its fucking gone.  It had gone flaccid about the time you had starting feeling your breasts up, but even the minor bulge your averaged sized cock usually makes was gone.^^You rip your pants down to see it pulling inside of you, a tiny worm of a penis still remaining, showered by your chest hair as it fell out.~]
    say__p=1;ParaContent(); (PHR_928_r9 ());ParaContent(); print " ~I.. uhmp... help...~, you manage to mutter, your back  beginning to slightly arch as you fingers find where the shockingly good feelings were originating.  You're not avoiding it though.. even though you know what it is.^^Your hands are in fact encouraging the feeling, kneeding your nipples.  You haven't experienced these feelings before, the incredible shocks making it really damn hard to think.^^Wait.. that weird smell seemingly overwhelming now, the realization snapping you back into reality.  Looking around, you can see the witch leaning against the wall, entertained by what was happening, and Becky... well Becky was still right there, staring you down with the strangest look on her face.  And you?  Well you're sitting here with your hands practically milking your new lovepillows.^^Suddenly, you feel your nipples grow in between your mischevious fingers, expanding to meet the sex of the flesh around them. Changing from a mans to a womans and still growing, the hue of the nipples reaching a dark brown from the pink they were before.";ParaContent(); DivideParagraphPoint(); new_line;ParaContent(); print " ~Yeah,~ Becky says, making you jump.^^You keep forgetting she was in the room, your changes keep taking up your though patterns. ~Yeah, what?~ you halfheartedly utter, your focus on the now tightening feeling in your waist, and the never ending stream of pleasurable tingles from milking your now C-Cup breasts.  ~It's you.~, Becky says with force, drawing in close to you.^^~You are the smell..~, her breath slamming into you as she seems unnaturally close, practically on you.  But the breathing becomes the least of your worries as you notice the prodding object below you, moving in unison to her thrusts. ";ParaContent(); DivideParagraphPoint(); new_line;ParaContent(); print " You have no idea why when you looked down and saw the bulge her new cock was causing in her pants... why you felt excited and something similar to the tingles your breast kneeding had given you...^^But your attention is once again quickly whisked away.  When you notice your cock is quite the opposite of the building phallus in Beckys strained pants.  In fact, its fucking gone.  It had gone flaccid about the time you had starting feeling your breasts up, but even the minor bulge your averaged sized cock usually makes was gone.^^You rip your pants down to see it pulling inside of you, a tiny worm of a penis still remaining, showered by your chest hair as it fell out."; new_line; .L_Say497; .L_SayX497;
    ! [6: say ~'..NO! Oh god please donnnn--RHEEEEEEEEEE.'  You stop immediately, stunned that you had just whinnied. Your first whinny.  Tears break out of your eyes while you watch the shaft of your most prized possession pull up more and more into you until its gone.^^Your testicles quickly follow, causing a small snort out of Becky as the hole in which your precious balls disappeared into begins to mimic that of a vagina.  You're still crying in shock, moving your hands (now feminized and growing darker already) slowly and reluctantly down to touch... your new pussy.^^The sudden appearing new mimic of a girl genitals is definitely a real pussy, having seen and well.. fucking a few in your life.  You moan as you continue to explore it, your lips soft and wet and a  exploding source of pleasure.. especially when you start grinding your hips together like...[paragraph break] 'Mmmmmm.' A deep bellow of approval rumbles from Becky.  Oh crap, shes still here, you realize, humiliated.  Or well he... as you notice the massive stallion cock sprouting from between her legs.  Staring at it, you feel a weird twinging feeling from your newly acquired genitals, a feeling of dampness settling in your panties... or boxers, shit.  Your mind is even started to pull tricks on you, crap, you think to yourself.^^'Whats happening to me?' you whimper, realizing your voice also seems a bit different. You moan as the tingling feeling shoots through you again, making you bite your lip in reaction to the lust, your moans growing in intensity as a strange feeling settles in your hips.^^They begin to grow.  They seem to be gaining fat, unline your lower torso and waist, which was doing very much the opposite.  Your hips are growing into those of voluptuous young woman, you realize. [pause_clear]~]
    say__p=1;ParaContent(); print "~..NO! Oh god please donnnn--RHEEEEEEEEEE.~  You stop immediately, stunned that you had just whinnied. Your first whinny.  Tears break out of your eyes while you watch the shaft of your most prized possession pull up more and more into you until its gone.^^Your testicles quickly follow, causing a small snort out of Becky as the hole in which your precious balls disappeared into begins to mimic that of a vagina.  You're still crying in shock, moving your hands (now feminized and growing darker already) slowly and reluctantly down to touch... your new pussy.^^The sudden appearing new mimic of a girl genitals is definitely a real pussy, having seen and well.. fucking a few in your life.  You moan as you continue to explore it, your lips soft and wet and a  exploding source of pleasure.. especially when you start grinding your hips together like...";ParaContent(); DivideParagraphPoint(); new_line;ParaContent(); print " ~Mmmmmm.~ A deep bellow of approval rumbles from Becky.  Oh crap, shes still here, you realize, humiliated.  Or well he... as you notice the massive stallion cock sprouting from between her legs.  Staring at it, you feel a weird twinging feeling from your newly acquired genitals, a feeling of dampness settling in your panties... or boxers, shit.  Your mind is even started to pull tricks on you, crap, you think to yourself.^^~Whats happening to me?~ you whimper, realizing your voice also seems a bit different. You moan as the tingling feeling shoots through you again, making you bite your lip in reaction to the lust, your moans growing in intensity as a strange feeling settles in your hips.^^They begin to grow.  They seem to be gaining fat, unline your lower torso and waist, which was doing very much the opposite.  Your hips are growing into those of voluptuous young woman, you realize. ";ParaContent(); (PHR_928_r9 ()); .L_Say498; .L_SayX498;
    ! [7: say ~'CRAP THIS SHOULDN'T BE HAPPENING' you yell in complete confusion.  Oh no... your voice is high and soft and freakin feminine as well.  You feel vulnerable and scared and.. wet.  Oh god were you wet.^^Your pussy is giving you new feelings of lust, its lips slimy with your own juices. A snort escapes your mouth, as you once again let your fingers find their way down to your new pussy, teasing the lips of it. [paragraph break] 'I fuck you and feel good' came a surprisingly deep in treble and simple in composition declaration from the changing Becky.  You had almost forgotten she was here. Again, you had forgotten a second time, damn... your mind must be slipping.^^'No we can't...' you respond, your words trailing off as you glance at her again, your small jaw dropping at what you see.  Becky is a stallion.  Like a massive horse with giant throbbing erection, hairy balls hanging behind, and snorting muzzle. And verrrry much ready to mate.  'Oh god Becky let's just try to think this out...[pause_clear]'~]
    say__p=1;ParaContent(); print "~CRAP THIS SHOULDN'T BE HAPPENING~ you yell in complete confusion.  Oh no... your voice is high and soft and freakin feminine as well.  You feel vulnerable and scared and.. wet.  Oh god were you wet.^^Your pussy is giving you new feelings of lust, its lips slimy with your own juices. A snort escapes your mouth, as you once again let your fingers find their way down to your new pussy, teasing the lips of it. ";ParaContent(); DivideParagraphPoint(); new_line;ParaContent(); print " ~I fuck you and feel good~ came a surprisingly deep in treble and simple in composition declaration from the changing Becky.  You had almost forgotten she was here. Again, you had forgotten a second time, damn... your mind must be slipping.^^~No we can't...~ you respond, your words trailing off as you glance at her again, your small jaw dropping at what you see.  Becky is a stallion.  Like a massive horse with giant throbbing erection, hairy balls hanging behind, and snorting muzzle. And verrrry much ready to mate.  ~Oh god Becky let's just try to think this out..."; new_line;ParaContent(); (PHR_928_r9 ());ParaContent(); print "~"; .L_Say499; .L_SayX499;
    ! [8: say ~Oh fuck, you think to yourself, fuck.. gotta get outta here before you GET fucked.  You take your first two steps full of determination and hope.  But the third falls on your front.. hooves? A loud animalistic cry of desperation, nothing more then a mares whinny, explodes out of your mouth.^^You feel a new tail stretch out of your pretty girl butt, its Palomino tinted hair falling down to cover the shifting pussy in between your legs.^^You feel your new pleasure hole fatten and thicken and begin to morph to accomodate the massive dicks your future stallion mates.  [paragraph break]'Oh god no I donnntttt wEEEEEAAHHHHannaaaa be a marreee WWHEEEEEE', the high pitched words fly out of your mouth as you speed away on your clopping hooves to wherever, anywhere, just not here.^^Not near the stallion, or Becky, or whatever she was now.  'WHHEEEEEEEEEEEE' a emabarrassing whinny leaves your mouth uncontrollably as you feel a something new from behind you.^^Just thinking of her.. or him, you can feel the tingling feeling sprout from your horse vagina, the realization that you have a winking pussy of a mare.  You feel it squelch behind you as you slow  your gallop to a normal gait, trying to think what your options are.^^As your hooves slow their raucous gallop, you immediately notice the sound of others right behind you. [pause_clear] A louder, deeper whinny announces the arrival of Becky in all her glory.  'Oh please no I can't do this' you think to yourself, desperately trying to escape again but to no luck.^^Within seconds Becky is on you, the massive stallion just too fast.  Shivering in fear... or lust, you can only sit there as the feeling of her.. his breath lightly caresses the space in between your wide horse asscheeks.^^You feel your mate shove his large snout in between your hips, viciously licking and pleasuring your new chubby horse vagina, his long horse tongue shooting deeper then you had anticipated.  'WWHEEWEHHEEEE' is all you can muster as you feel guilty waves of glorious lust spread through you, urges to surrender shooting through your mind. ~]
    say__p=1;ParaContent(); print "Oh fuck, you think to yourself, fuck.. gotta get outta here before you GET fucked.  You take your first two steps full of determination and hope.  But the third falls on your front.. hooves? A loud animalistic cry of desperation, nothing more then a mares whinny, explodes out of your mouth.^^You feel a new tail stretch out of your pretty girl butt, its Palomino tinted hair falling down to cover the shifting pussy in between your legs.^^You feel your new pleasure hole fatten and thicken and begin to morph to accomodate the massive dicks your future stallion mates.  ";ParaContent(); DivideParagraphPoint(); new_line;ParaContent(); print "~Oh god no I donnntttt wEEEEEAAHHHHannaaaa be a marreee WWHEEEEEE~, the high pitched words fly out of your mouth as you speed away on your clopping hooves to wherever, anywhere, just not here.^^Not near the stallion, or Becky, or whatever she was now.  ~WHHEEEEEEEEEEEE~ a emabarrassing whinny leaves your mouth uncontrollably as you feel a something new from behind you.^^Just thinking of her.. or him, you can feel the tingling feeling sprout from your horse vagina, the realization that you have a winking pussy of a mare.  You feel it squelch behind you as you slow  your gallop to a normal gait, trying to think what your options are.^^As your hooves slow their raucous gallop, you immediately notice the sound of others right behind you. ";ParaContent(); (PHR_928_r9 ());ParaContent(); print " A louder, deeper whinny announces the arrival of Becky in all her glory.  ~Oh please no I can't do this~ you think to yourself, desperately trying to escape again but to no luck.^^Within seconds Becky is on you, the massive stallion just too fast.  Shivering in fear... or lust, you can only sit there as the feeling of her.. his breath lightly caresses the space in between your wide horse asscheeks.^^You feel your mate shove his large snout in between your hips, viciously licking and pleasuring your new chubby horse vagina, his long horse tongue shooting deeper then you had anticipated.  ~WWHEEWEHHEEEE~ is all you can muster as you feel guilty waves of glorious lust spread through you, urges to surrender shooting through your mind. "; .L_Say500; .L_SayX500;
    ! [9: say ~You can feel your tail flicking to the side against your will, giving Becky the room she needs to take you.  NOOOOOOOO PLEASE STOPPPP, you can only think as your body is giving Becky the sign that your mare body is ready to be impregnated.^^The squelch of your new pussy winking in anticipation is almost deafening as Becky mounts you, his massive dick slapping against the sides of your mare haunches as he tries to position himself.^^Your panting and wild eyed frenzy and resistance means nothing to him, you realize.  He's going to fuck you into a mindless animal and make you carry his foals. The thought makes your pussy squirt out some of your mare juices, your body unbelievably excited for your mating. [pause_clear]^^And then he enters you.  Slamming into the fat pussy that had formed in place of your male parts, claiming you like the mare you are.  You can feel the stallion hot breath on the back of your neck, your pussy coating his dick with a frothy mix of precum and mare pussy juices.  He's pounding you, shoving himself in and out of your ugly black lipped love hole.^^You can feel the pleasure making your mare teets erect, accidentally pleasuring the stallion more as his enormous balls slap against your mammary glands.  Ones which your foals with suck the milk out of you, whether you like it or not.  The pleasure is unbelievable, sweltering you with guilt as well as the feeling of satisfaction.  Becky keeps pushing... you...  WHHIIHHEEEEEEEEEEEEEEEEEE!^^Letting out a raucous whinny, the feeling of the stallion cumming deep inside you pushes your own self to orgasm, your pussy clamping hard on his dick with a humiliating squelch, the force of it pushing a small amount of your combined horse cum out the sides, wetting your round donut on an asshole even more.^^You can feel your slimy horse pussy trembling with the guilty orgasm, the most intense orgasm of your life, milking his dick as you can feel your mind slipping.~]
    say__p=1;ParaContent(); print "You can feel your tail flicking to the side against your will, giving Becky the room she needs to take you.  NOOOOOOOO PLEASE STOPPPP, you can only think as your body is giving Becky the sign that your mare body is ready to be impregnated.^^The squelch of your new pussy winking in anticipation is almost deafening as Becky mounts you, his massive dick slapping against the sides of your mare haunches as he tries to position himself.^^Your panting and wild eyed frenzy and resistance means nothing to him, you realize.  He's going to fuck you into a mindless animal and make you carry his foals. The thought makes your pussy squirt out some of your mare juices, your body unbelievably excited for your mating. ";ParaContent(); (PHR_928_r9 ());ParaContent(); print "^^And then he enters you.  Slamming into the fat pussy that had formed in place of your male parts, claiming you like the mare you are.  You can feel the stallion hot breath on the back of your neck, your pussy coating his dick with a frothy mix of precum and mare pussy juices.  He's pounding you, shoving himself in and out of your ugly black lipped love hole.^^You can feel the pleasure making your mare teets erect, accidentally pleasuring the stallion more as his enormous balls slap against your mammary glands.  Ones which your foals with suck the milk out of you, whether you like it or not.  The pleasure is unbelievable, sweltering you with guilt as well as the feeling of satisfaction.  Becky keeps pushing... you...  WHHIIHHEEEEEEEEEEEEEEEEEE!^^Letting out a raucous whinny, the feeling of the stallion cumming deep inside you pushes your own self to orgasm, your pussy clamping hard on his dick with a humiliating squelch, the force of it pushing a small amount of your combined horse cum out the sides, wetting your round donut on an asshole even more.^^You can feel your slimy horse pussy trembling with the guilty orgasm, the most intense orgasm of your life, milking his dick as you can feel your mind slipping."; new_line; .L_Say501; .L_SayX501;
    ! [10: end the story saying ~Your whinnies of resistance cease as you can feel your thoughts turn to being a good submissive mare for your stallion, so that you can experience what its like to be claimed as his mate again.^^[bold type]Game Over.  [italic type]'Let's Get Mare-ied!'  [roman type]Male Human to Mare.~]
    deadflag=(TEXT_TY_ExpandIfPerishable(I7SFRAME,TX_S_484)); story_complete=false;
    rfalse;
];
! Request 26: phrase nothing -> nothing
! to say becomeSowGirl:
[ PHR_1009_r26  ;
    ! [1: say ~..'Okayy jeez Ill choose hog', you snap, 'its obvious you plan on doing that same change thing on me as the one I choose.'  You shake your head in frustration, angry at the witch and voicing it.  'You know, you will probably turn right over to Kim or whoever that is over there and turn her into some sow or however its pronounced.. and cackle as I fuck her. JEEZ you know Ive been outside in the past 24 hours right?!' [pause_clear].~]
    say__p=1;ParaContent(); print "..~Okayy jeez Ill choose hog~, you snap, ~its obvious you plan on doing that same change thing on me as the one I choose.~  You shake your head in frustration, angry at the witch and voicing it.  ~You know, you will probably turn right over to Kim or whoever that is over there and turn her into some sow or however its pronounced.. and cackle as I fuck her. JEEZ you know Ive been outside in the past 24 hours right?!~ ";ParaContent(); (PHR_928_r9 ());ParaContent(); print "."; new_line; .L_Say502; .L_SayX502;
    ! [2: say ~The witch just sits there, smiling at you. And oh man does that piss you off.  So enraged and pissed at the hordes of dumbass witches all day, you lurch forward to punch this bitch in the face. And stop when you feel the weight on the front of your chest.^^You look down in disbelief, wondering what's stopping you.  It's pretty hard to comprehend that the thing that stayed your hand being 8 teats lining your torso, but well...  fucking witches.  'SQUEAL?!' you cry out, an attempt at a rather vulgar namecalling, cut short by your apparent transformation. The one that happened instantly.^^'HAHAAAA' the witch guffaws, summoning a mirror with a flick of her wand.  What you see in the reflection makes you cry.  You aren't the skinny geeky male you were before.. but a beautiful buxom red haired woman.  One whos nose was slowly turning up into a pig snout.  'HELP PLEASE ILL *SQUEEEEAL* DO ANYTHING!' you beg the witch, still standing above Kim[pause_clear].~]
    say__p=1;ParaContent(); print "The witch just sits there, smiling at you. And oh man does that piss you off.  So enraged and pissed at the hordes of dumbass witches all day, you lurch forward to punch this bitch in the face. And stop when you feel the weight on the front of your chest.^^You look down in disbelief, wondering what's stopping you.  It's pretty hard to comprehend that the thing that stayed your hand being 8 teats lining your torso, but well...  fucking witches.  ~SQUEAL?!~ you cry out, an attempt at a rather vulgar namecalling, cut short by your apparent transformation. The one that happened instantly.^^~HAHAAAA~ the witch guffaws, summoning a mirror with a flick of her wand.  What you see in the reflection makes you cry.  You aren't the skinny geeky male you were before.. but a beautiful buxom red haired woman.  One whos nose was slowly turning up into a pig snout.  ~HELP PLEASE ILL *SQUEEEEAL* DO ANYTHING!~ you beg the witch, still standing above Kim";ParaContent(); (PHR_928_r9 ());ParaContent(); print "."; new_line; .L_Say503; .L_SayX503;
    ! [3: say ~'Why?' she asked cruelly, 'What can you offer me?'^^You stuttered over your words, trying to find an answer as you felt your new tits grow larger and larger, their nipples extending beyond human proportions.^^A deep in thought 'hmmm' and a *snap* of her fingers, and the witch had stopped your transformation into a sow.  You look up from your breasts, relieved it had ended.  She was still smiling cruelly though.  'How about we play a game?' she asked.^^'And unless you want me to go ahead and start that change again.. no you don't have a choice.'  You nod, your thoughts on the feeling of your soft legs touching themselves, and your wide baby birthing hips, and the warm feeling between your legs that replaced your dick.~]
    say__p=1;ParaContent(); print "~Why?~ she asked cruelly, ~What can you offer me?~^^You stuttered over your words, trying to find an answer as you felt your new tits grow larger and larger, their nipples extending beyond human proportions.^^A deep in thought ~hmmm~ and a *snap* of her fingers, and the witch had stopped your transformation into a sow.  You look up from your breasts, relieved it had ended.  She was still smiling cruelly though.  ~How about we play a game?~ she asked.^^~And unless you want me to go ahead and start that change again.. no you don't have a choice.~  You nod, your thoughts on the feeling of your soft legs touching themselves, and your wide baby birthing hips, and the warm feeling between your legs that replaced your dick."; new_line; .L_Say504; .L_SayX504;
    rfalse;
];
! Request 27: phrase nothing -> nothing
! to say becomeSexDoll:
[ PHR_1017_r27  ;
    ! [1: say ~.~]
    say__p=1;ParaContent(); print "."; new_line; .L_Say505; .L_SayX505;
    rfalse;
];
! From "Locksmith" by Emily Short
! Request 28: phrase object -> nothing
! To say key-refusal for ( locked-thing - an object ):
[ PHR_820_r28  
    t_0 ! Call parameter 'locked-thing': object
    ;
    ! [1: carry out the refusing keys activity with the locked-thing]
    CarryOutActivity(V34_refusing_keys, t_0);
    rfalse;
];
! From "Menus" by Emily Short
! Request 29: phrase table name -> nothing
! To reprint ( selected menu - a table name ):
[ PHR_897_r29  
    t_0 ! Call parameter 'selected menu': table name
    tmp_0 ! Let/loop value, e.g., '__index': number
    tmp_1 ! Let/loop value, e.g., '?-1,-1?'(deallocated by end of phrase)
    tmp_2 ! Let/loop value, e.g., '?-1,-1?'(deallocated by end of phrase)
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    ! [1: redraw status line]
    DrawStatusLine();
    ! [2: say fixed letter spacing]
    say__p=1;ParaContent(); font off; .L_Say506; .L_SayX506;
    ! [3: let __index be 1]

    		tmp_0 = 1;
    ! [4: clear only the main screen]
    VM_ClearScreen(2);
    ! [5: repeat through selected menu begin]
    @push ct_0; @push ct_1;
    		for (tmp_1=t_0, tmp_2=1, ct_0=tmp_1, ct_1=tmp_2:
    			tmp_2<=TableRows(tmp_1):
    			tmp_2++, ct_0=tmp_1, ct_1=tmp_2)
    			if (TableRowIsBlank(ct_0, ct_1)==false){
        ! [6: if __index is current menu selection , say ~ >~]
        if (((tmp_0 == (Global_Vars-->20)))) { say__p=1;ParaContent(); print " >"; .L_Say507; .L_SayX507; }
        ! [7: otherwise say ~  ~]
        else { say__p=1;ParaContent(); print "  "; .L_Say508; .L_SayX508; }
        ! [8: say ~ [title entry][line break]~]
        say__p=1;ParaContent(); print " ";ParaContent(); print (TEXT_TY_Say) TableLookUpEntry(ct_0,107,ct_1);ParaContent(); new_line; .L_Say509; .L_SayX509;
        ! [9: increase __index by 1]
        tmp_0 = tmp_0 + 1;;
        ! [10: end repeat]
        }
        @pull ct_1; @pull ct_0;
    ! [11: say variable letter spacing]
    say__p=1;ParaContent(); font on; .L_Say510; .L_SayX510;
    rfalse;
];
! From "Basic Screen Effects" by Emily Short
! Request 30: phrase nothing -> nothing
! To pause the/-- game:
[ PHR_909_r30  ;
    ! [1: carry out the pausing the game activity]
    CarryOutActivity(V36_pausing_the_game);
    rfalse;
];
! From "Menus" by Emily Short
! Request 31: phrase table name -> nothing
! To say known hints from ( hint booklet - table name ):
[ PHR_901_r31  
    t_0 ! Call parameter 'hint booklet': table name
    tmp_0 ! Let/loop value, e.g., '__index': number
    tmp_1 ! Let/loop value, e.g., '?-1,-1?'(deallocated by end of phrase)
    tmp_2 ! Let/loop value, e.g., '?-1,-1?'(deallocated by end of phrase)
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    ! [1: let __index be 0]

    		tmp_0 = 0;
    ! [2: clear only the main screen]
    VM_ClearScreen(2);
    ! [3: repeat through hint booklet begin]
    @push ct_0; @push ct_1;
    		for (tmp_1=t_0, tmp_2=1, ct_0=tmp_1, ct_1=tmp_2:
    			tmp_2<=TableRows(tmp_1):
    			tmp_2++, ct_0=tmp_1, ct_1=tmp_2)
    			if (TableRowIsBlank(ct_0, ct_1)==false){
        ! [4: increase __index by 1]
        tmp_0 = tmp_0 + 1;;
        ! [5: if there is a used entry begin]
        if (((ExistsTableLookUpEntry(ct_0,117,ct_1)))){
            ! [6: say ~[__index]/[number of rows in hint booklet]: [hint entry][paragraph break]~]
            say__p=1;ParaContent(); print (say__n=tmp_0);ParaContent(); print "/";ParaContent(); print (say__n=TableRows(t_0));ParaContent(); print ": ";ParaContent(); print (TEXT_TY_Say) TableLookUpEntry(ct_0,116,ct_1);ParaContent(); DivideParagraphPoint(); new_line; .L_Say511; .L_SayX511;
            ! [7: otherwise]
            } else {

            ! [8: if __index is 1 begin]
            if (((tmp_0 == 1))){
                ! [9: now used entry is turn count]
                TableLookUpEntry(ct_0,117,ct_1,1,turns);
                ! [10: say ~[__index]/[number of rows in hint booklet]: [hint entry][paragraph break]~]
                say__p=1;ParaContent(); print (say__n=tmp_0);ParaContent(); print "/";ParaContent(); print (say__n=TableRows(t_0));ParaContent(); print ": ";ParaContent(); print (TEXT_TY_Say) TableLookUpEntry(ct_0,116,ct_1);ParaContent(); DivideParagraphPoint(); new_line; .L_Say512; .L_SayX512;
                ! [11: end if]
                }

            ! [12: end if]
            }

        ! [13: end repeat]
        }
        @pull ct_1; @pull ct_0;
    ! [14: say ~Press SPACE to return to the menu or H to reveal another hint.~]
    say__p=1;ParaContent(); print "Press SPACE to return to the menu or H to reveal another hint."; new_line; .L_Say513; .L_SayX513;
    rfalse;
];
! From "Menus" by Emily Short
! Request 32: phrase table name -> nothing
! To say hints from ( hint booklet - table name ):
[ PHR_902_r32  
    t_0 ! Call parameter 'hint booklet': table name
    tmp_0 ! Let/loop value, e.g., '__index': number
    tmp_1 ! Let/loop value, e.g., '?-1,-1?'(deallocated by end of phrase)
    tmp_2 ! Let/loop value, e.g., '?-1,-1?'(deallocated by end of phrase)
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    ! [1: let __index be 0]

    		tmp_0 = 0;
    ! [2: clear only the main screen]
    VM_ClearScreen(2);
    ! [3: repeat through hint booklet begin]
    @push ct_0; @push ct_1;
    		for (tmp_1=t_0, tmp_2=1, ct_0=tmp_1, ct_1=tmp_2:
    			tmp_2<=TableRows(tmp_1):
    			tmp_2++, ct_0=tmp_1, ct_1=tmp_2)
    			if (TableRowIsBlank(ct_0, ct_1)==false){
        ! [4: increase __index by 1]
        tmp_0 = tmp_0 + 1;;
        ! [5: say ~[__index]/[number of rows in hint booklet]: [hint entry][paragraph break]~]
        say__p=1;ParaContent(); print (say__n=tmp_0);ParaContent(); print "/";ParaContent(); print (say__n=TableRows(t_0));ParaContent(); print ": ";ParaContent(); print (TEXT_TY_Say) TableLookUpEntry(ct_0,116,ct_1);ParaContent(); DivideParagraphPoint(); new_line; .L_Say514; .L_SayX514;
        ! [6: if there is a used entry begin]
        if (((ExistsTableLookUpEntry(ct_0,117,ct_1)))){
            ! [7: do nothing]
            ;
            ! [8: otherwise]
            } else {

            ! [9: now used entry is turn count]
            TableLookUpEntry(ct_0,117,ct_1,1,turns);
            ! [10: say ~Press SPACE to return to the menu[if __index < number of rows in hint booklet] or H to reveal another hint[end if].~]
            say__p=1;ParaContent(); print "Press SPACE to return to the menu";
            	if (~~((((tmp_0 < TableRows(t_0)))))) jump L_Say515;ParaContent(); print " or H to reveal another hint";
            	.L_Say515; .L_SayX515;ParaContent(); print "."; new_line; .L_Say516; .L_SayX516;
            ! [11: make no decision]
            rfalse;
            ! [12: end if]
            }

        ! [13: end repeat]
        }
        @pull ct_1; @pull ct_0;
    ! [14: say ~Press SPACE to return to the menu[if __index < number of rows in hint booklet] or H to reveal another hint[end if].~]
    say__p=1;ParaContent(); print "Press SPACE to return to the menu";
    	if (~~((((tmp_0 < TableRows(t_0)))))) jump L_Say517;ParaContent(); print " or H to reveal another hint";
    	.L_Say517; .L_SayX517;ParaContent(); print "."; new_line; .L_Say518; .L_SayX518;
    rfalse;
];
! From the Standard Rules
! Request 33: phrase nothing -> nothing
! To say no line break -- running on ( documented at phs_nolinebreak ):
[ PHR_351_r33  ;
    ! [1: do nothing]
    ;
    rfalse;
];
! From the Standard Rules
! Request 34: phrase response -> nothing
! To say text of ( R - response ) ( documented at phs_response ):
[ PHR_391_r34  
    t_0 ! Call parameter 'R': response
    ;
    ! [1: carry out the issuing the response text activity with r]
    CarryOutActivity(V33_issuing_the_response_tex, t_0);
    rfalse;
];
! From the Standard Rules
! Request 35: phrase real number -> real number
! To decide which real number is the real square of ( R - a real number ) ( this is the rsqr function inverse to root ):
[ PHR_425_r35  
    t_0 ! Call parameter 'R': real number
    tmp_0 ! Let/loop value, e.g., 'x': real number
    ;
    ! [1: let x be given by x = r@@94@{32} where x is a real number]

    		! Solving E0_english for 'x'
    (tmp_0 = (REAL_NUMBER_TY_Pow(t_0, NUMBER_TY_to_REAL_NUMBER_TY(2))));
    ;
    ! [2: decide on x]
    return tmp_0;
    return 0;
];
! From the Standard Rules
! Request 36: phrase real number -> real number
! To decide which real number is the hyperbolic arcsine of ( R - a real number ) ( documented at ph_hyperbolicarcsine ) ( this is the arcsinh function inverse to sinh ):
[ PHR_443_r36  
    t_0 ! Call parameter 'R': real number
    tmp_0 ! Let/loop value, e.g., 'x': real number
    ;
    ! [1: let x be given by x = log ( r + root ( r@@94@{32} + 1 ) ) where x is a real number]

    		! Solving E1_english for 'x'
    (tmp_0 = (REAL_NUMBER_TY_Log((REAL_NUMBER_TY_Plus(t_0, (REAL_NUMBER_TY_Root((REAL_NUMBER_TY_Plus((REAL_NUMBER_TY_Pow(t_0, NUMBER_TY_to_REAL_NUMBER_TY(2))), NUMBER_TY_to_REAL_NUMBER_TY(1))))))))));
    ;
    ! [2: decide on x]
    return tmp_0;
    return 0;
];
! From the Standard Rules
! Request 37: phrase real number -> real number
! To decide which real number is the hyperbolic arccosine of ( R - a real number ) ( documented at ph_hyperbolicarccosine ) ( this is the arccosh function inverse to cosh ):
[ PHR_444_r37  
    t_0 ! Call parameter 'R': real number
    tmp_0 ! Let/loop value, e.g., 'x': real number
    ;
    ! [1: let x be given by x = log ( r + root ( r@@94@{32} - 1 ) ) where x is a real number]

    		! Solving E2_english for 'x'
    (tmp_0 = (REAL_NUMBER_TY_Log((REAL_NUMBER_TY_Plus(t_0, (REAL_NUMBER_TY_Root((REAL_NUMBER_TY_Minus((REAL_NUMBER_TY_Pow(t_0, NUMBER_TY_to_REAL_NUMBER_TY(2))), NUMBER_TY_to_REAL_NUMBER_TY(1))))))))));
    ;
    ! [2: decide on x]
    return tmp_0;
    return 0;
];
! From the Standard Rules
! Request 38: phrase real number -> real number
! To decide which real number is the hyperbolic arctangent of ( R - a real number ) ( documented at ph_hyperbolicarctangent ) ( this is the arctanh function inverse to tanh ):
[ PHR_445_r38  
    t_0 ! Call parameter 'R': real number
    tmp_0 ! Let/loop value, e.g., 'x': real number
    ;
    ! [1: let x be given by x = 0.5* ( log ( 1+r ) - log ( 1-r ) ) where x is a real number]

    		! Solving E3_english for 'x'
    (tmp_0 = (REAL_NUMBER_TY_Times(1056964608, (REAL_NUMBER_TY_Minus((REAL_NUMBER_TY_Log((REAL_NUMBER_TY_Plus(NUMBER_TY_to_REAL_NUMBER_TY(1), t_0)))), (REAL_NUMBER_TY_Log((REAL_NUMBER_TY_Minus(NUMBER_TY_to_REAL_NUMBER_TY(1), t_0)))))))));
    ;
    ! [2: decide on x]
    return tmp_0;
    return 0;
];
! From the Standard Rules
! Request 39: phrase nothing -> nothing
! To say here ( documented at phs_here ):
[ PHR_528_r39  ;
    ! [1: say ~[if story tense is present tense]here[otherwise]there~]
    say__p=1;
    	if (~~((((story_tense == I105_present_tense))))) jump L_Say519;ParaContent(); print "here";
    	jump L_SayX519; .L_Say519;ParaContent(); print "there"; .L_Say520; .L_SayX519;
    rfalse;
];
! From the Standard Rules
! Request 40: phrase nothing -> nothing
! To say now ( documented at phs_now ):
[ PHR_529_r40  ;
    ! [1: say ~[if story tense is present tense]now[otherwise]then~]
    say__p=1;
    	if (~~((((story_tense == I105_present_tense))))) jump L_Say521;ParaContent(); print "now";
    	jump L_SayX520; .L_Say521;ParaContent(); print "then"; .L_Say522; .L_SayX520;
    rfalse;
];
! From "English Language" by Graham Nelson
! Request 41: phrase nothing -> nothing
! To say we:
[ PHR_774_r41  ;
    ! [1: now the prior named object is the player]
    prior_named_noun = player;
    ! [2: if the story viewpoint is first person singular begin]
    if (((story_viewpoint == I111_first_person_singular))){
        ! [3: say ~I~]
        say__p=1;ParaContent(); print "I"; .L_Say523; .L_SayX521;
        ! [4: end if]
        }

    ! [5: if the story viewpoint is second person singular begin]
    if (((story_viewpoint == I112_second_person_singular))){
        ! [6: say ~you~]
        say__p=1;ParaContent(); print "you"; .L_Say524; .L_SayX522;
        ! [7: end if]
        }

    ! [8: if the story viewpoint is third person singular begin]
    if (((story_viewpoint == I113_third_person_singular))){
        ! [9: if the player is male begin]
        if ((((Adj_82_t1_v10(player))))){
            ! [10: say ~he~]
            say__p=1;ParaContent(); print "he"; .L_Say525; .L_SayX523;
            ! [11: otherwise]
            } else {

            ! [12: say ~she~]
            say__p=1;ParaContent(); print "she"; .L_Say526; .L_SayX524;
            ! [13: end if]
            }

        ! [14: end if]
        }

    ! [15: if the story viewpoint is first person plural begin]
    if (((story_viewpoint == I114_first_person_plural))){
        ! [16: say ~we~]
        say__p=1;ParaContent(); print "we"; .L_Say527; .L_SayX525;
        ! [17: end if]
        }

    ! [18: if the story viewpoint is second person plural begin]
    if (((story_viewpoint == I115_second_person_plural))){
        ! [19: say ~you~]
        say__p=1;ParaContent(); print "you"; .L_Say528; .L_SayX526;
        ! [20: end if]
        }

    ! [21: if the story viewpoint is third person plural begin]
    if (((story_viewpoint == I116_third_person_plural))){
        ! [22: say ~they~]
        say__p=1;ParaContent(); print "they"; .L_Say529; .L_SayX527;
        ! [23: end if]
        }

        rfalse;
];
! From "English Language" by Graham Nelson
! Request 42: phrase nothing -> nothing
! To say us:
[ PHR_775_r42  ;
    ! [1: now the prior named object is the player]
    prior_named_noun = player;
    ! [2: if the story viewpoint is first person singular begin]
    if (((story_viewpoint == I111_first_person_singular))){
        ! [3: say ~me~]
        say__p=1;ParaContent(); print "me"; .L_Say530; .L_SayX528;
        ! [4: end if]
        }

    ! [5: if the story viewpoint is second person singular begin]
    if (((story_viewpoint == I112_second_person_singular))){
        ! [6: say ~you~]
        say__p=1;ParaContent(); print "you"; .L_Say531; .L_SayX529;
        ! [7: end if]
        }

    ! [8: if the story viewpoint is third person singular begin]
    if (((story_viewpoint == I113_third_person_singular))){
        ! [9: if the player is male begin]
        if ((((Adj_82_t1_v10(player))))){
            ! [10: say ~him~]
            say__p=1;ParaContent(); print "him"; .L_Say532; .L_SayX530;
            ! [11: otherwise]
            } else {

            ! [12: say ~her~]
            say__p=1;ParaContent(); print "her"; .L_Say533; .L_SayX531;
            ! [13: end if]
            }

        ! [14: end if]
        }

    ! [15: if the story viewpoint is first person plural begin]
    if (((story_viewpoint == I114_first_person_plural))){
        ! [16: say ~us~]
        say__p=1;ParaContent(); print "us"; .L_Say534; .L_SayX532;
        ! [17: end if]
        }

    ! [18: if the story viewpoint is second person plural begin]
    if (((story_viewpoint == I115_second_person_plural))){
        ! [19: say ~you~]
        say__p=1;ParaContent(); print "you"; .L_Say535; .L_SayX533;
        ! [20: end if]
        }

    ! [21: if the story viewpoint is third person plural begin]
    if (((story_viewpoint == I116_third_person_plural))){
        ! [22: say ~them~]
        say__p=1;ParaContent(); print "them"; .L_Say536; .L_SayX534;
        ! [23: end if]
        }

        rfalse;
];
! From "English Language" by Graham Nelson
! Request 43: phrase nothing -> nothing
! To say ours:
[ PHR_776_r43  ;
    ! [1: now the prior named object is the player]
    prior_named_noun = player;
    ! [2: if the story viewpoint is first person singular begin]
    if (((story_viewpoint == I111_first_person_singular))){
        ! [3: say ~mine~]
        say__p=1;ParaContent(); print "mine"; .L_Say537; .L_SayX535;
        ! [4: end if]
        }

    ! [5: if the story viewpoint is second person singular begin]
    if (((story_viewpoint == I112_second_person_singular))){
        ! [6: say ~yours~]
        say__p=1;ParaContent(); print "yours"; .L_Say538; .L_SayX536;
        ! [7: end if]
        }

    ! [8: if the story viewpoint is third person singular begin]
    if (((story_viewpoint == I113_third_person_singular))){
        ! [9: if the player is male begin]
        if ((((Adj_82_t1_v10(player))))){
            ! [10: say ~his~]
            say__p=1;ParaContent(); print "his"; .L_Say539; .L_SayX537;
            ! [11: otherwise]
            } else {

            ! [12: say ~hers~]
            say__p=1;ParaContent(); print "hers"; .L_Say540; .L_SayX538;
            ! [13: end if]
            }

        ! [14: end if]
        }

    ! [15: if the story viewpoint is first person plural begin]
    if (((story_viewpoint == I114_first_person_plural))){
        ! [16: say ~ours~]
        say__p=1;ParaContent(); print "ours"; .L_Say541; .L_SayX539;
        ! [17: end if]
        }

    ! [18: if the story viewpoint is second person plural begin]
    if (((story_viewpoint == I115_second_person_plural))){
        ! [19: say ~yours~]
        say__p=1;ParaContent(); print "yours"; .L_Say542; .L_SayX540;
        ! [20: end if]
        }

    ! [21: if the story viewpoint is third person plural begin]
    if (((story_viewpoint == I116_third_person_plural))){
        ! [22: say ~theirs~]
        say__p=1;ParaContent(); print "theirs"; .L_Say543; .L_SayX541;
        ! [23: end if]
        }

        rfalse;
];
! From "English Language" by Graham Nelson
! Request 44: phrase nothing -> nothing
! To say ourselves:
[ PHR_777_r44  ;
    ! [1: now the prior named object is the player]
    prior_named_noun = player;
    ! [2: if the story viewpoint is first person singular begin]
    if (((story_viewpoint == I111_first_person_singular))){
        ! [3: say ~myself~]
        say__p=1;ParaContent(); print "myself"; .L_Say544; .L_SayX542;
        ! [4: end if]
        }

    ! [5: if the story viewpoint is second person singular begin]
    if (((story_viewpoint == I112_second_person_singular))){
        ! [6: say ~yourself~]
        say__p=1;ParaContent(); print "yourself"; .L_Say545; .L_SayX543;
        ! [7: end if]
        }

    ! [8: if the story viewpoint is third person singular begin]
    if (((story_viewpoint == I113_third_person_singular))){
        ! [9: if the player is male begin]
        if ((((Adj_82_t1_v10(player))))){
            ! [10: say ~himself~]
            say__p=1;ParaContent(); print "himself"; .L_Say546; .L_SayX544;
            ! [11: otherwise]
            } else {

            ! [12: say ~herself~]
            say__p=1;ParaContent(); print "herself"; .L_Say547; .L_SayX545;
            ! [13: end if]
            }

        ! [14: end if]
        }

    ! [15: if the story viewpoint is first person plural begin]
    if (((story_viewpoint == I114_first_person_plural))){
        ! [16: say ~ourselves~]
        say__p=1;ParaContent(); print "ourselves"; .L_Say548; .L_SayX546;
        ! [17: end if]
        }

    ! [18: if the story viewpoint is second person plural begin]
    if (((story_viewpoint == I115_second_person_plural))){
        ! [19: say ~yourselves~]
        say__p=1;ParaContent(); print "yourselves"; .L_Say549; .L_SayX547;
        ! [20: end if]
        }

    ! [21: if the story viewpoint is third person plural begin]
    if (((story_viewpoint == I116_third_person_plural))){
        ! [22: say ~themselves~]
        say__p=1;ParaContent(); print "themselves"; .L_Say550; .L_SayX548;
        ! [23: end if]
        }

        rfalse;
];
! From "English Language" by Graham Nelson
! Request 45: phrase nothing -> nothing
! To say our:
[ PHR_778_r45  ;
    ! [1: now the prior named object is the player]
    prior_named_noun = player;
    ! [2: if the story viewpoint is first person singular begin]
    if (((story_viewpoint == I111_first_person_singular))){
        ! [3: say ~my~]
        say__p=1;ParaContent(); print "my"; .L_Say551; .L_SayX549;
        ! [4: end if]
        }

    ! [5: if the story viewpoint is second person singular begin]
    if (((story_viewpoint == I112_second_person_singular))){
        ! [6: say ~your~]
        say__p=1;ParaContent(); print "your"; .L_Say552; .L_SayX550;
        ! [7: end if]
        }

    ! [8: if the story viewpoint is third person singular begin]
    if (((story_viewpoint == I113_third_person_singular))){
        ! [9: if the player is male begin]
        if ((((Adj_82_t1_v10(player))))){
            ! [10: say ~his~]
            say__p=1;ParaContent(); print "his"; .L_Say553; .L_SayX551;
            ! [11: otherwise]
            } else {

            ! [12: say ~her~]
            say__p=1;ParaContent(); print "her"; .L_Say554; .L_SayX552;
            ! [13: end if]
            }

        ! [14: end if]
        }

    ! [15: if the story viewpoint is first person plural begin]
    if (((story_viewpoint == I114_first_person_plural))){
        ! [16: say ~our~]
        say__p=1;ParaContent(); print "our"; .L_Say555; .L_SayX553;
        ! [17: end if]
        }

    ! [18: if the story viewpoint is second person plural begin]
    if (((story_viewpoint == I115_second_person_plural))){
        ! [19: say ~your~]
        say__p=1;ParaContent(); print "your"; .L_Say556; .L_SayX554;
        ! [20: end if]
        }

    ! [21: if the story viewpoint is third person plural begin]
    if (((story_viewpoint == I116_third_person_plural))){
        ! [22: say ~their~]
        say__p=1;ParaContent(); print "their"; .L_Say557; .L_SayX555;
        ! [23: end if]
        }

        rfalse;
];
! From "English Language" by Graham Nelson
! Request 46: phrase nothing -> nothing
! To say We:
[ PHR_779_r46  ;
    ! [1: now the prior named object is the player]
    prior_named_noun = player;
    ! [2: if the story viewpoint is first person singular begin]
    if (((story_viewpoint == I111_first_person_singular))){
        ! [3: say ~I~]
        say__p=1;ParaContent(); print "I"; .L_Say558; .L_SayX556;
        ! [4: end if]
        }

    ! [5: if the story viewpoint is second person singular begin]
    if (((story_viewpoint == I112_second_person_singular))){
        ! [6: say ~You~]
        say__p=1;ParaContent(); print "You"; .L_Say559; .L_SayX557;
        ! [7: end if]
        }

    ! [8: if the story viewpoint is third person singular begin]
    if (((story_viewpoint == I113_third_person_singular))){
        ! [9: if the player is male begin]
        if ((((Adj_82_t1_v10(player))))){
            ! [10: say ~He~]
            say__p=1;ParaContent(); print "He"; .L_Say560; .L_SayX558;
            ! [11: otherwise]
            } else {

            ! [12: say ~She~]
            say__p=1;ParaContent(); print "She"; .L_Say561; .L_SayX559;
            ! [13: end if]
            }

        ! [14: end if]
        }

    ! [15: if the story viewpoint is first person plural begin]
    if (((story_viewpoint == I114_first_person_plural))){
        ! [16: say ~We~]
        say__p=1;ParaContent(); print "We"; .L_Say562; .L_SayX560;
        ! [17: end if]
        }

    ! [18: if the story viewpoint is second person plural begin]
    if (((story_viewpoint == I115_second_person_plural))){
        ! [19: say ~You~]
        say__p=1;ParaContent(); print "You"; .L_Say563; .L_SayX561;
        ! [20: end if]
        }

    ! [21: if the story viewpoint is third person plural begin]
    if (((story_viewpoint == I116_third_person_plural))){
        ! [22: say ~They~]
        say__p=1;ParaContent(); print "They"; .L_Say564; .L_SayX562;
        ! [23: end if]
        }

        rfalse;
];
! From "English Language" by Graham Nelson
! Request 47: phrase nothing -> nothing
! To say Us:
[ PHR_780_r47  ;
    ! [1: now the prior named object is the player]
    prior_named_noun = player;
    ! [2: if the story viewpoint is first person singular begin]
    if (((story_viewpoint == I111_first_person_singular))){
        ! [3: say ~Me~]
        say__p=1;ParaContent(); print "Me"; .L_Say565; .L_SayX563;
        ! [4: end if]
        }

    ! [5: if the story viewpoint is second person singular begin]
    if (((story_viewpoint == I112_second_person_singular))){
        ! [6: say ~You~]
        say__p=1;ParaContent(); print "You"; .L_Say566; .L_SayX564;
        ! [7: end if]
        }

    ! [8: if the story viewpoint is third person singular begin]
    if (((story_viewpoint == I113_third_person_singular))){
        ! [9: if the player is male begin]
        if ((((Adj_82_t1_v10(player))))){
            ! [10: say ~Him~]
            say__p=1;ParaContent(); print "Him"; .L_Say567; .L_SayX565;
            ! [11: otherwise]
            } else {

            ! [12: say ~Her~]
            say__p=1;ParaContent(); print "Her"; .L_Say568; .L_SayX566;
            ! [13: end if]
            }

        ! [14: end if]
        }

    ! [15: if the story viewpoint is first person plural begin]
    if (((story_viewpoint == I114_first_person_plural))){
        ! [16: say ~Us~]
        say__p=1;ParaContent(); print "Us"; .L_Say569; .L_SayX567;
        ! [17: end if]
        }

    ! [18: if the story viewpoint is second person plural begin]
    if (((story_viewpoint == I115_second_person_plural))){
        ! [19: say ~You~]
        say__p=1;ParaContent(); print "You"; .L_Say570; .L_SayX568;
        ! [20: end if]
        }

    ! [21: if the story viewpoint is third person plural begin]
    if (((story_viewpoint == I116_third_person_plural))){
        ! [22: say ~Them~]
        say__p=1;ParaContent(); print "Them"; .L_Say571; .L_SayX569;
        ! [23: end if]
        }

        rfalse;
];
! From "English Language" by Graham Nelson
! Request 48: phrase nothing -> nothing
! To say Ours:
[ PHR_781_r48  ;
    ! [1: now the prior named object is the player]
    prior_named_noun = player;
    ! [2: if the story viewpoint is first person singular begin]
    if (((story_viewpoint == I111_first_person_singular))){
        ! [3: say ~Mine~]
        say__p=1;ParaContent(); print "Mine"; .L_Say572; .L_SayX570;
        ! [4: end if]
        }

    ! [5: if the story viewpoint is second person singular begin]
    if (((story_viewpoint == I112_second_person_singular))){
        ! [6: say ~Yours~]
        say__p=1;ParaContent(); print "Yours"; .L_Say573; .L_SayX571;
        ! [7: end if]
        }

    ! [8: if the story viewpoint is third person singular begin]
    if (((story_viewpoint == I113_third_person_singular))){
        ! [9: if the player is male begin]
        if ((((Adj_82_t1_v10(player))))){
            ! [10: say ~His~]
            say__p=1;ParaContent(); print "His"; .L_Say574; .L_SayX572;
            ! [11: otherwise]
            } else {

            ! [12: say ~Hers~]
            say__p=1;ParaContent(); print "Hers"; .L_Say575; .L_SayX573;
            ! [13: end if]
            }

        ! [14: end if]
        }

    ! [15: if the story viewpoint is first person plural begin]
    if (((story_viewpoint == I114_first_person_plural))){
        ! [16: say ~Ours~]
        say__p=1;ParaContent(); print "Ours"; .L_Say576; .L_SayX574;
        ! [17: end if]
        }

    ! [18: if the story viewpoint is second person plural begin]
    if (((story_viewpoint == I115_second_person_plural))){
        ! [19: say ~Yours~]
        say__p=1;ParaContent(); print "Yours"; .L_Say577; .L_SayX575;
        ! [20: end if]
        }

    ! [21: if the story viewpoint is third person plural begin]
    if (((story_viewpoint == I116_third_person_plural))){
        ! [22: say ~Theirs~]
        say__p=1;ParaContent(); print "Theirs"; .L_Say578; .L_SayX576;
        ! [23: end if]
        }

        rfalse;
];
! From "English Language" by Graham Nelson
! Request 49: phrase nothing -> nothing
! To say Ourselves:
[ PHR_782_r49  ;
    ! [1: now the prior named object is the player]
    prior_named_noun = player;
    ! [2: if the story viewpoint is first person singular begin]
    if (((story_viewpoint == I111_first_person_singular))){
        ! [3: say ~Myself~]
        say__p=1;ParaContent(); print "Myself"; .L_Say579; .L_SayX577;
        ! [4: end if]
        }

    ! [5: if the story viewpoint is second person singular begin]
    if (((story_viewpoint == I112_second_person_singular))){
        ! [6: say ~Yourself~]
        say__p=1;ParaContent(); print "Yourself"; .L_Say580; .L_SayX578;
        ! [7: end if]
        }

    ! [8: if the story viewpoint is third person singular begin]
    if (((story_viewpoint == I113_third_person_singular))){
        ! [9: if the player is male begin]
        if ((((Adj_82_t1_v10(player))))){
            ! [10: say ~Himself~]
            say__p=1;ParaContent(); print "Himself"; .L_Say581; .L_SayX579;
            ! [11: otherwise]
            } else {

            ! [12: say ~Herself~]
            say__p=1;ParaContent(); print "Herself"; .L_Say582; .L_SayX580;
            ! [13: end if]
            }

        ! [14: end if]
        }

    ! [15: if the story viewpoint is first person plural begin]
    if (((story_viewpoint == I114_first_person_plural))){
        ! [16: say ~Ourselves~]
        say__p=1;ParaContent(); print "Ourselves"; .L_Say583; .L_SayX581;
        ! [17: end if]
        }

    ! [18: if the story viewpoint is second person plural begin]
    if (((story_viewpoint == I115_second_person_plural))){
        ! [19: say ~Yourselves~]
        say__p=1;ParaContent(); print "Yourselves"; .L_Say584; .L_SayX582;
        ! [20: end if]
        }

    ! [21: if the story viewpoint is third person plural begin]
    if (((story_viewpoint == I116_third_person_plural))){
        ! [22: say ~Themselves~]
        say__p=1;ParaContent(); print "Themselves"; .L_Say585; .L_SayX583;
        ! [23: end if]
        }

        rfalse;
];
! From "English Language" by Graham Nelson
! Request 50: phrase nothing -> nothing
! To say Our:
[ PHR_783_r50  ;
    ! [1: now the prior named object is the player]
    prior_named_noun = player;
    ! [2: if the story viewpoint is first person singular begin]
    if (((story_viewpoint == I111_first_person_singular))){
        ! [3: say ~My~]
        say__p=1;ParaContent(); print "My"; .L_Say586; .L_SayX584;
        ! [4: end if]
        }

    ! [5: if the story viewpoint is second person singular begin]
    if (((story_viewpoint == I112_second_person_singular))){
        ! [6: say ~Your~]
        say__p=1;ParaContent(); print "Your"; .L_Say587; .L_SayX585;
        ! [7: end if]
        }

    ! [8: if the story viewpoint is third person singular begin]
    if (((story_viewpoint == I113_third_person_singular))){
        ! [9: if the player is male begin]
        if ((((Adj_82_t1_v10(player))))){
            ! [10: say ~His~]
            say__p=1;ParaContent(); print "His"; .L_Say588; .L_SayX586;
            ! [11: otherwise]
            } else {

            ! [12: say ~Her~]
            say__p=1;ParaContent(); print "Her"; .L_Say589; .L_SayX587;
            ! [13: end if]
            }

        ! [14: end if]
        }

    ! [15: if the story viewpoint is first person plural begin]
    if (((story_viewpoint == I114_first_person_plural))){
        ! [16: say ~Our~]
        say__p=1;ParaContent(); print "Our"; .L_Say590; .L_SayX588;
        ! [17: end if]
        }

    ! [18: if the story viewpoint is second person plural begin]
    if (((story_viewpoint == I115_second_person_plural))){
        ! [19: say ~Your~]
        say__p=1;ParaContent(); print "Your"; .L_Say591; .L_SayX589;
        ! [20: end if]
        }

    ! [21: if the story viewpoint is third person plural begin]
    if (((story_viewpoint == I116_third_person_plural))){
        ! [22: say ~Their~]
        say__p=1;ParaContent(); print "Their"; .L_Say592; .L_SayX590;
        ! [23: end if]
        }

        rfalse;
];
! From "English Language" by Graham Nelson
! Request 51: phrase nothing -> nothing
! To say those:
[ PHR_784_r51  ;
    ! [1: say those in the accusative]
    say__p=1;ParaContent(); (PHR_786_r53 (I119_accusative)); .L_Say593; .L_SayX591;
    rfalse;
];
! From "English Language" by Graham Nelson
! Request 52: phrase nothing -> nothing
! To say Those:
[ PHR_785_r52  ;
    ! [1: say those in the nominative]
    say__p=1;ParaContent(); (PHR_787_r54 (I118_nominative)); .L_Say594; .L_SayX592;
    rfalse;
];
! From "English Language" by Graham Nelson
! Request 53: phrase grammatical case -> nothing
! To say those in ( case - grammatical case ):
[ PHR_786_r53  
    t_0 ! Call parameter 'case': grammatical case
    tmp_0 ! Let/loop value, e.g., '?-1,-1?'(deallocated by end of phrase)
    ;
    ! [1: if the case is nominative begin]
    if (((t_0 == I118_nominative))){
        ! [2: let the item be the prior named object]

        		tmp_0 = prior_named_noun;
        ! [3: if the prior naming context is plural begin]
        if ((((prior_named_list >= 2) || (prior_named_noun && prior_named_noun has pluralname)))){
            ! [4: say ~those~]
            say__p=1;ParaContent(); print "those"; .L_Say595; .L_SayX593;
            ! [5: otherwise if the item is the player]
            } else if (((tmp_0 == player))) {
            ! [6: say ~[we]~]
            say__p=1;ParaContent(); (PHR_774_r41 ()); .L_Say596; .L_SayX594;
            ! [7: otherwise if the item is a male person and item is not neuter]
            } else if ((((tmp_0 ofclass K8_person) && ((Adj_82_t1_v10(tmp_0))))) && (((~~(((Adj_83_t1_v10(tmp_0)))))))) {
            ! [8: say ~he~]
            say__p=1;ParaContent(); print "he"; .L_Say597; .L_SayX595;
            ! [9: otherwise if the item is a female person and item is not neuter]
            } else if ((((tmp_0 ofclass K8_person) && ((Adj_81_t1_v10(tmp_0))))) && (((~~(((Adj_83_t1_v10(tmp_0)))))))) {
            ! [10: say ~she~]
            say__p=1;ParaContent(); print "she"; .L_Say598; .L_SayX596;
            ! [11: otherwise]
            } else {

            ! [12: say ~that~]
            say__p=1;ParaContent(); print "that"; .L_Say599; .L_SayX597;
            ! [13: end if]
            }

        ! [14: otherwise]
        } else {

        ! [15: let the item be the prior named object]

        		tmp_0 = prior_named_noun;
        ! [16: if the prior naming context is plural begin]
        if ((((prior_named_list >= 2) || (prior_named_noun && prior_named_noun has pluralname)))){
            ! [17: say ~those~]
            say__p=1;ParaContent(); print "those"; .L_Say600; .L_SayX598;
            ! [18: otherwise if the item is the player]
            } else if (((tmp_0 == player))) {
            ! [19: say ~[we]~]
            say__p=1;ParaContent(); (PHR_774_r41 ()); .L_Say601; .L_SayX599;
            ! [20: otherwise if the item is a male person and item is not neuter]
            } else if ((((tmp_0 ofclass K8_person) && ((Adj_82_t1_v10(tmp_0))))) && (((~~(((Adj_83_t1_v10(tmp_0)))))))) {
            ! [21: say ~him~]
            say__p=1;ParaContent(); print "him"; .L_Say602; .L_SayX600;
            ! [22: otherwise if the item is a female person and item is not neuter]
            } else if ((((tmp_0 ofclass K8_person) && ((Adj_81_t1_v10(tmp_0))))) && (((~~(((Adj_83_t1_v10(tmp_0)))))))) {
            ! [23: say ~her~]
            say__p=1;ParaContent(); print "her"; .L_Say603; .L_SayX601;
            ! [24: otherwise]
            } else {

            ! [25: say ~that~]
            say__p=1;ParaContent(); print "that"; .L_Say604; .L_SayX602;
            ! [26: end if]
            }

        ! [27: end if]
        }

        rfalse;
];
! From "English Language" by Graham Nelson
! Request 54: phrase grammatical case -> nothing
! To say Those in ( case - grammatical case ):
[ PHR_787_r54  
    t_0 ! Call parameter 'case': grammatical case
    tmp_0 ! Let/loop value, e.g., '?-1,-1?'(deallocated by end of phrase)
    ;
    ! [1: if the case is nominative begin]
    if (((t_0 == I118_nominative))){
        ! [2: let the item be the prior named object]

        		tmp_0 = prior_named_noun;
        ! [3: if the prior naming context is plural begin]
        if ((((prior_named_list >= 2) || (prior_named_noun && prior_named_noun has pluralname)))){
            ! [4: say ~Those~]
            say__p=1;ParaContent(); print "Those"; .L_Say605; .L_SayX603;
            ! [5: otherwise if the item is the player]
            } else if (((tmp_0 == player))) {
            ! [6: say ~[We]~]
            say__p=1;ParaContent(); (PHR_779_r46 ()); .L_Say606; .L_SayX604;
            ! [7: otherwise if the item is a male person and item is not neuter]
            } else if ((((tmp_0 ofclass K8_person) && ((Adj_82_t1_v10(tmp_0))))) && (((~~(((Adj_83_t1_v10(tmp_0)))))))) {
            ! [8: say ~He~]
            say__p=1;ParaContent(); print "He"; .L_Say607; .L_SayX605;
            ! [9: otherwise if the item is a female person and item is not neuter]
            } else if ((((tmp_0 ofclass K8_person) && ((Adj_81_t1_v10(tmp_0))))) && (((~~(((Adj_83_t1_v10(tmp_0)))))))) {
            ! [10: say ~She~]
            say__p=1;ParaContent(); print "She"; .L_Say608; .L_SayX606;
            ! [11: otherwise]
            } else {

            ! [12: say ~That~]
            say__p=1;ParaContent(); print "That"; .L_Say609; .L_SayX607;
            ! [13: end if]
            }

        ! [14: otherwise]
        } else {

        ! [15: let the item be the prior named object]

        		tmp_0 = prior_named_noun;
        ! [16: if the prior naming context is plural begin]
        if ((((prior_named_list >= 2) || (prior_named_noun && prior_named_noun has pluralname)))){
            ! [17: say ~Those~]
            say__p=1;ParaContent(); print "Those"; .L_Say610; .L_SayX608;
            ! [18: otherwise if the item is the player]
            } else if (((tmp_0 == player))) {
            ! [19: say ~[We]~]
            say__p=1;ParaContent(); (PHR_779_r46 ()); .L_Say611; .L_SayX609;
            ! [20: otherwise if the item is a male person and item is not neuter]
            } else if ((((tmp_0 ofclass K8_person) && ((Adj_82_t1_v10(tmp_0))))) && (((~~(((Adj_83_t1_v10(tmp_0)))))))) {
            ! [21: say ~Him~]
            say__p=1;ParaContent(); print "Him"; .L_Say612; .L_SayX610;
            ! [22: otherwise if the item is a female person and item is not neuter]
            } else if ((((tmp_0 ofclass K8_person) && ((Adj_81_t1_v10(tmp_0))))) && (((~~(((Adj_83_t1_v10(tmp_0)))))))) {
            ! [23: say ~Her~]
            say__p=1;ParaContent(); print "Her"; .L_Say613; .L_SayX611;
            ! [24: otherwise]
            } else {

            ! [25: say ~That~]
            say__p=1;ParaContent(); print "That"; .L_Say614; .L_SayX612;
            ! [26: end if]
            }

        ! [27: end if]
        }

        rfalse;
];
! From "English Language" by Graham Nelson
! Request 55: phrase nothing -> nothing
! To say they:
[ PHR_788_r55  
    tmp_0 ! Let/loop value, e.g., 'item': object
    ;
    ! [1: let the item be the prior named object]

    		tmp_0 = prior_named_noun;
    ! [2: if the prior naming context is plural begin]
    if ((((prior_named_list >= 2) || (prior_named_noun && prior_named_noun has pluralname)))){
        ! [3: say ~they~]
        say__p=1;ParaContent(); print "they"; .L_Say615; .L_SayX613;
        ! [4: otherwise if the item is the player]
        } else if (((tmp_0 == player))) {
        ! [5: say ~[we]~]
        say__p=1;ParaContent(); (PHR_774_r41 ()); .L_Say616; .L_SayX614;
        ! [6: otherwise if the item is a male person and item is not neuter]
        } else if ((((tmp_0 ofclass K8_person) && ((Adj_82_t1_v10(tmp_0))))) && (((~~(((Adj_83_t1_v10(tmp_0)))))))) {
        ! [7: say ~he~]
        say__p=1;ParaContent(); print "he"; .L_Say617; .L_SayX615;
        ! [8: otherwise if the item is a female person and item is not neuter]
        } else if ((((tmp_0 ofclass K8_person) && ((Adj_81_t1_v10(tmp_0))))) && (((~~(((Adj_83_t1_v10(tmp_0)))))))) {
        ! [9: say ~she~]
        say__p=1;ParaContent(); print "she"; .L_Say618; .L_SayX616;
        ! [10: otherwise]
        } else {

        ! [11: say ~it~]
        say__p=1;ParaContent(); print "it"; .L_Say619; .L_SayX617;
        ! [12: end if]
        }

        rfalse;
];
! From "English Language" by Graham Nelson
! Request 56: phrase nothing -> nothing
! To say They:
[ PHR_789_r56  
    tmp_0 ! Let/loop value, e.g., 'item': object
    ;
    ! [1: let the item be the prior named object]

    		tmp_0 = prior_named_noun;
    ! [2: if the prior naming context is plural begin]
    if ((((prior_named_list >= 2) || (prior_named_noun && prior_named_noun has pluralname)))){
        ! [3: say ~They~]
        say__p=1;ParaContent(); print "They"; .L_Say620; .L_SayX618;
        ! [4: otherwise if the item is the player]
        } else if (((tmp_0 == player))) {
        ! [5: say ~[We]~]
        say__p=1;ParaContent(); (PHR_779_r46 ()); .L_Say621; .L_SayX619;
        ! [6: otherwise if the item is a male person and item is not neuter]
        } else if ((((tmp_0 ofclass K8_person) && ((Adj_82_t1_v10(tmp_0))))) && (((~~(((Adj_83_t1_v10(tmp_0)))))))) {
        ! [7: say ~He~]
        say__p=1;ParaContent(); print "He"; .L_Say622; .L_SayX620;
        ! [8: otherwise if the item is a female person and item is not neuter]
        } else if ((((tmp_0 ofclass K8_person) && ((Adj_81_t1_v10(tmp_0))))) && (((~~(((Adj_83_t1_v10(tmp_0)))))))) {
        ! [9: say ~She~]
        say__p=1;ParaContent(); print "She"; .L_Say623; .L_SayX621;
        ! [10: otherwise]
        } else {

        ! [11: say ~It~]
        say__p=1;ParaContent(); print "It"; .L_Say624; .L_SayX622;
        ! [12: end if]
        }

        rfalse;
];
! From "English Language" by Graham Nelson
! Request 57: phrase nothing -> nothing
! To say their:
[ PHR_790_r57  
    tmp_0 ! Let/loop value, e.g., 'item': object
    ;
    ! [1: let the item be the prior named object]

    		tmp_0 = prior_named_noun;
    ! [2: if the prior naming context is plural begin]
    if ((((prior_named_list >= 2) || (prior_named_noun && prior_named_noun has pluralname)))){
        ! [3: say ~their~]
        say__p=1;ParaContent(); print "their"; .L_Say625; .L_SayX623;
        ! [4: otherwise if the item is the player]
        } else if (((tmp_0 == player))) {
        ! [5: say ~[our]~]
        say__p=1;ParaContent(); (PHR_778_r45 ()); .L_Say626; .L_SayX624;
        ! [6: otherwise if the item is a male person and item is not neuter]
        } else if ((((tmp_0 ofclass K8_person) && ((Adj_82_t1_v10(tmp_0))))) && (((~~(((Adj_83_t1_v10(tmp_0)))))))) {
        ! [7: say ~his~]
        say__p=1;ParaContent(); print "his"; .L_Say627; .L_SayX625;
        ! [8: otherwise if the item is a female person and item is not neuter]
        } else if ((((tmp_0 ofclass K8_person) && ((Adj_81_t1_v10(tmp_0))))) && (((~~(((Adj_83_t1_v10(tmp_0)))))))) {
        ! [9: say ~her~]
        say__p=1;ParaContent(); print "her"; .L_Say628; .L_SayX626;
        ! [10: otherwise]
        } else {

        ! [11: say ~its~]
        say__p=1;ParaContent(); print "its"; .L_Say629; .L_SayX627;
        ! [12: end if]
        }

        rfalse;
];
! From "English Language" by Graham Nelson
! Request 58: phrase nothing -> nothing
! To say Their:
[ PHR_791_r58  
    tmp_0 ! Let/loop value, e.g., 'item': object
    ;
    ! [1: let the item be the prior named object]

    		tmp_0 = prior_named_noun;
    ! [2: if the prior naming context is plural begin]
    if ((((prior_named_list >= 2) || (prior_named_noun && prior_named_noun has pluralname)))){
        ! [3: say ~Their~]
        say__p=1;ParaContent(); print "Their"; .L_Say630; .L_SayX628;
        ! [4: otherwise if the item is the player]
        } else if (((tmp_0 == player))) {
        ! [5: say ~[Our]~]
        say__p=1;ParaContent(); (PHR_783_r50 ()); .L_Say631; .L_SayX629;
        ! [6: otherwise if the item is a male person and item is not neuter]
        } else if ((((tmp_0 ofclass K8_person) && ((Adj_82_t1_v10(tmp_0))))) && (((~~(((Adj_83_t1_v10(tmp_0)))))))) {
        ! [7: say ~His~]
        say__p=1;ParaContent(); print "His"; .L_Say632; .L_SayX630;
        ! [8: otherwise if the item is a female person and item is not neuter]
        } else if ((((tmp_0 ofclass K8_person) && ((Adj_81_t1_v10(tmp_0))))) && (((~~(((Adj_83_t1_v10(tmp_0)))))))) {
        ! [9: say ~Her~]
        say__p=1;ParaContent(); print "Her"; .L_Say633; .L_SayX631;
        ! [10: otherwise]
        } else {

        ! [11: say ~Its~]
        say__p=1;ParaContent(); print "Its"; .L_Say634; .L_SayX632;
        ! [12: end if]
        }

        rfalse;
];
! From "English Language" by Graham Nelson
! Request 59: phrase nothing -> nothing
! To say them:
[ PHR_792_r59  
    tmp_0 ! Let/loop value, e.g., 'item': object
    ;
    ! [1: let the item be the prior named object]

    		tmp_0 = prior_named_noun;
    ! [2: if the prior naming context is plural begin]
    if ((((prior_named_list >= 2) || (prior_named_noun && prior_named_noun has pluralname)))){
        ! [3: say ~them~]
        say__p=1;ParaContent(); print "them"; .L_Say635; .L_SayX633;
        ! [4: otherwise if the item is the player]
        } else if (((tmp_0 == player))) {
        ! [5: say ~[us]~]
        say__p=1;ParaContent(); (PHR_775_r42 ()); .L_Say636; .L_SayX634;
        ! [6: otherwise if the item is a male person and item is not neuter]
        } else if ((((tmp_0 ofclass K8_person) && ((Adj_82_t1_v10(tmp_0))))) && (((~~(((Adj_83_t1_v10(tmp_0)))))))) {
        ! [7: say ~him~]
        say__p=1;ParaContent(); print "him"; .L_Say637; .L_SayX635;
        ! [8: otherwise if the item is a female person and item is not neuter]
        } else if ((((tmp_0 ofclass K8_person) && ((Adj_81_t1_v10(tmp_0))))) && (((~~(((Adj_83_t1_v10(tmp_0)))))))) {
        ! [9: say ~her~]
        say__p=1;ParaContent(); print "her"; .L_Say638; .L_SayX636;
        ! [10: otherwise]
        } else {

        ! [11: say ~it~]
        say__p=1;ParaContent(); print "it"; .L_Say639; .L_SayX637;
        ! [12: end if]
        }

        rfalse;
];
! From "English Language" by Graham Nelson
! Request 60: phrase nothing -> nothing
! To say Them:
[ PHR_793_r60  
    tmp_0 ! Let/loop value, e.g., 'item': object
    ;
    ! [1: let the item be the prior named object]

    		tmp_0 = prior_named_noun;
    ! [2: if the prior naming context is plural begin]
    if ((((prior_named_list >= 2) || (prior_named_noun && prior_named_noun has pluralname)))){
        ! [3: say ~Them~]
        say__p=1;ParaContent(); print "Them"; .L_Say640; .L_SayX638;
        ! [4: otherwise if the item is the player]
        } else if (((tmp_0 == player))) {
        ! [5: say ~[Us]~]
        say__p=1;ParaContent(); (PHR_780_r47 ()); .L_Say641; .L_SayX639;
        ! [6: otherwise if the item is a male person and item is not neuter]
        } else if ((((tmp_0 ofclass K8_person) && ((Adj_82_t1_v10(tmp_0))))) && (((~~(((Adj_83_t1_v10(tmp_0)))))))) {
        ! [7: say ~Him~]
        say__p=1;ParaContent(); print "Him"; .L_Say642; .L_SayX640;
        ! [8: otherwise if the item is a female person and item is not neuter]
        } else if ((((tmp_0 ofclass K8_person) && ((Adj_81_t1_v10(tmp_0))))) && (((~~(((Adj_83_t1_v10(tmp_0)))))))) {
        ! [9: say ~Her~]
        say__p=1;ParaContent(); print "Her"; .L_Say643; .L_SayX641;
        ! [10: otherwise]
        } else {

        ! [11: say ~It~]
        say__p=1;ParaContent(); print "It"; .L_Say644; .L_SayX642;
        ! [12: end if]
        }

        rfalse;
];
! From "English Language" by Graham Nelson
! Request 61: phrase nothing -> nothing
! To say theirs:
[ PHR_794_r61  
    tmp_0 ! Let/loop value, e.g., 'item': object
    ;
    ! [1: let the item be the prior named object]

    		tmp_0 = prior_named_noun;
    ! [2: if the prior naming context is plural begin]
    if ((((prior_named_list >= 2) || (prior_named_noun && prior_named_noun has pluralname)))){
        ! [3: say ~theirs~]
        say__p=1;ParaContent(); print "theirs"; .L_Say645; .L_SayX643;
        ! [4: otherwise if the item is the player]
        } else if (((tmp_0 == player))) {
        ! [5: say ~[ours]~]
        say__p=1;ParaContent(); (PHR_776_r43 ()); .L_Say646; .L_SayX644;
        ! [6: otherwise if the item is a male person and item is not neuter]
        } else if ((((tmp_0 ofclass K8_person) && ((Adj_82_t1_v10(tmp_0))))) && (((~~(((Adj_83_t1_v10(tmp_0)))))))) {
        ! [7: say ~his~]
        say__p=1;ParaContent(); print "his"; .L_Say647; .L_SayX645;
        ! [8: otherwise if the item is a female person and item is not neuter]
        } else if ((((tmp_0 ofclass K8_person) && ((Adj_81_t1_v10(tmp_0))))) && (((~~(((Adj_83_t1_v10(tmp_0)))))))) {
        ! [9: say ~hers~]
        say__p=1;ParaContent(); print "hers"; .L_Say648; .L_SayX646;
        ! [10: otherwise]
        } else {

        ! [11: say ~its~]
        say__p=1;ParaContent(); print "its"; .L_Say649; .L_SayX647;
        ! [12: end if]
        }

        rfalse;
];
! From "English Language" by Graham Nelson
! Request 62: phrase nothing -> nothing
! To say Theirs:
[ PHR_795_r62  
    tmp_0 ! Let/loop value, e.g., 'item': object
    ;
    ! [1: let the item be the prior named object]

    		tmp_0 = prior_named_noun;
    ! [2: if the prior naming context is plural begin]
    if ((((prior_named_list >= 2) || (prior_named_noun && prior_named_noun has pluralname)))){
        ! [3: say ~Theirs~]
        say__p=1;ParaContent(); print "Theirs"; .L_Say650; .L_SayX648;
        ! [4: otherwise if the item is the player]
        } else if (((tmp_0 == player))) {
        ! [5: say ~[Ours]~]
        say__p=1;ParaContent(); (PHR_781_r48 ()); .L_Say651; .L_SayX649;
        ! [6: otherwise if the item is a male person and item is not neuter]
        } else if ((((tmp_0 ofclass K8_person) && ((Adj_82_t1_v10(tmp_0))))) && (((~~(((Adj_83_t1_v10(tmp_0)))))))) {
        ! [7: say ~His~]
        say__p=1;ParaContent(); print "His"; .L_Say652; .L_SayX650;
        ! [8: otherwise if the item is a female person and item is not neuter]
        } else if ((((tmp_0 ofclass K8_person) && ((Adj_81_t1_v10(tmp_0))))) && (((~~(((Adj_83_t1_v10(tmp_0)))))))) {
        ! [9: say ~Hers~]
        say__p=1;ParaContent(); print "Hers"; .L_Say653; .L_SayX651;
        ! [10: otherwise]
        } else {

        ! [11: say ~Its~]
        say__p=1;ParaContent(); print "Its"; .L_Say654; .L_SayX652;
        ! [12: end if]
        }

        rfalse;
];
! From "English Language" by Graham Nelson
! Request 63: phrase nothing -> nothing
! To say themselves:
[ PHR_796_r63  
    tmp_0 ! Let/loop value, e.g., 'item': object
    ;
    ! [1: let the item be the prior named object]

    		tmp_0 = prior_named_noun;
    ! [2: if the prior naming context is plural begin]
    if ((((prior_named_list >= 2) || (prior_named_noun && prior_named_noun has pluralname)))){
        ! [3: say ~themselves~]
        say__p=1;ParaContent(); print "themselves"; .L_Say655; .L_SayX653;
        ! [4: otherwise if the item is the player]
        } else if (((tmp_0 == player))) {
        ! [5: say ~[ourselves]~]
        say__p=1;ParaContent(); (PHR_777_r44 ()); .L_Say656; .L_SayX654;
        ! [6: otherwise if the item is a male person and item is not neuter]
        } else if ((((tmp_0 ofclass K8_person) && ((Adj_82_t1_v10(tmp_0))))) && (((~~(((Adj_83_t1_v10(tmp_0)))))))) {
        ! [7: say ~himself~]
        say__p=1;ParaContent(); print "himself"; .L_Say657; .L_SayX655;
        ! [8: otherwise if the item is a female person and item is not neuter]
        } else if ((((tmp_0 ofclass K8_person) && ((Adj_81_t1_v10(tmp_0))))) && (((~~(((Adj_83_t1_v10(tmp_0)))))))) {
        ! [9: say ~herself~]
        say__p=1;ParaContent(); print "herself"; .L_Say658; .L_SayX656;
        ! [10: otherwise]
        } else {

        ! [11: say ~itself~]
        say__p=1;ParaContent(); print "itself"; .L_Say659; .L_SayX657;
        ! [12: end if]
        }

        rfalse;
];
! From "English Language" by Graham Nelson
! Request 64: phrase nothing -> nothing
! To say Themselves:
[ PHR_797_r64  
    tmp_0 ! Let/loop value, e.g., 'item': object
    ;
    ! [1: let the item be the prior named object]

    		tmp_0 = prior_named_noun;
    ! [2: if the prior naming context is plural begin]
    if ((((prior_named_list >= 2) || (prior_named_noun && prior_named_noun has pluralname)))){
        ! [3: say ~Themselves~]
        say__p=1;ParaContent(); print "Themselves"; .L_Say660; .L_SayX658;
        ! [4: otherwise if the item is the player]
        } else if (((tmp_0 == player))) {
        ! [5: say ~[Ourselves]~]
        say__p=1;ParaContent(); (PHR_782_r49 ()); .L_Say661; .L_SayX659;
        ! [6: otherwise if the item is a male person and item is not neuter]
        } else if ((((tmp_0 ofclass K8_person) && ((Adj_82_t1_v10(tmp_0))))) && (((~~(((Adj_83_t1_v10(tmp_0)))))))) {
        ! [7: say ~Himself~]
        say__p=1;ParaContent(); print "Himself"; .L_Say662; .L_SayX660;
        ! [8: otherwise if the item is a female person and item is not neuter]
        } else if ((((tmp_0 ofclass K8_person) && ((Adj_81_t1_v10(tmp_0))))) && (((~~(((Adj_83_t1_v10(tmp_0)))))))) {
        ! [9: say ~Herself~]
        say__p=1;ParaContent(); print "Herself"; .L_Say663; .L_SayX661;
        ! [10: otherwise]
        } else {

        ! [11: say ~Itself~]
        say__p=1;ParaContent(); print "Itself"; .L_Say664; .L_SayX662;
        ! [12: end if]
        }

        rfalse;
];
! From "English Language" by Graham Nelson
! Request 65: phrase nothing -> nothing
! To say they're:
[ PHR_798_r65  
    tmp_0 ! Let/loop value, e.g., 'item': object
    ;
    ! [1: let the item be the prior named object]

    		tmp_0 = prior_named_noun;
    ! [2: if the prior naming context is plural begin]
    if ((((prior_named_list >= 2) || (prior_named_noun && prior_named_noun has pluralname)))){
        ! [3: say ~they~]
        say__p=1;ParaContent(); print "they"; .L_Say665; .L_SayX663;
        ! [4: otherwise if the item is the player]
        } else if (((tmp_0 == player))) {
        ! [5: say ~[we]~]
        say__p=1;ParaContent(); (PHR_774_r41 ()); .L_Say666; .L_SayX664;
        ! [6: otherwise if the item is a male person and item is not neuter]
        } else if ((((tmp_0 ofclass K8_person) && ((Adj_82_t1_v10(tmp_0))))) && (((~~(((Adj_83_t1_v10(tmp_0)))))))) {
        ! [7: say ~he~]
        say__p=1;ParaContent(); print "he"; .L_Say667; .L_SayX665;
        ! [8: otherwise if the item is a female person and item is not neuter]
        } else if ((((tmp_0 ofclass K8_person) && ((Adj_81_t1_v10(tmp_0))))) && (((~~(((Adj_83_t1_v10(tmp_0)))))))) {
        ! [9: say ~she~]
        say__p=1;ParaContent(); print "she"; .L_Say668; .L_SayX666;
        ! [10: otherwise]
        } else {

        ! [11: say ~that~]
        say__p=1;ParaContent(); print "that"; .L_Say669; .L_SayX667;
        ! [12: end if]
        }

    ! [13: say ~['re]~]
    ConjugateVerb_74(CV_POS, PNToVP(), story_tense); say__p=1;  .L_Say670; .L_SayX668;
    rfalse;
];
! From "English Language" by Graham Nelson
! Request 66: phrase nothing -> nothing
! To say They're:
[ PHR_799_r66  
    tmp_0 ! Let/loop value, e.g., 'item': object
    ;
    ! [1: let the item be the prior named object]

    		tmp_0 = prior_named_noun;
    ! [2: if the prior naming context is plural begin]
    if ((((prior_named_list >= 2) || (prior_named_noun && prior_named_noun has pluralname)))){
        ! [3: say ~They~]
        say__p=1;ParaContent(); print "They"; .L_Say671; .L_SayX669;
        ! [4: otherwise if the item is the player]
        } else if (((tmp_0 == player))) {
        ! [5: say ~[We]~]
        say__p=1;ParaContent(); (PHR_779_r46 ()); .L_Say672; .L_SayX670;
        ! [6: otherwise if the item is a male person and item is not neuter]
        } else if ((((tmp_0 ofclass K8_person) && ((Adj_82_t1_v10(tmp_0))))) && (((~~(((Adj_83_t1_v10(tmp_0)))))))) {
        ! [7: say ~He~]
        say__p=1;ParaContent(); print "He"; .L_Say673; .L_SayX671;
        ! [8: otherwise if the item is a female person and item is not neuter]
        } else if ((((tmp_0 ofclass K8_person) && ((Adj_81_t1_v10(tmp_0))))) && (((~~(((Adj_83_t1_v10(tmp_0)))))))) {
        ! [9: say ~She~]
        say__p=1;ParaContent(); print "She"; .L_Say674; .L_SayX672;
        ! [10: otherwise]
        } else {

        ! [11: say ~That~]
        say__p=1;ParaContent(); print "That"; .L_Say675; .L_SayX673;
        ! [12: end if]
        }

    ! [13: say ~['re]~]
    ConjugateVerb_74(CV_POS, PNToVP(), story_tense); say__p=1;  .L_Say676; .L_SayX674;
    rfalse;
];
! From "English Language" by Graham Nelson
! Request 67: phrase nothing -> nothing
! To say It:
[ PHR_800_r67  ;
    ! [1: say ~[regarding nothing]It~]
    say__p=1;ParaContent(); RegardingSingleObject(nothing);ParaContent(); print "It"; .L_Say677; .L_SayX675;
    rfalse;
];
! From "English Language" by Graham Nelson
! Request 68: phrase nothing -> nothing
! To say There:
[ PHR_801_r68  ;
    ! [1: say ~[regarding nothing]There~]
    say__p=1;ParaContent(); RegardingSingleObject(nothing);ParaContent(); print "There"; .L_Say678; .L_SayX676;
    rfalse;
];
! From "English Language" by Graham Nelson
! Request 69: phrase nothing -> nothing
! To say it:
[ PHR_802_r69  ;
    ! [1: say ~[regarding nothing]it~]
    say__p=1;ParaContent(); RegardingSingleObject(nothing);ParaContent(); print "it"; .L_Say679; .L_SayX677;
    rfalse;
];
! From "English Language" by Graham Nelson
! Request 70: phrase nothing -> nothing
! To say there:
[ PHR_803_r70  ;
    ! [1: say ~[regarding nothing]there~]
    say__p=1;ParaContent(); RegardingSingleObject(nothing);ParaContent(); print "there"; .L_Say680; .L_SayX678;
    rfalse;
];
! From "English Language" by Graham Nelson
! Request 71: phrase nothing -> nothing
! To say It's:
[ PHR_804_r71  ;
    ! [1: say ~[regarding nothing]It['re]~]
    say__p=1;ParaContent(); RegardingSingleObject(nothing);ParaContent(); print "It";ConjugateVerb_74(CV_POS, PNToVP(), story_tense); say__p=1;  .L_Say681; .L_SayX679;
    rfalse;
];
! From "English Language" by Graham Nelson
! Request 72: phrase nothing -> nothing
! To say There's:
[ PHR_805_r72  ;
    ! [1: say ~[regarding nothing]There['re]~]
    say__p=1;ParaContent(); RegardingSingleObject(nothing);ParaContent(); print "There";ConjugateVerb_74(CV_POS, PNToVP(), story_tense); say__p=1;  .L_Say682; .L_SayX680;
    rfalse;
];
! From "English Language" by Graham Nelson
! Request 73: phrase nothing -> nothing
! To say it's:
[ PHR_806_r73  ;
    ! [1: say ~[regarding nothing]it['re]~]
    say__p=1;ParaContent(); RegardingSingleObject(nothing);ParaContent(); print "it";ConjugateVerb_74(CV_POS, PNToVP(), story_tense); say__p=1;  .L_Say683; .L_SayX681;
    rfalse;
];
! From "English Language" by Graham Nelson
! Request 74: phrase nothing -> nothing
! To say there's:
[ PHR_807_r74  ;
    ! [1: say ~[regarding nothing]there['re]~]
    say__p=1;ParaContent(); RegardingSingleObject(nothing);ParaContent(); print "there";ConjugateVerb_74(CV_POS, PNToVP(), story_tense); say__p=1;  .L_Say684; .L_SayX682;
    rfalse;
];
! From "English Language" by Graham Nelson
! Request 75: phrase nothing -> nothing
! To say possessive:
[ PHR_808_r75  
    tmp_0 ! Let/loop value, e.g., 'item': object
    ;
    ! [1: let the item be the prior named object]

    		tmp_0 = prior_named_noun;
    ! [2: if the item is the player begin]
    if (((tmp_0 == player))){
        ! [3: say ~[our]~]
        say__p=1;ParaContent(); (PHR_778_r45 ()); .L_Say685; .L_SayX683;
        ! [4: otherwise if the prior naming context is plural]
        } else if ((((prior_named_list >= 2) || (prior_named_noun && prior_named_noun has pluralname)))) {
        ! [5: say ~[the item][apostrophe]~]
        say__p=1;ParaContent(); print (the) tmp_0;ParaContent(); print "'"; .L_Say686; .L_SayX684;
        ! [6: otherwise]
        } else {

        ! [7: say ~[the item][apostrophe]s~]
        say__p=1;ParaContent(); print (the) tmp_0;ParaContent(); print "'";ParaContent(); print "s"; .L_Say687; .L_SayX685;
        ! [8: end if]
        }

        rfalse;
];
! From "English Language" by Graham Nelson
! Request 76: phrase nothing -> nothing
! To say Possessive:
[ PHR_809_r76  
    tmp_0 ! Let/loop value, e.g., 'item': object
    ;
    ! [1: let the item be the prior named object]

    		tmp_0 = prior_named_noun;
    ! [2: if the item is the player begin]
    if (((tmp_0 == player))){
        ! [3: say ~[Our]~]
        say__p=1;ParaContent(); (PHR_783_r50 ()); .L_Say688; .L_SayX686;
        ! [4: otherwise if the prior naming context is plural]
        } else if ((((prior_named_list >= 2) || (prior_named_noun && prior_named_noun has pluralname)))) {
        ! [5: say ~[The item][apostrophe]~]
        say__p=1;ParaContent(); print (The) tmp_0;ParaContent(); print "'"; .L_Say689; .L_SayX687;
        ! [6: otherwise]
        } else {

        ! [7: say ~[The item][apostrophe]s~]
        say__p=1;ParaContent(); print (The) tmp_0;ParaContent(); print "'";ParaContent(); print "s"; .L_Say690; .L_SayX688;
        ! [8: end if]
        }

        rfalse;
];
! From "Plurality" by Emily Short
! Request 77: phrase object -> truth state
! To decide whether ( item - an object ) acts plural:
[ PHR_850_r77  
    t_0 ! Call parameter 'item': object
    ;
    ! [1: if the item is plural-named or the item is ambiguously plural begin]
    if (((((Adj_44_t1_v10(t_0))))) || ((((Adj_48_t1_v10(t_0)))))){
        ! [2: yes]
        rtrue;
        ! [3: end if]
        }

    ! [4: no]
    rfalse;
    return false;
];
! From "Plurality" by Emily Short
! Request 78: phrase nothing -> nothing
! To say is-are:
[ PHR_851_r78  ;
    ! [1: say is-are of prior named noun]
    say__p=1;ParaContent(); (PHR_852_r79 ((Global_Vars-->15))); .L_Say691; .L_SayX689;
    rfalse;
];
! From "Plurality" by Emily Short
! Request 79: phrase thing -> nothing
! To say is-are of ( item - a thing ):
[ PHR_852_r79  
    t_0 ! Call parameter 'item': thing
    ;
    ! [1: now the prior named noun is the item]
    (Global_Vars-->15) = t_0;
    ! [2: if prior named noun acts plural or the prior named noun is the player , say ~are~]
    if ((((PHR_850_r77 ((Global_Vars-->15))))) || ((((Global_Vars-->15) == player)))) { say__p=1;ParaContent(); print "are"; .L_Say692; .L_SayX690; }
    ! [3: otherwise say ~is~]
    else { say__p=1;ParaContent(); print "is"; .L_Say693; .L_SayX691; }
    rfalse;
];
! From "Plurality" by Emily Short
! Request 80: phrase nothing -> nothing
! To say has-have:
[ PHR_853_r80  ;
    ! [1: say has-have of prior named noun]
    say__p=1;ParaContent(); (PHR_854_r81 ((Global_Vars-->15))); .L_Say694; .L_SayX692;
    rfalse;
];
! From "Plurality" by Emily Short
! Request 81: phrase thing -> nothing
! To say has-have of ( item - a thing ):
[ PHR_854_r81  
    t_0 ! Call parameter 'item': thing
    ;
    ! [1: if the item acts plural or the item is the player begin]
    if ((((PHR_850_r77 (t_0)))) || (((t_0 == player)))){
        ! [2: say ~have~]
        say__p=1;ParaContent(); print "have"; .L_Say695; .L_SayX693;
        ! [3: otherwise]
        } else {

        ! [4: say ~has~]
        say__p=1;ParaContent(); print "has"; .L_Say696; .L_SayX694;
        ! [5: end if]
        }

        rfalse;
];
! From "Plurality" by Emily Short
! Request 82: phrase nothing -> nothing
! To say es:
[ PHR_857_r82  ;
    ! [1: say es of prior named noun]
    say__p=1;ParaContent(); (PHR_858_r83 ((Global_Vars-->15))); .L_Say697; .L_SayX695;
    rfalse;
];
! From "Plurality" by Emily Short
! Request 83: phrase thing -> nothing
! To say es of ( item - a thing ):
[ PHR_858_r83  
    t_0 ! Call parameter 'item': thing
    ;
    ! [1: if the item acts plural or the item is the player begin]
    if ((((PHR_850_r77 (t_0)))) || (((t_0 == player)))){
        ! [2: say ~~]
        say__p=1;ParaContent(); print ""; .L_Say698; .L_SayX696;
        ! [3: otherwise]
        } else {

        ! [4: say ~es~]
        say__p=1;ParaContent(); print "es"; .L_Say699; .L_SayX697;
        ! [5: end if]
        }

        rfalse;
];
! From "Plurality" by Emily Short
! Request 84: phrase nothing -> nothing
! To say ies:
[ PHR_859_r84  ;
    ! [1: say ies of prior named noun]
    say__p=1;ParaContent(); (PHR_860_r85 ((Global_Vars-->15))); .L_Say700; .L_SayX698;
    rfalse;
];
! From "Plurality" by Emily Short
! Request 85: phrase thing -> nothing
! To say ies of ( item - a thing ):
[ PHR_860_r85  
    t_0 ! Call parameter 'item': thing
    ;
    ! [1: if the item acts plural or the item is the player begin]
    if ((((PHR_850_r77 (t_0)))) || (((t_0 == player)))){
        ! [2: say ~y~]
        say__p=1;ParaContent(); print "y"; .L_Say701; .L_SayX699;
        ! [3: otherwise]
        } else {

        ! [4: say ~ies~]
        say__p=1;ParaContent(); print "ies"; .L_Say702; .L_SayX700;
        ! [5: end if]
        }

        rfalse;
];
! From "Plurality" by Emily Short
! Request 86: phrase nothing -> nothing
! To say that-those:
[ PHR_861_r86  ;
    ! [1: say that-those prior named noun]
    say__p=1;ParaContent(); (PHR_865_r90 ((Global_Vars-->15))); .L_Say703; .L_SayX701;
    rfalse;
];
! From "Plurality" by Emily Short
! Request 87: phrase nothing -> nothing
! To say Cap that-those:
[ PHR_862_r87  ;
    ! [1: say cap that-those prior named noun]
    say__p=1;ParaContent(); (PHR_864_r89 ((Global_Vars-->15))); .L_Say704; .L_SayX702;
    rfalse;
];
! From "Plurality" by Emily Short
! Request 88: phrase thing -> nothing
! To say that-those of ( item - a thing ):
[ PHR_863_r88  
    t_0 ! Call parameter 'item': thing
    ;
    ! [1: now the prior named noun is the item]
    (Global_Vars-->15) = t_0;
    ! [2: mark prior named noun in output]
    (PHR_847_r7 ((Global_Vars-->15)));
    ! [3: if the item acts plural begin]
    if (((PHR_850_r77 (t_0)))){
        ! [4: say ~those~]
        say__p=1;ParaContent(); print "those"; .L_Say705; .L_SayX703;
        ! [5: otherwise if the item is the player]
        } else if (((t_0 == player))) {
        ! [6: say ~you~]
        say__p=1;ParaContent(); print "you"; .L_Say706; .L_SayX704;
        ! [7: otherwise if the item is male and item is not neuter]
        } else if (((((Adj_82_t1_v10(t_0))))) && (((~~(((Adj_83_t1_v10(t_0)))))))) {
        ! [8: say ~he~]
        say__p=1;ParaContent(); print "he"; .L_Say707; .L_SayX705;
        ! [9: otherwise if the item is female and item is not neuter]
        } else if (((((Adj_81_t1_v10(t_0))))) && (((~~(((Adj_83_t1_v10(t_0)))))))) {
        ! [10: say ~she~]
        say__p=1;ParaContent(); print "she"; .L_Say708; .L_SayX706;
        ! [11: otherwise]
        } else {

        ! [12: say ~that~]
        say__p=1;ParaContent(); print "that"; .L_Say709; .L_SayX707;
        ! [13: end if]
        }

        rfalse;
];
! From "Plurality" by Emily Short
! Request 89: phrase thing -> nothing
! To say Cap that-those ( item - a thing ):
[ PHR_864_r89  
    t_0 ! Call parameter 'item': thing
    ;
    ! [1: now the prior named noun is the item]
    (Global_Vars-->15) = t_0;
    ! [2: mark prior named noun in output]
    (PHR_847_r7 ((Global_Vars-->15)));
    ! [3: if the item acts plural begin]
    if (((PHR_850_r77 (t_0)))){
        ! [4: say ~Those~]
        say__p=1;ParaContent(); print "Those"; .L_Say710; .L_SayX708;
        ! [5: otherwise if the item is the player]
        } else if (((t_0 == player))) {
        ! [6: say ~You~]
        say__p=1;ParaContent(); print "You"; .L_Say711; .L_SayX709;
        ! [7: otherwise if the item is male and item is not neuter]
        } else if (((((Adj_82_t1_v10(t_0))))) && (((~~(((Adj_83_t1_v10(t_0)))))))) {
        ! [8: say ~He~]
        say__p=1;ParaContent(); print "He"; .L_Say712; .L_SayX710;
        ! [9: otherwise if the item is female and item is not neuter]
        } else if (((((Adj_81_t1_v10(t_0))))) && (((~~(((Adj_83_t1_v10(t_0)))))))) {
        ! [10: say ~She~]
        say__p=1;ParaContent(); print "She"; .L_Say713; .L_SayX711;
        ! [11: otherwise]
        } else {

        ! [12: say ~That~]
        say__p=1;ParaContent(); print "That"; .L_Say714; .L_SayX712;
        ! [13: end if]
        }

        rfalse;
];
! From "Plurality" by Emily Short
! Request 90: phrase thing -> nothing
! To say that-those ( item - a thing ):
[ PHR_865_r90  
    t_0 ! Call parameter 'item': thing
    ;
    ! [1: now the prior named noun is the item]
    (Global_Vars-->15) = t_0;
    ! [2: mark prior named noun in output]
    (PHR_847_r7 ((Global_Vars-->15)));
    ! [3: if the item acts plural begin]
    if (((PHR_850_r77 (t_0)))){
        ! [4: say ~those~]
        say__p=1;ParaContent(); print "those"; .L_Say715; .L_SayX713;
        ! [5: otherwise if the item is the player]
        } else if (((t_0 == player))) {
        ! [6: say ~you~]
        say__p=1;ParaContent(); print "you"; .L_Say716; .L_SayX714;
        ! [7: otherwise if the item is male and item is not neuter]
        } else if (((((Adj_82_t1_v10(t_0))))) && (((~~(((Adj_83_t1_v10(t_0)))))))) {
        ! [8: say ~he~]
        say__p=1;ParaContent(); print "he"; .L_Say717; .L_SayX715;
        ! [9: otherwise if the item is female and item is not neuter]
        } else if (((((Adj_81_t1_v10(t_0))))) && (((~~(((Adj_83_t1_v10(t_0)))))))) {
        ! [10: say ~she~]
        say__p=1;ParaContent(); print "she"; .L_Say718; .L_SayX716;
        ! [11: otherwise]
        } else {

        ! [12: say ~that~]
        say__p=1;ParaContent(); print "that"; .L_Say719; .L_SayX717;
        ! [13: end if]
        }

        rfalse;
];
! From "Plurality" by Emily Short
! Request 91: phrase thing -> nothing
! To say Cap that-those of ( item - a thing ):
[ PHR_866_r91  
    t_0 ! Call parameter 'item': thing
    ;
    ! [1: now the prior named noun is the item]
    (Global_Vars-->15) = t_0;
    ! [2: mark prior named noun in output]
    (PHR_847_r7 ((Global_Vars-->15)));
    ! [3: if the item acts plural begin]
    if (((PHR_850_r77 (t_0)))){
        ! [4: say ~Those~]
        say__p=1;ParaContent(); print "Those"; .L_Say720; .L_SayX718;
        ! [5: otherwise if the item is the player]
        } else if (((t_0 == player))) {
        ! [6: say ~You~]
        say__p=1;ParaContent(); print "You"; .L_Say721; .L_SayX719;
        ! [7: otherwise if the item is male and item is not neuter]
        } else if (((((Adj_82_t1_v10(t_0))))) && (((~~(((Adj_83_t1_v10(t_0)))))))) {
        ! [8: say ~He~]
        say__p=1;ParaContent(); print "He"; .L_Say722; .L_SayX720;
        ! [9: otherwise if the item is female and item is not neuter]
        } else if (((((Adj_81_t1_v10(t_0))))) && (((~~(((Adj_83_t1_v10(t_0)))))))) {
        ! [10: say ~She~]
        say__p=1;ParaContent(); print "She"; .L_Say723; .L_SayX721;
        ! [11: otherwise]
        } else {

        ! [12: say ~That~]
        say__p=1;ParaContent(); print "That"; .L_Say724; .L_SayX722;
        ! [13: end if]
        }

        rfalse;
];
! From "Plurality" by Emily Short
! Request 92: phrase nothing -> nothing
! To say it-they:
[ PHR_867_r92  ;
    ! [1: say it-they of prior named noun]
    say__p=1;ParaContent(); (PHR_868_r93 ((Global_Vars-->15))); .L_Say725; .L_SayX723;
    rfalse;
];
! From "Plurality" by Emily Short
! Request 93: phrase thing -> nothing
! To say it-they of ( item - a thing ):
[ PHR_868_r93  
    t_0 ! Call parameter 'item': thing
    ;
    ! [1: now the prior named noun is the item]
    (Global_Vars-->15) = t_0;
    ! [2: mark prior named noun in output]
    (PHR_847_r7 ((Global_Vars-->15)));
    ! [3: if the item acts plural begin]
    if (((PHR_850_r77 (t_0)))){
        ! [4: say ~they~]
        say__p=1;ParaContent(); print "they"; .L_Say726; .L_SayX724;
        ! [5: otherwise if the item is the player]
        } else if (((t_0 == player))) {
        ! [6: say ~you~]
        say__p=1;ParaContent(); print "you"; .L_Say727; .L_SayX725;
        ! [7: otherwise if the item is male and item is not neuter]
        } else if (((((Adj_82_t1_v10(t_0))))) && (((~~(((Adj_83_t1_v10(t_0)))))))) {
        ! [8: say ~he~]
        say__p=1;ParaContent(); print "he"; .L_Say728; .L_SayX726;
        ! [9: otherwise if the item is female and item is not neuter]
        } else if (((((Adj_81_t1_v10(t_0))))) && (((~~(((Adj_83_t1_v10(t_0)))))))) {
        ! [10: say ~she~]
        say__p=1;ParaContent(); print "she"; .L_Say729; .L_SayX727;
        ! [11: otherwise]
        } else {

        ! [12: say ~it~]
        say__p=1;ParaContent(); print "it"; .L_Say730; .L_SayX728;
        ! [13: end if]
        }

        rfalse;
];
! From "Plurality" by Emily Short
! Request 94: phrase nothing -> nothing
! To say Cap it-they:
[ PHR_869_r94  ;
    ! [1: say cap it-they of prior named noun]
    say__p=1;ParaContent(); (PHR_870_r95 ((Global_Vars-->15))); .L_Say731; .L_SayX729;
    rfalse;
];
! From "Plurality" by Emily Short
! Request 95: phrase thing -> nothing
! To say Cap it-they of ( item - a thing ):
[ PHR_870_r95  
    t_0 ! Call parameter 'item': thing
    ;
    ! [1: now the prior named noun is the item]
    (Global_Vars-->15) = t_0;
    ! [2: mark prior named noun in output]
    (PHR_847_r7 ((Global_Vars-->15)));
    ! [3: if the item acts plural begin]
    if (((PHR_850_r77 (t_0)))){
        ! [4: say ~They~]
        say__p=1;ParaContent(); print "They"; .L_Say732; .L_SayX730;
        ! [5: otherwise if the item is the player]
        } else if (((t_0 == player))) {
        ! [6: say ~You~]
        say__p=1;ParaContent(); print "You"; .L_Say733; .L_SayX731;
        ! [7: otherwise if the item is male and item is not neuter]
        } else if (((((Adj_82_t1_v10(t_0))))) && (((~~(((Adj_83_t1_v10(t_0)))))))) {
        ! [8: say ~He~]
        say__p=1;ParaContent(); print "He"; .L_Say734; .L_SayX732;
        ! [9: otherwise if the item is female and item is not neuter]
        } else if (((((Adj_81_t1_v10(t_0))))) && (((~~(((Adj_83_t1_v10(t_0)))))))) {
        ! [10: say ~She~]
        say__p=1;ParaContent(); print "She"; .L_Say735; .L_SayX733;
        ! [11: otherwise]
        } else {

        ! [12: say ~It~]
        say__p=1;ParaContent(); print "It"; .L_Say736; .L_SayX734;
        ! [13: end if]
        }

        rfalse;
];
! From "Plurality" by Emily Short
! Request 96: phrase nothing -> nothing
! To say its-their:
[ PHR_871_r96  ;
    ! [1: say its-their of prior named noun]
    say__p=1;ParaContent(); (PHR_872_r97 ((Global_Vars-->15))); .L_Say737; .L_SayX735;
    rfalse;
];
! From "Plurality" by Emily Short
! Request 97: phrase thing -> nothing
! To say its-their of ( item - a thing ):
[ PHR_872_r97  
    t_0 ! Call parameter 'item': thing
    ;
    ! [1: now the prior named noun is the item]
    (Global_Vars-->15) = t_0;
    ! [2: mark prior named noun in output]
    (PHR_847_r7 ((Global_Vars-->15)));
    ! [3: if the item acts plural begin]
    if (((PHR_850_r77 (t_0)))){
        ! [4: say ~their~]
        say__p=1;ParaContent(); print "their"; .L_Say738; .L_SayX736;
        ! [5: otherwise if the item is the player]
        } else if (((t_0 == player))) {
        ! [6: say ~your~]
        say__p=1;ParaContent(); print "your"; .L_Say739; .L_SayX737;
        ! [7: otherwise if the item is male and item is not neuter]
        } else if (((((Adj_82_t1_v10(t_0))))) && (((~~(((Adj_83_t1_v10(t_0)))))))) {
        ! [8: say ~his~]
        say__p=1;ParaContent(); print "his"; .L_Say740; .L_SayX738;
        ! [9: otherwise if the item is female and item is not neuter]
        } else if (((((Adj_81_t1_v10(t_0))))) && (((~~(((Adj_83_t1_v10(t_0)))))))) {
        ! [10: say ~her~]
        say__p=1;ParaContent(); print "her"; .L_Say741; .L_SayX739;
        ! [11: otherwise]
        } else {

        ! [12: say ~its~]
        say__p=1;ParaContent(); print "its"; .L_Say742; .L_SayX740;
        ! [13: end if]
        }

        rfalse;
];
! From "Plurality" by Emily Short
! Request 98: phrase nothing -> nothing
! To say Cap its-their:
[ PHR_873_r98  ;
    ! [1: say cap its-their of prior named noun]
    say__p=1;ParaContent(); (PHR_874_r99 ((Global_Vars-->15))); .L_Say743; .L_SayX741;
    rfalse;
];
! From "Plurality" by Emily Short
! Request 99: phrase thing -> nothing
! To say Cap its-their of ( item - a thing ):
[ PHR_874_r99  
    t_0 ! Call parameter 'item': thing
    ;
    ! [1: now the prior named noun is the item]
    (Global_Vars-->15) = t_0;
    ! [2: mark prior named noun in output]
    (PHR_847_r7 ((Global_Vars-->15)));
    ! [3: if the item acts plural begin]
    if (((PHR_850_r77 (t_0)))){
        ! [4: say ~Their~]
        say__p=1;ParaContent(); print "Their"; .L_Say744; .L_SayX742;
        ! [5: otherwise if the item is the player]
        } else if (((t_0 == player))) {
        ! [6: say ~Your~]
        say__p=1;ParaContent(); print "Your"; .L_Say745; .L_SayX743;
        ! [7: otherwise if the item is male and item is not neuter]
        } else if (((((Adj_82_t1_v10(t_0))))) && (((~~(((Adj_83_t1_v10(t_0)))))))) {
        ! [8: say ~His~]
        say__p=1;ParaContent(); print "His"; .L_Say746; .L_SayX744;
        ! [9: otherwise if the item is female and item is not neuter]
        } else if (((((Adj_81_t1_v10(t_0))))) && (((~~(((Adj_83_t1_v10(t_0)))))))) {
        ! [10: say ~Her~]
        say__p=1;ParaContent(); print "Her"; .L_Say747; .L_SayX745;
        ! [11: otherwise]
        } else {

        ! [12: say ~Its~]
        say__p=1;ParaContent(); print "Its"; .L_Say748; .L_SayX746;
        ! [13: end if]
        }

        rfalse;
];
! From "Plurality" by Emily Short
! Request 100: phrase nothing -> nothing
! To say it-them:
[ PHR_875_r100  ;
    ! [1: say it-them of prior named noun]
    say__p=1;ParaContent(); (PHR_876_r101 ((Global_Vars-->15))); .L_Say749; .L_SayX747;
    rfalse;
];
! From "Plurality" by Emily Short
! Request 101: phrase thing -> nothing
! To say it-them of ( item - a thing ):
[ PHR_876_r101  
    t_0 ! Call parameter 'item': thing
    ;
    ! [1: now the prior named noun is the item]
    (Global_Vars-->15) = t_0;
    ! [2: mark prior named noun in output]
    (PHR_847_r7 ((Global_Vars-->15)));
    ! [3: if the item acts plural begin]
    if (((PHR_850_r77 (t_0)))){
        ! [4: say ~them~]
        say__p=1;ParaContent(); print "them"; .L_Say750; .L_SayX748;
        ! [5: otherwise if the item is the player]
        } else if (((t_0 == player))) {
        ! [6: say ~you~]
        say__p=1;ParaContent(); print "you"; .L_Say751; .L_SayX749;
        ! [7: otherwise if the item is male and item is not neuter]
        } else if (((((Adj_82_t1_v10(t_0))))) && (((~~(((Adj_83_t1_v10(t_0)))))))) {
        ! [8: say ~him~]
        say__p=1;ParaContent(); print "him"; .L_Say752; .L_SayX750;
        ! [9: otherwise if the item is female and item is not neuter]
        } else if (((((Adj_81_t1_v10(t_0))))) && (((~~(((Adj_83_t1_v10(t_0)))))))) {
        ! [10: say ~her~]
        say__p=1;ParaContent(); print "her"; .L_Say753; .L_SayX751;
        ! [11: otherwise]
        } else {

        ! [12: say ~it~]
        say__p=1;ParaContent(); print "it"; .L_Say754; .L_SayX752;
        ! [13: end if]
        }

        rfalse;
];
! From "Plurality" by Emily Short
! Request 102: phrase nothing -> nothing
! To say Cap it-them:
[ PHR_877_r102  ;
    ! [1: say cap it-them of prior named noun]
    say__p=1;ParaContent(); (PHR_878_r103 ((Global_Vars-->15))); .L_Say755; .L_SayX753;
    rfalse;
];
! From "Plurality" by Emily Short
! Request 103: phrase thing -> nothing
! To say Cap it-them of ( item - a thing ):
[ PHR_878_r103  
    t_0 ! Call parameter 'item': thing
    ;
    ! [1: now the prior named noun is the item]
    (Global_Vars-->15) = t_0;
    ! [2: mark prior named noun in output]
    (PHR_847_r7 ((Global_Vars-->15)));
    ! [3: if the item acts plural begin]
    if (((PHR_850_r77 (t_0)))){
        ! [4: say ~Them~]
        say__p=1;ParaContent(); print "Them"; .L_Say756; .L_SayX754;
        ! [5: otherwise if the item is the player]
        } else if (((t_0 == player))) {
        ! [6: say ~You~]
        say__p=1;ParaContent(); print "You"; .L_Say757; .L_SayX755;
        ! [7: otherwise if the item is male and item is not neuter]
        } else if (((((Adj_82_t1_v10(t_0))))) && (((~~(((Adj_83_t1_v10(t_0)))))))) {
        ! [8: say ~Him~]
        say__p=1;ParaContent(); print "Him"; .L_Say758; .L_SayX756;
        ! [9: otherwise if the item is female and item is not neuter]
        } else if (((((Adj_81_t1_v10(t_0))))) && (((~~(((Adj_83_t1_v10(t_0)))))))) {
        ! [10: say ~Her~]
        say__p=1;ParaContent(); print "Her"; .L_Say759; .L_SayX757;
        ! [11: otherwise]
        } else {

        ! [12: say ~It~]
        say__p=1;ParaContent(); print "It"; .L_Say760; .L_SayX758;
        ! [13: end if]
        }

        rfalse;
];
! From "Plurality" by Emily Short
! Request 104: phrase nothing -> nothing
! To say its-theirs:
[ PHR_879_r104  ;
    ! [1: say its-theirs of prior named noun]
    say__p=1;ParaContent(); (PHR_880_r105 ((Global_Vars-->15))); .L_Say761; .L_SayX759;
    rfalse;
];
! From "Plurality" by Emily Short
! Request 105: phrase thing -> nothing
! To say its-theirs of ( item - a thing ):
[ PHR_880_r105  
    t_0 ! Call parameter 'item': thing
    ;
    ! [1: now the prior named noun is the item]
    (Global_Vars-->15) = t_0;
    ! [2: mark prior named noun in output]
    (PHR_847_r7 ((Global_Vars-->15)));
    ! [3: if the item acts plural begin]
    if (((PHR_850_r77 (t_0)))){
        ! [4: say ~theirs~]
        say__p=1;ParaContent(); print "theirs"; .L_Say762; .L_SayX760;
        ! [5: otherwise if the item is the player]
        } else if (((t_0 == player))) {
        ! [6: say ~yours~]
        say__p=1;ParaContent(); print "yours"; .L_Say763; .L_SayX761;
        ! [7: otherwise if the item is male and item is not neuter]
        } else if (((((Adj_82_t1_v10(t_0))))) && (((~~(((Adj_83_t1_v10(t_0)))))))) {
        ! [8: say ~his~]
        say__p=1;ParaContent(); print "his"; .L_Say764; .L_SayX762;
        ! [9: otherwise if the item is female and item is not neuter]
        } else if (((((Adj_81_t1_v10(t_0))))) && (((~~(((Adj_83_t1_v10(t_0)))))))) {
        ! [10: say ~hers~]
        say__p=1;ParaContent(); print "hers"; .L_Say765; .L_SayX763;
        ! [11: otherwise]
        } else {

        ! [12: say ~its~]
        say__p=1;ParaContent(); print "its"; .L_Say766; .L_SayX764;
        ! [13: end if]
        }

        rfalse;
];
! From "Plurality" by Emily Short
! Request 106: phrase nothing -> nothing
! To say Cap its-theirs:
[ PHR_881_r106  ;
    ! [1: say its-theirs of prior named noun]
    say__p=1;ParaContent(); (PHR_880_r105 ((Global_Vars-->15))); .L_Say767; .L_SayX765;
    rfalse;
];
! From "Plurality" by Emily Short
! Request 107: phrase thing -> nothing
! To say Cap its-theirs of ( item - a thing ):
[ PHR_882_r107  
    t_0 ! Call parameter 'item': thing
    ;
    ! [1: now the prior named noun is the item]
    (Global_Vars-->15) = t_0;
    ! [2: mark prior named noun in output]
    (PHR_847_r7 ((Global_Vars-->15)));
    ! [3: if the item acts plural begin]
    if (((PHR_850_r77 (t_0)))){
        ! [4: say ~Theirs~]
        say__p=1;ParaContent(); print "Theirs"; .L_Say768; .L_SayX766;
        ! [5: otherwise if the item is the player]
        } else if (((t_0 == player))) {
        ! [6: say ~Yours~]
        say__p=1;ParaContent(); print "Yours"; .L_Say769; .L_SayX767;
        ! [7: otherwise if the item is male and item is not neuter]
        } else if (((((Adj_82_t1_v10(t_0))))) && (((~~(((Adj_83_t1_v10(t_0)))))))) {
        ! [8: say ~His~]
        say__p=1;ParaContent(); print "His"; .L_Say770; .L_SayX768;
        ! [9: otherwise if the item is female and item is not neuter]
        } else if (((((Adj_81_t1_v10(t_0))))) && (((~~(((Adj_83_t1_v10(t_0)))))))) {
        ! [10: say ~Hers~]
        say__p=1;ParaContent(); print "Hers"; .L_Say771; .L_SayX769;
        ! [11: otherwise]
        } else {

        ! [12: say ~Its~]
        say__p=1;ParaContent(); print "Its"; .L_Say772; .L_SayX770;
        ! [13: end if]
        }

        rfalse;
];
! From "Plurality" by Emily Short
! Request 108: phrase nothing -> nothing
! To say possessive:
[ PHR_883_r108  ;
    ! [1: say possessive of prior named noun]
    say__p=1;ParaContent(); (PHR_884_r109 ((Global_Vars-->15))); .L_Say773; .L_SayX771;
    rfalse;
];
! From "Plurality" by Emily Short
! Request 109: phrase thing -> nothing
! To say possessive of ( item - a thing ):
[ PHR_884_r109  
    t_0 ! Call parameter 'item': thing
    ;
    ! [1: now the prior named noun is the item]
    (Global_Vars-->15) = t_0;
    ! [2: mark prior named noun in output]
    (PHR_847_r7 ((Global_Vars-->15)));
    ! [3: if the item is the player begin]
    if (((t_0 == player))){
        ! [4: say ~your~]
        say__p=1;ParaContent(); print "your"; .L_Say774; .L_SayX772;
        ! [5: otherwise if the item acts plural]
        } else if (((PHR_850_r77 (t_0)))) {
        ! [6: say ~[the item][apostrophe]~]
        say__p=1;ParaContent(); print (the) t_0;ParaContent(); print "'"; .L_Say775; .L_SayX773;
        ! [7: otherwise]
        } else {

        ! [8: say ~[the item][apostrophe]s~]
        say__p=1;ParaContent(); print (the) t_0;ParaContent(); print "'";ParaContent(); print "s"; .L_Say776; .L_SayX774;
        ! [9: end if]
        }

        rfalse;
];
! From "Plurality" by Emily Short
! Request 110: phrase nothing -> nothing
! To say Cap possessive:
[ PHR_885_r110  ;
    ! [1: say cap possessive of prior named noun]
    say__p=1;ParaContent(); (PHR_886_r111 ((Global_Vars-->15))); .L_Say777; .L_SayX775;
    rfalse;
];
! From "Plurality" by Emily Short
! Request 111: phrase thing -> nothing
! To say Cap possessive of ( item - a thing ):
[ PHR_886_r111  
    t_0 ! Call parameter 'item': thing
    ;
    ! [1: now the prior named noun is the item]
    (Global_Vars-->15) = t_0;
    ! [2: mark prior named noun in output]
    (PHR_847_r7 ((Global_Vars-->15)));
    ! [3: if the item is the player begin]
    if (((t_0 == player))){
        ! [4: say ~Your~]
        say__p=1;ParaContent(); print "Your"; .L_Say778; .L_SayX776;
        ! [5: otherwise if the item acts plural]
        } else if (((PHR_850_r77 (t_0)))) {
        ! [6: say ~[The item][apostrophe]~]
        say__p=1;ParaContent(); print (The) t_0;ParaContent(); print "'"; .L_Say779; .L_SayX777;
        ! [7: otherwise]
        } else {

        ! [8: say ~[The item][apostrophe]s~]
        say__p=1;ParaContent(); print (The) t_0;ParaContent(); print "'";ParaContent(); print "s"; .L_Say780; .L_SayX778;
        ! [9: end if]
        }

        rfalse;
];
! From "Plurality" by Emily Short
! Request 112: phrase object -> nothing
! To have the parser notice ( o - an object ):
[ PHR_890_r112  
    t_0 ! Call parameter 'o': object
    ;
    ! [1: if o is ambiguously plural , notice the plurality of o]
    if ((((Adj_48_t1_v10(t_0))))) { PlugPlural(t_0); }
    ! [2: otherwise set pronouns from o]
    else { PronounNotice(t_0); }
    rfalse;
];
! From "Useful Functions" by ShadowChaser
! Request 113: phrase nothing -> number
! To decide what number is the key_pressed:
[ PHR_922_r113  
    tmp_0 ! Let/loop value, e.g., 'keypress': number
    ;
    ! [1: let keypress be 0]

    		tmp_0 = 0;
    ! [2: while keypress is 0 begin]
    while (((tmp_0 == 0))){
        ! [3: let keypress be the chosen letter]
        tmp_0 = VM_KeyChar();
        ! [4: end while]
        }

    ! [5: decide on the keypress]
    return tmp_0;
    return 0;
];
! From "Useful Functions" by ShadowChaser
! Request 114: phrase text -> number
! To decide what number is the key_pressed_with_question ( question - some text ):
[ PHR_923_r114  
    t_0 ! Call parameter 'question': text
    ;
    ! [1: say ~[question][line break]~]
    say__p=1;ParaContent(); print (TEXT_TY_Say) t_0;ParaContent(); new_line; .L_Say781; .L_SayX779;
    ! [2: decide on the key_pressed]
    return (PHR_922_r113 ());
    return 0;
];
! From "Useful Functions" by ShadowChaser
! Request 115: phrase nothing -> text
! To decide what text is the yesno_answer:
[ PHR_924_r115  I7RBLK ;
    @push I7SFRAME;
    StackFrameCreate(4);
    BlkValueCreateOnStack(2, TEXT_TY);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = BlkValueCopy(I7RBLK, KERNEL_16());
    BlkValueFreeOnStack(2);
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! text
];
[ KERNEL_16 
    tmp_0 ! Let/loop value, e.g., 'answer': text
    tmp_1 ! Let/loop value, e.g., 'exitvalue': number
    tmp_2 ! Let/loop value, e.g., '?-1,-1?'(deallocated by end of phrase)
    ;
    ! [1: let the answer be ~MAYBE~]
    tmp_0 = I7SFRAME; 
    		BlkValueCopy(tmp_0, TX_L_441);
    ! [2: let the exitvalue be 0]

    		tmp_1 = 0;
    ! [3: while the exitvalue is 0 begin]
    while (((tmp_1 == 0))){
        ! [4: let keypress be the key_pressed]

        		tmp_2 = (PHR_922_r113 ());
        ! [5: if keypress is 89 or keypress is 121 begin]
        if ((((tmp_2 == 89))) || (((tmp_2 == 121)))){
            ! [6: let the answer be ~YES~]
            BlkValueCopy(tmp_0, TX_L_442);
            ! [7: let the exitvalue be 1]
            tmp_1 = 1;
            ! [8: otherwise if keypress is 78 or keypress is 110]
            } else if ((((tmp_2 == 78))) || (((tmp_2 == 110)))) {
            ! [9: let the answer be ~NO~]
            BlkValueCopy(tmp_0, TX_L_443);
            ! [10: let the exitvalue be 1]
            tmp_1 = 1;
            ! [11: end if]
            }

        ! [12: end while]
        }

    ! [13: decide on the answer]
    return BlkValueCopy((I7SFRAME+WORDSIZE*2), tmp_0);
    return BC_2239;
];
! From "Useful Functions" by ShadowChaser
! Request 116: phrase text -> text
! To decide what text is the yesno_answer_with_question ( question - some text ):
[ PHR_925_r116  I7RBLK 
    t_0 ! Call parameter 'question': text
;
    @push I7SFRAME;
    StackFrameCreate(4);
    BlkValueCreateOnStack(2, TEXT_TY);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = BlkValueCopy(I7RBLK, KERNEL_17(t_0));
    BlkValueFreeOnStack(2);
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! text
];
[ KERNEL_17 
    t_0 ! Call parameter 'question': text
    ;
    ! [1: say ~[question][line break]~]
    say__p=1;ParaContent(); print (TEXT_TY_Say) t_0;ParaContent(); new_line; .L_Say782; .L_SayX780;
    ! [2: decide on the yesno_answer]
    return BlkValueCopy(I7SFRAME, (PHR_924_r115 ((I7SFRAME+WORDSIZE*2))));
    return BC_2240;
];
! From "Useful Functions" by ShadowChaser
! Request 117: phrase nothing -> nothing
! To pause_clear:
[ PHR_926_r117  I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_18();
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_18 
    tmp_0 ! Let/loop value, e.g., 'kp': number
    ;
    ! [1: say paragraph break]
    say__p=1;ParaContent(); DivideParagraphPoint(); new_line; .L_Say783; .L_SayX781;
    ! [2: let kp be the key_pressed_with_question ~Press any key to continue ...~]

    		tmp_0 = (PHR_923_r114 (BlkValueCopy(I7SFRAME, TX_L_444)));
    ! [3: clear the screen]
    VM_ClearScreen(0);
    ! [4: redraw status line]
    DrawStatusLine();
    rfalse;
];
! From "Useful Functions" by ShadowChaser
! Request 118: phrase text -> nothing
! To pause_clear ( the_message - some text ):
[ PHR_927_r118  
    t_0 ! Call parameter 'the_message': text
I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_19(t_0);
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_19 
    t_0 ! Call parameter 'the_message': text
    tmp_0 ! Let/loop value, e.g., 'kp': number
    ;
    ! [1: let kp be the key_pressed_with_question the_message]

    		tmp_0 = (PHR_923_r114 (BlkValueCopy(I7SFRAME, t_0)));
    ! [2: clear the screen]
    VM_ClearScreen(0);
    ! [3: redraw status line]
    DrawStatusLine();
    rfalse;
];
! From "Useful Functions" by ShadowChaser
! Request 119: phrase text -> nothing
! To say pause_clear ( the_message - some text ):
[ PHR_929_r119  
    t_0 ! Call parameter 'the_message': text
I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_20(t_0);
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_20 
    t_0 ! Call parameter 'the_message': text
    ;
    ! [1: pause_clear the_message]
    (PHR_927_r118 (BlkValueCopy(I7SFRAME, t_0)));
    rfalse;
];
! From "Useful Functions" by ShadowChaser
! Request 120: phrase (number, number) -> nothing
! To ( dividend - a number ) percentage of ( divisor - a number ):
[ PHR_930_r120  
    t_0 ! Call parameter 'dividend': number
    t_1 ! Call parameter 'divisor': number
    tmp_0 ! Let/loop value, e.g., 'quotient_integral': number
    tmp_1 ! Let/loop value, e.g., '?-1,-1?'(deallocated by end of phrase)
    tmp_2 ! Let/loop value, e.g., '?-1,-1?'(deallocated by end of phrase)
    tmp_3 ! Let/loop value, e.g., '?-1,-1?'(deallocated by end of phrase)
    ;
    ! [1: let quotient_integral be ( dividend * 100 ) / divisor]

    		tmp_0 = (IntegerDivide((t_0 * 100), t_1));
    ! [2: say ~[quotient_integral]~]
    say__p=1;ParaContent(); print (say__n=tmp_0); .L_Say784; .L_SayX782;
    ! [3: if percentage_precision > 0 begin]
    if ((((Global_Vars-->24) > 0))){
        ! [4: say ~.[run paragraph on]~]
        say__p=1;ParaContent(); print ".";ParaContent(); RunParagraphOn(); .L_Say785; .L_SayX783;
        ! [5: let quotient_remainder be remainder after dividing dividend by divisor]

        		tmp_1 = (IntegerRemainder(t_0, t_1));
        ! [6: let pp be percentage_precision]

        		tmp_2 = (Global_Vars-->24);
        ! [7: while pp > 0 begin]
        while (((tmp_2 > 0))){
            ! [8: let quotient_digit be quotient_remainder * 10 / divisor]

            		tmp_3 = (tmp_1 * (IntegerDivide(10, t_1)));
            ! [9: say ~[quotient_digit]~]
            say__p=1;ParaContent(); print (say__n=tmp_3); .L_Say786; .L_SayX784;
            ! [10: let quotient_remainder be remainder after dividing ( quotient_remainder * 10 ) by divisor]
            tmp_1 = (IntegerRemainder((tmp_1 * 10), t_1));
            ! [11: let pp be pp - 1]
            tmp_2 = (tmp_2 - 1);
            ! [12: end while]
            }

        ! [13: end if]
        }

    ! [14: say ~[percentage_suffix]~]
    say__p=1;ParaContent(); print (TEXT_TY_Say) (Global_Vars-->23); .L_Say787; .L_SayX785;
    rfalse;
];
! From "Useful Functions" by ShadowChaser
! Request 121: phrase (number, number) -> nothing
! To say ( dividend - a number ) percentage of ( divisor - a number ):
[ PHR_931_r121  
    t_0 ! Call parameter 'dividend': number
    t_1 ! Call parameter 'divisor': number
    ;
    ! [1: dividend percentage of divisor]
    (PHR_930_r120 (t_0,t_1));
    rfalse;
];
! From "Useful Functions" by ShadowChaser
! Request 122: phrase (number, number, table name) -> text
! To decide what text is the EqualRankOf ( value - a number ) out_of ( max_value - a number ) from_table ( rankTable - a table-name ):
[ PHR_932_r122  I7RBLK 
    t_0 ! Call parameter 'value': number
    t_1 ! Call parameter 'max_value': number
    t_2 ! Call parameter 'rankTable': table name
;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = BlkValueCopy(I7RBLK, KERNEL_21(t_0, t_1, t_2));
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! text
];
[ KERNEL_21 
    t_0 ! Call parameter 'value': number
    t_1 ! Call parameter 'max_value': number
    t_2 ! Call parameter 'rankTable': table name
    tmp_0 ! Let/loop value, e.g., 'max_rows': number
    tmp_1 ! Let/loop value, e.g., 'row_number': number
    ;
    ! [1: let max_rows be the number of rows in ranktable]

    		tmp_0 = TableRows(t_2);
    ! [2: let row_number be ( value * max_rows ) / max_value]

    		tmp_1 = (IntegerDivide((t_0 * tmp_0), t_1));
    ! [3: if row_number is 0 , let row_number be 1]
    if (((tmp_1 == 0))) { tmp_1 = 1; }
    ! [4: decide on the rank in row row_number of ranktable]
    return BlkValueCopy(I7SFRAME, TableLookUpEntry(t_2,118,tmp_1));
    return BC_2241;
];
! From "Useful Functions" by ShadowChaser
! Request 123: phrase (number, number, table name) -> text
! To decide what text is the RangedRankOf ( value - a number ) out_of ( max_value - a number ) from_table ( rankTable - a table-name ):
[ PHR_933_r123  I7RBLK 
    t_0 ! Call parameter 'value': number
    t_1 ! Call parameter 'max_value': number
    t_2 ! Call parameter 'rankTable': table name
;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = BlkValueCopy(I7RBLK, KERNEL_22(t_0, t_1, t_2));
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! text
];
[ KERNEL_22 
    t_0 ! Call parameter 'value': number
    t_1 ! Call parameter 'max_value': number
    t_2 ! Call parameter 'rankTable': table name
    tmp_0 ! Let/loop value, e.g., 'max_rows': number
    tmp_1 ! Let/loop value, e.g., 'row_percent': number
    tmp_2 ! Let/loop value, e.g., 'rank_spoken': number
    tmp_3 ! Let/loop value, e.g., '?-1,-1?'(deallocated by end of phrase)
    ;
    ! [1: let max_rows be the number of rows in ranktable]

    		tmp_0 = TableRows(t_2);
    ! [2: let row_percent be ( value * 100 ) / max_value]

    		tmp_1 = (IntegerDivide((t_0 * 100), t_1));
    ! [3: let rank_spoken be 0]

    		tmp_2 = 0;
    ! [4: repeat with row_number running from 1 to the number of rows in ranktable begin]
    for (tmp_3=1: tmp_3<=TableRows(t_2): tmp_3++){
        ! [5: if row_percent <= maxpercent in row row_number of ranktable begin]
        if (((tmp_1 <= TableLookUpEntry(t_2,119,tmp_3)))){
            ! [6: if rank_spoken is 0 begin]
            if (((tmp_2 == 0))){
                ! [7: decide on the rank in row row_number of ranktable]
                return BlkValueCopy(I7SFRAME, TableLookUpEntry(t_2,118,tmp_3));
                ! [8: let rank_spoken be 1]
                tmp_2 = 1;
                ! [9: end if]
                }

            ! [10: end if]
            }

        ! [11: end repeat]
        }

        return BC_2242;
];
! From "Useful Functions" by ShadowChaser
! Request 124: phrase number -> number
! To decide what number is the square_root of ( x - a number ):
[ PHR_934_r124  
    t_0 ! Call parameter 'x': number
    tmp_0 ! Let/loop value, e.g., '?-1,-1?'(deallocated by end of phrase)
    tmp_1 ! Let/loop value, e.g., '?-1,-1?'(deallocated by end of phrase)
    ;
    ! [1: if x is 0 begin]
    if (((t_0 == 0))){
        ! [2: decide on 0]
        return 0;
        ! [3: otherwise]
        } else {

        ! [4: let guess be ( x / 2 ) + 1]

        		tmp_0 = ((IntegerDivide(t_0, 2)) + 1);
        ! [5: let guess2 be x / guess]

        		tmp_1 = (IntegerDivide(t_0, tmp_0));
        ! [6: let guess2 be guess + guess2]
        tmp_1 = (tmp_0 + tmp_1);
        ! [7: let guess2 be guess2 / 2]
        tmp_1 = (IntegerDivide(tmp_1, 2));
        ! [8: while guess2 < guess begin]
        while (((tmp_1 < tmp_0))){
            ! [9: let guess be guess2]
            tmp_0 = tmp_1;
            ! [10: let guess2 be x / guess]
            tmp_1 = (IntegerDivide(t_0, tmp_0));
            ! [11: let guess2 be guess + guess2]
            tmp_1 = (tmp_0 + tmp_1);
            ! [12: let guess2 be guess2 / 2]
            tmp_1 = (IntegerDivide(tmp_1, 2));
            ! [13: end while]
            }

        ! [14: decide on guess]
        return tmp_0;
        ! [15: end if]
        }

        return 0;
];
! Request 125: phrase nothing -> nothing
! to say becomeStag:
[ PHR_983_r125  ;
    ! [1: say ~You wouldn't have made it anyway.  The deer woman regained her composure almost immediately.  'Now, where were we?' she asks, her confidence returning.^^'OH!' she said, waving her wand.  You moaned, waves of lust rolling over you.  Meredith looked beautiful, or at least her pussy did, which was practically right in your face. 'Good boy, why don't you help her out?' the witch said, making you lose control.^^The vines disappeared, and you shoved your face between her cheeks. The girl screamed as you frantically licked her clit, exploring her sex with your tongue.  'OOOHH SOMEONE PLEEEEEEEEEEASE' she screamed, your heart going out to her, but your body wired to an extreme and under the control of the humanoid doe.^^'Oh shush,' the doe sorceress said, dismissing the cries. 'Soon you'll love it, and desperately want the muzzle of a stag halfway up your fuckhole, you ass.'  ~]
    say__p=1;ParaContent(); print "You wouldn't have made it anyway.  The deer woman regained her composure almost immediately.  ~Now, where were we?~ she asks, her confidence returning.^^~OH!~ she said, waving her wand.  You moaned, waves of lust rolling over you.  Meredith looked beautiful, or at least her pussy did, which was practically right in your face. ~Good boy, why don't you help her out?~ the witch said, making you lose control.^^The vines disappeared, and you shoved your face between her cheeks. The girl screamed as you frantically licked her clit, exploring her sex with your tongue.  ~OOOHH SOMEONE PLEEEEEEEEEEASE~ she screamed, your heart going out to her, but your body wired to an extreme and under the control of the humanoid doe.^^~Oh shush,~ the doe sorceress said, dismissing the cries. ~Soon you'll love it, and desperately want the muzzle of a stag halfway up your fuckhole, you ass.~  "; .L_Say788; .L_SayX786;
    rfalse;
];
! Request 126: phrase nothing -> nothing
! to say becomeDoe:
[ PHR_984_r126  I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_23();
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_23 ;
    ! [1: say ~You refuse to, breaking free of the magical vines and running through the back door.^^As you sprint across the alley to the woods behind the building you find yourself... Growing? No! You're lifting.. Levitating into the air. 'Fuck!' You yell, unable to go anywhere.^^Against your will, you start to turn in the air, revealing the witch and bound Jennifer standing behind you. The witch has her wand pointed at you, its magic holding you in the air.^^'You just had to run. You couldn't take my generous gift' her spiteful taunt making you feel sick. 'Well lets give you your punishment..'^^*POPPP*^^All your clothes are gone. You try to cover your shame but you still cant control your limbs. You'll have to settle for just staring daggers at the witch. Then you feel your penis twitch. Then twitch again. 'What are you doing?!' You yell, weird feelings flying through your body. The witch smiles and waves her arm, forcing your head to look down.[pause_clear]~]
    say__p=1;ParaContent(); print "You refuse to, breaking free of the magical vines and running through the back door.^^As you sprint across the alley to the woods behind the building you find yourself... Growing? No! You're lifting.. Levitating into the air. ~Fuck!~ You yell, unable to go anywhere.^^Against your will, you start to turn in the air, revealing the witch and bound Jennifer standing behind you. The witch has her wand pointed at you, its magic holding you in the air.^^~You just had to run. You couldn't take my generous gift~ her spiteful taunt making you feel sick. ~Well lets give you your punishment..~^^*POPPP*^^All your clothes are gone. You try to cover your shame but you still cant control your limbs. You'll have to settle for just staring daggers at the witch. Then you feel your penis twitch. Then twitch again. ~What are you doing?!~ You yell, weird feelings flying through your body. The witch smiles and waves her arm, forcing your head to look down."; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say789; .L_SayX787;
    ! [2: say ~Your cock is fully erect, it standing like a sideways flag pole out of your nethers. But its twitching, and darkening. You watch as the head of it disappears into its length, the feeling of warmth spreading from it. You can only gasp as the skin behind it bubbles and expands like a bloated... Breast?^^The breast skin holding your dick changes to the same color as it, your dick shrinking slightly in size as your balls disappear in the mammary mass. 'Whyyyy?' Your ragged cry escapes your mouth at the sight of what you thought was still your dick multiplying into 3 more, the realization that you now have a few small teets sinking in. Brown fur erupts from the outside of your jiggling breasts tissue and starts to cover your widening ass.^^The area behind your utter is stirring, and from what you can feel growing warmer and wetter. 'ohhhhhh' you moan as you can feel a tail wiggling above your ass, the warm feeling right below it and moving to meet with your butt hole.^^Suddenly you drop from the sky, landing nimbly on your hardening fingers. 'Get her, Jennifer' the command from the witch causing you to jump, you had forgotten they were there.^^*SNIFF*^^the warmth behind you is being nuzzled by something, and its making you feel weird. Looking behind, you have just enough time to see the antlers of a stag before his tongue licks your warmth, sending a shockwave of pleasure through you.[pause_clear]~]
    say__p=1;ParaContent(); print "Your cock is fully erect, it standing like a sideways flag pole out of your nethers. But its twitching, and darkening. You watch as the head of it disappears into its length, the feeling of warmth spreading from it. You can only gasp as the skin behind it bubbles and expands like a bloated... Breast?^^The breast skin holding your dick changes to the same color as it, your dick shrinking slightly in size as your balls disappear in the mammary mass. ~Whyyyy?~ Your ragged cry escapes your mouth at the sight of what you thought was still your dick multiplying into 3 more, the realization that you now have a few small teets sinking in. Brown fur erupts from the outside of your jiggling breasts tissue and starts to cover your widening ass.^^The area behind your utter is stirring, and from what you can feel growing warmer and wetter. ~ohhhhhh~ you moan as you can feel a tail wiggling above your ass, the warm feeling right below it and moving to meet with your butt hole.^^Suddenly you drop from the sky, landing nimbly on your hardening fingers. ~Get her, Jennifer~ the command from the witch causing you to jump, you had forgotten they were there.^^*SNIFF*^^the warmth behind you is being nuzzled by something, and its making you feel weird. Looking behind, you have just enough time to see the antlers of a stag before his tongue licks your warmth, sending a shockwave of pleasure through you."; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say790; .L_SayX788;
    ! [3: say ~Its then that you realize what's happening to you. 'Pleaze don't make me the doe' you beg, 'ill do whatever you want.. Please dooOOOOOOHH' The stag jumps on top of you, thrusting frustratingly at your doe pussy. You bleat, trying to get out from underneath him. His dick finally hits the target though.. But its your little doe asshole.^^He plows into it, causing you to cry out in a deerlike whimper. He starts fucking you like mad, the feeling of being mated with a new feeling for you. His balls keep slapping against your plump doe teets as one of his thrusts pull out far enough to plop out of your asshole, the next finding your vagina.^^He starts going to town again, what you can only assume as a shit covered deer dick pounding your pussy. You keep crying out in fear but you can feel something stirring inside of you. 'Nooooooo' the bleat the closest to a human sound you can make as you piss yourself from the pleasurable humiliation.^^The stag thrusts all the way in, your eyes popping out of your head as the sudden move pushes you to cum on his hilted cock. You can feel his seed pumping inside of you, and you know you've been claimed.^^You bleat as he pulls out,exhausted, a squelching sound of your still wet pussy spewing out some of his cum. But its still too much, you know you're pregnant.^^The witch laughs at you, turning to leave you there to get raped by former Jennifer some more. 'im going to leave you with your mind intact asshole,' her last words to you putting terror into your heart, 'i hope you enjoy deer dicks pounding you for the rest of your life, because that's all your gonna get.'.~]
    say__p=1;ParaContent(); print "Its then that you realize what's happening to you. ~Pleaze don't make me the doe~ you beg, ~ill do whatever you want.. Please dooOOOOOOHH~ The stag jumps on top of you, thrusting frustratingly at your doe pussy. You bleat, trying to get out from underneath him. His dick finally hits the target though.. But its your little doe asshole.^^He plows into it, causing you to cry out in a deerlike whimper. He starts fucking you like mad, the feeling of being mated with a new feeling for you. His balls keep slapping against your plump doe teets as one of his thrusts pull out far enough to plop out of your asshole, the next finding your vagina.^^He starts going to town again, what you can only assume as a shit covered deer dick pounding your pussy. You keep crying out in fear but you can feel something stirring inside of you. ~Nooooooo~ the bleat the closest to a human sound you can make as you piss yourself from the pleasurable humiliation.^^The stag thrusts all the way in, your eyes popping out of your head as the sudden move pushes you to cum on his hilted cock. You can feel his seed pumping inside of you, and you know you've been claimed.^^You bleat as he pulls out,exhausted, a squelching sound of your still wet pussy spewing out some of his cum. But its still too much, you know you're pregnant.^^The witch laughs at you, turning to leave you there to get raped by former Jennifer some more. ~im going to leave you with your mind intact asshole,~ her last words to you putting terror into your heart, ~i hope you enjoy deer dicks pounding you for the rest of your life, because that's all your gonna get.~."; new_line; .L_Say791; .L_SayX789;
    ! [4: end the story saying ~[bold type]Game Over.  [italic type]'DOH!!!'  [roman type]Male Human to Doe.~]
    deadflag=(TEXT_TY_ExpandIfPerishable(I7SFRAME,TX_S_485)); story_complete=false;
    rfalse;
];
! Request 127: phrase nothing -> nothing
! to say becomeDairyCow:
[ PHR_986_r127  ;
    ! [1: say ~*SNAP*^^The snap of the witches fingers, a slight burning sensation and the warping of your perspective later, and... well shit, what happened?  You are still in the room, and you can see the witch and... yourself?^^'What the FUCK!' you started to say, the sound of your girlfriends voice as your own shocking you.  'You switched our damn bodies?!'   The witch laughed in return, nodding and a cruel smirk on her face.  'And I'm going to have fun with youuu.  Yoooouuuuuuu?' her last sentence curling off into a deep low.  'MOOOOO' she says, a look of terror and surprise on her own face. [pause_clear].~]
    say__p=1;ParaContent(); print "*SNAP*^^The snap of the witches fingers, a slight burning sensation and the warping of your perspective later, and... well shit, what happened?  You are still in the room, and you can see the witch and... yourself?^^~What the FUCK!~ you started to say, the sound of your girlfriends voice as your own shocking you.  ~You switched our damn bodies?!~   The witch laughed in return, nodding and a cruel smirk on her face.  ~And I'm going to have fun with youuu.  Yoooouuuuuuu?~ her last sentence curling off into a deep low.  ~MOOOOO~ she says, a look of terror and surprise on her own face. ";ParaContent(); (PHR_928_r9 ());ParaContent(); print "."; new_line; .L_Say792; .L_SayX790;
    ! [2: say ~You just stare, jaw dropped, as she starts to struggle to stand, her weight bulking at a incredible speed.  The door to your right swings open, another sorceress appearing from it with her wand pointed directly at the struggling witch.^^'MOOOOOO pleeeeeeease dooooMOOOOOOO' you victim begs the newly arriving witch as she rolls on the ground, her clothes reach their limit.  With a loud ripping noise they give in to the extreme pressure, and other then a stubborn pair of panties, the 'female' witch is naked.  Though shes hardly female anymore, as you can see.^^A growing dick is sprouting out of her nether region, flopping around as the witch transforms into a bull. 'Oh god..' is all you can say as you see her gain mass and testosterone, muscle spreading all over her as her dick grows hard, the erection standing straight out of her sheath.^^Your own changes were happening, your curvy body putting on more mass as you felt your loins were almost on fire. ~]
    say__p=1;ParaContent(); print "You just stare, jaw dropped, as she starts to struggle to stand, her weight bulking at a incredible speed.  The door to your right swings open, another sorceress appearing from it with her wand pointed directly at the struggling witch.^^~MOOOOOO pleeeeeeease dooooMOOOOOOO~ you victim begs the newly arriving witch as she rolls on the ground, her clothes reach their limit.  With a loud ripping noise they give in to the extreme pressure, and other then a stubborn pair of panties, the ~female~ witch is naked.  Though shes hardly female anymore, as you can see.^^A growing dick is sprouting out of her nether region, flopping around as the witch transforms into a bull. ~Oh god..~ is all you can say as you see her gain mass and testosterone, muscle spreading all over her as her dick grows hard, the erection standing straight out of her sheath.^^Your own changes were happening, your curvy body putting on more mass as you felt your loins were almost on fire. "; .L_Say793; .L_SayX791;
    rfalse;
];
! Request 128: phrase nothing -> nothing
! to say femaleDog:
[ PHR_990_r128  I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_24();
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_24 ;
    ! [1: say ~You scream as you start to itch all over, fur sprouting out of every inch of your body.  Your pussy is unbelievably wet, and you can't help but think of the large doberman your neighbors own next door.  You fall to all fours as you whimper at the last changes of your humanity.~]
    say__p=1;ParaContent(); print "You scream as you start to itch all over, fur sprouting out of every inch of your body.  Your pussy is unbelievably wet, and you can't help but think of the large doberman your neighbors own next door.  You fall to all fours as you whimper at the last changes of your humanity."; new_line; .L_Say794; .L_SayX792;
    ! [2: end the story saying ~[bold type]Game Over.  [italic type]'Good girl!'  [roman type]Female Human to Dog.~]
    deadflag=(TEXT_TY_ExpandIfPerishable(I7SFRAME,TX_S_486)); story_complete=false;
    rfalse;
];
! Request 129: phrase nothing -> nothing
! to say becomeMaleDog:
[ PHR_991_r129  I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_25();
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_25 ;
    ! [1: if player is male begin]
    if ((((Adj_82_t1_v10(player))))){
        ! [2: say ~Something knocks you hard on the back of your head, and everything goes dark..^^When you wake up, you can see your chained to a bed in the middle of the room full of cages.  At the end of the bed, a woman with tribal tattoos sits in lingirie.  'HEY! That's my stuff!' you yell, causing her to jump slightly as her back was turned to you. Shes looking through your stuff, and more specifically, your Artifact box.  'Lookie what I got', she says in a terrifying tone, turning to show you that she had found the Wand of the Dog the protector had given you.^^'I'm tired of serving under the fucking Farm Coven.  And if you can't tell, I like turning humans into dogs'  She waves her hand to acknowledge the rows of cages with the dogs as if you didn't know.  'So the fates must've brought you to me for things to turn out this good for me,' a sneer developing on her face.^^'The Wand I have so desperately wanted from the hand of the Ancient One herself, brought to me by my first real TF subject.'[pause_clear]~]
        say__p=1;ParaContent(); print "Something knocks you hard on the back of your head, and everything goes dark..^^When you wake up, you can see your chained to a bed in the middle of the room full of cages.  At the end of the bed, a woman with tribal tattoos sits in lingirie.  ~HEY! That's my stuff!~ you yell, causing her to jump slightly as her back was turned to you. Shes looking through your stuff, and more specifically, your Artifact box.  ~Lookie what I got~, she says in a terrifying tone, turning to show you that she had found the Wand of the Dog the protector had given you.^^~I'm tired of serving under the fucking Farm Coven.  And if you can't tell, I like turning humans into dogs~  She waves her hand to acknowledge the rows of cages with the dogs as if you didn't know.  ~So the fates must've brought you to me for things to turn out this good for me,~ a sneer developing on her face.^^~The Wand I have so desperately wanted from the hand of the Ancient One herself, brought to me by my first real TF subject.~"; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say795; .L_SayX793;
        ! [3: say ~Well fuck.  You didn't know there were 'ambitious' witches like this around.  Suddenly she leans forward and smacks you, 'HEY! Pay attention! I don't want to be monologuing.  Now what was I saying?  Oh yes! Well anyways the transformations til now have taken forever, weeks of slow changes, with no fun for me at all.' She pulls the wand up, pointing it at you. You can only struggle, your legs and hands tied to the bed by magic rope.  'But that's all going to end now' she says, the wand shooting a beam out and hitting your restrained body.^^'NOOOOO' you yell as you feel tingling feelings developing all over.  Fur starts to grow on your chest, a a dark underlayer with a plume of white in the middle.  You have to get out of here, but you can't think of what to do as a naked victim tied to a bed.  As you struggle, the ambitious witch sitting with a look of delight on her face, you can feel your tongue swell in your mouth, growing so long you can't hold it in.^^You open your mouth, letting in hang out, your breathing naturally settling on a chronic pant.  You twist and turn, trying to escape your humiliating end as the fur runs up your neck.  'Please!' your desperate pleas turning into begging.  But the witch doesn't seem to care, this is her dreams coming true. [pause_clear]~]
        say__p=1;ParaContent(); print "Well fuck.  You didn't know there were ~ambitious~ witches like this around.  Suddenly she leans forward and smacks you, ~HEY! Pay attention! I don't want to be monologuing.  Now what was I saying?  Oh yes! Well anyways the transformations til now have taken forever, weeks of slow changes, with no fun for me at all.~ She pulls the wand up, pointing it at you. You can only struggle, your legs and hands tied to the bed by magic rope.  ~But that's all going to end now~ she says, the wand shooting a beam out and hitting your restrained body.^^~NOOOOO~ you yell as you feel tingling feelings developing all over.  Fur starts to grow on your chest, a a dark underlayer with a plume of white in the middle.  You have to get out of here, but you can't think of what to do as a naked victim tied to a bed.  As you struggle, the ambitious witch sitting with a look of delight on her face, you can feel your tongue swell in your mouth, growing so long you can't hold it in.^^You open your mouth, letting in hang out, your breathing naturally settling on a chronic pant.  You twist and turn, trying to escape your humiliating end as the fur runs up your neck.  ~Please!~ your desperate pleas turning into begging.  But the witch doesn't seem to care, this is her dreams coming true. ";ParaContent(); (PHR_928_r9 ()); .L_Say796; .L_SayX794;
        ! [4: say ~The tingling reaches your face, with your lips and nose feeling like they are going to explode.  And they do... but explode out of your face, it lengthening into a muzzle as your pleading turns into the whimpers of a dog.  Your nose can smell everything now, the other dogs, the Artifact... and the witches apparent attraction to what was happening.^^You sniffed some more, smelling the scent of a very sexually excited human.  Your ears extend out the sides of your changing head, ending at points.  The overwhelming experience of hearing everything nearly makes you faint as you try to reorient your senses.^^DOGS BARKING! Fuck you need to resist the urge to join in.. the witches breathing is increasing, as well as the smell of her wetness.  She's getting really turned on by your transformation, and its starting to get you excited as well.^^Craning your German Shepherd snout down, you can see the changes have only encompassed your torso and above so far, you still have a normal human penis.  Which is swelling with the thought of the witches warm pussy gaining wetness for you.  It starts to gain weight, like a flag pole slowly being raised, until your embarrassing erection stands like a monument to your changing body.^^You whine at your frustration, urges to lick yourself and end your sexual torment abound in your mind.  'Ohhh.. well umm, poor doggie?' the witch says, subconciously leaning closer.  'I umm guess I can help, a little bit of pleasure your way wont hurt either of us.'[pause_clear]~]
        say__p=1;ParaContent(); print "The tingling reaches your face, with your lips and nose feeling like they are going to explode.  And they do... but explode out of your face, it lengthening into a muzzle as your pleading turns into the whimpers of a dog.  Your nose can smell everything now, the other dogs, the Artifact... and the witches apparent attraction to what was happening.^^You sniffed some more, smelling the scent of a very sexually excited human.  Your ears extend out the sides of your changing head, ending at points.  The overwhelming experience of hearing everything nearly makes you faint as you try to reorient your senses.^^DOGS BARKING! Fuck you need to resist the urge to join in.. the witches breathing is increasing, as well as the smell of her wetness.  She's getting really turned on by your transformation, and its starting to get you excited as well.^^Craning your German Shepherd snout down, you can see the changes have only encompassed your torso and above so far, you still have a normal human penis.  Which is swelling with the thought of the witches warm pussy gaining wetness for you.  It starts to gain weight, like a flag pole slowly being raised, until your embarrassing erection stands like a monument to your changing body.^^You whine at your frustration, urges to lick yourself and end your sexual torment abound in your mind.  ~Ohhh.. well umm, poor doggie?~ the witch says, subconciously leaning closer.  ~I umm guess I can help, a little bit of pleasure your way wont hurt either of us.~"; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say797; .L_SayX795;
        ! [5: say ~She reaches out her thin white hand, touching your erection softly and almost lovingly, her eyes completely transfixed on it, the smell of her needy pussy almost overwhelming.  Her eyes flutter like shes being seduced, and she slowly leans down, moving her head closer like a mind control victim.^^The first lick sends you spiraling into pleasure, your dog mind happy at the thought of getting relief.  Before you know it, she is licking your changing dick like mad, your fur having spread down to your legs.  Then she just puts the whole thing in her mouth, deep enough you can feel the back of her throat.^^'RRRRRRRR' you churr in mind blowing pleasure, the feeling of her soft lips around your cock almost too much to take.  Slowly she starts to move them up and down, blowing your changing self and increasing in pace.  You can only stare as her beautiful face goes up and down, each time your dick looking more canine like.[pause_clear]~]
        say__p=1;ParaContent(); print "She reaches out her thin white hand, touching your erection softly and almost lovingly, her eyes completely transfixed on it, the smell of her needy pussy almost overwhelming.  Her eyes flutter like shes being seduced, and she slowly leans down, moving her head closer like a mind control victim.^^The first lick sends you spiraling into pleasure, your dog mind happy at the thought of getting relief.  Before you know it, she is licking your changing dick like mad, your fur having spread down to your legs.  Then she just puts the whole thing in her mouth, deep enough you can feel the back of her throat.^^~RRRRRRRR~ you churr in mind blowing pleasure, the feeling of her soft lips around your cock almost too much to take.  Slowly she starts to move them up and down, blowing your changing self and increasing in pace.  You can only stare as her beautiful face goes up and down, each time your dick looking more canine like."; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say798; .L_SayX796;
        ! [6: say ~First time, its getting redder.  Second time, longer and bigger. Third time, nearly cherry red with the start of a sheath.  God it feels amazing, even though you don't want to be sucked off into a dog.  'Mmmmm' she moans, completely obsessed with your pleasure.^^Something must've happening with the spell, you can hear her breathing changing, and her smell changing as well.  Shes starting to smell like something you can only recognize from your new instincts...^^A bitch in heat.^^'GRRAAARRRRRR' your growl rumbles out of you as you can't take the pleasure anymore, your dick spasming and shooting your doggie load down her throat.  Though despite your orgasm, you can feel your dick start to swell even more, remembering dogs have knots to keep them in the female.  Yours grows at a considerable pace, and despite the witches past fascination with dogs, she does't remember in time.[pause_clear]~]
        say__p=1;ParaContent(); print "First time, its getting redder.  Second time, longer and bigger. Third time, nearly cherry red with the start of a sheath.  God it feels amazing, even though you don't want to be sucked off into a dog.  ~Mmmmm~ she moans, completely obsessed with your pleasure.^^Something must've happening with the spell, you can hear her breathing changing, and her smell changing as well.  Shes starting to smell like something you can only recognize from your new instincts...^^A bitch in heat.^^~GRRAAARRRRRR~ your growl rumbles out of you as you can't take the pleasure anymore, your dick spasming and shooting your doggie load down her throat.  Though despite your orgasm, you can feel your dick start to swell even more, remembering dogs have knots to keep them in the female.  Yours grows at a considerable pace, and despite the witches past fascination with dogs, she does't remember in time."; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say799; .L_SayX797;
        ! [7: say ~'WARRRRRR FURRRR GERRMERRROUTTAHERRRR' her muffled cry comes, her tongue sending another spasm down your dog dick.  She's stuck, ironically, and you can see her eyes frantically looking around for something to do about it.^^She can't seem to reach her wand or the Wand of the Dog, and you're chained to this damn bed, now pretty much completely a dog, so she really is stuck.^^And that's when you notice her changes.  Specifically, the tail growing out of her ass.  'NURRRRRRRRRRRRRRRR' she cries with tears streaming down her ass, obviously able to feel it wagging behind her.^^She scrambles, trying to get anywhere, as her body starts to be wrapped in the fur of a fellow German Shepherd.  And the smell of her heat is wafting over to you, sending tingles of shock down your spine and instinctual thoughts to mate with her.[pause_clear]~]
        say__p=1;ParaContent(); print "~WARRRRRR FURRRR GERRMERRROUTTAHERRRR~ her muffled cry comes, her tongue sending another spasm down your dog dick.  She's stuck, ironically, and you can see her eyes frantically looking around for something to do about it.^^She can't seem to reach her wand or the Wand of the Dog, and you're chained to this damn bed, now pretty much completely a dog, so she really is stuck.^^And that's when you notice her changes.  Specifically, the tail growing out of her ass.  ~NURRRRRRRRRRRRRRRR~ she cries with tears streaming down her ass, obviously able to feel it wagging behind her.^^She scrambles, trying to get anywhere, as her body starts to be wrapped in the fur of a fellow German Shepherd.  And the smell of her heat is wafting over to you, sending tingles of shock down your spine and instinctual thoughts to mate with her."; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say800; .L_SayX798;
        ! [8: say ~Her ears start to grow pointed, just like yours, as her snout grows forward.  Her mouth grows large enough that she pulls your dick out of her mouth and in an act of desperation, turns around to grab the Wand, her only hope of reversing or at least stopping this.^^But you can see her fumble the wand, dropping it.  She tries to pick it up again to no avail, when you notice her hands are dog paws now.^^You laugh the best alpha male dog laugh you can, finding humor in her similar end.  'THIS IS YOUR FAUAAAALT' she screams, her accusation turning into a half growl by the end of it.^^'Nooeerrrr I don't wanna be bittccchh' she moans, writhing on top of your legs still.  To your delight, you can see her back arch as she whines, nipples popping out all down her torso as she grows teets.  The smell of her swollen pussy is almost too much to bear now, you need to fuck it.[pause_clear]~]
        say__p=1;ParaContent(); print "Her ears start to grow pointed, just like yours, as her snout grows forward.  Her mouth grows large enough that she pulls your dick out of her mouth and in an act of desperation, turns around to grab the Wand, her only hope of reversing or at least stopping this.^^But you can see her fumble the wand, dropping it.  She tries to pick it up again to no avail, when you notice her hands are dog paws now.^^You laugh the best alpha male dog laugh you can, finding humor in her similar end.  ~THIS IS YOUR FAUAAAALT~ she screams, her accusation turning into a half growl by the end of it.^^~Nooeerrrr I don't wanna be bittccchh~ she moans, writhing on top of your legs still.  To your delight, you can see her back arch as she whines, nipples popping out all down her torso as she grows teets.  The smell of her swollen pussy is almost too much to bear now, you need to fuck it."; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say801; .L_SayX799;
        ! [9: say ~And your prayers are answered! WIth her fading humanity, her magic begins to fade as well, the chains disappearing and losing their hold over you.  Bounding up on your paws for the first time, you can see that being on all fours isn't that bad, especially when you have a whimpering bitch right in front of you.^^Completely distracted by her changes, she is still sitting there, whining when you shove your snout into her nether regions, your nose getting a better sniff of the twisting, plumping pussy as its lips are losing the last of their human look at changing into the spaded looking of a dog.^^You can't help but lick it with your new doggie tongue, the moaning growling coming from her one of reluctant pleasure.[pause_clear]~]
        say__p=1;ParaContent(); print "And your prayers are answered! WIth her fading humanity, her magic begins to fade as well, the chains disappearing and losing their hold over you.  Bounding up on your paws for the first time, you can see that being on all fours isn't that bad, especially when you have a whimpering bitch right in front of you.^^Completely distracted by her changes, she is still sitting there, whining when you shove your snout into her nether regions, your nose getting a better sniff of the twisting, plumping pussy as its lips are losing the last of their human look at changing into the spaded looking of a dog.^^You can't help but lick it with your new doggie tongue, the moaning growling coming from her one of reluctant pleasure."; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say802; .L_SayX800;
        ! [10: say ~She turns around, climbing up on all fours and presenting herself with her tail raised.  You know how to dog all this stuff by instinct, taking your place behind her heated pussy and climbing on top of her.  As you prod for her pussy, she cranes her head around, and in a clear voice (and her last as a human) she says 'Please don't, I can't be a bitch.'^^But you can hardly understand her words, as your mind is losing any of its human personality with the opportunity of claiming a mate right in front of you.^^So you thrust forward, entering her with a soft squelching noise, a yip of surprise emitting from her snout.  And do you claim her.  You fuck her, holding her in place with your maw as she pants underneath.^^Her pants grow faster and faster apart as you can feel her body twisting in guilty pleasure, and you time your second orgasm with hers, filling her with your seed right as her pussy grips yours in her own trembling orgasm.  You both howl in unison, the feeling of claiming a mate showering you with happiness, and the last of both of your human thoughts fading away.  Replaced by a mated pair of dogs.~]
        say__p=1;ParaContent(); print "She turns around, climbing up on all fours and presenting herself with her tail raised.  You know how to dog all this stuff by instinct, taking your place behind her heated pussy and climbing on top of her.  As you prod for her pussy, she cranes her head around, and in a clear voice (and her last as a human) she says ~Please don't, I can't be a bitch.~^^But you can hardly understand her words, as your mind is losing any of its human personality with the opportunity of claiming a mate right in front of you.^^So you thrust forward, entering her with a soft squelching noise, a yip of surprise emitting from her snout.  And do you claim her.  You fuck her, holding her in place with your maw as she pants underneath.^^Her pants grow faster and faster apart as you can feel her body twisting in guilty pleasure, and you time your second orgasm with hers, filling her with your seed right as her pussy grips yours in her own trembling orgasm.  You both howl in unison, the feeling of claiming a mate showering you with happiness, and the last of both of your human thoughts fading away.  Replaced by a mated pair of dogs."; new_line; .L_Say803; .L_SayX801;
        ! [11: end the story saying ~[bold type]Game Over.  [italic type]'Good boy!'  [roman type]Male Human to Dog.~]
        deadflag=(TEXT_TY_ExpandIfPerishable(I7SFRAME,TX_S_487)); story_complete=false;
        ! [12: otherwise]
        } else {

        ! [13: say femaledog]
        say__p=1;ParaContent(); (PHR_990_r128 ()); .L_Say804; .L_SayX802;
        ! [14: end if]
        }

        rfalse;
];
! Request 130: phrase nothing -> nothing
! to say femaleToFrog:
[ PHR_998_r130  I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_26();
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_26 ;
    ! [1: say ~Ohhhh nooooo you begin to think before the quaking of your pussy surprises you, it's apparent hacking and heaving growing stronger at the same rate as the shots of pleasure wiring through you.  In one last heave, your changing lusty hole spreads open...[pause_clear]~]
    say__p=1;ParaContent(); print "Ohhhh nooooo you begin to think before the quaking of your pussy surprises you, it's apparent hacking and heaving growing stronger at the same rate as the shots of pleasure wiring through you.  In one last heave, your changing lusty hole spreads open..."; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say805; .L_SayX803;
    ! [2: say ~'Ohhhhhhh' you squeak in a surprising croaking gasp.  'What's happening to meeee?'  Your breasts are so sensitive, the nipples sticking out against your shirt. Wait what, you have breasts now?!  And at that moment your gaping feminine hole spews out a massive amount of small clear spheres, forcing a mindblowing orgasm on your sensitive new body.^^A frog clutch.  You had just spewed a frog clutch onto the ground from your new... body.  Which was still changing, and soooo so sensitive.  Suddenl you couldn't stop thinking about yourself.. and males. And letting them crawl on you and pounding your tight frog puss- 'WHOA' you croaked, shocked by Beccas presence shoving you down to the ground and breaking your trance.^^She.. he was on you in a second, shoving your face into the ground and what must be a finger into each hole your squelching holes.[pause_clear]~]
    say__p=1;ParaContent(); print "~Ohhhhhhh~ you squeak in a surprising croaking gasp.  ~What's happening to meeee?~  Your breasts are so sensitive, the nipples sticking out against your shirt. Wait what, you have breasts now?!  And at that moment your gaping feminine hole spews out a massive amount of small clear spheres, forcing a mindblowing orgasm on your sensitive new body.^^A frog clutch.  You had just spewed a frog clutch onto the ground from your new... body.  Which was still changing, and soooo so sensitive.  Suddenl you couldn't stop thinking about yourself.. and males. And letting them crawl on you and pounding your tight frog puss- ~WHOA~ you croaked, shocked by Beccas presence shoving you down to the ground and breaking your trance.^^She.. he was on you in a second, shoving your face into the ground and what must be a finger into each hole your squelching holes."; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say806; .L_SayX804;
    ! [3: say ~You have never been more humiliated in your life.  Becca was fingerfucking you like mad, your new frog pussy spewing all sorts of juices as you cried and moaned in uncontrollable lust.  'Please...' you begged her, pleading for her to stop, and not sure you really meant it.  Little did you know that it was the last thing you were going to say as a human.^^'RIBBITTTT' your throat convulsed unexpectedly.  Oh god oh fuck, your mind racing, I have to do something.  The floor was rushing up to meet you though, your only option to bend your legs, stick your ass out and catch yourself with your hands.  And there you sat, with a girl pleasuring your new animal love hole, you on the ground LIKE a frog, and feeling a lot like one as well.  'RIBBBBBIT' you croaked again as your stomach rumbled, a familiar feeling coming to you again.^^Becca was just able to move her hand before you birthed another pile of spawn, your pussy making a noticeable PLBBBBBBPPPLPPPPP noise as it shuddered with a massive orgasm.  You sat there, eyes out to the side of your head, the finishing changes happening as you kept orgasming beyond belief.^^The last thought through your head was one of wishing you were something more graceful then a breeding frog.. but it was lost as Becca shoved her fist back into your hole, wiping your humanity from your mind, and sealing your fate as a female frog forever.~]
    say__p=1;ParaContent(); print "You have never been more humiliated in your life.  Becca was fingerfucking you like mad, your new frog pussy spewing all sorts of juices as you cried and moaned in uncontrollable lust.  ~Please...~ you begged her, pleading for her to stop, and not sure you really meant it.  Little did you know that it was the last thing you were going to say as a human.^^~RIBBITTTT~ your throat convulsed unexpectedly.  Oh god oh fuck, your mind racing, I have to do something.  The floor was rushing up to meet you though, your only option to bend your legs, stick your ass out and catch yourself with your hands.  And there you sat, with a girl pleasuring your new animal love hole, you on the ground LIKE a frog, and feeling a lot like one as well.  ~RIBBBBBIT~ you croaked again as your stomach rumbled, a familiar feeling coming to you again.^^Becca was just able to move her hand before you birthed another pile of spawn, your pussy making a noticeable PLBBBBBBPPPLPPPPP noise as it shuddered with a massive orgasm.  You sat there, eyes out to the side of your head, the finishing changes happening as you kept orgasming beyond belief.^^The last thought through your head was one of wishing you were something more graceful then a breeding frog.. but it was lost as Becca shoved her fist back into your hole, wiping your humanity from your mind, and sealing your fate as a female frog forever."; new_line; .L_Say807; .L_SayX805;
    ! [4: end the story saying ~[bold type]Game Over.  [italic type]'A Lot More Children Then What You Were Expecting'  [roman type]Female Human to Frog.~]
    deadflag=(TEXT_TY_ExpandIfPerishable(I7SFRAME,TX_S_488)); story_complete=false;
    rfalse;
];
! Request 131: phrase nothing -> nothing
! to say becomeFemaleSkunk:
[ PHR_999_r131  I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_27();
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_27 ;
    ! [1: say ~The spray hits you full force, making you  recoil with disgust. 'what the fuck?!' You yell, gagging.  Its all over you, the male skunk juice practically dripping off you there's so much. 'I fuc...' You start to berate the skunkman, before realizing something weird about your body. 'is it getting hot in here?' You can barely stand the temperature, a rush of heat flooding every inch of your body.^^The skunkman just snorts (a sound uncommon to all the skunks you had met til now..but hey this is a unique situation), turns tail and walks into the bushes, leaving you to writhe uncomfortably alone.  [pause_clear] So hot and soo sensitive.. You think as you catch yourself rubbing your hips uncharacteristically. Your body feels soft and.. Different.  In innocent curiosity you pull up your shirt to a shower of body hair.^^Its all fallen out from your torso.  'umm fuck guess im allergic to skunks' you mutter, something that would have probably had you in a panic if it wasn't for the emanations of euphoria shooting through your body.^^Sudden pain wracks your body, causing you to fall to the ground writhing, desperately wanting it to stop. You jerk your hand up to your throat as you feel the alien feeling of it constricting and pulling inside of itself.  Your Adams apple is gone.^^'whaaa?!' Is all you can manage once your throat stops transforming.  That's not your voice, what the hell, you think to yourself.  It was the soft high pitch tones of a young woman.. What the hell is happening?![pause_clear]~]
    say__p=1;ParaContent(); print "The spray hits you full force, making you  recoil with disgust. ~what the fuck?!~ You yell, gagging.  Its all over you, the male skunk juice practically dripping off you there's so much. ~I fuc...~ You start to berate the skunkman, before realizing something weird about your body. ~is it getting hot in here?~ You can barely stand the temperature, a rush of heat flooding every inch of your body.^^The skunkman just snorts (a sound uncommon to all the skunks you had met til now..but hey this is a unique situation), turns tail and walks into the bushes, leaving you to writhe uncomfortably alone.  ";ParaContent(); (PHR_928_r9 ());ParaContent(); print " So hot and soo sensitive.. You think as you catch yourself rubbing your hips uncharacteristically. Your body feels soft and.. Different.  In innocent curiosity you pull up your shirt to a shower of body hair.^^Its all fallen out from your torso.  ~umm fuck guess im allergic to skunks~ you mutter, something that would have probably had you in a panic if it wasn't for the emanations of euphoria shooting through your body.^^Sudden pain wracks your body, causing you to fall to the ground writhing, desperately wanting it to stop. You jerk your hand up to your throat as you feel the alien feeling of it constricting and pulling inside of itself.  Your Adams apple is gone.^^~whaaa?!~ Is all you can manage once your throat stops transforming.  That's not your voice, what the hell, you think to yourself.  It was the soft high pitch tones of a young woman.. What the hell is happening?!"; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say808; .L_SayX806;
    ! [2: say ~And then the pain is back. This time wracking every inch, making you seize in reaction.  Your pants are growing tighter and tighter til POP RIIIIIIP.. The buttons pop then the rest of the legs gives way, ripping them off of your body against your will.  Another soft female whimper slips out of your growing lips as you feel like you are about to wet yourself in fear.^^But the feeling changes, your precious nether regions burning to the point you yelp in surprise.  Looking down you can see the imprint of your dick writhing much like you did just moments before, twisting and turning as if to escape some horrible fate.  And then it begins to grow less of a prominent outline against your underwear.^^'Nooo fffuuuu' you screw using your.. New feminine hands.. To pull down your stretched boxers.  Your penis is disappearing, your balls pulling up with it as well.[pause_clear] You think of what you can do to stop it from happening. Before you know it, your beloved male genitalia is gone, sucked back up inside you.  A new warm and wet feeling begins to creep into your consciousness, its origin directly under the bald expanse where you genitalia once was.^^Oooo and it feels gooooood you think as you notice your hips, much curvier this time around, beginning to grind against each other.  As if controlled by another, your small soft hands trail their way down your hairless stomach, moving over the mound and under to feel a... Pussy. You shoulda known, especially with the other clues.^^Ooohh you moan, catching yourself by surprise and snapping you out of your trance to realize you are currently on your knees.. In some bushes, moaning and you explore the soft cleft you just grew.  God you have to think straight and get help immediately, forcing your now wet fingers back above.[pause_clear]~]
    say__p=1;ParaContent(); print "And then the pain is back. This time wracking every inch, making you seize in reaction.  Your pants are growing tighter and tighter til POP RIIIIIIP.. The buttons pop then the rest of the legs gives way, ripping them off of your body against your will.  Another soft female whimper slips out of your growing lips as you feel like you are about to wet yourself in fear.^^But the feeling changes, your precious nether regions burning to the point you yelp in surprise.  Looking down you can see the imprint of your dick writhing much like you did just moments before, twisting and turning as if to escape some horrible fate.  And then it begins to grow less of a prominent outline against your underwear.^^~Nooo fffuuuu~ you screw using your.. New feminine hands.. To pull down your stretched boxers.  Your penis is disappearing, your balls pulling up with it as well."; new_line;ParaContent(); (PHR_928_r9 ());ParaContent(); print " You think of what you can do to stop it from happening. Before you know it, your beloved male genitalia is gone, sucked back up inside you.  A new warm and wet feeling begins to creep into your consciousness, its origin directly under the bald expanse where you genitalia once was.^^Oooo and it feels gooooood you think as you notice your hips, much curvier this time around, beginning to grind against each other.  As if controlled by another, your small soft hands trail their way down your hairless stomach, moving over the mound and under to feel a... Pussy. You shoulda known, especially with the other clues.^^Ooohh you moan, catching yourself by surprise and snapping you out of your trance to realize you are currently on your knees.. In some bushes, moaning and you explore the soft cleft you just grew.  God you have to think straight and get help immediately, forcing your now wet fingers back above."; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say809; .L_SayX807;
    ! [3: say ~But then again, that did feel good, maybe a little more wouldn't hurt.  You certainly deserve it after the pain and loss you went through to get it.. The sound of snapping branch nearly makes you jump out of your skin as you wheel around (your new long lustrous blonde hair smacking you in the face unexpectedly) to see the skunkman returning, chewing on some ragweed.^^Overwhelmed with the recent changes and the rearrival of the being that initiated them, you act out of instinct, turning, spreading your cheeks and spewing out.. Skunk spray?^^PSSSSSSSSSSSSSSSSH^^'Ohho god whyyyy' you cry out, more distresssed at the inhuman act you are doing then the return of the skunkman. He turns his head a bit to shield his eyes, but is laughing otherwise.  'oh well isn't this interesting' sneering at your predicament.  You can hardly think you are so in shock, your skunk spray slowly petering out.  'Looks like I got myself a new mate' the voice of the skunkman wafting into your ear, its origin right behind your shivering female body.^^All of a sudden he grabs you, pulling your small frame in as his hands forcifully feel you up, starting with your soft small breasts.  The feeling is completely new to you, and the sensation makes your body feel alive and healthy, much to your own humiliation.^^'Please..' is all you manage to whisper as he grabs your sensitive nipples, pinching them so hard you feel your body release a small PSSSH of skunk spray, it dribbling down your inner thigh with the new wetness from your just acquired love hole.[pause_clear]~]
    say__p=1;ParaContent(); print "But then again, that did feel good, maybe a little more wouldn't hurt.  You certainly deserve it after the pain and loss you went through to get it.. The sound of snapping branch nearly makes you jump out of your skin as you wheel around (your new long lustrous blonde hair smacking you in the face unexpectedly) to see the skunkman returning, chewing on some ragweed.^^Overwhelmed with the recent changes and the rearrival of the being that initiated them, you act out of instinct, turning, spreading your cheeks and spewing out.. Skunk spray?^^PSSSSSSSSSSSSSSSSH^^~Ohho god whyyyy~ you cry out, more distresssed at the inhuman act you are doing then the return of the skunkman. He turns his head a bit to shield his eyes, but is laughing otherwise.  ~oh well isn't this interesting~ sneering at your predicament.  You can hardly think you are so in shock, your skunk spray slowly petering out.  ~Looks like I got myself a new mate~ the voice of the skunkman wafting into your ear, its origin right behind your shivering female body.^^All of a sudden he grabs you, pulling your small frame in as his hands forcifully feel you up, starting with your soft small breasts.  The feeling is completely new to you, and the sensation makes your body feel alive and healthy, much to your own humiliation.^^~Please..~ is all you manage to whisper as he grabs your sensitive nipples, pinching them so hard you feel your body release a small PSSSH of skunk spray, it dribbling down your inner thigh with the new wetness from your just acquired love hole."; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say810; .L_SayX808;
    ! [4: say ~As he pinched your nipples, you felt them grow in between his fingers, to strong breast-feeding quality, perfect for a mother. POP POP POP, tiny little bursts exploded all over your smooth thin torso, causing you to look down and realize you were growing more breasts. You groaned in confused lust, with a little dread, as you realized you may have to feed tiny skunk children with each soft mound that emerged on your chest.^^The skunkman was so close, grabbing and feeling each one, obviously enraptured with your very much reluctant self.  You could feel the slow feeling of coordinated rhythmic humping begining, an act you had only been on the other side of before.^^His... cock? Animal dick?  Must've emerged from his sheath as you could feel it knocking into your thighs, sometimes finding its way almost into your tight new butthole or your pulsing pussy.  You almost wanted to bend over and... 'NO!' you shout, ripping yourself away in desperation and wildly looking about.[pause_clear]~]
    say__p=1;ParaContent(); print "As he pinched your nipples, you felt them grow in between his fingers, to strong breast-feeding quality, perfect for a mother. POP POP POP, tiny little bursts exploded all over your smooth thin torso, causing you to look down and realize you were growing more breasts. You groaned in confused lust, with a little dread, as you realized you may have to feed tiny skunk children with each soft mound that emerged on your chest.^^The skunkman was so close, grabbing and feeling each one, obviously enraptured with your very much reluctant self.  You could feel the slow feeling of coordinated rhythmic humping begining, an act you had only been on the other side of before.^^His... cock? Animal dick?  Must've emerged from his sheath as you could feel it knocking into your thighs, sometimes finding its way almost into your tight new butthole or your pulsing pussy.  You almost wanted to bend over and... ~NO!~ you shout, ripping yourself away in desperation and wildly looking about."; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say811; .L_SayX809;
    ! [5: say ~Running through your options, you wondered if you should just run.  But what would anyone think of a eight titted naked blonde running through this town, especially every time she got scared she bent over and sprayed like a damn skunk.  Then suddenly the pain was back.^^'OWWWWWAAA YYYYAAOWWW' you screamed as your spine extended and extended, a massive bushy skunk tail growing almost 6 feet out.   You could feel your anus changing, becoming more animalistic as it and your chubby pussy moved higher with the tail, coming to rest farther back.  You realized it was for easy access to male when you crawled about as a skunk.^^'Oh god...' you muttered, a strange.. good? Maybe? Well anyways certainly arousing feeling spreading through you, making the thought of being claimed by a male sound perfect.  You fell to all fours again, shoving your hand under you and up to play with those beautiful lips of yours.  'Cant ... think...' you gasped, overwhelmed by your lust.  You felt just so warm and fucking FUCKING HORNY.[pause_clear]~]
    say__p=1;ParaContent(); print "Running through your options, you wondered if you should just run.  But what would anyone think of a eight titted naked blonde running through this town, especially every time she got scared she bent over and sprayed like a damn skunk.  Then suddenly the pain was back.^^~OWWWWWAAA YYYYAAOWWW~ you screamed as your spine extended and extended, a massive bushy skunk tail growing almost 6 feet out.   You could feel your anus changing, becoming more animalistic as it and your chubby pussy moved higher with the tail, coming to rest farther back.  You realized it was for easy access to male when you crawled about as a skunk.^^~Oh god...~ you muttered, a strange.. good? Maybe? Well anyways certainly arousing feeling spreading through you, making the thought of being claimed by a male sound perfect.  You fell to all fours again, shoving your hand under you and up to play with those beautiful lips of yours.  ~Cant ... think...~ you gasped, overwhelmed by your lust.  You felt just so warm and fucking FUCKING HORNY."; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say812; .L_SayX810;
    ! [6: say ~Before you knew it you had two fingers plunging in and out of your pussy, the pleasure making your eyes tear up and your legs shake. 'IIIII uhhhAHHH' you cried, practically drooling.  The voice that had already changed once today was losing its humanity, turning into the screetches of a female skunk in heat.^^But you couldn't stop.. not now.. 'OHO OHHH GODDDD' your scream was your last human utterance as your orgasm ripped through you. PSSSH you sprayed as well, overcome with pleasure, your asshole and pussy trembling and practically gaping with lust.^^You squeak as the male climbs on top, shoving himself inside of you immediately.  You had forgotten he was there, but it was too late even if you wanted it to stop.  The feeling of being on all fours and your round ass being pounded made you cum again instantly, uncontrollably spraying into the skunkmans abs.^^And was on you and in you and your humanity was slipping... and gone as you shrank smaller and smaller.  Your squeaks were completely animalistic, and his as well as he ended up only a feral skunk as well.[pause_clear]~]
    say__p=1;ParaContent(); print "Before you knew it you had two fingers plunging in and out of your pussy, the pleasure making your eyes tear up and your legs shake. ~IIIII uhhhAHHH~ you cried, practically drooling.  The voice that had already changed once today was losing its humanity, turning into the screetches of a female skunk in heat.^^But you couldn't stop.. not now.. ~OHO OHHH GODDDD~ your scream was your last human utterance as your orgasm ripped through you. PSSSH you sprayed as well, overcome with pleasure, your asshole and pussy trembling and practically gaping with lust.^^You squeak as the male climbs on top, shoving himself inside of you immediately.  You had forgotten he was there, but it was too late even if you wanted it to stop.  The feeling of being on all fours and your round ass being pounded made you cum again instantly, uncontrollably spraying into the skunkmans abs.^^And was on you and in you and your humanity was slipping... and gone as you shrank smaller and smaller.  Your squeaks were completely animalistic, and his as well as he ended up only a feral skunk as well."; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say813; .L_SayX811;
    ! [7: end the story saying ~[bold type]Game Over.  [italic type]'Sticky Icky'  [roman type]Male Human to Female Skunk.~]
    deadflag=(TEXT_TY_ExpandIfPerishable(I7SFRAME,TX_S_489)); story_complete=false;
    rfalse;
];
! Request 132: phrase nothing -> nothing
! to say becomeMaleGoat:
[ PHR_1002_r132  ;
    ! [1: say ~.~]
    say__p=1;ParaContent(); print "."; new_line; .L_Say814; .L_SayX812;
    rfalse;
];
! Request 133: phrase nothing -> nothing
! to say becomeFemaleDonkey:
[ PHR_1004_r133  ;
    ! [1: say ~.~]
    say__p=1;ParaContent(); print "."; new_line; .L_Say815; .L_SayX813;
    rfalse;
];
! Request 134: phrase nothing -> nothing
! to say becomeBreedingStallion:
[ PHR_1007_r134  I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_28();
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_28 ;
    ! [1: say ~Your simple mind was blown at the glimpse of (the very much fantasized about) soft, small lips of Courtneys, nested in between her thin thighs.  The soft pink entrance just barely noticeably covered in light-peach-hairs.. and twisting and changing, her juices spewing from it.^^She archs her back, biting her lip as the the plump little clam that's her pussy starts to grow darker and even fatter, gaining in size to meet the size of a common breeding mare.  She lets out a audible 'Oooooooh' as it winks for the first time, seeming to invite you to come shove your snout in it.^^The pussy you had craved so much, not knowing til now, was changing into the swollen needy cunt of a mare in heat.  In some amount of effort, Courtney craned her head to look at you, smiling at the sight of you under her spell, 'Come get me, I've needed you again all this time.'.^^The end of the last sentence was her last as a human, shifting from her desperate begging to the whinny of a very reluctant breeding mare.[pause_clear]~]
    say__p=1;ParaContent(); print "Your simple mind was blown at the glimpse of (the very much fantasized about) soft, small lips of Courtneys, nested in between her thin thighs.  The soft pink entrance just barely noticeably covered in light-peach-hairs.. and twisting and changing, her juices spewing from it.^^She archs her back, biting her lip as the the plump little clam that's her pussy starts to grow darker and even fatter, gaining in size to meet the size of a common breeding mare.  She lets out a audible ~Oooooooh~ as it winks for the first time, seeming to invite you to come shove your snout in it.^^The pussy you had craved so much, not knowing til now, was changing into the swollen needy cunt of a mare in heat.  In some amount of effort, Courtney craned her head to look at you, smiling at the sight of you under her spell, ~Come get me, I've needed you again all this time.~.^^The end of the last sentence was her last as a human, shifting from her desperate begging to the whinny of a very reluctant breeding mare."; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say816; .L_SayX814;
    ! [2: say ~^^One that you neeeeeded.  You catch yourself, stunned at the thought that snuck into your mi- OH MY GOD IT SMELLS AMAZING.  Your pants stirred, your vision stuck on the now complete pussy winking in front of you.  The scent, oh god, the scent of beautiful things, of happinnnneeess in physical form, you NEEEEEEEEEEEEIIGGHHH.^^A whinny explodes from your mouth as the world spins a full ninety degrees, shaken from the terrifying fall by your front hooves landing on the firm ground.  You know somethings going on with your body, your mind or what... whatever it doesn't matter, as your nostrils have landed only inches away from the nervous mare in front of you.^^Specifically, inches away from the squelching of her needy pussy.  You know it's Courtney, you know she doesn't want you to mate with her, and you don't care.  Her desperate struggles can't prevent you from jumping ontop her, your new stallion penis breaking out of its sheath to sink slowly, wetly into her guilty pleasure..^^Her whinny of surprise hardly breaks you from your trance as you follow the rules of nature, fucking her so hard that she falls down on her front knees in desperate attempt to manage the massive strength of your thrusting.^^She's yours, you can feel it coming, you're claiiimminggggg NEEIEHGGHGGHHHHHHHHHHH.~]
    say__p=1;ParaContent(); print "^^One that you neeeeeded.  You catch yourself, stunned at the thought that snuck into your mi- OH MY GOD IT SMELLS AMAZING.  Your pants stirred, your vision stuck on the now complete pussy winking in front of you.  The scent, oh god, the scent of beautiful things, of happinnnneeess in physical form, you NEEEEEEEEEEEEIIGGHHH.^^A whinny explodes from your mouth as the world spins a full ninety degrees, shaken from the terrifying fall by your front hooves landing on the firm ground.  You know somethings going on with your body, your mind or what... whatever it doesn't matter, as your nostrils have landed only inches away from the nervous mare in front of you.^^Specifically, inches away from the squelching of her needy pussy.  You know it's Courtney, you know she doesn't want you to mate with her, and you don't care.  Her desperate struggles can't prevent you from jumping ontop her, your new stallion penis breaking out of its sheath to sink slowly, wetly into her guilty pleasure..^^Her whinny of surprise hardly breaks you from your trance as you follow the rules of nature, fucking her so hard that she falls down on her front knees in desperate attempt to manage the massive strength of your thrusting.^^She's yours, you can feel it coming, you're claiiimminggggg NEEIEHGGHGGHHHHHHHHHHH."; new_line; .L_Say817; .L_SayX815;
    ! [3: end the story saying ~The last thought fades from your mind as you impregnate the now mindless mare. Eventually you reluctantly pull out, knowing Courtney is ready to bear your young for the rest of her life.^^[bold type]Game Over.  [italic type]'Now Thats A Stallion'  [roman type]Male Human to Stallion.~]
    deadflag=(TEXT_TY_ExpandIfPerishable(I7SFRAME,TX_S_490)); story_complete=false;
    rfalse;
];
! Request 135: phrase nothing -> nothing
! to say preSwineOption:
[ PHR_1008_r135  ;
    ! [1: say ~I should pay more attention, you thought.  You snuck through the store, it's empty expanse chilling you both to the bone.  Towards the back, the store seemed to twist and turn in a labyrinth of different rooms and hallways.  Working your way through the now pitch black maze, you started to see the entrance to a large room in the back with flickering candlelight.^^As you get closer, you catch a glimpse of a woman, naked except for the tribal tattoos covering most her body.  Luckily she was facing the other way, as there was definitely something otherworldly about her, and it felt wrong for her just to be here.  Suddenly she spoke, the sudden noise making you almost jump out of your skin.^^'You will make a great tool for us, Kim m'dear,' the singsong voice of the beautiful woman rang out, facing someone one who wasn't in view.  'Now it appears your friends have come to visit.  Maybe they can serve me, and your fellow coven members, as well!'.^^Annnnnd she turned right around to stare directly at you.  Her face was absolutely stunning, that of a goddess. And her smile lured both you and your friend into the room.  I mean... she had already somehow spotted you both anyways.. right?[pause_clear]~]
    say__p=1;ParaContent(); print "I should pay more attention, you thought.  You snuck through the store, it's empty expanse chilling you both to the bone.  Towards the back, the store seemed to twist and turn in a labyrinth of different rooms and hallways.  Working your way through the now pitch black maze, you started to see the entrance to a large room in the back with flickering candlelight.^^As you get closer, you catch a glimpse of a woman, naked except for the tribal tattoos covering most her body.  Luckily she was facing the other way, as there was definitely something otherworldly about her, and it felt wrong for her just to be here.  Suddenly she spoke, the sudden noise making you almost jump out of your skin.^^~You will make a great tool for us, Kim m'dear,~ the singsong voice of the beautiful woman rang out, facing someone one who wasn't in view.  ~Now it appears your friends have come to visit.  Maybe they can serve me, and your fellow coven members, as well!~.^^Annnnnd she turned right around to stare directly at you.  Her face was absolutely stunning, that of a goddess. And her smile lured both you and your friend into the room.  I mean... she had already somehow spotted you both anyways.. right?"; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say818; .L_SayX816;
    ! [2: say ~As soon as you entered the room, you could see who she was talking to.  Another woman, almost as beautiful, sat tattooed and naked on an altar across from the woman with the singsong voice.^^'See what I gave to Kim?' the woman said, breaking you out of your funk.  'We are the Coven of Nature, here to reclaim the Earth and to take it back to the days in which the poison of humanity didn't taint it.' she proclaimed, waving her arms.  Suddenly she made a closing movement with her arms, and the doors slammed close behind you[pause_clear].^^'Now,' she continues, 'Kim got a chance to choose like this, but decided to leave it to you. I'm feeling generous as well after witnessing her yielding of choice... Anyways, sow or hog?'^^Somehow finding your voice, you stuttered 'What?! Why are you doing this?'.  The woman tsked, shaking her head and once again asking, 'Sow or hog?'^^Your jaw dropped, trying to comprehend two beautiful naked women asking you the sex of a pig.  'Ummmm' you stuttered, looking at this supposed 'Kim' then back at the mistress witch in complete incredulity. [pause_clear]~]
    say__p=1;ParaContent(); print "As soon as you entered the room, you could see who she was talking to.  Another woman, almost as beautiful, sat tattooed and naked on an altar across from the woman with the singsong voice.^^~See what I gave to Kim?~ the woman said, breaking you out of your funk.  ~We are the Coven of Nature, here to reclaim the Earth and to take it back to the days in which the poison of humanity didn't taint it.~ she proclaimed, waving her arms.  Suddenly she made a closing movement with her arms, and the doors slammed close behind you";ParaContent(); (PHR_928_r9 ());ParaContent(); print ".^^~Now,~ she continues, ~Kim got a chance to choose like this, but decided to leave it to you. I'm feeling generous as well after witnessing her yielding of choice... Anyways, sow or hog?~^^Somehow finding your voice, you stuttered ~What?! Why are you doing this?~.  The woman tsked, shaking her head and once again asking, ~Sow or hog?~^^Your jaw dropped, trying to comprehend two beautiful naked women asking you the sex of a pig.  ~Ummmm~ you stuttered, looking at this supposed ~Kim~ then back at the mistress witch in complete incredulity. ";ParaContent(); (PHR_928_r9 ()); .L_Say819; .L_SayX817;
    rfalse;
];
! Request 136: phrase nothing -> nothing
! to say feralSow:
[ PHR_1010_r136  I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_29();
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_29 ;
    ! [1: say ~A loud, heavy squeal erupts from Kims now growing snout.  You watch in horror as she stumbles to her feet, a massive erection becoming apparent as she turns and starts heading directly towards you. 'Oh fuck' you squeal, trying to turn to go.^^But your feet are planted to the ground, and your eyes can't rip away from the cock bobbing its way towards you.  You can feel your pussy stretch and grow, becoming more and more like the fat lips of a breeding sow.  And the cock keeps getting closer.  It smells so good too, sitting under a handsome hog.^^Slowly you begin to bend over, your feet still planted on the ground and slowly changing into hooves.  Your fat pussy moves up to meet your asshole like an animals, and your bending motion makes it spread apart with a loud SQUELCH, gaping and clasping as you slip further into heat.[pause_clear]~]
    say__p=1;ParaContent(); print "A loud, heavy squeal erupts from Kims now growing snout.  You watch in horror as she stumbles to her feet, a massive erection becoming apparent as she turns and starts heading directly towards you. ~Oh fuck~ you squeal, trying to turn to go.^^But your feet are planted to the ground, and your eyes can't rip away from the cock bobbing its way towards you.  You can feel your pussy stretch and grow, becoming more and more like the fat lips of a breeding sow.  And the cock keeps getting closer.  It smells so good too, sitting under a handsome hog.^^Slowly you begin to bend over, your feet still planted on the ground and slowly changing into hooves.  Your fat pussy moves up to meet your asshole like an animals, and your bending motion makes it spread apart with a loud SQUELCH, gaping and clasping as you slip further into heat."; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say820; .L_SayX818;
    ! [2: say ~^^'SQUEEEEAL' Kim, dropping a pile of manure on the ground, rears up in front of you, the sudden act breaking you from your trance.  Before you can do anything, she thrusts forward, shoving her newly acquired sheathed phallus into your throat and fucking away. Each thrust makes your sow tits grow bigger and bigger, and your whimpers into oinks and grunts.^^Your beautiful redhead body is nearly gone now, the sexual thoughts of mating with a hog becoming nearly impossible to control.  You feel tears rolling down your snout as you are throat fucked by the hog that used to be Kim.^^'Awwwww, poor piggie' the witch sneers mockingly, as you feel the hog increase the intensity of his thrusts as hes nearing orgasm.  She waves her wand and you feel your pussy squelch again, forcing a pleasured muffled squeal from your stuffed snout.^^Kim pulls off, sniffing the air.  You can hardly feel anything other then need for the wet cock hovering near your face to fuck your chubby pig cunt til you are pregnant. 'Noooo' you moan, or grunt, or squeal.  Whatever the noise is, its the closest you'll get to saying something human again.  Kim has made it to your back side, spotted your treasure and licks it lovingly.^^MATE. The word shoots through your head with each lick, your human mind melting away as the hog mounts you, stuffing your chubby pussy to the hilt.  You squeal in defeat and absolute pleasure as he tenses almost immediately, the rewarding feeling of cum flooding your pig ovaries pushing you to your own beautiful 30 min orgasm.  You'll be a sow forever now.~]
    say__p=1;ParaContent(); print "^^~SQUEEEEAL~ Kim, dropping a pile of manure on the ground, rears up in front of you, the sudden act breaking you from your trance.  Before you can do anything, she thrusts forward, shoving her newly acquired sheathed phallus into your throat and fucking away. Each thrust makes your sow tits grow bigger and bigger, and your whimpers into oinks and grunts.^^Your beautiful redhead body is nearly gone now, the sexual thoughts of mating with a hog becoming nearly impossible to control.  You feel tears rolling down your snout as you are throat fucked by the hog that used to be Kim.^^~Awwwww, poor piggie~ the witch sneers mockingly, as you feel the hog increase the intensity of his thrusts as hes nearing orgasm.  She waves her wand and you feel your pussy squelch again, forcing a pleasured muffled squeal from your stuffed snout.^^Kim pulls off, sniffing the air.  You can hardly feel anything other then need for the wet cock hovering near your face to fuck your chubby pig cunt til you are pregnant. ~Noooo~ you moan, or grunt, or squeal.  Whatever the noise is, its the closest you'll get to saying something human again.  Kim has made it to your back side, spotted your treasure and licks it lovingly.^^MATE. The word shoots through your head with each lick, your human mind melting away as the hog mounts you, stuffing your chubby pussy to the hilt.  You squeal in defeat and absolute pleasure as he tenses almost immediately, the rewarding feeling of cum flooding your pig ovaries pushing you to your own beautiful 30 min orgasm.  You'll be a sow forever now."; new_line; .L_Say821; .L_SayX819;
    ! [3: end the story saying ~[bold type]Game Over.  [italic type]'Sniffing for Truffles'  [roman type]Male Human to Sow.~]
    deadflag=(TEXT_TY_ExpandIfPerishable(I7SFRAME,TX_S_491)); story_complete=false;
    rfalse;
];
! Request 137: phrase nothing -> nothing
! to say beginWitchQuestions:
[ PHR_1011_r137  ;
    ! [1: say ~The witch leans in close, her lips so close to your own. 'I'm going to ask you some questions..  like a inquisitive sphinx.' Squinting your eyes in reaction, you ponder what the hell a sphinx is.. 'And if you don't answer correctly, I'll wave my little wand and change you and little Kim over here into what you deserve to be... whether its a sow and her hog, a sex doll, another wand.. whatever.' her final words had morphed into laughter, cruel and torterous. ~]
    say__p=1;ParaContent(); print "The witch leans in close, her lips so close to your own. ~I'm going to ask you some questions..  like a inquisitive sphinx.~ Squinting your eyes in reaction, you ponder what the hell a sphinx is.. ~And if you don't answer correctly, I'll wave my little wand and change you and little Kim over here into what you deserve to be... whether its a sow and her hog, a sex doll, another wand.. whatever.~ her final words had morphed into laughter, cruel and torterous. "; .L_Say822; .L_SayX820;
    ! [2: say ~'Well, do you accept?'~]
    say__p=1;ParaContent(); print "~Well, do you accept?~"; new_line; .L_Say823; .L_SayX821;
    ! [3: if the player consents begin]
    if ((YesOrNo())){
        ! [4: say sphinxquestionone]
        say__p=1;ParaContent(); (PHR_1012_r138 ()); .L_Say824; .L_SayX822;
        ! [5: otherwise]
        } else {

        ! [6: say feralsow]
        say__p=1;ParaContent(); (PHR_1010_r136 ()); .L_Say825; .L_SayX823;
        ! [7: end if]
        }

        rfalse;
];
! Request 138: phrase nothing -> nothing
! to say sphinxQuestionOne:
[ PHR_1012_r138  ;
    ! [1: say ~Sows have the longest orgasms of almost all animals.  Is it less then an hour?~]
    say__p=1;ParaContent(); print "Sows have the longest orgasms of almost all animals.  Is it less then an hour?"; new_line; .L_Say826; .L_SayX824;
    ! [2: if the player consents begin]
    if ((YesOrNo())){
        ! [3: say ~You nod your head vigorously, as it surely must be less then a whole hour.~]
        say__p=1;ParaContent(); print "You nod your head vigorously, as it surely must be less then a whole hour."; new_line; .L_Say827; .L_SayX825;
        ! [4: say ~The witch mockingly claps her hands. 'Good job girl, next question.~]
        say__p=1;ParaContent(); print "The witch mockingly claps her hands. ~Good job girl, next question."; new_line; .L_Say828; .L_SayX826;
        ! [5: say sphinxquestiontwo]
        say__p=1;ParaContent(); (PHR_1013_r139 ()); .L_Say829; .L_SayX827;
        ! [6: otherwise]
        } else {

        ! [7: say feralsow]
        say__p=1;ParaContent(); (PHR_1010_r136 ()); .L_Say830; .L_SayX828;
        ! [8: end if]
        }

        rfalse;
];
! Request 139: phrase nothing -> nothing
! to say sphinxQuestionTwo:
[ PHR_1013_r139  ;
    ! [1: say ~Are pigs ranked number 3 in animal intelligence?~]
    say__p=1;ParaContent(); print "Are pigs ranked number 3 in animal intelligence?"; new_line; .L_Say831; .L_SayX829;
    ! [2: if the player consents begin]
    if ((YesOrNo())){
        ! [3: say ~A loud laugh accompanies the twirl of the witchs wand, the feeling of accelerating changes rolling through your new body.  'Guess you'll have to learn the answer to that the hard way!'~]
        say__p=1;ParaContent(); print "A loud laugh accompanies the twirl of the witchs wand, the feeling of accelerating changes rolling through your new body.  ~Guess you'll have to learn the answer to that the hard way!~"; new_line; .L_Say832; .L_SayX830;
        ! [4: say feralsow]
        say__p=1;ParaContent(); (PHR_1010_r136 ()); .L_Say833; .L_SayX831;
        ! [5: otherwise]
        } else {

        ! [6: say ~'Hmmm fine' the witch spits out 'final one, slut'.~]
        say__p=1;ParaContent(); print "~Hmmm fine~ the witch spits out ~final one, slut~."; new_line; .L_Say834; .L_SayX832;
        ! [7: say sphinxquestionthree]
        say__p=1;ParaContent(); (PHR_1014_r140 ()); .L_Say835; .L_SayX833;
        ! [8: end if]
        }

        rfalse;
];
! Request 140: phrase nothing -> nothing
! to say sphinxQuestionThree:
[ PHR_1014_r140  ;
    ! [1: say ~'Are you ready to be a fat, horny, and verrrry dumb sow for the rest of your pathetic life?'~]
    say__p=1;ParaContent(); print "~Are you ready to be a fat, horny, and verrrry dumb sow for the rest of your pathetic life?~"; new_line; .L_Say836; .L_SayX834;
    ! [2: if the player consents begin]
    if ((YesOrNo())){
        ! [3: say ~'Well it's hard to say no to that.  I'll at least make it very fun!' the witch says before twirling her wand~]
        say__p=1;ParaContent(); print "~Well it's hard to say no to that.  I'll at least make it very fun!~ the witch says before twirling her wand"; .L_Say837; .L_SayX835;
        ! [4: say feralsow]
        say__p=1;ParaContent(); (PHR_1010_r136 ()); .L_Say838; .L_SayX836;
        ! [5: otherwise]
        } else {

        ! [6: say ~The witch smirks, 'Well I'll honor your wish.'  Your heart soars with hope, looking down in the hope of changing back.~]
        say__p=1;ParaContent(); print "The witch smirks, ~Well I'll honor your wish.~  Your heart soars with hope, looking down in the hope of changing back."; new_line; .L_Say839; .L_SayX837;
        ! [7: say becomesexdoll]
        say__p=1;ParaContent(); (PHR_1017_r27 ()); .L_Say840; .L_SayX838;
        ! [8: end if]
        }

        rfalse;
];
! Request 141: phrase nothing -> nothing
! to say witchFight:
[ PHR_1019_r141  ;
    ! [1: say ~Traveling down a side alley, you notice a skirmish in front of you. Two witches are shooting magical bolts at each other in a perilous battle of spite.^^You duck behind a nearby trashbin, hoping they will move elsewhere eventually, and let you on your way. Spells are richocheting all over the alley as the two sorceresses duel, their spells thrown with noticeable spite.^^' You've always been an ass, Minerva!' One chides as a purple bolt flies from her wand deftly countered by the other with a flick of her wrist. Frustrated, the namecaller starts spamming her spells, sending them richocheting down the alley.^^A random bus boy chose the wrong time to emerge from his restaurant, and is soon just a braying donkey, bucking and kicking, his balls flopping all over.~]
    say__p=1;ParaContent(); print "Traveling down a side alley, you notice a skirmish in front of you. Two witches are shooting magical bolts at each other in a perilous battle of spite.^^You duck behind a nearby trashbin, hoping they will move elsewhere eventually, and let you on your way. Spells are richocheting all over the alley as the two sorceresses duel, their spells thrown with noticeable spite.^^~ You've always been an ass, Minerva!~ One chides as a purple bolt flies from her wand deftly countered by the other with a flick of her wrist. Frustrated, the namecaller starts spamming her spells, sending them richocheting down the alley.^^A random bus boy chose the wrong time to emerge from his restaurant, and is soon just a braying donkey, bucking and kicking, his balls flopping all over."; new_line; .L_Say841; .L_SayX839;
    ! [2: say ~The fight is getting a bit dangerous, you realize now.  Maybe you shouldn't... BAM! The trashcan explodes next to you, vaporizing immediately.  And there you sit, out in the open.[pause_clear]~]
    say__p=1;ParaContent(); print "The fight is getting a bit dangerous, you realize now.  Maybe you shouldn't... BAM! The trashcan explodes next to you, vaporizing immediately.  And there you sit, out in the open."; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say842; .L_SayX840;
    ! [3: say ~'Uhhhhh, hey guyyysss', you awkwardly say, both witches having immediately ended their fighting and proceeded to sit there staring at you in a ... not so promising way.^^Minerva, you realize now, is the much stronger of the witches, looking like pure evil and much more intimidating then the other. And she's walking towards you, wand held out glowing like a searing brand.~]
    say__p=1;ParaContent(); print "~Uhhhhh, hey guyyysss~, you awkwardly say, both witches having immediately ended their fighting and proceeded to sit there staring at you in a ... not so promising way.^^Minerva, you realize now, is the much stronger of the witches, looking like pure evil and much more intimidating then the other. And she's walking towards you, wand held out glowing like a searing brand."; new_line; .L_Say843; .L_SayX841;
    ! [4: if player is male begin]
    if ((((Adj_82_t1_v10(player))))){
        ! [5: say ~.~]
        say__p=1;ParaContent(); print "."; new_line; .L_Say844; .L_SayX842;
        ! [6: otherwise]
        } else {

        ! [7: say ~In one quick motion, she surprises you by changing her target to the unsuspecting other witch, shooting white lightning out of the wand into the stunned stunned womans chest.  The other witch cried out, knowing she had been bested and would soon meet her fate.  Minerva turned her cruel smile to the doomed witch, sneering 'You always were a tool, Caspra.'^^The doomed Caspras arms were fading away, her cries growing quieter and quieter as she was seemingly sucked into the ground.  But she was just shrinking, her body becoming cylindrical and solid.  Veins started to stick out of her, and her frozen face twisted up into a slight spiral.^^Soon the only thing left of the other witch was a rather weird looking dildo, its tip a spiral, and while lacking in girth, had considerable length to it.[pause_clear]~]
        say__p=1;ParaContent(); print "In one quick motion, she surprises you by changing her target to the unsuspecting other witch, shooting white lightning out of the wand into the stunned stunned womans chest.  The other witch cried out, knowing she had been bested and would soon meet her fate.  Minerva turned her cruel smile to the doomed witch, sneering ~You always were a tool, Caspra.~^^The doomed Caspras arms were fading away, her cries growing quieter and quieter as she was seemingly sucked into the ground.  But she was just shrinking, her body becoming cylindrical and solid.  Veins started to stick out of her, and her frozen face twisted up into a slight spiral.^^Soon the only thing left of the other witch was a rather weird looking dildo, its tip a spiral, and while lacking in girth, had considerable length to it."; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say845; .L_SayX843;
        ! [8: say ~Minerva was just laughing at the fate she had forced on the other woman.  You started to shuffle away silently, but the crone turned and snapped 'And just where do you think you're going?'^^'I'm sorry, I didn't man any harm!' you squeal in response, just really wanting to get away from this evil woman.  'Oh?' she asks, her tone adding to your worry, 'You'll miss all the fun!  I want to see how Caspra is enjoying being a hog dildo.'^^You quickly apologize, and explain you cant and try to turn to go. But you can't, and you can't seem to move your eyes away from Minervas, your eyes fluttering almost as if you are falling asleep.  'That'sssss right,' Minerva says in a lulling tone, hypnotizing you completely. .[pause_clear]~]
        say__p=1;ParaContent(); print "Minerva was just laughing at the fate she had forced on the other woman.  You started to shuffle away silently, but the crone turned and snapped ~And just where do you think you're going?~^^~I'm sorry, I didn't man any harm!~ you squeal in response, just really wanting to get away from this evil woman.  ~Oh?~ she asks, her tone adding to your worry, ~You'll miss all the fun!  I want to see how Caspra is enjoying being a hog dildo.~^^You quickly apologize, and explain you cant and try to turn to go. But you can't, and you can't seem to move your eyes away from Minervas, your eyes fluttering almost as if you are falling asleep.  ~That'sssss right,~ Minerva says in a lulling tone, hypnotizing you completely. ."; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say846; .L_SayX844;
        ! [9: say ~Minerva cackles in delight, the real world feeling like only a dream.  'Plppleee..pp..leease sttopppp..' is all you can whimper before your mouth slams shut against your control.^^'Good girl, now let's see what you look like in your natural form' her hand tracing invisible notes in the air, filling it with static charged magic.^^You blink, and your clothes are gone completely, your body nude for everyone to see.  If there was anyone else in this alleyway other then Minerva... whos walking up to you with that dark smile on her face.^^Cupping your breasts in her talon like fingers, she begins to go over your body, evaluating it in detail, only nods and 'hmphs' coming out of her mouth as she touches parts of you that you really don't want her near.^^'Relatively skinny, with small breats, a pink vagina and an asshole that has never been fucked.  How bland.' she snorts.  'Well, I love giving people the experience of their opposites, so why don't we go from there.  Sit down on Caspras over there!'[pause_clear]~]
        say__p=1;ParaContent(); print "Minerva cackles in delight, the real world feeling like only a dream.  ~Plppleee..pp..leease sttopppp..~ is all you can whimper before your mouth slams shut against your control.^^~Good girl, now let's see what you look like in your natural form~ her hand tracing invisible notes in the air, filling it with static charged magic.^^You blink, and your clothes are gone completely, your body nude for everyone to see.  If there was anyone else in this alleyway other then Minerva... whos walking up to you with that dark smile on her face.^^Cupping your breasts in her talon like fingers, she begins to go over your body, evaluating it in detail, only nods and ~hmphs~ coming out of her mouth as she touches parts of you that you really don't want her near.^^~Relatively skinny, with small breats, a pink vagina and an asshole that has never been fucked.  How bland.~ she snorts.  ~Well, I love giving people the experience of their opposites, so why don't we go from there.  Sit down on Caspras over there!~"; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say847; .L_SayX845;
        ! [10: say ~What? You can only think it to yourself, the shock of whats shes asking ringing through your head, and its starting to make you panic.  Frantically you look around, your eyes the only thing you can move, desperate to find a way out of this.^^'Ohhh, poor dear,' Minervas tone dripping with pseudo empathy, 'Let me help you with that'.  Your stress only increases as she cackles even more, beginning to wave her arms again, summoning her dark magic.^^Suddenly your body is bathed in lust.  God, the feeling is unbelievable, your body showering you with dopamine in the hopes of you mating.^^You can feel your pussy practically squirming between your thighs as your nipples stand straight up, hardening with the lustful spell cast on you.  You don't care if it was a spell or not though, all you care about is getting fucked.^^Slowly your body begins to walk over to the pig-shaped-dildo, your realization of how that tool can be used to screw yourself free of this need settling in your mind.  You can feel your pussy squirting out juices in anticipation, your body almost bending over with the instincts of an animal in heat controlling your actions.[pause_clear]~]
        say__p=1;ParaContent(); print "What? You can only think it to yourself, the shock of whats shes asking ringing through your head, and its starting to make you panic.  Frantically you look around, your eyes the only thing you can move, desperate to find a way out of this.^^~Ohhh, poor dear,~ Minervas tone dripping with pseudo empathy, ~Let me help you with that~.  Your stress only increases as she cackles even more, beginning to wave her arms again, summoning her dark magic.^^Suddenly your body is bathed in lust.  God, the feeling is unbelievable, your body showering you with dopamine in the hopes of you mating.^^You can feel your pussy practically squirming between your thighs as your nipples stand straight up, hardening with the lustful spell cast on you.  You don't care if it was a spell or not though, all you care about is getting fucked.^^Slowly your body begins to walk over to the pig-shaped-dildo, your realization of how that tool can be used to screw yourself free of this need settling in your mind.  You can feel your pussy squirting out juices in anticipation, your body almost bending over with the instincts of an animal in heat controlling your actions."; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say848; .L_SayX846;
        ! [11: end if]
        }

    ! [12: say ~^^You squat down, your pussy slick enough that its growing lips slide right around the new form of Caspras.  'SQUEEEEEEAAL' you cry to your own horror, your reaction to the feeling of easing all the way down on the dildo nothing more then the cry of a horny sow.^^'Yes thats it' Minerva says, her smile turning even darker, 'now let's take the rest from you.'  At the end of the sentence, you could feel your torso start to bubble, nipples growing from your flesh to add six more under your small breasts.^^Then the teets behind them exploded out, another squeal erupting from your mouth as small tusks pulled your lips apart, growing from your mouth.^^All the while you were making wet squishing noises as you rode the large dildo, your lower parts changing to.  Your shoes exploded off as your feet were replaced with tiny hooves.  You felt your ass fatten as the change moved to your private area between your thighs.^^You felt your clit grow into the sensitive clit of a sow, your lips growing large enough to push your hips apart as you snorted and squealed riding the dildo.  You felt your ovaries change as your mind suddenly lusted for a ugly hog to pin you down to fuck your piggie ass.^^'SQUEEEEEAALL' you cried, an attempt at 'noooo' but your human body so far gone that you cannot muster it.  Humiliated by your uncontrollable pounding on Caspras, you stooped down another level of embarrassment a small pile of manure fell from your sow ass, the true sign that you were fully a barn animal now.^^Minerva laughed, and laughed, and then *POOF* disappeared, missing your raucous cries as with one final squelch you shove down on Caspras and cum so hard you pass out.^^When you wake a few moments later you can feel your pussy still shooting out juices, remembering that sows have 30 min long orgasms.  Your mind finally breaks as your lay there, nipples rubbing the ground as your spasm in orgasmic bliss with a dildo still in you.~]
    say__p=1;ParaContent(); print "^^You squat down, your pussy slick enough that its growing lips slide right around the new form of Caspras.  ~SQUEEEEEEAAL~ you cry to your own horror, your reaction to the feeling of easing all the way down on the dildo nothing more then the cry of a horny sow.^^~Yes thats it~ Minerva says, her smile turning even darker, ~now let's take the rest from you.~  At the end of the sentence, you could feel your torso start to bubble, nipples growing from your flesh to add six more under your small breasts.^^Then the teets behind them exploded out, another squeal erupting from your mouth as small tusks pulled your lips apart, growing from your mouth.^^All the while you were making wet squishing noises as you rode the large dildo, your lower parts changing to.  Your shoes exploded off as your feet were replaced with tiny hooves.  You felt your ass fatten as the change moved to your private area between your thighs.^^You felt your clit grow into the sensitive clit of a sow, your lips growing large enough to push your hips apart as you snorted and squealed riding the dildo.  You felt your ovaries change as your mind suddenly lusted for a ugly hog to pin you down to fuck your piggie ass.^^~SQUEEEEEAALL~ you cried, an attempt at ~noooo~ but your human body so far gone that you cannot muster it.  Humiliated by your uncontrollable pounding on Caspras, you stooped down another level of embarrassment a small pile of manure fell from your sow ass, the true sign that you were fully a barn animal now.^^Minerva laughed, and laughed, and then *POOF* disappeared, missing your raucous cries as with one final squelch you shove down on Caspras and cum so hard you pass out.^^When you wake a few moments later you can feel your pussy still shooting out juices, remembering that sows have 30 min long orgasms.  Your mind finally breaks as your lay there, nipples rubbing the ground as your spasm in orgasmic bliss with a dildo still in you."; new_line; .L_Say849; .L_SayX847;
    rfalse;
];
! Request 142: phrase nothing -> nothing
! to say MeredithElse:
[ PHR_1021_r142  ;
    ! [1: say ~With one last sob, she pulled her sweater up, revealing what was underneath.~]
    say__p=1;ParaContent(); print "With one last sob, she pulled her sweater up, revealing what was underneath."; new_line; .L_Say850; .L_SayX848;
    ! [2: if a random chance of 1 in 2 succeeds , say meredithpig]
    if (((GenerateRandomNumber(1, 2) <= 1))) { say__p=1;ParaContent(); (PHR_1022_r143 ()); .L_Say851; .L_SayX849; }
    ! [3: otherwise say meredithmare]
    else { say__p=1;ParaContent(); (PHR_1023_r144 ()); .L_Say852; .L_SayX850; }
    rfalse;
];
! Request 143: phrase nothing -> nothing
! to say MeredithPig:
[ PHR_1022_r143  I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_30();
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_30 ;
    ! [1: say ~With one last sob, she pulled her sweater up, revealing what was underneath.^^Three pairs of jiggling breasts sat underneath her polka dotted bra. Your jaw dropped at the sight of her unnatural nudity. 'I think I was close to the spell that turned those peopl into swine' she said, a little snort escaping her mouth at the end, causing her to break into tears. 'I don't want to end up a pppigg!'. You got close, thinking you would hug her to comfort her, but remembering she had three extra pairs of breasts out in the open...^^She noticed you staring and blushed, lowering her sweater to cover her bare sow teets again.  You both sat there awkwardly for a bit, until she broke the silence, 'Hey, let's get to where it's safe... come on!' Taking your hand in hers, she led you back to the conference room that she was hiding in when you showed up.  Her computer was on, having been moved into the room, and you could see its screen dimly lighting the fortress of blankets that was set up in a small hovel.  She sheepishly smiled, 'I thought a blanket fort would be a good idea, and keep my mind off things... Come on I moved the office couch in there so we can chill in the fort and try to find out what to do!'  You chuckled, nodding with a smile on your face to encourage the girl.  Damn was she cute.^^She lifted a blanket, revealing the entrance to the fort, and crawled in.  You crawled in after her, finding it impressively homely and comfortable inside.  Her computer screen had recent news articles of the strange happenings going on, and a few other tabs were open.  She quickly shuffled over to the keyboard and mouse, closing the other tabs as fast as she could.  But you were able to read their titles as she removed them one by one... two being facts about pigs, one titled male-pig.jpg, and one a... ummm porn site.  She must've been bored.  Or feeling the change in sexual ways..  SOmething you had noticed with other transformation victims.[pause_clear]~]
    say__p=1;ParaContent(); print "With one last sob, she pulled her sweater up, revealing what was underneath.^^Three pairs of jiggling breasts sat underneath her polka dotted bra. Your jaw dropped at the sight of her unnatural nudity. ~I think I was close to the spell that turned those peopl into swine~ she said, a little snort escaping her mouth at the end, causing her to break into tears. ~I don't want to end up a pppigg!~. You got close, thinking you would hug her to comfort her, but remembering she had three extra pairs of breasts out in the open...^^She noticed you staring and blushed, lowering her sweater to cover her bare sow teets again.  You both sat there awkwardly for a bit, until she broke the silence, ~Hey, let's get to where it's safe... come on!~ Taking your hand in hers, she led you back to the conference room that she was hiding in when you showed up.  Her computer was on, having been moved into the room, and you could see its screen dimly lighting the fortress of blankets that was set up in a small hovel.  She sheepishly smiled, ~I thought a blanket fort would be a good idea, and keep my mind off things... Come on I moved the office couch in there so we can chill in the fort and try to find out what to do!~  You chuckled, nodding with a smile on your face to encourage the girl.  Damn was she cute.^^She lifted a blanket, revealing the entrance to the fort, and crawled in.  You crawled in after her, finding it impressively homely and comfortable inside.  Her computer screen had recent news articles of the strange happenings going on, and a few other tabs were open.  She quickly shuffled over to the keyboard and mouse, closing the other tabs as fast as she could.  But you were able to read their titles as she removed them one by one... two being facts about pigs, one titled male-pig.jpg, and one a... ummm porn site.  She must've been bored.  Or feeling the change in sexual ways..  SOmething you had noticed with other transformation victims."; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say853; .L_SayX851;
    ! [2: say ~'Sooo watcha wanna do?' she asked, chirping happily.  But you knew something else was bothering her, and you knew she was afraid of the effects of a transformation spell. 'Hey, you're okay, right?' you said, empathy coating your tone.  'Oh... oh yeah, I'm fine' her reply unconvincing, 'I just... do you want to watch a movie or something?'  You looked at her for a second, trying to read her, and nodded.^^She started up Netflix, put on the Emperors New Groove, and laid down next to you.  Soon she was snoozing quietly, and your own eyes were becoming hard to keep open, and before you knew it... you were asleep.^^*SNORT SNURFFFFFF SNORT* The strange sound woke you, you shooting up to see Meredith missing.  But she hasn't gone far.. shes on the computer.  Well, more watching something on the computer.  A video of a male pig, her hands shoved down her pants as she sat there humping the ground.  You could practically smell her lust, realizing that must be the smell of a sow in heat.^^'Meredith!' you yell, causing her to stop.  She turns around, eyes rolling her their sockets as she seems to be still caught in lust. 'Oh god please its changing my pussy is changing i don't want to be a oh god i don't want to be a SOWWWWWWWWW' her cry shooting up in tone, practically a squeal.  You could see her breasts, now massive, the bottom pair even flopping out under her sweaters, jiggling like mad. 'Please you have to stop', you say as you jump up running over to console her.  'Iiiiiii ughhh SNORT I don't want I DONT WANT TO STOP SQUEEEAAL!' she yells, catching you off guard.^^Grabbing your head with considerable strength, she pulls you down til your face is squishing against her bottom teats.  'SUCK THEM, DAMNIT!' she yells at you in desperation.  [pause_clear]~]
    say__p=1;ParaContent(); print "~Sooo watcha wanna do?~ she asked, chirping happily.  But you knew something else was bothering her, and you knew she was afraid of the effects of a transformation spell. ~Hey, you're okay, right?~ you said, empathy coating your tone.  ~Oh... oh yeah, I'm fine~ her reply unconvincing, ~I just... do you want to watch a movie or something?~  You looked at her for a second, trying to read her, and nodded.^^She started up Netflix, put on the Emperors New Groove, and laid down next to you.  Soon she was snoozing quietly, and your own eyes were becoming hard to keep open, and before you knew it... you were asleep.^^*SNORT SNURFFFFFF SNORT* The strange sound woke you, you shooting up to see Meredith missing.  But she hasn't gone far.. shes on the computer.  Well, more watching something on the computer.  A video of a male pig, her hands shoved down her pants as she sat there humping the ground.  You could practically smell her lust, realizing that must be the smell of a sow in heat.^^~Meredith!~ you yell, causing her to stop.  She turns around, eyes rolling her their sockets as she seems to be still caught in lust. ~Oh god please its changing my pussy is changing i don't want to be a oh god i don't want to be a SOWWWWWWWWW~ her cry shooting up in tone, practically a squeal.  You could see her breasts, now massive, the bottom pair even flopping out under her sweaters, jiggling like mad. ~Please you have to stop~, you say as you jump up running over to console her.  ~Iiiiiii ughhh SNORT I don't want I DONT WANT TO STOP SQUEEEAAL!~ she yells, catching you off guard.^^Grabbing your head with considerable strength, she pulls you down til your face is squishing against her bottom teats.  ~SUCK THEM, DAMNIT!~ she yells at you in desperation.  ";ParaContent(); (PHR_928_r9 ()); .L_Say854; .L_SayX852;
    ! [3: say ~You don't even know why you do it, it was like you were watching yourself do it.. but you shifted onto your knees and took a nipple into your mouth, sucking.  Her squeal of delight wasn't even heard by you, as you were shocked to feel milk shooting down your throat as you began snorting as well.  'THATS IT, thats it please milllkk SNORTTTT SQUEEEAALLL!' she said, holding your head down as you tried to get away.  The milk was changing you, your nose turning upwards and growing longer into a pigs snout.  Your felt your body growing used to being on all fours, knowing you were turning into a hog.^^Or at least you thought so, surprised to feel your dick... shrinking?  You tried to get away, breaking free for just a second to try to cry for help, milk falling out of our pig snout as all you can get off is a loud SQUUEEEAAALLL before the frustrated Meredith grabs you again and shoves her face even lower, into her fat pussy. You tried to scream, only snorts coming out as you felt the last of your dick recede into a growing new hole that was moving up next to your asshole.  A tail, probably a curly sow tail, pushed against your jeans as you changed. The pussy in your face was smelling amazing, and you couldn't help but lap it as massive breasts grew in, flopping underneath you. 'NOORRRRRORT SNORTTTT SNORRTTT' you squeal, feeling you mind change, desperately trying to hold onto your humanity as you felt instincts flooding into your mind, cumming at the pleasure flooding through your...^^And your mind breaks, you just watching yourself a sow in heat for the rest of your life.~]
    say__p=1;ParaContent(); print "You don't even know why you do it, it was like you were watching yourself do it.. but you shifted onto your knees and took a nipple into your mouth, sucking.  Her squeal of delight wasn't even heard by you, as you were shocked to feel milk shooting down your throat as you began snorting as well.  ~THATS IT, thats it please milllkk SNORTTTT SQUEEEAALLL!~ she said, holding your head down as you tried to get away.  The milk was changing you, your nose turning upwards and growing longer into a pigs snout.  Your felt your body growing used to being on all fours, knowing you were turning into a hog.^^Or at least you thought so, surprised to feel your dick... shrinking?  You tried to get away, breaking free for just a second to try to cry for help, milk falling out of our pig snout as all you can get off is a loud SQUUEEEAAALLL before the frustrated Meredith grabs you again and shoves her face even lower, into her fat pussy. You tried to scream, only snorts coming out as you felt the last of your dick recede into a growing new hole that was moving up next to your asshole.  A tail, probably a curly sow tail, pushed against your jeans as you changed. The pussy in your face was smelling amazing, and you couldn't help but lap it as massive breasts grew in, flopping underneath you. ~NOORRRRRORT SNORTTTT SNORRTTT~ you squeal, feeling you mind change, desperately trying to hold onto your humanity as you felt instincts flooding into your mind, cumming at the pleasure flooding through your...^^And your mind breaks, you just watching yourself a sow in heat for the rest of your life."; new_line; .L_Say855; .L_SayX853;
    ! [4: end the story saying ~[bold type]Game Over.  [italic type]'Raped Into a Mindless Sow'  [roman type]Male Human to Sow.~]
    deadflag=(TEXT_TY_ExpandIfPerishable(I7SFRAME,TX_S_492)); story_complete=false;
    rfalse;
];
! Request 144: phrase nothing -> nothing
! to say MeredithMare:
[ PHR_1023_r144  I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_31();
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_31 ;
    ! [1: say ~Her breasts were normal, or at least from what you see, as they were still tucked under her bra.  What was abnormal was the dark brown bulge that flopped down over her jeans, two long nipples spreading out of the teets.  'God its been terrible, I don't even know what type of animals it is... but I have to milk them, and they're... they're mineee!' her forced talk broke into a bunch of sobbing, the fat little teets jiggling with each huff and sob.^^'I'm so sorry, Meredith, that's horrible! This happened down there?'  She nodded, scratching one of them, the look on her face giving away that they were obviously very full and bothering her.  'Is it getting worse?' you asked as she came in from a hug again, the long nipples pressing against you, turning you on unexpectedly. 'I don't think so.. well.. they got a bit worse and some of my thoughts were weird when... ummm.  I just can't..' You looked at her, wondering why she was having trouble getting it out. She looked up into your eyes, her cute face scrunched in worry, knowing that she would have to explain. 'I can't get.. ya know.. turned on.  That makes it worse.  For sure.' she said, blushing and looking away.[pause_clear]~]
    say__p=1;ParaContent(); print "Her breasts were normal, or at least from what you see, as they were still tucked under her bra.  What was abnormal was the dark brown bulge that flopped down over her jeans, two long nipples spreading out of the teets.  ~God its been terrible, I don't even know what type of animals it is... but I have to milk them, and they're... they're mineee!~ her forced talk broke into a bunch of sobbing, the fat little teets jiggling with each huff and sob.^^~I'm so sorry, Meredith, that's horrible! This happened down there?~  She nodded, scratching one of them, the look on her face giving away that they were obviously very full and bothering her.  ~Is it getting worse?~ you asked as she came in from a hug again, the long nipples pressing against you, turning you on unexpectedly. ~I don't think so.. well.. they got a bit worse and some of my thoughts were weird when... ummm.  I just can't..~ You looked at her, wondering why she was having trouble getting it out. She looked up into your eyes, her cute face scrunched in worry, knowing that she would have to explain. ~I can't get.. ya know.. turned on.  That makes it worse.  For sure.~ she said, blushing and looking away."; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say856; .L_SayX854;
    ! [2: say ~'But they need to be ummm... helped.  They are really sore and feel full. And I can't even seem to help it, I tugged and tugged and did my best but nothing happened since the first time!' she immediately broke down again, snorting and rubbing her tears from her face.^^'Don't feel scared,' you said, mustering your best courage, 'I'll do my best, and don't feel embarrassed, no one should have to deal with this' She nodded, covering her hand with her mouth, silently wording a quick 'thank you' and turning her head away.  You were confused until she slightly pushed her teets forward, obviously expecting you to help right away.  Kinda turned on by the event, you took your fingers up to just barely touch one, its soft long length responding to your touch by growing slightly harder and more erect.  It felt warm and good, the teet that of a healthy young... well, maybe some sort of barn animal?  You tugged softly at it, taking your other hand to grab the other one and doing the best 'milking' you could think of.  'Does that hurt?' you asked softly, not wanting to make this more uncomfortable for her.  'Nno.. no.. but it won't help and I feel like I'm going to burst, please try harder!' her voice obviously one of desperation at the soreness of the pressure.  You began milking it like crazy, trying to ease some amount of her milk out, her face scrunched in embarrassment or the pain of her fertile but full animal teets.  'Pleeeease!' she cried, it almost sounding a bit different... like an animal, but you couldn't think of what one it was reminding you of.[pause_clear]~]
    say__p=1;ParaContent(); print "~But they need to be ummm... helped.  They are really sore and feel full. And I can't even seem to help it, I tugged and tugged and did my best but nothing happened since the first time!~ she immediately broke down again, snorting and rubbing her tears from her face.^^~Don't feel scared,~ you said, mustering your best courage, ~I'll do my best, and don't feel embarrassed, no one should have to deal with this~ She nodded, covering her hand with her mouth, silently wording a quick ~thank you~ and turning her head away.  You were confused until she slightly pushed her teets forward, obviously expecting you to help right away.  Kinda turned on by the event, you took your fingers up to just barely touch one, its soft long length responding to your touch by growing slightly harder and more erect.  It felt warm and good, the teet that of a healthy young... well, maybe some sort of barn animal?  You tugged softly at it, taking your other hand to grab the other one and doing the best ~milking~ you could think of.  ~Does that hurt?~ you asked softly, not wanting to make this more uncomfortable for her.  ~Nno.. no.. but it won't help and I feel like I'm going to burst, please try harder!~ her voice obviously one of desperation at the soreness of the pressure.  You began milking it like crazy, trying to ease some amount of her milk out, her face scrunched in embarrassment or the pain of her fertile but full animal teets.  ~Pleeeease!~ she cried, it almost sounding a bit different... like an animal, but you couldn't think of what one it was reminding you of."; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say857; .L_SayX855;
    ! [3: say ~Looking into your eyes and nodding, you resulted to your last idea, slowing bending your head down to place it in your mouth. 'Ohhhh' she said with surprise and excitement.  And you sucked, the first attempt spraying delicious milk down your throat, Meredith moaning a sigh of relief and pleasure from above you.  'Ohhh, that's it oh my goddd' she cried in absolute relief, you just sucking because it felt good, comforting.  She moaned your name as you helped her, feeling the girl press her teet against your mouth in pleasure at the feeling of being milked.^^'Hello you two!' a new voice echoed through the room, causing Meredith to scream in fear.  You took your lips off the latching suckle you were doing to see a.. witch.  'Its her!' Meredith squealed, taking cover behind you and noticeably shaking.  The witch cackled, her terrifying voice slicing through the air, 'I just came to finish the job, but it looks like we can have more fun now!', in obvious reference to you.  'Those are mare teets you have there, girl.  You are going to be a pretty palomino breeding mare, and this friend of yours will be the stallion that makes you so.'[pause_clear]~]
    say__p=1;ParaContent(); print "Looking into your eyes and nodding, you resulted to your last idea, slowing bending your head down to place it in your mouth. ~Ohhhh~ she said with surprise and excitement.  And you sucked, the first attempt spraying delicious milk down your throat, Meredith moaning a sigh of relief and pleasure from above you.  ~Ohhh, that's it oh my goddd~ she cried in absolute relief, you just sucking because it felt good, comforting.  She moaned your name as you helped her, feeling the girl press her teet against your mouth in pleasure at the feeling of being milked.^^~Hello you two!~ a new voice echoed through the room, causing Meredith to scream in fear.  You took your lips off the latching suckle you were doing to see a.. witch.  ~Its her!~ Meredith squealed, taking cover behind you and noticeably shaking.  The witch cackled, her terrifying voice slicing through the air, ~I just came to finish the job, but it looks like we can have more fun now!~, in obvious reference to you.  ~Those are mare teets you have there, girl.  You are going to be a pretty palomino breeding mare, and this friend of yours will be the stallion that makes you so.~"; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say858; .L_SayX856;
    ! [4: say ~'OH hell no, asshole!' you yell throwing your body forward with aggressive spite.  'Ah ah ahhhh' the witch responds with a taunt and a deft sidestep, her wand glowing with harsh light before shooting the spell directly into you.^^You stumbled, feeling your balls growing massive in your pants, your dick twisting and growing, its mottled tip shooting out the top of your jeans. 'NOOOOEEEEEIIGGGHHH' your cry of fear turned into a loud whinny, your body flooded with stallion testosterone.  You feel to your hands and knees, your mass growing with your desperate cries for help. 'Meredith, stop her, I don't want to be a REEIGHHHHHH' your whinny interrupting you again as a tail exploded from your ass, right before your clothes started ripping from your body.  Your horse cock was in a sheath under you, massive in size, behind it your stallion balls hanging noticably low, and the minor breeze in the office running across your asshole as it thickened into a thick horse donut-shaped asshole.  You tried to cry for help again but all that came out was a loud 'WWEEEEIIIIIIIIII' your frustrated bucking causing your balls to flop around as you completed your physical transformation into a breeding stallion.[pause_clear]~]
    say__p=1;ParaContent(); print "~OH hell no, asshole!~ you yell throwing your body forward with aggressive spite.  ~Ah ah ahhhh~ the witch responds with a taunt and a deft sidestep, her wand glowing with harsh light before shooting the spell directly into you.^^You stumbled, feeling your balls growing massive in your pants, your dick twisting and growing, its mottled tip shooting out the top of your jeans. ~NOOOOEEEEEIIGGGHHH~ your cry of fear turned into a loud whinny, your body flooded with stallion testosterone.  You feel to your hands and knees, your mass growing with your desperate cries for help. ~Meredith, stop her, I don't want to be a REEIGHHHHHH~ your whinny interrupting you again as a tail exploded from your ass, right before your clothes started ripping from your body.  Your horse cock was in a sheath under you, massive in size, behind it your stallion balls hanging noticably low, and the minor breeze in the office running across your asshole as it thickened into a thick horse donut-shaped asshole.  You tried to cry for help again but all that came out was a loud ~WWEEEEIIIIIIIIII~ your frustrated bucking causing your balls to flop around as you completed your physical transformation into a breeding stallion."; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say859; .L_SayX857;
    ! [5: say ~Your transformation was so fast you hardly knew what was going on.  You just sat there snorting at the witch, your obvious enemy, stomping the ground with your hooves in frustration.  'Oh, now there, I just gave you a wonderful gift!' she sorceress cackled, a long horse whip appearing in her hand.  She sneered and turned to Meredith, who was sitting there trembling, her mare teets still sticking out, milk rolling out of their ends.  Waving her wand, the witch nodded at Meredith saying, 'It's time to join your mate, healthy brood mare.'^^Meredith let out a desperate yelp and turned to run in fear, hardly making it anywhere before the spell hit her. 'Nnnnoooooooo' she moaned, crying as she felt her body change.  You watched as she shook, patterned palomino fur spreading across her soft skin.  'Please don't do this to me, please' she begged the witch, crawling on her hands and knees, as if she was still going to get away.  'My assssss' she groaned as you saw it bubble under her jeans, slight ripping sounds serving as warning, her jeans ripping off right after.  'Nooo!' she yelled as her haunches thickened and rippled with muscle, her pink panties struggling to stay on her expansive ass.  A tail grew out above them, swatting back in forth as you could feel your cock come alive and start growing, falling out of your thick sheath.[pause_clear]~]
    say__p=1;ParaContent(); print "Your transformation was so fast you hardly knew what was going on.  You just sat there snorting at the witch, your obvious enemy, stomping the ground with your hooves in frustration.  ~Oh, now there, I just gave you a wonderful gift!~ she sorceress cackled, a long horse whip appearing in her hand.  She sneered and turned to Meredith, who was sitting there trembling, her mare teets still sticking out, milk rolling out of their ends.  Waving her wand, the witch nodded at Meredith saying, ~It's time to join your mate, healthy brood mare.~^^Meredith let out a desperate yelp and turned to run in fear, hardly making it anywhere before the spell hit her. ~Nnnnoooooooo~ she moaned, crying as she felt her body change.  You watched as she shook, patterned palomino fur spreading across her soft skin.  ~Please don't do this to me, please~ she begged the witch, crawling on her hands and knees, as if she was still going to get away.  ~My assssss~ she groaned as you saw it bubble under her jeans, slight ripping sounds serving as warning, her jeans ripping off right after.  ~Nooo!~ she yelled as her haunches thickened and rippled with muscle, her pink panties struggling to stay on her expansive ass.  A tail grew out above them, swatting back in forth as you could feel your cock come alive and start growing, falling out of your thick sheath."; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say860; .L_SayX858;
    ! [6: say ~Her panties were shifted to the side by the warping of her changing pussy, her face scrunched with humiliation at the feeling.  It was growing fatter, and thicker, and much darker.  The tiny pink lips were trembling, growing to massive sizes needed to be fucked properly by a stallion, it becoming simpler and more animalistic.  'WEEEEHHHHHIII' she whinnied in shock at the feeling of it growing hot and wet, winking in the presence of a virile stallion.  You could smell her pheromones, wonderful and encouraging instincts that helped your cock achieve a massive erection.  You snorted and stamped, walking over to the mare, your movement driven completely by her pheromones.^^'NnooooOOOWEEIIII Ryan, we can'ttttt, we'lll be animallss... horrrrseessss for liffeee.' Meredith begged, despite her increasing horniness. But it was too late, she was almost completely a mare.  A terrified whinny grew in pitch as a dark stream of urine shot out of her, almost nabbing you in the nose.  The amount of pheromones in the amazing smelling urine drove you mad, you frothing with horniness as you started shoving your long stallion tongue into her pussy, even her large mare asshole. 'Ohh ohh nooo oh god' she moaned in intense pleasure.  You could see her mare teets jiggling under her as her rump wiggled in orgasmic pleasure.  'Pllleeeassee' she begged the witch.. or you, who knows.  The witch laughed at both of your imminent doom, wacking poor Meredith the mare on her fat ass, causing a high pitched whinny to come from her.  She wacked your huge stallion ass next, yelling 'GIDDY UP!' [pause_clear]~]
    say__p=1;ParaContent(); print "Her panties were shifted to the side by the warping of her changing pussy, her face scrunched with humiliation at the feeling.  It was growing fatter, and thicker, and much darker.  The tiny pink lips were trembling, growing to massive sizes needed to be fucked properly by a stallion, it becoming simpler and more animalistic.  ~WEEEEHHHHHIII~ she whinnied in shock at the feeling of it growing hot and wet, winking in the presence of a virile stallion.  You could smell her pheromones, wonderful and encouraging instincts that helped your cock achieve a massive erection.  You snorted and stamped, walking over to the mare, your movement driven completely by her pheromones.^^~NnooooOOOWEEIIII Ryan, we can'ttttt, we'lll be animallss... horrrrseessss for liffeee.~ Meredith begged, despite her increasing horniness. But it was too late, she was almost completely a mare.  A terrified whinny grew in pitch as a dark stream of urine shot out of her, almost nabbing you in the nose.  The amount of pheromones in the amazing smelling urine drove you mad, you frothing with horniness as you started shoving your long stallion tongue into her pussy, even her large mare asshole. ~Ohh ohh nooo oh god~ she moaned in intense pleasure.  You could see her mare teets jiggling under her as her rump wiggled in orgasmic pleasure.  ~Pllleeeassee~ she begged the witch.. or you, who knows.  The witch laughed at both of your imminent doom, wacking poor Meredith the mare on her fat ass, causing a high pitched whinny to come from her.  She wacked your huge stallion ass next, yelling ~GIDDY UP!~ ";ParaContent(); (PHR_928_r9 ()); .L_Say861; .L_SayX859;
    ! [7: say ~With the encouragement from the winking pussy that was hugging your lips, and the pressure from the witch, her whip and your massive stallion cock, you mounted Meredith, her tail raising to help your access.  'I'mmmm youurrssssssWEEEEEEEEEHEIIIIIIIIIII' she whinnied her last human phrase as your dick shoved itself between her large mare haunches, easily finding the chubby needy horse pussy between.^^You shoved into her, riding her in glorious pleasure.  'WEEEEEEIIHIIIIII' you couldn't control your whinny as you shoved inside her warm wet hole.  Her snorting with pleasure and trembling beneath you.  You were on her and in her, her mind melting with the pleasure that your horse cock was giving her. 'WEEIIIIIIII' she cried underneath you, her pussy trembling then *SQUELLLLCH* you could feel and hear her mare cunt cum on your dick, a stream of urine shooting and strafing you huge balls as they slapped agianst her teets.  She came so hard she pissed herself. Her pussy was still winking and shaking on your cock when you thrust forward for the last time, hilting against her giant ass as your gigantic cock spasmed and belched cum into her, you whinny of dominance exploding out of your muzzle.  She whimpered underneath you, pinned down as your slowly did a few finishing thrusts into her animal pussy, the realization of what had just been forced on her coming into her mind.  She was your mare, and she knew she was pregnant with your seed, and would be many more times after this.~]
    say__p=1;ParaContent(); print "With the encouragement from the winking pussy that was hugging your lips, and the pressure from the witch, her whip and your massive stallion cock, you mounted Meredith, her tail raising to help your access.  ~I'mmmm youurrssssssWEEEEEEEEEHEIIIIIIIIIII~ she whinnied her last human phrase as your dick shoved itself between her large mare haunches, easily finding the chubby needy horse pussy between.^^You shoved into her, riding her in glorious pleasure.  ~WEEEEEEIIHIIIIII~ you couldn't control your whinny as you shoved inside her warm wet hole.  Her snorting with pleasure and trembling beneath you.  You were on her and in her, her mind melting with the pleasure that your horse cock was giving her. ~WEEIIIIIIII~ she cried underneath you, her pussy trembling then *SQUELLLLCH* you could feel and hear her mare cunt cum on your dick, a stream of urine shooting and strafing you huge balls as they slapped agianst her teets.  She came so hard she pissed herself. Her pussy was still winking and shaking on your cock when you thrust forward for the last time, hilting against her giant ass as your gigantic cock spasmed and belched cum into her, you whinny of dominance exploding out of your muzzle.  She whimpered underneath you, pinned down as your slowly did a few finishing thrusts into her animal pussy, the realization of what had just been forced on her coming into her mind.  She was your mare, and she knew she was pregnant with your seed, and would be many more times after this."; new_line; .L_Say862; .L_SayX860;
    ! [8: end the story saying ~[bold type]Game Over.  [italic type]'Mare Milk'  [roman type]Male Human to Stallion.~]
    deadflag=(TEXT_TY_ExpandIfPerishable(I7SFRAME,TX_S_493)); story_complete=false;
    rfalse;
];
! Request 145: phrase nothing -> nothing
! to say MeredithDog:
[ PHR_1024_r145  I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_32();
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_32 ;
    ! [1: say ~With one last sob, she pulled her sweater up, revealing what was underneath.^^You gasped, her polka dotted bra sitting above.. 3 pairs of teets. 'They are so sssensitive' her sobbing voice coming from behind her sweater, her hands bringing it back down to reveal her beautiful face again. She threw herself forward, smothering her face in your shirt again, your stunned face relaxing to a resting smile again, hugging her. 'Itll be okay, it'll be okay' is all you can say, knowing almost nothing about the magic you have witnessed today.^^She was still trembling in your arms, no wait.. Rubbing against you. Not that you had a problem with it, but it was likely the magic, not her, making her act on her lust. She sensed you stiffening in reaction, pulling back again. 'Im sorry!' Her voice full of desperation, 'Ive just.. Kinda liked you for a while, and these changes have made me feel.. Weird.' She licked her lips, noticing that it wasn't just your posture that had stiffened. She was practically salivating, staring at the minor bulge in your pants. I mean.. She was cute, and had always been.. What damage is a few teets gonna do.  You stepped forward, taking advantage of the poor girls changes, finally finding the chance to show how you feel for her... in a douchebag way.[pause_clear]~]
    say__p=1;ParaContent(); print "With one last sob, she pulled her sweater up, revealing what was underneath.^^You gasped, her polka dotted bra sitting above.. 3 pairs of teets. ~They are so sssensitive~ her sobbing voice coming from behind her sweater, her hands bringing it back down to reveal her beautiful face again. She threw herself forward, smothering her face in your shirt again, your stunned face relaxing to a resting smile again, hugging her. ~Itll be okay, it'll be okay~ is all you can say, knowing almost nothing about the magic you have witnessed today.^^She was still trembling in your arms, no wait.. Rubbing against you. Not that you had a problem with it, but it was likely the magic, not her, making her act on her lust. She sensed you stiffening in reaction, pulling back again. ~Im sorry!~ Her voice full of desperation, ~Ive just.. Kinda liked you for a while, and these changes have made me feel.. Weird.~ She licked her lips, noticing that it wasn't just your posture that had stiffened. She was practically salivating, staring at the minor bulge in your pants. I mean.. She was cute, and had always been.. What damage is a few teets gonna do.  You stepped forward, taking advantage of the poor girls changes, finally finding the chance to show how you feel for her... in a douchebag way."; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say863; .L_SayX861;
    ! [2: say ~^^You put your hands around her waist, looking her in the eyes, her soft grey eyes staring back into yours, trying to figure out what was going to happen.  You put your hand behind her head and pulled her in, kissing her deeply, feeling her push back against you.  She was savagely kissing you, obvious going near mad with lust, her tongue exploring your mouth, seemingly longer then what you had seen when you pulled her in.   'Ohhhhhh' she moaned, moving away and staring at you.  'You smell so good, what cologne is that?' she whimpered, staring at the bulge that had grown immensely.^^She hardly wasted a second, giving you a quick glance, her eyes fluttering with her extreme lust, before she leaned down to start kissing the bulge in your pants.  Her blonde head bobbed below, licking the outside of your jeans as she tried to be patient.  'Oh I need it!' she yelped, undoing your jeans before you even knew it, pulling them down as well as your boxer briefs, freeing your erection to pop straight forward.[pause_clear]~]
    say__p=1;ParaContent(); print "^^You put your hands around her waist, looking her in the eyes, her soft grey eyes staring back into yours, trying to figure out what was going to happen.  You put your hand behind her head and pulled her in, kissing her deeply, feeling her push back against you.  She was savagely kissing you, obvious going near mad with lust, her tongue exploring your mouth, seemingly longer then what you had seen when you pulled her in.   ~Ohhhhhh~ she moaned, moving away and staring at you.  ~You smell so good, what cologne is that?~ she whimpered, staring at the bulge that had grown immensely.^^She hardly wasted a second, giving you a quick glance, her eyes fluttering with her extreme lust, before she leaned down to start kissing the bulge in your pants.  Her blonde head bobbed below, licking the outside of your jeans as she tried to be patient.  ~Oh I need it!~ she yelped, undoing your jeans before you even knew it, pulling them down as well as your boxer briefs, freeing your erection to pop straight forward."; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say864; .L_SayX862;
    ! [3: say ~^^She shoved it in her mouth almost seeming in desperation, sucking you right from the bat.  The squelching sound of her lips running up and down your resounded through the empty office, you hardly believing what was happening.  God you were already close to cumming, she was practically forcing you to cum down her throat.^^'WHOA! Whoa, Meredith, hold on!' you almost yelled, pushing her back.  Her tongue could still reach the end of your dick, so she licked the end, looking up at you as you said, 'Meredith I think you're amazing but you are under a spell.. that witch did more damage then your.. uhhh..' You gestured towards her breasts.  'No no nooo,' she responded, her beautiful eyes blinking at you, 'I have wanted this, its okay.  I mean.. I didn't anticipate the ummm extra nipples, but it'll be fine!  I want you to mount me anyway!' Your jaw just dropped, the bluntness of the statement catching you off guard. She turned around, wiggling her ass at you on all fours, her back arching so that her little round butt was tight against her jeans.  'I'm yours, take me, please!' she begged, turning her head around, her desperate need apparent in her eyes.^^That was too tough to resist, you fell to your knees, your spit covered penis still wide open, your jeans around your feet.  This was really damn hot... teets or not.  Plus she really needed the relief.. You leaned forward, shoving your head in between her cheeks, your nose rubbing against her pussy through her jeans.  She smelled really good, and you could feel the heat emanating from her pussy.  You could hear her panting with anticipation as you pealed down her jeans, her white butt perfectly round.  She had pink panties with frilly white lace around the edges still.  God she smelled so good, you just wanted to take her now.  You could see the swollen wet lips of her pussy pushing around the bottom of her panties.  You pulled them to the side, revealing the glorious pink lipped pussy, smelling like heaven.  You shoved your face in between her cheeks again, lapping like crazy as your nose prodded her tight asshole.  You could hardly think you were so full of lust, the smell of her sex so amazing it felt like it was taking over your mind.  You noticed she had been making loud yelps and moans, so you continued your vigorious licking, closing your eyes to experience the feeling of your tongue finding its way between those sensitive lips.[pause_clear]~]
    say__p=1;ParaContent(); print "^^She shoved it in her mouth almost seeming in desperation, sucking you right from the bat.  The squelching sound of her lips running up and down your resounded through the empty office, you hardly believing what was happening.  God you were already close to cumming, she was practically forcing you to cum down her throat.^^~WHOA! Whoa, Meredith, hold on!~ you almost yelled, pushing her back.  Her tongue could still reach the end of your dick, so she licked the end, looking up at you as you said, ~Meredith I think you're amazing but you are under a spell.. that witch did more damage then your.. uhhh..~ You gestured towards her breasts.  ~No no nooo,~ she responded, her beautiful eyes blinking at you, ~I have wanted this, its okay.  I mean.. I didn't anticipate the ummm extra nipples, but it'll be fine!  I want you to mount me anyway!~ Your jaw just dropped, the bluntness of the statement catching you off guard. She turned around, wiggling her ass at you on all fours, her back arching so that her little round butt was tight against her jeans.  ~I'm yours, take me, please!~ she begged, turning her head around, her desperate need apparent in her eyes.^^That was too tough to resist, you fell to your knees, your spit covered penis still wide open, your jeans around your feet.  This was really damn hot... teets or not.  Plus she really needed the relief.. You leaned forward, shoving your head in between her cheeks, your nose rubbing against her pussy through her jeans.  She smelled really good, and you could feel the heat emanating from her pussy.  You could hear her panting with anticipation as you pealed down her jeans, her white butt perfectly round.  She had pink panties with frilly white lace around the edges still.  God she smelled so good, you just wanted to take her now.  You could see the swollen wet lips of her pussy pushing around the bottom of her panties.  You pulled them to the side, revealing the glorious pink lipped pussy, smelling like heaven.  You shoved your face in between her cheeks again, lapping like crazy as your nose prodded her tight asshole.  You could hardly think you were so full of lust, the smell of her sex so amazing it felt like it was taking over your mind.  You noticed she had been making loud yelps and moans, so you continued your vigorious licking, closing your eyes to experience the feeling of your tongue finding its way between those sensitive lips."; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say865; .L_SayX863;
    ! [4: say ~^^She started to move in front of you, her asshole pushing against your nose oddly, as you something brush against your face.  You opened your eyes in confusion. 'WHOA!' you said, pulling your face from the sex of the bucking girl.  She turned around confused as well, especially at the absence of the tongue that was pleasuring her.  'AIIIIIAAAAAAHH!!' she screamed with no restraint, breaking into crying immediately.  She had seen her tail, wagging back in forth when you were eating her out, but now lowering like a shamed dog.  It looked like a huskies tail, already covered with a huskies thick fur.  Its growth had pulled her asshole and pussy up higher though, like as if to make it easier for mounting dogs.^^'I-I-IIIII DON'T WANNA BE A DOG!' she broke through her sobs, putting her face in her hands, little pants escaping between each sob.  You could still smell that wonderful smell, your own eyes fluttering as one little waft reach your nose.  You could feel your cock standing completely erect, not perturbed by her continuing transformation.  You had to touch it, you couldn't just stop here.   You stroked your length, the effort making you take small deep breaths quickly.  Or you were panting, you didn't care, your head rolling back to stare at the sky in pleasure.  Oh god, your cock was changing.  You could feel it twist in your hands, causing you to look down in fear, your soft toned thick headed human penis changing into a dogs.  You whined as you saw it change shape, lengthening and some parts growing bulbous.  A sheath grew up it as its tone turned to a bright red, it throbbing in your hands like it was encouraging you to fuck something with it.  Your sheath started to mesh with your torso, it hanging under your stomach like a normal male dog. [pause_clear]~]
    say__p=1;ParaContent(); print "^^She started to move in front of you, her asshole pushing against your nose oddly, as you something brush against your face.  You opened your eyes in confusion. ~WHOA!~ you said, pulling your face from the sex of the bucking girl.  She turned around confused as well, especially at the absence of the tongue that was pleasuring her.  ~AIIIIIAAAAAAHH!!~ she screamed with no restraint, breaking into crying immediately.  She had seen her tail, wagging back in forth when you were eating her out, but now lowering like a shamed dog.  It looked like a huskies tail, already covered with a huskies thick fur.  Its growth had pulled her asshole and pussy up higher though, like as if to make it easier for mounting dogs.^^~I-I-IIIII DON'T WANNA BE A DOG!~ she broke through her sobs, putting her face in her hands, little pants escaping between each sob.  You could still smell that wonderful smell, your own eyes fluttering as one little waft reach your nose.  You could feel your cock standing completely erect, not perturbed by her continuing transformation.  You had to touch it, you couldn't just stop here.   You stroked your length, the effort making you take small deep breaths quickly.  Or you were panting, you didn't care, your head rolling back to stare at the sky in pleasure.  Oh god, your cock was changing.  You could feel it twist in your hands, causing you to look down in fear, your soft toned thick headed human penis changing into a dogs.  You whined as you saw it change shape, lengthening and some parts growing bulbous.  A sheath grew up it as its tone turned to a bright red, it throbbing in your hands like it was encouraging you to fuck something with it.  Your sheath started to mesh with your torso, it hanging under your stomach like a normal male dog. ";ParaContent(); (PHR_928_r9 ()); .L_Say866; .L_SayX864;
    ! [5: say ~^^'Gggod no fuckk' you moaned, causing Meredith to look up from her hands, her sobbing ceasing.  'Oh noooo,' she cried, 'Please no I didn't mean for this to happen, your.. your dick.. it's...' you watched as she halted, licking her lips and eying your stiff doggie dick.  'It's changed... to a dogs.' she said, her tongue falling out of her mouth and her panting beginning again.  She crawled over to you as you rolled on your back in desperation, your body continuing to change. She leaned her head down to lap at your balls, the feeling nearly pushing you to cum right there.  'Noooo nonooo' you moaned as your felt a tail slowly push out of your spine, your hands changing to paws, and your spine altering the way your legs connected.  Fur was spreading all over you, but most importantly the smell of a willing bitch in heat was nearby.  You jumped up onto all fours, sniffing Meredith.  'Wait, we have to stop, we can't do this,' she stammered, moving away from you.  'Its turning us both even more, I don't want to be a female dog... and I know you don't want to be a mindless animal.. Right?' You couldn't even hear her, the smell of the plump pussy between her thighs too much.  She gasped as your lept forward, lapping her changing vagina like mad.^^'Noooo STOP MY PUSSSSSSSSSY' she yelled, your tongue feeling it squelch with its changes, the thick lipped human vagina twisting into a spaded pussy of a husky bitch. 'Ugh ugh OH GOD IM GONNA CUMMMM' she said grabbing the scruff of your neck with your forceful tongue pushing her pussy to its first dog orgasm.    She whined, her muzzle exploding out of her face, the beautiful features of her humanity changing to that of a dog in heat.[pause_clear]~]
    say__p=1;ParaContent(); print "^^~Gggod no fuckk~ you moaned, causing Meredith to look up from her hands, her sobbing ceasing.  ~Oh noooo,~ she cried, ~Please no I didn't mean for this to happen, your.. your dick.. it's...~ you watched as she halted, licking her lips and eying your stiff doggie dick.  ~It's changed... to a dogs.~ she said, her tongue falling out of her mouth and her panting beginning again.  She crawled over to you as you rolled on your back in desperation, your body continuing to change. She leaned her head down to lap at your balls, the feeling nearly pushing you to cum right there.  ~Noooo nonooo~ you moaned as your felt a tail slowly push out of your spine, your hands changing to paws, and your spine altering the way your legs connected.  Fur was spreading all over you, but most importantly the smell of a willing bitch in heat was nearby.  You jumped up onto all fours, sniffing Meredith.  ~Wait, we have to stop, we can't do this,~ she stammered, moving away from you.  ~Its turning us both even more, I don't want to be a female dog... and I know you don't want to be a mindless animal.. Right?~ You couldn't even hear her, the smell of the plump pussy between her thighs too much.  She gasped as your lept forward, lapping her changing vagina like mad.^^~Noooo STOP MY PUSSSSSSSSSY~ she yelled, your tongue feeling it squelch with its changes, the thick lipped human vagina twisting into a spaded pussy of a husky bitch. ~Ugh ugh OH GOD IM GONNA CUMMMM~ she said grabbing the scruff of your neck with your forceful tongue pushing her pussy to its first dog orgasm.    She whined, her muzzle exploding out of her face, the beautiful features of her humanity changing to that of a dog in heat."; new_line;ParaContent(); (PHR_928_r9 ()); .L_Say867; .L_SayX865;
    ! [6: say ~You could feel her heat only increasing from her trembling orgasming pussy, knowing she would only be satisfied by you giving her pups.  'Norrrf weee canttt dontt furckkk meee your make meee a dorrggggg.ggg....gg' she whined as she struggled her last human words.  Despite her begging, she turned around and raised her tail to present herself, the blast of bitch in heat pheromones hitting your square in the face.  Meredith was your submissive bitch, it was time to claim her.^^You jumped on top, probbing around til you could feel the lips of her pussy against the tip of your cock.  You grabbed the scruff of her neck with your maw to gain control as she tried to push back onto your cock with her uncontrollable lust.  You pinned her down and *SQUELCH* you shoved yourself inside of her.  Both of you panted in pleasure, the feeling of her dog pussy massaging the walls of your cock making your mind slip into bliss.  You could feel your intelligence leaving, just relying on instincts from now on.  She yipped and yipped, her mind still there basking in the feeling of you pounding inside of her, making her yours.  You could feel her pussy spasm again, her orgasm causing you to release into your own, filling her doggie womb with your cum.  You both howled, her still pinned down under you.  You both nuzzled each other in animal love after, your knot stuck in her.  She was your mate and she knew it, your human minds gone forever. ~]
    say__p=1;ParaContent(); print "You could feel her heat only increasing from her trembling orgasming pussy, knowing she would only be satisfied by you giving her pups.  ~Norrrf weee canttt dontt furckkk meee your make meee a dorrggggg.ggg....gg~ she whined as she struggled her last human words.  Despite her begging, she turned around and raised her tail to present herself, the blast of bitch in heat pheromones hitting your square in the face.  Meredith was your submissive bitch, it was time to claim her.^^You jumped on top, probbing around til you could feel the lips of her pussy against the tip of your cock.  You grabbed the scruff of her neck with your maw to gain control as she tried to push back onto your cock with her uncontrollable lust.  You pinned her down and *SQUELCH* you shoved yourself inside of her.  Both of you panted in pleasure, the feeling of her dog pussy massaging the walls of your cock making your mind slip into bliss.  You could feel your intelligence leaving, just relying on instincts from now on.  She yipped and yipped, her mind still there basking in the feeling of you pounding inside of her, making her yours.  You could feel her pussy spasm again, her orgasm causing you to release into your own, filling her doggie womb with your cum.  You both howled, her still pinned down under you.  You both nuzzled each other in animal love after, your knot stuck in her.  She was your mate and she knew it, your human minds gone forever. "; .L_Say868; .L_SayX866;
    ! [7: end the story saying ~[bold type]Game Over.  [italic type]'Doggie Love'  [roman type]Male Human to Husky.~]
    deadflag=(TEXT_TY_ExpandIfPerishable(I7SFRAME,TX_S_494)); story_complete=false;
    rfalse;
];
Array TX_R_0 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_0_R;
[ TX_R_0_R ;
    ResponseViaActivity(R_319_RESP_A);
];
[ ADJUST_LIGHT_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_0;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_1 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_1_R;
[ TX_R_1_R ;
    ResponseViaActivity(R_321_RESP_A);
];
[ GENERATE_ACTION_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_1;
        'B': str = TX_R_2;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_2 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_2_R;
[ TX_R_2_R ;
    ResponseViaActivity(R_321_RESP_B);
];
Array TX_R_3 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_3_R;
[ TX_R_3_R ;
    ResponseViaActivity(R_328_RESP_A);
];
[ BASIC_ACCESSIBILITY_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_3;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_4 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_4_R;
[ TX_R_4_R ;
    ResponseViaActivity(R_329_RESP_A);
];
[ BASIC_VISIBILITY_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_4;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_5 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_5_R;
[ TX_R_5_R ;
    ResponseViaActivity(R_331_RESP_A);
];
[ REQUESTED_ACTIONS_REQUIRE_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_5;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_6 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_6_R;
[ TX_R_6_R ;
    ResponseViaActivity(R_332_RESP_A);
];
[ CARRY_OUT_REQUESTED_ACTIONS_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_6;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_7 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_7_R;
[ TX_R_7_R ;
    ResponseViaActivity(R_335_RESP_A);
];
[ ACCESS_THROUGH_BARRIERS_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_7;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_8 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_8_R;
[ TX_R_8_R ;
    ResponseViaActivity(R_336_RESP_A);
];
[ CANT_REACH_INSIDE_CLOSED_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_8;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_9 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_9_R;
[ TX_R_9_R ;
    ResponseViaActivity(R_337_RESP_A);
];
[ CANT_REACH_INSIDE_ROOMS_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_9;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_10 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_10_R;
[ TX_R_10_R ;
    ResponseViaActivity(R_338_RESP_A);
];
[ CANT_REACH_OUTSIDE_CLOSED_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_10;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_11 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_11_R;
[ TX_R_11_R ;
    ResponseViaActivity(R_339_RESP_A);
];
[ LIST_WRITER_INTERNAL_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_11;
        'B': str = TX_R_12;
        'C': str = TX_R_13;
        'D': str = TX_R_14;
        'E': str = TX_R_15;
        'F': str = TX_R_16;
        'G': str = TX_R_17;
        'H': str = TX_R_18;
        'I': str = TX_R_19;
        'J': str = TX_R_20;
        'K': str = TX_R_21;
        'L': str = TX_R_22;
        'M': str = TX_R_23;
        'N': str = TX_R_24;
        'O': str = TX_R_25;
        'P': str = TX_R_26;
        'Q': str = TX_R_27;
        'R': str = TX_R_28;
        'S': str = TX_R_29;
        'T': str = TX_R_30;
        'U': str = TX_R_31;
        'V': str = TX_R_32;
        'W': str = TX_R_33;
        'X': str = TX_R_34;
        'Y': str = TX_R_35;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_12 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_12_R;
[ TX_R_12_R ;
    ResponseViaActivity(R_339_RESP_B);
];
Array TX_R_13 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_13_R;
[ TX_R_13_R ;
    ResponseViaActivity(R_339_RESP_C);
];
Array TX_R_14 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_14_R;
[ TX_R_14_R ;
    ResponseViaActivity(R_339_RESP_D);
];
Array TX_R_15 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_15_R;
[ TX_R_15_R ;
    ResponseViaActivity(R_339_RESP_E);
];
Array TX_R_16 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_16_R;
[ TX_R_16_R ;
    ResponseViaActivity(R_339_RESP_F);
];
Array TX_R_17 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_17_R;
[ TX_R_17_R ;
    ResponseViaActivity(R_339_RESP_G);
];
Array TX_R_18 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_18_R;
[ TX_R_18_R ;
    ResponseViaActivity(R_339_RESP_H);
];
Array TX_R_19 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_19_R;
[ TX_R_19_R ;
    ResponseViaActivity(R_339_RESP_I);
];
Array TX_R_20 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_20_R;
[ TX_R_20_R ;
    ResponseViaActivity(R_339_RESP_J);
];
Array TX_R_21 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_21_R;
[ TX_R_21_R ;
    ResponseViaActivity(R_339_RESP_K);
];
Array TX_R_22 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_22_R;
[ TX_R_22_R ;
    ResponseViaActivity(R_339_RESP_L);
];
Array TX_R_23 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_23_R;
[ TX_R_23_R ;
    ResponseViaActivity(R_339_RESP_M);
];
Array TX_R_24 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_24_R;
[ TX_R_24_R ;
    ResponseViaActivity(R_339_RESP_N);
];
Array TX_R_25 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_25_R;
[ TX_R_25_R ;
    ResponseViaActivity(R_339_RESP_O);
];
Array TX_R_26 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_26_R;
[ TX_R_26_R ;
    ResponseViaActivity(R_339_RESP_P);
];
Array TX_R_27 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_27_R;
[ TX_R_27_R ;
    ResponseViaActivity(R_339_RESP_Q);
];
Array TX_R_28 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_28_R;
[ TX_R_28_R ;
    ResponseViaActivity(R_339_RESP_R);
];
Array TX_R_29 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_29_R;
[ TX_R_29_R ;
    ResponseViaActivity(R_339_RESP_S);
];
Array TX_R_30 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_30_R;
[ TX_R_30_R ;
    ResponseViaActivity(R_339_RESP_T);
];
Array TX_R_31 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_31_R;
[ TX_R_31_R ;
    ResponseViaActivity(R_339_RESP_U);
];
Array TX_R_32 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_32_R;
[ TX_R_32_R ;
    ResponseViaActivity(R_339_RESP_V);
];
Array TX_R_33 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_33_R;
[ TX_R_33_R ;
    ResponseViaActivity(R_339_RESP_W);
];
Array TX_R_34 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_34_R;
[ TX_R_34_R ;
    ResponseViaActivity(R_339_RESP_X);
];
Array TX_R_35 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_35_R;
[ TX_R_35_R ;
    ResponseViaActivity(R_339_RESP_Y);
];
Array TX_R_36 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_36_R;
[ TX_R_36_R ;
    ResponseViaActivity(R_340_RESP_A);
];
[ ACTION_PROCESSING_INTERNAL_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_36;
        'B': str = TX_R_37;
        'C': str = TX_R_38;
        'D': str = TX_R_39;
        'E': str = TX_R_40;
        'F': str = TX_R_41;
        'G': str = TX_R_42;
        'H': str = TX_R_43;
        'I': str = TX_R_44;
        'J': str = TX_R_45;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_37 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_37_R;
[ TX_R_37_R ;
    ResponseViaActivity(R_340_RESP_B);
];
Array TX_R_38 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_38_R;
[ TX_R_38_R ;
    ResponseViaActivity(R_340_RESP_C);
];
Array TX_R_39 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_39_R;
[ TX_R_39_R ;
    ResponseViaActivity(R_340_RESP_D);
];
Array TX_R_40 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_40_R;
[ TX_R_40_R ;
    ResponseViaActivity(R_340_RESP_E);
];
Array TX_R_41 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_41_R;
[ TX_R_41_R ;
    ResponseViaActivity(R_340_RESP_F);
];
Array TX_R_42 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_42_R;
[ TX_R_42_R ;
    ResponseViaActivity(R_340_RESP_G);
];
Array TX_R_43 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_43_R;
[ TX_R_43_R ;
    ResponseViaActivity(R_340_RESP_H);
];
Array TX_R_44 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_44_R;
[ TX_R_44_R ;
    ResponseViaActivity(R_340_RESP_I);
];
Array TX_R_45 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_45_R;
[ TX_R_45_R ;
    ResponseViaActivity(R_340_RESP_J);
];
Array TX_R_46 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_46_R;
[ TX_R_46_R ;
    ResponseViaActivity(R_341_RESP_A);
];
[ PARSER_ERROR_INTERNAL_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_46;
        'B': str = TX_R_47;
        'C': str = TX_R_48;
        'D': str = TX_R_49;
        'E': str = TX_R_50;
        'F': str = TX_R_51;
        'G': str = TX_R_52;
        'H': str = TX_R_53;
        'I': str = TX_R_54;
        'J': str = TX_R_55;
        'K': str = TX_R_56;
        'L': str = TX_R_57;
        'M': str = TX_R_58;
        'N': str = TX_R_59;
        'O': str = TX_R_60;
        'P': str = TX_R_61;
        'Q': str = TX_R_62;
        'R': str = TX_R_63;
        'S': str = TX_R_64;
        'T': str = TX_R_65;
        'U': str = TX_R_66;
        'V': str = TX_R_67;
        'W': str = TX_R_68;
        'X': str = TX_R_69;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_47 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_47_R;
[ TX_R_47_R ;
    ResponseViaActivity(R_341_RESP_B);
];
Array TX_R_48 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_48_R;
[ TX_R_48_R ;
    ResponseViaActivity(R_341_RESP_C);
];
Array TX_R_49 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_49_R;
[ TX_R_49_R ;
    ResponseViaActivity(R_341_RESP_D);
];
Array TX_R_50 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_50_R;
[ TX_R_50_R ;
    ResponseViaActivity(R_341_RESP_E);
];
Array TX_R_51 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_51_R;
[ TX_R_51_R ;
    ResponseViaActivity(R_341_RESP_F);
];
Array TX_R_52 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_52_R;
[ TX_R_52_R ;
    ResponseViaActivity(R_341_RESP_G);
];
Array TX_R_53 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_53_R;
[ TX_R_53_R ;
    ResponseViaActivity(R_341_RESP_H);
];
Array TX_R_54 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_54_R;
[ TX_R_54_R ;
    ResponseViaActivity(R_341_RESP_I);
];
Array TX_R_55 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_55_R;
[ TX_R_55_R ;
    ResponseViaActivity(R_341_RESP_J);
];
Array TX_R_56 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_56_R;
[ TX_R_56_R ;
    ResponseViaActivity(R_341_RESP_K);
];
Array TX_R_57 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_57_R;
[ TX_R_57_R ;
    ResponseViaActivity(R_341_RESP_L);
];
Array TX_R_58 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_58_R;
[ TX_R_58_R ;
    ResponseViaActivity(R_341_RESP_M);
];
Array TX_R_59 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_59_R;
[ TX_R_59_R ;
    ResponseViaActivity(R_341_RESP_N);
];
Array TX_R_60 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_60_R;
[ TX_R_60_R ;
    ResponseViaActivity(R_341_RESP_O);
];
Array TX_R_61 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_61_R;
[ TX_R_61_R ;
    ResponseViaActivity(R_341_RESP_P);
];
Array TX_R_62 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_62_R;
[ TX_R_62_R ;
    ResponseViaActivity(R_341_RESP_Q);
];
Array TX_R_63 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_63_R;
[ TX_R_63_R ;
    ResponseViaActivity(R_341_RESP_R);
];
Array TX_R_64 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_64_R;
[ TX_R_64_R ;
    ResponseViaActivity(R_341_RESP_S);
];
Array TX_R_65 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_65_R;
[ TX_R_65_R ;
    ResponseViaActivity(R_341_RESP_T);
];
Array TX_R_66 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_66_R;
[ TX_R_66_R ;
    ResponseViaActivity(R_341_RESP_U);
];
Array TX_R_67 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_67_R;
[ TX_R_67_R ;
    ResponseViaActivity(R_341_RESP_V);
];
Array TX_R_68 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_68_R;
[ TX_R_68_R ;
    ResponseViaActivity(R_341_RESP_W);
];
Array TX_R_69 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_69_R;
[ TX_R_69_R ;
    ResponseViaActivity(R_341_RESP_X);
];
Array TX_R_70 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_70_R;
[ TX_R_70_R ;
    ResponseViaActivity(R_342_RESP_A);
];
[ PARSER_N_ERROR_INTERNAL_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_70;
        'B': str = TX_R_71;
        'C': str = TX_R_72;
        'D': str = TX_R_73;
        'E': str = TX_R_74;
        'F': str = TX_R_75;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_71 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_71_R;
[ TX_R_71_R ;
    ResponseViaActivity(R_342_RESP_B);
];
Array TX_R_72 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_72_R;
[ TX_R_72_R ;
    ResponseViaActivity(R_342_RESP_C);
];
Array TX_R_73 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_73_R;
[ TX_R_73_R ;
    ResponseViaActivity(R_342_RESP_D);
];
Array TX_R_74 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_74_R;
[ TX_R_74_R ;
    ResponseViaActivity(R_342_RESP_E);
];
Array TX_R_75 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_75_R;
[ TX_R_75_R ;
    ResponseViaActivity(R_342_RESP_F);
];
Array TX_R_76 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_76_R;
[ TX_R_76_R ;
    ResponseViaActivity(R_343_RESP_A);
];
[ DARKNESS_NAME_INTERNAL_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_76;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_77 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_77_R;
[ TX_R_77_R ;
    ResponseViaActivity(R_344_RESP_A);
];
[ PARSER_COMMAND_INTERNAL_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_77;
        'B': str = TX_R_78;
        'C': str = TX_R_79;
        'D': str = TX_R_80;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_78 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_78_R;
[ TX_R_78_R ;
    ResponseViaActivity(R_344_RESP_B);
];
Array TX_R_79 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_79_R;
[ TX_R_79_R ;
    ResponseViaActivity(R_344_RESP_C);
];
Array TX_R_80 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_80_R;
[ TX_R_80_R ;
    ResponseViaActivity(R_344_RESP_D);
];
Array TX_R_81 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_81_R;
[ TX_R_81_R ;
    ResponseViaActivity(R_345_RESP_A);
];
[ PARSER_CLARIF_INTERNAL_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_81;
        'B': str = TX_R_82;
        'C': str = TX_R_83;
        'D': str = TX_R_84;
        'E': str = TX_R_85;
        'F': str = TX_R_86;
        'G': str = TX_R_87;
        'H': str = TX_R_88;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_82 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_82_R;
[ TX_R_82_R ;
    ResponseViaActivity(R_345_RESP_B);
];
Array TX_R_83 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_83_R;
[ TX_R_83_R ;
    ResponseViaActivity(R_345_RESP_C);
];
Array TX_R_84 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_84_R;
[ TX_R_84_R ;
    ResponseViaActivity(R_345_RESP_D);
];
Array TX_R_85 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_85_R;
[ TX_R_85_R ;
    ResponseViaActivity(R_345_RESP_E);
];
Array TX_R_86 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_86_R;
[ TX_R_86_R ;
    ResponseViaActivity(R_345_RESP_F);
];
Array TX_R_87 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_87_R;
[ TX_R_87_R ;
    ResponseViaActivity(R_345_RESP_G);
];
Array TX_R_88 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_88_R;
[ TX_R_88_R ;
    ResponseViaActivity(R_345_RESP_H);
];
Array TX_R_89 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_89_R;
[ TX_R_89_R ;
    ResponseViaActivity(R_346_RESP_A);
];
[ YES_OR_NO_QUESTION_INTERNAL_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_89;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_90 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_90_R;
[ TX_R_90_R ;
    ResponseViaActivity(R_347_RESP_A);
];
[ PRINT_PROTAGONIST_INTERNAL_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_90;
        'B': str = TX_R_91;
        'C': str = TX_R_92;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_91 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_91_R;
[ TX_R_91_R ;
    ResponseViaActivity(R_347_RESP_B);
];
Array TX_R_92 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_92_R;
[ TX_R_92_R ;
    ResponseViaActivity(R_347_RESP_C);
];
Array TX_R_93 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_93_R;
[ TX_R_93_R ;
    ResponseViaActivity(R_350_RESP_A);
];
[ STANDARD_IMPLICIT_TAKING_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_93;
        'B': str = TX_R_94;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_94 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_94_R;
[ TX_R_94_R ;
    ResponseViaActivity(R_350_RESP_B);
];
Array TX_R_95 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_95_R;
[ TX_R_95_R ;
    ResponseViaActivity(R_352_RESP_A);
];
[ PRINT_OBITUARY_HEADLINE_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_95;
        'B': str = TX_R_96;
        'C': str = TX_R_97;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_96 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_96_R;
[ TX_R_96_R ;
    ResponseViaActivity(R_352_RESP_B);
];
Array TX_R_97 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_97_R;
[ TX_R_97_R ;
    ResponseViaActivity(R_352_RESP_C);
];
Array TX_R_98 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_98_R;
[ TX_R_98_R ;
    ResponseViaActivity(R_358_RESP_A);
];
[ IMMEDIATELY_UNDO_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_98;
        'B': str = TX_R_99;
        'C': str = TX_R_100;
        'D': str = TX_R_101;
        'E': str = TX_R_102;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_99 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_99_R;
[ TX_R_99_R ;
    ResponseViaActivity(R_358_RESP_B);
];
Array TX_R_100 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_100_R;
[ TX_R_100_R ;
    ResponseViaActivity(R_358_RESP_C);
];
Array TX_R_101 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_101_R;
[ TX_R_101_R ;
    ResponseViaActivity(R_358_RESP_D);
];
Array TX_R_102 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_102_R;
[ TX_R_102_R ;
    ResponseViaActivity(R_358_RESP_E);
];
Array TX_R_103 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_103_R;
[ TX_R_103_R ;
    ResponseViaActivity(R_361_RESP_A);
];
[ QUIT_THE_GAME_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_103;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_104 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_104_R;
[ TX_R_104_R ;
    ResponseViaActivity(R_362_RESP_A);
];
[ SAVE_THE_GAME_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_104;
        'B': str = TX_R_105;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_105 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_105_R;
[ TX_R_105_R ;
    ResponseViaActivity(R_362_RESP_B);
];
Array TX_R_106 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_106_R;
[ TX_R_106_R ;
    ResponseViaActivity(R_363_RESP_A);
];
[ RESTORE_THE_GAME_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_106;
        'B': str = TX_R_107;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_107 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_107_R;
[ TX_R_107_R ;
    ResponseViaActivity(R_363_RESP_B);
];
Array TX_R_108 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_108_R;
[ TX_R_108_R ;
    ResponseViaActivity(R_364_RESP_A);
];
[ RESTART_THE_GAME_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_108;
        'B': str = TX_R_109;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_109 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_109_R;
[ TX_R_109_R ;
    ResponseViaActivity(R_364_RESP_B);
];
Array TX_R_110 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_110_R;
[ TX_R_110_R ;
    ResponseViaActivity(R_365_RESP_A);
];
[ VERIFY_THE_STORY_FILE_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_110;
        'B': str = TX_R_111;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_111 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_111_R;
[ TX_R_111_R ;
    ResponseViaActivity(R_365_RESP_B);
];
Array TX_R_112 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_112_R;
[ TX_R_112_R ;
    ResponseViaActivity(R_366_RESP_A);
];
[ SWITCH_TRANSCRIPT_ON_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_112;
        'B': str = TX_R_113;
        'C': str = TX_R_114;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_113 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_113_R;
[ TX_R_113_R ;
    ResponseViaActivity(R_366_RESP_B);
];
Array TX_R_114 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_114_R;
[ TX_R_114_R ;
    ResponseViaActivity(R_366_RESP_C);
];
Array TX_R_115 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_115_R;
[ TX_R_115_R ;
    ResponseViaActivity(R_367_RESP_A);
];
[ SWITCH_TRANSCRIPT_OFF_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_115;
        'B': str = TX_R_116;
        'C': str = TX_R_117;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_116 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_116_R;
[ TX_R_116_R ;
    ResponseViaActivity(R_367_RESP_B);
];
Array TX_R_117 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_117_R;
[ TX_R_117_R ;
    ResponseViaActivity(R_367_RESP_C);
];
Array TX_R_118 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_118_R;
[ TX_R_118_R ;
    ResponseViaActivity(R_369_RESP_A);
];
[ ANNOUNCE_SCORE_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_118;
        'B': str = TX_R_119;
        'C': str = TX_R_120;
        'D': str = TX_R_121;
        'E': str = TX_R_122;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_119 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_119_R;
[ TX_R_119_R ;
    ResponseViaActivity(R_369_RESP_B);
];
Array TX_R_120 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_120_R;
[ TX_R_120_R ;
    ResponseViaActivity(R_369_RESP_C);
];
Array TX_R_121 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_121_R;
[ TX_R_121_R ;
    ResponseViaActivity(R_369_RESP_D);
];
Array TX_R_122 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_122_R;
[ TX_R_122_R ;
    ResponseViaActivity(R_369_RESP_E);
];
Array TX_R_123 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_123_R;
[ TX_R_123_R ;
    ResponseViaActivity(R_371_RESP_A);
];
[ REP_PREFER_ABBREVIATED_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_123;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_124 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_124_R;
[ TX_R_124_R ;
    ResponseViaActivity(R_373_RESP_A);
];
[ REP_PREFER_UNABBREVIATED_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_124;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_125 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_125_R;
[ TX_R_125_R ;
    ResponseViaActivity(R_375_RESP_A);
];
[ REP_PREFER_SOMETIMES_ABBR_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_125;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_126 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_126_R;
[ TX_R_126_R ;
    ResponseViaActivity(R_377_RESP_A);
];
[ REP_SWITCH_NOTIFY_ON_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_126;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_127 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_127_R;
[ TX_R_127_R ;
    ResponseViaActivity(R_379_RESP_A);
];
[ REP_SWITCH_NOTIFY_OFF_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_127;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_128 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_128_R;
[ TX_R_128_R ;
    ResponseViaActivity(R_380_RESP_A);
];
[ ANNOUNCE_PRONOUN_MEANINGS_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_128;
        'B': str = TX_R_129;
        'C': str = TX_R_130;
        'D': str = TX_R_131;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_129 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_129_R;
[ TX_R_129_R ;
    ResponseViaActivity(R_380_RESP_B);
];
Array TX_R_130 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_130_R;
[ TX_R_130_R ;
    ResponseViaActivity(R_380_RESP_C);
];
Array TX_R_131 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_131_R;
[ TX_R_131_R ;
    ResponseViaActivity(R_380_RESP_D);
];
Array TX_R_132 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_132_R;
[ TX_R_132_R ;
    ResponseViaActivity(R_274_RESP_A);
];
Array TX_R_133 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_133_R;
[ TX_R_133_R ;
    ResponseViaActivity(R_275_RESP_A);
];
Array TX_R_134 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_134_R;
[ TX_R_134_R ;
    ResponseViaActivity(R_276_RESP_A);
];
Array TX_R_135 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_135_R;
[ TX_R_135_R ;
    ResponseViaActivity(R_277_RESP_A);
];
Array TX_R_136 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_136_R;
[ TX_R_136_R ;
    ResponseViaActivity(R_296_RESP_A);
];
Array TX_R_137 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_137_R;
[ TX_R_137_R ;
    ResponseViaActivity(R_291_RESP_A);
];
Array TX_R_138 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_138_R;
[ TX_R_138_R ;
    ResponseViaActivity(R_290_RESP_A);
];
Array TX_R_139 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_139_R;
[ TX_R_139_R ;
    ResponseViaActivity(R_38_RESP_A);
];
Array TX_R_140 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_140_R;
[ TX_R_140_R ;
    ResponseViaActivity(R_40_RESP_A);
];
Array TX_R_141 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_141_R;
[ TX_R_141_R ;
    ResponseViaActivity(R_40_RESP_B);
];
Array TX_R_142 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_142_R;
[ TX_R_142_R ;
    ResponseViaActivity(R_39_RESP_A);
];
Array TX_R_143 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_143_R;
[ TX_R_143_R ;
    ResponseViaActivity(R_41_RESP_A);
];
Array TX_R_144 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_144_R;
[ TX_R_144_R ;
    ResponseViaActivity(R_45_RESP_A);
];
Array TX_R_145 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_145_R;
[ TX_R_145_R ;
    ResponseViaActivity(R_45_RESP_B);
];
Array TX_R_146 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_146_R;
[ TX_R_146_R ;
    ResponseViaActivity(R_45_RESP_C);
];
Array TX_R_147 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_147_R;
[ TX_R_147_R ;
    ResponseViaActivity(R_45_RESP_D);
];
Array TX_R_148 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_148_R;
[ TX_R_148_R ;
    ResponseViaActivity(R_45_RESP_E);
];
Array TX_R_149 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_149_R;
[ TX_R_149_R ;
    ResponseViaActivity(R_45_RESP_F);
];
Array TX_R_150 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_150_R;
[ TX_R_150_R ;
    ResponseViaActivity(R_52_RESP_A);
];
Array TX_R_151 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_151_R;
[ TX_R_151_R ;
    ResponseViaActivity(R_54_RESP_A);
];
Array TX_R_152 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_152_R;
[ TX_R_152_R ;
    ResponseViaActivity(R_55_RESP_A);
];
Array TX_R_153 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_153_R;
[ TX_R_153_R ;
    ResponseViaActivity(R_56_RESP_A);
];
Array TX_R_154 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_154_R;
[ TX_R_154_R ;
    ResponseViaActivity(R_57_RESP_A);
];
Array TX_R_155 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_155_R;
[ TX_R_155_R ;
    ResponseViaActivity(R_58_RESP_A);
];
Array TX_R_156 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_156_R;
[ TX_R_156_R ;
    ResponseViaActivity(R_59_RESP_A);
];
Array TX_R_157 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_157_R;
[ TX_R_157_R ;
    ResponseViaActivity(R_60_RESP_A);
];
Array TX_R_158 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_158_R;
[ TX_R_158_R ;
    ResponseViaActivity(R_61_RESP_A);
];
Array TX_R_159 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_159_R;
[ TX_R_159_R ;
    ResponseViaActivity(R_62_RESP_A);
];
Array TX_R_160 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_160_R;
[ TX_R_160_R ;
    ResponseViaActivity(R_63_RESP_A);
];
Array TX_R_161 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_161_R;
[ TX_R_161_R ;
    ResponseViaActivity(R_64_RESP_A);
];
Array TX_R_162 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_162_R;
[ TX_R_162_R ;
    ResponseViaActivity(R_65_RESP_A);
];
Array TX_R_163 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_163_R;
[ TX_R_163_R ;
    ResponseViaActivity(R_66_RESP_A);
];
Array TX_R_164 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_164_R;
[ TX_R_164_R ;
    ResponseViaActivity(R_67_RESP_A);
];
Array TX_R_165 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_165_R;
[ TX_R_165_R ;
    ResponseViaActivity(R_68_RESP_A);
];
Array TX_R_166 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_166_R;
[ TX_R_166_R ;
    ResponseViaActivity(R_69_RESP_A);
];
Array TX_R_167 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_167_R;
[ TX_R_167_R ;
    ResponseViaActivity(R_71_RESP_A);
];
Array TX_R_168 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_168_R;
[ TX_R_168_R ;
    ResponseViaActivity(R_71_RESP_B);
];
Array TX_R_169 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_169_R;
[ TX_R_169_R ;
    ResponseViaActivity(R_72_RESP_A);
];
Array TX_R_170 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_170_R;
[ TX_R_170_R ;
    ResponseViaActivity(R_73_RESP_A);
];
Array TX_R_171 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_171_R;
[ TX_R_171_R ;
    ResponseViaActivity(R_76_RESP_A);
];
Array TX_R_172 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_172_R;
[ TX_R_172_R ;
    ResponseViaActivity(R_75_RESP_A);
];
Array TX_R_173 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_173_R;
[ TX_R_173_R ;
    ResponseViaActivity(R_77_RESP_A);
];
Array TX_R_174 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_174_R;
[ TX_R_174_R ;
    ResponseViaActivity(R_78_RESP_A);
];
Array TX_R_175 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_175_R;
[ TX_R_175_R ;
    ResponseViaActivity(R_79_RESP_A);
];
Array TX_R_176 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_176_R;
[ TX_R_176_R ;
    ResponseViaActivity(R_80_RESP_A);
];
Array TX_R_177 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_177_R;
[ TX_R_177_R ;
    ResponseViaActivity(R_80_RESP_B);
];
Array TX_R_178 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_178_R;
[ TX_R_178_R ;
    ResponseViaActivity(R_82_RESP_A);
];
Array TX_R_179 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_179_R;
[ TX_R_179_R ;
    ResponseViaActivity(R_82_RESP_B);
];
Array TX_R_180 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_180_R;
[ TX_R_180_R ;
    ResponseViaActivity(R_85_RESP_A);
];
Array TX_R_181 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_181_R;
[ TX_R_181_R ;
    ResponseViaActivity(R_86_RESP_A);
];
Array TX_R_182 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_182_R;
[ TX_R_182_R ;
    ResponseViaActivity(R_87_RESP_A);
];
Array TX_R_183 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_183_R;
[ TX_R_183_R ;
    ResponseViaActivity(R_88_RESP_A);
];
Array TX_R_184 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_184_R;
[ TX_R_184_R ;
    ResponseViaActivity(R_90_RESP_A);
];
Array TX_R_185 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_185_R;
[ TX_R_185_R ;
    ResponseViaActivity(R_91_RESP_A);
];
Array TX_R_186 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_186_R;
[ TX_R_186_R ;
    ResponseViaActivity(R_94_RESP_A);
];
Array TX_R_187 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_187_R;
[ TX_R_187_R ;
    ResponseViaActivity(R_95_RESP_A);
];
Array TX_R_188 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_188_R;
[ TX_R_188_R ;
    ResponseViaActivity(R_96_RESP_A);
];
Array TX_R_189 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_189_R;
[ TX_R_189_R ;
    ResponseViaActivity(R_97_RESP_A);
];
Array TX_R_190 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_190_R;
[ TX_R_190_R ;
    ResponseViaActivity(R_98_RESP_A);
];
Array TX_R_191 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_191_R;
[ TX_R_191_R ;
    ResponseViaActivity(R_100_RESP_A);
];
Array TX_R_192 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_192_R;
[ TX_R_192_R ;
    ResponseViaActivity(R_101_RESP_A);
];
Array TX_R_193 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_193_R;
[ TX_R_193_R ;
    ResponseViaActivity(R_102_RESP_A);
];
Array TX_R_194 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_194_R;
[ TX_R_194_R ;
    ResponseViaActivity(R_103_RESP_A);
];
Array TX_R_195 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_195_R;
[ TX_R_195_R ;
    ResponseViaActivity(R_104_RESP_A);
];
Array TX_R_196 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_196_R;
[ TX_R_196_R ;
    ResponseViaActivity(R_107_RESP_A);
];
Array TX_R_197 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_197_R;
[ TX_R_197_R ;
    ResponseViaActivity(R_107_RESP_B);
];
Array TX_R_198 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_198_R;
[ TX_R_198_R ;
    ResponseViaActivity(R_109_RESP_A);
];
Array TX_R_199 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_199_R;
[ TX_R_199_R ;
    ResponseViaActivity(R_110_RESP_A);
];
Array TX_R_200 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_200_R;
[ TX_R_200_R ;
    ResponseViaActivity(R_110_RESP_B);
];
Array TX_R_201 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_201_R;
[ TX_R_201_R ;
    ResponseViaActivity(R_111_RESP_A);
];
Array TX_R_202 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_202_R;
[ TX_R_202_R ;
    ResponseViaActivity(R_112_RESP_A);
];
Array TX_R_203 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_203_R;
[ TX_R_203_R ;
    ResponseViaActivity(R_114_RESP_A);
];
Array TX_R_204 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_204_R;
[ TX_R_204_R ;
    ResponseViaActivity(R_114_RESP_B);
];
Array TX_R_205 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_205_R;
[ TX_R_205_R ;
    ResponseViaActivity(R_118_RESP_A);
];
Array TX_R_206 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_206_R;
[ TX_R_206_R ;
    ResponseViaActivity(R_118_RESP_B);
];
Array TX_R_207 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_207_R;
[ TX_R_207_R ;
    ResponseViaActivity(R_118_RESP_C);
];
Array TX_R_208 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_208_R;
[ TX_R_208_R ;
    ResponseViaActivity(R_118_RESP_D);
];
Array TX_R_209 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_209_R;
[ TX_R_209_R ;
    ResponseViaActivity(R_118_RESP_E);
];
Array TX_R_210 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_210_R;
[ TX_R_210_R ;
    ResponseViaActivity(R_118_RESP_F);
];
Array TX_R_211 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_211_R;
[ TX_R_211_R ;
    ResponseViaActivity(R_118_RESP_G);
];
Array TX_R_212 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_212_R;
[ TX_R_212_R ;
    ResponseViaActivity(R_118_RESP_H);
];
Array TX_R_213 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_213_R;
[ TX_R_213_R ;
    ResponseViaActivity(R_118_RESP_I);
];
Array TX_R_214 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_214_R;
[ TX_R_214_R ;
    ResponseViaActivity(R_118_RESP_J);
];
Array TX_R_215 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_215_R;
[ TX_R_215_R ;
    ResponseViaActivity(R_118_RESP_K);
];
Array TX_R_216 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_216_R;
[ TX_R_216_R ;
    ResponseViaActivity(R_118_RESP_L);
];
Array TX_R_217 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_217_R;
[ TX_R_217_R ;
    ResponseViaActivity(R_118_RESP_M);
];
Array TX_R_218 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_218_R;
[ TX_R_218_R ;
    ResponseViaActivity(R_118_RESP_N);
];
Array TX_R_219 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_219_R;
[ TX_R_219_R ;
    ResponseViaActivity(R_118_RESP_O);
];
Array TX_R_220 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_220_R;
[ TX_R_220_R ;
    ResponseViaActivity(R_118_RESP_P);
];
Array TX_R_221 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_221_R;
[ TX_R_221_R ;
    ResponseViaActivity(R_118_RESP_Q);
];
Array TX_R_222 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_222_R;
[ TX_R_222_R ;
    ResponseViaActivity(R_118_RESP_R);
];
Array TX_R_223 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_223_R;
[ TX_R_223_R ;
    ResponseViaActivity(R_118_RESP_S);
];
Array TX_R_224 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_224_R;
[ TX_R_224_R ;
    ResponseViaActivity(R_122_RESP_A);
];
Array TX_R_225 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_225_R;
[ TX_R_225_R ;
    ResponseViaActivity(R_122_RESP_B);
];
Array TX_R_226 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_226_R;
[ TX_R_226_R ;
    ResponseViaActivity(R_123_RESP_A);
];
Array TX_R_227 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_227_R;
[ TX_R_227_R ;
    ResponseViaActivity(R_123_RESP_B);
];
Array TX_R_228 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_228_R;
[ TX_R_228_R ;
    ResponseViaActivity(R_123_RESP_C);
];
Array TX_R_229 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_229_R;
[ TX_R_229_R ;
    ResponseViaActivity(R_123_RESP_D);
];
Array TX_R_230 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_230_R;
[ TX_R_230_R ;
    ResponseViaActivity(R_124_RESP_A);
];
Array TX_R_231 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_231_R;
[ TX_R_231_R ;
    ResponseViaActivity(R_125_RESP_A);
];
Array TX_R_232 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_232_R;
[ TX_R_232_R ;
    ResponseViaActivity(R_125_RESP_B);
];
Array TX_R_233 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_233_R;
[ TX_R_233_R ;
    ResponseViaActivity(R_126_RESP_A);
];
Array TX_R_234 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_234_R;
[ TX_R_234_R ;
    ResponseViaActivity(R_127_RESP_A);
];
Array TX_R_235 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_235_R;
[ TX_R_235_R ;
    ResponseViaActivity(R_127_RESP_B);
];
Array TX_R_236 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_236_R;
[ TX_R_236_R ;
    ResponseViaActivity(R_127_RESP_C);
];
Array TX_R_237 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_237_R;
[ TX_R_237_R ;
    ResponseViaActivity(R_127_RESP_D);
];
Array TX_R_238 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_238_R;
[ TX_R_238_R ;
    ResponseViaActivity(R_127_RESP_E);
];
Array TX_R_239 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_239_R;
[ TX_R_239_R ;
    ResponseViaActivity(R_129_RESP_A);
];
Array TX_R_240 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_240_R;
[ TX_R_240_R ;
    ResponseViaActivity(R_129_RESP_B);
];
Array TX_R_241 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_241_R;
[ TX_R_241_R ;
    ResponseViaActivity(R_129_RESP_C);
];
Array TX_R_242 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_242_R;
[ TX_R_242_R ;
    ResponseViaActivity(R_129_RESP_D);
];
Array TX_R_243 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_243_R;
[ TX_R_243_R ;
    ResponseViaActivity(R_132_RESP_A);
];
Array TX_R_244 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_244_R;
[ TX_R_244_R ;
    ResponseViaActivity(R_133_RESP_A);
];
Array TX_R_245 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_245_R;
[ TX_R_245_R ;
    ResponseViaActivity(R_136_RESP_A);
];
Array TX_R_246 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_246_R;
[ TX_R_246_R ;
    ResponseViaActivity(R_136_RESP_B);
];
Array TX_R_247 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_247_R;
[ TX_R_247_R ;
    ResponseViaActivity(R_136_RESP_C);
];
Array TX_R_248 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_248_R;
[ TX_R_248_R ;
    ResponseViaActivity(R_138_RESP_A);
];
Array TX_R_249 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_249_R;
[ TX_R_249_R ;
    ResponseViaActivity(R_140_RESP_A);
];
Array TX_R_250 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_250_R;
[ TX_R_250_R ;
    ResponseViaActivity(R_144_RESP_A);
];
Array TX_R_251 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_251_R;
[ TX_R_251_R ;
    ResponseViaActivity(R_144_RESP_B);
];
Array TX_R_252 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_252_R;
[ TX_R_252_R ;
    ResponseViaActivity(R_144_RESP_C);
];
Array TX_R_253 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_253_R;
[ TX_R_253_R ;
    ResponseViaActivity(R_145_RESP_A);
];
Array TX_R_254 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_254_R;
[ TX_R_254_R ;
    ResponseViaActivity(R_148_RESP_A);
];
Array TX_R_255 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_255_R;
[ TX_R_255_R ;
    ResponseViaActivity(R_150_RESP_A);
];
Array TX_R_256 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_256_R;
[ TX_R_256_R ;
    ResponseViaActivity(R_151_RESP_A);
];
Array TX_R_257 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_257_R;
[ TX_R_257_R ;
    ResponseViaActivity(R_151_RESP_B);
];
Array TX_R_258 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_258_R;
[ TX_R_258_R ;
    ResponseViaActivity(R_152_RESP_A);
];
Array TX_R_259 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_259_R;
[ TX_R_259_R ;
    ResponseViaActivity(R_153_RESP_A);
];
Array TX_R_260 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_260_R;
[ TX_R_260_R ;
    ResponseViaActivity(R_154_RESP_A);
];
Array TX_R_261 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_261_R;
[ TX_R_261_R ;
    ResponseViaActivity(R_155_RESP_A);
];
Array TX_R_262 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_262_R;
[ TX_R_262_R ;
    ResponseViaActivity(R_156_RESP_A);
];
Array TX_R_263 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_263_R;
[ TX_R_263_R ;
    ResponseViaActivity(R_157_RESP_A);
];
Array TX_R_264 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_264_R;
[ TX_R_264_R ;
    ResponseViaActivity(R_158_RESP_A);
];
Array TX_R_265 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_265_R;
[ TX_R_265_R ;
    ResponseViaActivity(R_159_RESP_A);
];
Array TX_R_266 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_266_R;
[ TX_R_266_R ;
    ResponseViaActivity(R_160_RESP_A);
];
Array TX_R_267 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_267_R;
[ TX_R_267_R ;
    ResponseViaActivity(R_160_RESP_B);
];
Array TX_R_268 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_268_R;
[ TX_R_268_R ;
    ResponseViaActivity(R_161_RESP_A);
];
Array TX_R_269 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_269_R;
[ TX_R_269_R ;
    ResponseViaActivity(R_161_RESP_B);
];
Array TX_R_270 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_270_R;
[ TX_R_270_R ;
    ResponseViaActivity(R_162_RESP_A);
];
Array TX_R_271 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_271_R;
[ TX_R_271_R ;
    ResponseViaActivity(R_163_RESP_A);
];
Array TX_R_272 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_272_R;
[ TX_R_272_R ;
    ResponseViaActivity(R_163_RESP_B);
];
Array TX_R_273 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_273_R;
[ TX_R_273_R ;
    ResponseViaActivity(R_164_RESP_A);
];
Array TX_R_274 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_274_R;
[ TX_R_274_R ;
    ResponseViaActivity(R_165_RESP_A);
];
Array TX_R_275 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_275_R;
[ TX_R_275_R ;
    ResponseViaActivity(R_166_RESP_A);
];
Array TX_R_276 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_276_R;
[ TX_R_276_R ;
    ResponseViaActivity(R_285_RESP_A);
];
Array TX_R_277 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_277_R;
[ TX_R_277_R ;
    ResponseViaActivity(R_169_RESP_A);
];
Array TX_R_278 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_278_R;
[ TX_R_278_R ;
    ResponseViaActivity(R_169_RESP_B);
];
Array TX_R_279 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_279_R;
[ TX_R_279_R ;
    ResponseViaActivity(R_170_RESP_A);
];
Array TX_R_280 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_280_R;
[ TX_R_280_R ;
    ResponseViaActivity(R_171_RESP_A);
];
Array TX_R_281 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_281_R;
[ TX_R_281_R ;
    ResponseViaActivity(R_174_RESP_A);
];
Array TX_R_282 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_282_R;
[ TX_R_282_R ;
    ResponseViaActivity(R_174_RESP_B);
];
Array TX_R_283 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_283_R;
[ TX_R_283_R ;
    ResponseViaActivity(R_175_RESP_A);
];
Array TX_R_284 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_284_R;
[ TX_R_284_R ;
    ResponseViaActivity(R_176_RESP_A);
];
Array TX_R_285 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_285_R;
[ TX_R_285_R ;
    ResponseViaActivity(R_178_RESP_A);
];
Array TX_R_286 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_286_R;
[ TX_R_286_R ;
    ResponseViaActivity(R_179_RESP_A);
];
Array TX_R_287 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_287_R;
[ TX_R_287_R ;
    ResponseViaActivity(R_180_RESP_A);
];
Array TX_R_288 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_288_R;
[ TX_R_288_R ;
    ResponseViaActivity(R_182_RESP_A);
];
Array TX_R_289 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_289_R;
[ TX_R_289_R ;
    ResponseViaActivity(R_183_RESP_A);
];
Array TX_R_290 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_290_R;
[ TX_R_290_R ;
    ResponseViaActivity(R_184_RESP_A);
];
Array TX_R_291 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_291_R;
[ TX_R_291_R ;
    ResponseViaActivity(R_185_RESP_A);
];
Array TX_R_292 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_292_R;
[ TX_R_292_R ;
    ResponseViaActivity(R_187_RESP_A);
];
Array TX_R_293 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_293_R;
[ TX_R_293_R ;
    ResponseViaActivity(R_188_RESP_A);
];
Array TX_R_294 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_294_R;
[ TX_R_294_R ;
    ResponseViaActivity(R_188_RESP_B);
];
Array TX_R_295 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_295_R;
[ TX_R_295_R ;
    ResponseViaActivity(R_188_RESP_C);
];
Array TX_R_296 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_296_R;
[ TX_R_296_R ;
    ResponseViaActivity(R_189_RESP_A);
];
Array TX_R_297 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_297_R;
[ TX_R_297_R ;
    ResponseViaActivity(R_190_RESP_A);
];
Array TX_R_298 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_298_R;
[ TX_R_298_R ;
    ResponseViaActivity(R_192_RESP_A);
];
Array TX_R_299 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_299_R;
[ TX_R_299_R ;
    ResponseViaActivity(R_192_RESP_B);
];
Array TX_R_300 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_300_R;
[ TX_R_300_R ;
    ResponseViaActivity(R_192_RESP_C);
];
Array TX_R_301 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_301_R;
[ TX_R_301_R ;
    ResponseViaActivity(R_193_RESP_A);
];
Array TX_R_302 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_302_R;
[ TX_R_302_R ;
    ResponseViaActivity(R_194_RESP_A);
];
Array TX_R_303 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_303_R;
[ TX_R_303_R ;
    ResponseViaActivity(R_195_RESP_A);
];
Array TX_R_304 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_304_R;
[ TX_R_304_R ;
    ResponseViaActivity(R_197_RESP_A);
];
Array TX_R_305 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_305_R;
[ TX_R_305_R ;
    ResponseViaActivity(R_197_RESP_B);
];
Array TX_R_306 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_306_R;
[ TX_R_306_R ;
    ResponseViaActivity(R_198_RESP_A);
];
Array TX_R_307 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_307_R;
[ TX_R_307_R ;
    ResponseViaActivity(R_199_RESP_A);
];
Array TX_R_308 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_308_R;
[ TX_R_308_R ;
    ResponseViaActivity(R_201_RESP_A);
];
Array TX_R_309 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_309_R;
[ TX_R_309_R ;
    ResponseViaActivity(R_201_RESP_B);
];
Array TX_R_310 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_310_R;
[ TX_R_310_R ;
    ResponseViaActivity(R_202_RESP_A);
];
Array TX_R_311 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_311_R;
[ TX_R_311_R ;
    ResponseViaActivity(R_203_RESP_A);
];
Array TX_R_312 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_312_R;
[ TX_R_312_R ;
    ResponseViaActivity(R_204_RESP_A);
];
Array TX_R_313 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_313_R;
[ TX_R_313_R ;
    ResponseViaActivity(R_205_RESP_A);
];
Array TX_R_314 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_314_R;
[ TX_R_314_R ;
    ResponseViaActivity(R_206_RESP_A);
];
Array TX_R_315 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_315_R;
[ TX_R_315_R ;
    ResponseViaActivity(R_207_RESP_A);
];
Array TX_R_316 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_316_R;
[ TX_R_316_R ;
    ResponseViaActivity(R_209_RESP_A);
];
Array TX_R_317 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_317_R;
[ TX_R_317_R ;
    ResponseViaActivity(R_209_RESP_B);
];
Array TX_R_318 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_318_R;
[ TX_R_318_R ;
    ResponseViaActivity(R_209_RESP_C);
];
Array TX_R_319 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_319_R;
[ TX_R_319_R ;
    ResponseViaActivity(R_210_RESP_A);
];
Array TX_R_320 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_320_R;
[ TX_R_320_R ;
    ResponseViaActivity(R_212_RESP_A);
];
Array TX_R_321 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_321_R;
[ TX_R_321_R ;
    ResponseViaActivity(R_213_RESP_A);
];
Array TX_R_322 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_322_R;
[ TX_R_322_R ;
    ResponseViaActivity(R_214_RESP_A);
];
Array TX_R_323 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_323_R;
[ TX_R_323_R ;
    ResponseViaActivity(R_215_RESP_A);
];
Array TX_R_324 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_324_R;
[ TX_R_324_R ;
    ResponseViaActivity(R_216_RESP_A);
];
Array TX_R_325 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_325_R;
[ TX_R_325_R ;
    ResponseViaActivity(R_217_RESP_A);
];
Array TX_R_326 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_326_R;
[ TX_R_326_R ;
    ResponseViaActivity(R_218_RESP_A);
];
Array TX_R_327 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_327_R;
[ TX_R_327_R ;
    ResponseViaActivity(R_219_RESP_A);
];
Array TX_R_328 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_328_R;
[ TX_R_328_R ;
    ResponseViaActivity(R_220_RESP_A);
];
Array TX_R_329 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_329_R;
[ TX_R_329_R ;
    ResponseViaActivity(R_221_RESP_A);
];
Array TX_R_330 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_330_R;
[ TX_R_330_R ;
    ResponseViaActivity(R_222_RESP_A);
];
Array TX_R_331 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_331_R;
[ TX_R_331_R ;
    ResponseViaActivity(R_223_RESP_A);
];
Array TX_R_332 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_332_R;
[ TX_R_332_R ;
    ResponseViaActivity(R_226_RESP_A);
];
Array TX_R_333 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_333_R;
[ TX_R_333_R ;
    ResponseViaActivity(R_226_RESP_B);
];
Array TX_R_334 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_334_R;
[ TX_R_334_R ;
    ResponseViaActivity(R_227_RESP_A);
];
Array TX_R_335 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_335_R;
[ TX_R_335_R ;
    ResponseViaActivity(R_227_RESP_B);
];
Array TX_R_336 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_336_R;
[ TX_R_336_R ;
    ResponseViaActivity(R_228_RESP_A);
];
Array TX_R_337 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_337_R;
[ TX_R_337_R ;
    ResponseViaActivity(R_228_RESP_B);
];
Array TX_R_338 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_338_R;
[ TX_R_338_R ;
    ResponseViaActivity(R_228_RESP_C);
];
Array TX_R_339 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_339_R;
[ TX_R_339_R ;
    ResponseViaActivity(R_229_RESP_A);
];
Array TX_R_340 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_340_R;
[ TX_R_340_R ;
    ResponseViaActivity(R_229_RESP_B);
];
Array TX_R_341 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_341_R;
[ TX_R_341_R ;
    ResponseViaActivity(R_230_RESP_A);
];
Array TX_R_342 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_342_R;
[ TX_R_342_R ;
    ResponseViaActivity(R_231_RESP_A);
];
Array TX_R_343 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_343_R;
[ TX_R_343_R ;
    ResponseViaActivity(R_231_RESP_B);
];
Array TX_R_344 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_344_R;
[ TX_R_344_R ;
    ResponseViaActivity(R_232_RESP_A);
];
Array TX_R_345 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_345_R;
[ TX_R_345_R ;
    ResponseViaActivity(R_233_RESP_A);
];
Array TX_R_346 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_346_R;
[ TX_R_346_R ;
    ResponseViaActivity(R_234_RESP_A);
];
Array TX_R_347 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_347_R;
[ TX_R_347_R ;
    ResponseViaActivity(R_235_RESP_A);
];
Array TX_R_348 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_348_R;
[ TX_R_348_R ;
    ResponseViaActivity(R_235_RESP_B);
];
Array TX_R_349 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_349_R;
[ TX_R_349_R ;
    ResponseViaActivity(R_236_RESP_A);
];
Array TX_R_350 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_350_R;
[ TX_R_350_R ;
    ResponseViaActivity(R_237_RESP_A);
];
Array TX_R_351 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_351_R;
[ TX_R_351_R ;
    ResponseViaActivity(R_238_RESP_A);
];
Array TX_R_352 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_352_R;
[ TX_R_352_R ;
    ResponseViaActivity(R_239_RESP_A);
];
Array TX_R_353 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_353_R;
[ TX_R_353_R ;
    ResponseViaActivity(R_239_RESP_B);
];
Array TX_R_354 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_354_R;
[ TX_R_354_R ;
    ResponseViaActivity(R_240_RESP_A);
];
Array TX_R_355 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_355_R;
[ TX_R_355_R ;
    ResponseViaActivity(R_241_RESP_A);
];
Array TX_R_356 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_356_R;
[ TX_R_356_R ;
    ResponseViaActivity(R_242_RESP_A);
];
Array TX_R_357 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_357_R;
[ TX_R_357_R ;
    ResponseViaActivity(R_243_RESP_A);
];
Array TX_R_358 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_358_R;
[ TX_R_358_R ;
    ResponseViaActivity(R_243_RESP_B);
];
Array TX_R_359 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_359_R;
[ TX_R_359_R ;
    ResponseViaActivity(R_244_RESP_A);
];
Array TX_R_360 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_360_R;
[ TX_R_360_R ;
    ResponseViaActivity(R_245_RESP_A);
];
Array TX_R_361 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_361_R;
[ TX_R_361_R ;
    ResponseViaActivity(R_246_RESP_A);
];
Array TX_R_362 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_362_R;
[ TX_R_362_R ;
    ResponseViaActivity(R_247_RESP_A);
];
Array TX_R_363 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_363_R;
[ TX_R_363_R ;
    ResponseViaActivity(R_249_RESP_A);
];
Array TX_R_364 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_364_R;
[ TX_R_364_R ;
    ResponseViaActivity(R_250_RESP_A);
];
Array TX_R_365 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_365_R;
[ TX_R_365_R ;
    ResponseViaActivity(R_251_RESP_A);
];
Array TX_R_366 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_366_R;
[ TX_R_366_R ;
    ResponseViaActivity(R_251_RESP_B);
];
Array TX_R_367 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_367_R;
[ TX_R_367_R ;
    ResponseViaActivity(R_252_RESP_A);
];
Array TX_R_368 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_368_R;
[ TX_R_368_R ;
    ResponseViaActivity(R_253_RESP_A);
];
Array TX_R_369 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_369_R;
[ TX_R_369_R ;
    ResponseViaActivity(R_254_RESP_A);
];
Array TX_R_370 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_370_R;
[ TX_R_370_R ;
    ResponseViaActivity(R_255_RESP_A);
];
Array TX_R_371 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_371_R;
[ TX_R_371_R ;
    ResponseViaActivity(R_256_RESP_A);
];
Array TX_R_372 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_372_R;
[ TX_R_372_R ;
    ResponseViaActivity(R_257_RESP_A);
];
Array TX_R_373 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_373_R;
[ TX_R_373_R ;
    ResponseViaActivity(R_257_RESP_B);
];
Array TX_R_374 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_374_R;
[ TX_R_374_R ;
    ResponseViaActivity(R_258_RESP_A);
];
Array TX_R_375 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_375_R;
[ TX_R_375_R ;
    ResponseViaActivity(R_258_RESP_B);
];
Array TX_R_376 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_376_R;
[ TX_R_376_R ;
    ResponseViaActivity(R_259_RESP_A);
];
Array TX_R_377 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_377_R;
[ TX_R_377_R ;
    ResponseViaActivity(R_259_RESP_B);
];
Array TX_R_378 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_378_R;
[ TX_R_378_R ;
    ResponseViaActivity(R_260_RESP_A);
];
Array TX_R_379 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_379_R;
[ TX_R_379_R ;
    ResponseViaActivity(R_261_RESP_A);
];
Array TX_R_380 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_380_R;
[ TX_R_380_R ;
    ResponseViaActivity(R_261_RESP_B);
];
Array TX_R_381 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_381_R;
[ TX_R_381_R ;
    ResponseViaActivity(R_262_RESP_A);
];
Array TX_R_382 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_382_R;
[ TX_R_382_R ;
    ResponseViaActivity(R_263_RESP_A);
];
Array TX_R_383 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_383_R;
[ TX_R_383_R ;
    ResponseViaActivity(R_264_RESP_A);
];
Array TX_R_384 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_384_R;
[ TX_R_384_R ;
    ResponseViaActivity(R_265_RESP_A);
];
Array TX_R_385 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_385_R;
[ TX_R_385_R ;
    ResponseViaActivity(R_266_RESP_A);
];
Array TX_R_386 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_386_R;
[ TX_R_386_R ;
    ResponseViaActivity(R_267_RESP_A);
];
Array TX_R_387 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_387_R;
[ TX_R_387_R ;
    ResponseViaActivity(R_267_RESP_B);
];
Array TX_R_388 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_388_R;
[ TX_R_388_R ;
    ResponseViaActivity(R_268_RESP_A);
];
Array TX_R_389 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_389_R;
[ TX_R_389_R ;
    ResponseViaActivity(R_269_RESP_A);
];
Array TX_R_390 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_390_R;
[ TX_R_390_R ;
    ResponseViaActivity(R_269_RESP_B);
];
Array TX_R_391 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_391_R;
[ TX_R_391_R ;
    ResponseViaActivity(R_270_RESP_A);
];
Array TX_R_392 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_392_R;
[ TX_R_392_R ;
    ResponseViaActivity(R_271_RESP_A);
];
Array TX_R_393 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_393_R;
[ TX_R_393_R ;
    ResponseViaActivity(R_272_RESP_A);
];
Array TX_R_394 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_394_R;
[ TX_R_394_R ;
    ResponseViaActivity(R_283_RESP_A);
];
Array TX_R_395 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_395_R;
[ TX_R_395_R ;
    ResponseViaActivity(R_287_RESP_A);
];
Array TX_R_396 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_396_R;
[ TX_R_396_R ;
    ResponseViaActivity(R_289_RESP_A);
];
Array TX_R_397 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_397_R;
[ TX_R_397_R ;
    ResponseViaActivity(R_312_RESP_A);
];
Array TX_R_398 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_398_R;
[ TX_R_398_R ;
    ResponseViaActivity(R_167_RESP_A);
];
Array TX_R_399 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_399_R;
[ TX_R_399_R ;
    ResponseViaActivity(R_172_RESP_A);
];
Array TX_R_400 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_400_R;
[ TX_R_400_R ;
    ResponseViaActivity(R_303_RESP_A);
];
Array TX_R_401 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_401_R;
[ TX_R_401_R ;
    ResponseViaActivity(R_304_RESP_A);
];
[ R_TX_S_132 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[pause_clear] It's time to choose what sex you were born as.  You'll be lucky to stay this the course of the game, and even luckier to end it as human.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_928_r9 ());ParaContent(); print " It's time to choose what sex you were born as.  You'll be lucky to stay this the course of the game, and even luckier to end it as human."; .L_Say869; .L_SayX867;
    rtrue;
];
[ R_TX_S_133 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~The apparent Coven definitely seems lived in, as the torches on the walls are lit, and everything seems relatively clean.  'Our Mother Schera, blessed mother of our Coven' is etched above a large statue dominating the opposite wall.  The statue is of a elephant, this... covens apparent favorite animal.[bold type]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "The apparent Coven definitely seems lived in, as the torches on the walls are lit, and everything seems relatively clean.  ~Our Mother Schera, blessed mother of our Coven~ is etched above a large statue dominating the opposite wall.  The statue is of a elephant, this... covens apparent favorite animal.";ParaContent(); style bold; .L_Say870; .L_SayX868;
    rtrue;
];
[ R_TX_S_134 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~A scribbled note titled [italic type]How to Resist the Elephant[roman type], by Underwitch Kristen.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "A scribbled note titled ";ParaContent(); style underline;ParaContent(); print "How to Resist the Elephant";ParaContent(); style roman;ParaContent(); print ", by Underwitch Kristen."; .L_Say871; .L_SayX869;
    rtrue;
];
[ R_TX_S_135 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[italic type]You must resist the elephant.  I used to love him with all my heart, then I saw my sisters make him come alive.  They fell under his lust spell and he fucked them into his mindless elephant mates one by one.  The longer you are here the worse, just get what you need and leaveFor your own sake,Underwitch Kristen[roman type]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); style underline;ParaContent(); print "You must resist the elephant.  I used to love him with all my heart, then I saw my sisters make him come alive.  They fell under his lust spell and he fucked them into his mindless elephant mates one by one.  The longer you are here the worse, just get what you need and leave^^For your own sake,^^Underwitch Kristen";ParaContent(); style roman; .L_Say872; .L_SayX870;
    rtrue;
];
[ R_TX_S_136 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~A hole in the wall leads to a bright, candlelit room full of books and other archaic ornaments.  A massive statue of a bull sits in the middle of the room, his face one of stoic anger, despite the apparent ministrations of the groveling stone women below him.  One of the statue women is apparently pleasuring the bull too.  The witches must really like their animals.  Looking around some more you can see a important book that stands out as it sits on a stand, a cell phone that looks like your girlfriends, and stairs to a loft above.[bold type]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "A hole in the wall leads to a bright, candlelit room full of books and other archaic ornaments.  A massive statue of a bull sits in the middle of the room, his face one of stoic anger, despite the apparent ministrations of the groveling stone women below him.  One of the statue women is apparently pleasuring the bull too.  The witches must really like their animals.  Looking around some more you can see a important book that stands out as it sits on a stand, a cell phone that looks like your girlfriends, and stairs to a loft above.";ParaContent(); style bold; .L_Say873; .L_SayX871;
    rtrue;
];
[ R_TX_S_137 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~The foreboding darkness of the city park looms here, swallowing up any that dare go inside.  Something seems off about it tonight, and not in a good way.[bold type]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "The foreboding darkness of the city park looms here, swallowing up any that dare go inside.  Something seems off about it tonight, and not in a good way.";ParaContent(); style bold; .L_Say874; .L_SayX872;
    rtrue;
];
[ R_TX_S_138 
    tmp_0 ! Let/loop value, e.g., '?-1,-1?'(deallocated by end of phrase)
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The Witch] is wearing [a list of things worn by the Witch][if the Witch carries something] and carrying [a list of things carried by the Witch][end if].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) I157_witch;ParaContent(); print " is wearing ";ParaContent(); objectloop(tmp_0 ofclass Object)
    			if (((tmp_0 ofclass K2_thing) && (I157_witch == WearerOf(tmp_0))))
    				give tmp_0 workflag2;
    			else
    				give tmp_0 ~workflag2;
    		WriteListOfMarkedObjects(ENGLISH_BIT);
    	if (~~(((((Prop_48())))))) jump L_Say875;ParaContent(); print " and carrying ";ParaContent(); objectloop(tmp_0 ofclass Object)
    			if (((tmp_0 ofclass K2_thing) && (I157_witch == CarrierOf(tmp_0))))
    				give tmp_0 workflag2;
    			else
    				give tmp_0 ~workflag2;
    		WriteListOfMarkedObjects(ENGLISH_BIT);
    	.L_Say875; .L_SayX873;ParaContent(); print "."; .L_Say876; .L_SayX874;
    rtrue;
];
[ R_TX_S_139 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[bold type]A beautiful woman clad in dark stands before you.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); style bold;ParaContent(); print "A beautiful woman clad in dark stands before you."; .L_Say877; .L_SayX875;
    rtrue;
];
[ R_TX_S_140 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~The foreboding darkness of the city park looms here, swallowing up any that dare go inside.  Something seems off about it tonight, and not in a good way.[bold type]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "The foreboding darkness of the city park looms here, swallowing up any that dare go inside.  Something seems off about it tonight, and not in a good way.";ParaContent(); style bold; .L_Say878; .L_SayX876;
    rtrue;
];
[ R_TX_S_141 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~The junkyard seems empty other then sound of the wind blowing.  This shit hole seems like it would be the favorite spot of anything porcine, considering its atrocious smell and amount of mud.. Maybe it's best to watch where you step.[bold type]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "The junkyard seems empty other then sound of the wind blowing.  This shit hole seems like it would be the favorite spot of anything porcine, considering its atrocious smell and amount of mud.. Maybe it's best to watch where you step.";ParaContent(); style bold; .L_Say879; .L_SayX877;
    rtrue;
];
[ R_TX_S_142 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Something must be up.. people are acting weirder then they usually do in the train station.  A man is crying over on the far end of the station, and a young couple hurry down the steps that you just walked up, a look of fear plastered on both their faces.[bold type]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Something must be up.. people are acting weirder then they usually do in the train station.  A man is crying over on the far end of the station, and a young couple hurry down the steps that you just walked up, a look of fear plastered on both their faces.";ParaContent(); style bold; .L_Say880; .L_SayX878;
    rtrue;
];
[ R_TX_S_143 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~The crumbling building labeled 'Lackluster Apartments' is only really used by the assorted methheads living in the area, and as a quick, albeit dangerous, shortcut between the back gate of the nearby Research building and the city park.[bold type]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "The crumbling building labeled ~Lackluster Apartments~ is only really used by the assorted methheads living in the area, and as a quick, albeit dangerous, shortcut between the back gate of the nearby Research building and the city park.";ParaContent(); style bold; .L_Say881; .L_SayX879;
    rtrue;
];
[ R_TX_S_144 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~The inner quarters of the firm may be locked, but the same old passable fences are there.  The high end company tried to repair the cut holes and kicked in chains the first few months... but the companies decision to build their structure right in the middle of one of the primary paths through the city was a dumb idea.  People may work there during the day... but it was the path it provided at night that made it popular.[bold type]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "The inner quarters of the firm may be locked, but the same old passable fences are there.  The high end company tried to repair the cut holes and kicked in chains the first few months... but the companies decision to build their structure right in the middle of one of the primary paths through the city was a dumb idea.  People may work there during the day... but it was the path it provided at night that made it popular.";ParaContent(); style bold; .L_Say882; .L_SayX880;
    rtrue;
];
[ R_TX_S_145 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Pretty much just a paved path in the City Park, it seems the construction crew must've just given up and stopped here when making the surrounding area.  Of course... the area all around this kind of serves as proof of the supposed construction crews work ethic.. but who's complaining?[bold type]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Pretty much just a paved path in the City Park, it seems the construction crew must've just given up and stopped here when making the surrounding area.  Of course... the area all around this kind of serves as proof of the supposed construction crews work ethic.. but who's complaining?";ParaContent(); style bold; .L_Say883; .L_SayX881;
    rtrue;
];
[ R_TX_S_146 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~A dark trail, almost completely hidden, spirals in between the overgrowth, your ability to see where it ends being cut short by every bend in its winding path.[bold type]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "A dark trail, almost completely hidden, spirals in between the overgrowth, your ability to see where it ends being cut short by every bend in its winding path.";ParaContent(); style bold; .L_Say884; .L_SayX882;
    rtrue;
];
[ R_TX_S_147 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~The brush ends, coming to a gaping hole in a wall of rock.  Some sort of cave it seems, the wind whistling through it... no, not whistling, more whispering.  Creepy.[bold type]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "The brush ends, coming to a gaping hole in a wall of rock.  Some sort of cave it seems, the wind whistling through it... no, not whistling, more whispering.  Creepy.";ParaContent(); style bold; .L_Say885; .L_SayX883;
    rtrue;
];
[ R_TX_S_148 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~The Haverton Bridge juts off at an awkward angle, the addition of the uptown district obvious as a later one.  You can see a few people walking across it, drunk as shit.  The uptown district is known for one thing... its bars.  Well, two things.  The second is it's population.  All douchebags with orange spray tans, and hot chicks with a stick up their ass.[bold type]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "The Haverton Bridge juts off at an awkward angle, the addition of the uptown district obvious as a later one.  You can see a few people walking across it, drunk as shit.  The uptown district is known for one thing... its bars.  Well, two things.  The second is it's population.  All douchebags with orange spray tans, and hot chicks with a stick up their ass.";ParaContent(); style bold; .L_Say886; .L_SayX884;
    rtrue;
];
[ R_TX_S_149 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Kelmers Road used to be a big ass highway that went through the unfounded city you are in now. But times have passed, and now it serves as the entrance to the business part of the city, aptly named the Business District.  Nothing but boring suits and productivity over there though.. and you Monday through Friday.  Because believe it or not, you have a job like everyone else.[bold type]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Kelmers Road used to be a big ass highway that went through the unfounded city you are in now. But times have passed, and now it serves as the entrance to the business part of the city, aptly named the Business District.  Nothing but boring suits and productivity over there though.. and you Monday through Friday.  Because believe it or not, you have a job like everyone else.";ParaContent(); style bold; .L_Say887; .L_SayX885;
    rtrue;
];
[ R_TX_S_150 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Quite a crossroads, Commercial Intersection is busy despite... current events.  A group of young women, obviously oblivious to everything but themselves, are striding towards the mall, probably intent on selling their parents money.  A massive parking lot of cars rides along the road, backup for the underground parking garage at the mall.  A group of people putting on a play are running about in scripted motion a little farther down from the young women, and a crowd of people are watching next to it.  Though a large amount of them seem to be paying attention to something happening right next to them.  You can't see what though.[bold type]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Quite a crossroads, Commercial Intersection is busy despite... current events.  A group of young women, obviously oblivious to everything but themselves, are striding towards the mall, probably intent on selling their parents money.  A massive parking lot of cars rides along the road, backup for the underground parking garage at the mall.  A group of people putting on a play are running about in scripted motion a little farther down from the young women, and a crowd of people are watching next to it.  Though a large amount of them seem to be paying attention to something happening right next to them.  You can't see what though.";ParaContent(); style bold; .L_Say888; .L_SayX886;
    rtrue;
];
[ R_TX_S_151 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Hermes Station may be only one stop down from Atkins, but serves as the final stop before the train heads to your neighboring city, Celen.  Thinking on the days events, you wonder if you can go and restart your life there once it's all over.  Kind of like a sequel to this prequel, you think, laughing. Like if a writer was determining your life, his next novel would be your adventures there.  Hmm, thats crazy talk!.[bold type]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Hermes Station may be only one stop down from Atkins, but serves as the final stop before the train heads to your neighboring city, Celen.  Thinking on the days events, you wonder if you can go and restart your life there once it's all over.  Kind of like a sequel to this prequel, you think, laughing. Like if a writer was determining your life, his next novel would be your adventures there.  Hmm, thats crazy talk!.";ParaContent(); style bold; .L_Say889; .L_SayX887;
    rtrue;
];
[ R_TX_S_152 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[italic type]'Change is the root of all creation'[roman type]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); style underline;ParaContent(); print "~Change is the root of all creation~";ParaContent(); style roman; .L_Say890; .L_SayX888;
    rtrue;
];
[ R_TX_S_153 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~The Mall Entrance is a mostly fountain, with spiraling and shooting archs of water all over, an impressive sign over them stating its the entrance to St Peters Mall.  It certainly stands out.[bold type]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "The Mall Entrance is a mostly fountain, with spiraling and shooting archs of water all over, an impressive sign over them stating its the entrance to St Peters Mall.  It certainly stands out.";ParaContent(); style bold; .L_Say891; .L_SayX889;
    rtrue;
];
[ R_TX_S_154 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~All around you the mall bustles with people.  A certain uneasiness is in the air though, something isn't right.   You may want to check that out... or you could go to the food court and chow down on some delicious fast food.  Or, if you want to go shopping, there's assorted outlets throughout the store.[bold type]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "All around you the mall bustles with people.  A certain uneasiness is in the air though, something isn't right.   You may want to check that out... or you could go to the food court and chow down on some delicious fast food.  Or, if you want to go shopping, there's assorted outlets throughout the store.";ParaContent(); style bold; .L_Say892; .L_SayX890;
    rtrue;
];
[ R_TX_S_155 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~TV4U, the discount TV store in the mall, is showing the news coverage of some sort of downtown disaster. A terrified but dedicated newswoman appears to be on the disaster scene, giving viewers the scoop on what is happening.  The store is nearly empty because everyone, including the store employees, are outside it watching the news coverage.[bold type]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "TV4U, the discount TV store in the mall, is showing the news coverage of some sort of downtown disaster. A terrified but dedicated newswoman appears to be on the disaster scene, giving viewers the scoop on what is happening.  The store is nearly empty because everyone, including the store employees, are outside it watching the news coverage.";ParaContent(); style bold; .L_Say893; .L_SayX891;
    rtrue;
];
[ R_TX_S_156 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Ahhh the food court.  That runs through your head every damn time you've been here.  Good memories of hanging out when you were in high school, chowing down on food that would surely make you feel sick later that night and hanging with friends.  It's still rather popular, and everyone in there seems preoccupied with their own stuffing of faces.[bold type]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Ahhh the food court.  That runs through your head every damn time you've been here.  Good memories of hanging out when you were in high school, chowing down on food that would surely make you feel sick later that night and hanging with friends.  It's still rather popular, and everyone in there seems preoccupied with their own stuffing of faces.";ParaContent(); style bold; .L_Say894; .L_SayX892;
    rtrue;
];
[ R_TX_S_157 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Hotspot is a cool... well more gimicky 'hangout' spot in the mall.  And what do ya know, it's freakin empty.  The people that bought the awesome lazertag place that was there before are monsters.  And they couldn't even make their store work.[bold type]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Hotspot is a cool... well more gimicky ~hangout~ spot in the mall.  And what do ya know, it's freakin empty.  The people that bought the awesome lazertag place that was there before are monsters.  And they couldn't even make their store work.";ParaContent(); style bold; .L_Say895; .L_SayX893;
    rtrue;
];
[ R_TX_S_158 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~The nice sit down restaurant of the mall, Birds is a place you reallllly can't afford.  It's pretty high class 'rainforest' style food.  Whatever that means.  The doors are wide open but the usual seating attendant is no where to be found, huh. In fact it looks like it was practically ransacked, the tables inside pushed over or on top of eachother and more.  Then you notice the sign saying it closed down yesterday. Well, maybe the fast food places in the nearby food court have finally won the battle for the mall.[bold type]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "The nice sit down restaurant of the mall, Birds is a place you reallllly can't afford.  It's pretty high class ~rainforest~ style food.  Whatever that means.  The doors are wide open but the usual seating attendant is no where to be found, huh. In fact it looks like it was practically ransacked, the tables inside pushed over or on top of eachother and more.  Then you notice the sign saying it closed down yesterday. Well, maybe the fast food places in the nearby food court have finally won the battle for the mall.";ParaContent(); style bold; .L_Say896; .L_SayX894;
    rtrue;
];
[ R_TX_S_159 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Venus Hall is the second long hallway of the mall.  Looking down it you can see Statuesque, the cool modern statue and art store to the west.  You can also see a new store, Gellin Like A Vellin to the north and DPC, a clothing outlet to the south.[bold type]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Venus Hall is the second long hallway of the mall.  Looking down it you can see Statuesque, the cool modern statue and art store to the west.  You can also see a new store, Gellin Like A Vellin to the north and DPC, a clothing outlet to the south.";ParaContent(); style bold; .L_Say897; .L_SayX895;
    rtrue;
];
[ R_TX_S_160 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~The industrial quarter of the city is sprawled in front of you, the hundreds of shipping containers weaving around the massive warehouses here.  Most of them connect to the ocean, allowing enormous ships to dock and load up on supplies before heading out into the dark ocean.  Just like the park, it's silent and empty.  There's a few workers that must be here, though, as lights are on in several warehouses and hushed voices can be heard.[bold type]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "The industrial quarter of the city is sprawled in front of you, the hundreds of shipping containers weaving around the massive warehouses here.  Most of them connect to the ocean, allowing enormous ships to dock and load up on supplies before heading out into the dark ocean.  Just like the park, it's silent and empty.  There's a few workers that must be here, though, as lights are on in several warehouses and hushed voices can be heard.";ParaContent(); style bold; .L_Say898; .L_SayX896;
    rtrue;
];
[ R_TX_S_161 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Spiraling to the west is a lone path, which begins at a knocked down chain fence and rides the hills along the northern part of the Warehouse Row.  It's path can be somewhat treacherous, as the land changes from concrete structures to mountainous cliffsides.  Who knows where a path like that will lead...[bold type]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Spiraling to the west is a lone path, which begins at a knocked down chain fence and rides the hills along the northern part of the Warehouse Row.  It's path can be somewhat treacherous, as the land changes from concrete structures to mountainous cliffsides.  Who knows where a path like that will lead...";ParaContent(); style bold; .L_Say899; .L_SayX897;
    rtrue;
];
[ R_TX_S_162 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~A dank shed sits on the edge of the city, a place you regret ending up at.  Looking into the darkness, you begin to make out a table with a ornate chair behind it, a confident looking woman sitting in it.  She's mocking something... something in a cage?  Another woman, dressed in normal clothing, is in the cage pleading and crying.[bold type]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "A dank shed sits on the edge of the city, a place you regret ending up at.  Looking into the darkness, you begin to make out a table with a ornate chair behind it, a confident looking woman sitting in it.  She's mocking something... something in a cage?  Another woman, dressed in normal clothing, is in the cage pleading and crying.";ParaContent(); style bold; .L_Say900; .L_SayX898;
    rtrue;
];
[ R_TX_S_163 
    tmp_0 ! Let/loop value, e.g., '?-1,-1?'(deallocated by end of phrase)
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Obviously a witch, her robe is decorated with a little pin of a horses head.  Her wand is more of a riding crop, and explains the red lines across the caged womans legs. [Equestrian Mistress] is wearing [a list of things worn by Equestrian Mistress][if Equestrian Mistress carries something] and carrying [a list of things carried by Equestrian Mistress][end if].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Obviously a witch, her robe is decorated with a little pin of a horses head.  Her wand is more of a riding crop, and explains the red lines across the caged womans legs. ";ParaContent(); print (PrintShortName) I270_equestrian_mistress;ParaContent(); print " is wearing ";ParaContent(); objectloop(tmp_0 ofclass Object)
    			if (((tmp_0 ofclass K2_thing) && (I270_equestrian_mistress == WearerOf(tmp_0))))
    				give tmp_0 workflag2;
    			else
    				give tmp_0 ~workflag2;
    		WriteListOfMarkedObjects(ENGLISH_BIT);
    	if (~~(((((Prop_49())))))) jump L_Say901;ParaContent(); print " and carrying ";ParaContent(); objectloop(tmp_0 ofclass Object)
    			if (((tmp_0 ofclass K2_thing) && (I270_equestrian_mistress == CarrierOf(tmp_0))))
    				give tmp_0 workflag2;
    			else
    				give tmp_0 ~workflag2;
    		WriteListOfMarkedObjects(ENGLISH_BIT);
    	.L_Say901; .L_SayX899;ParaContent(); print "."; .L_Say902; .L_SayX900;
    rtrue;
];
[ R_TX_S_164 
    tmp_0 ! Let/loop value, e.g., '?-1,-1?'(deallocated by end of phrase)
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Her short skirt with tight sweater seems a bit of a oxymoron, but that's hardly the matter.  Her beautiful green eyes peer out in desperation from beneath her dark hair.  Her legs have what appear to be minor whip marks all over them.  She can't get out of the cage, but it doesn't look like shes been there long, as shes healthy and has the stamp of a nightclub on her wrist. [Becky] is wearing [a list of things worn by Becky][if Becky carries something] and carrying [a list of things carried by Becky][end if].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Her short skirt with tight sweater seems a bit of a oxymoron, but that's hardly the matter.  Her beautiful green eyes peer out in desperation from beneath her dark hair.  Her legs have what appear to be minor whip marks all over them.  She can't get out of the cage, but it doesn't look like shes been there long, as shes healthy and has the stamp of a nightclub on her wrist. ";ParaContent(); print (PrintShortName) I271_becky;ParaContent(); print " is wearing ";ParaContent(); objectloop(tmp_0 ofclass Object)
    			if (((tmp_0 ofclass K2_thing) && (I271_becky == WearerOf(tmp_0))))
    				give tmp_0 workflag2;
    			else
    				give tmp_0 ~workflag2;
    		WriteListOfMarkedObjects(ENGLISH_BIT);
    	if (~~(((((Prop_50())))))) jump L_Say903;ParaContent(); print " and carrying ";ParaContent(); objectloop(tmp_0 ofclass Object)
    			if (((tmp_0 ofclass K2_thing) && (I271_becky == CarrierOf(tmp_0))))
    				give tmp_0 workflag2;
    			else
    				give tmp_0 ~workflag2;
    		WriteListOfMarkedObjects(ENGLISH_BIT);
    	.L_Say903; .L_SayX901;ParaContent(); print "."; .L_Say904; .L_SayX902;
    rtrue;
];
[ R_TX_S_165 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~As you walk into the first warehouse of warehouse row, the sound of barking greets you.  Cages are everywhere, lining every wall with thousands of dogs in them. Looking closer it seems like they are pleading for help, most of them sitting there purposely trying to meet your gaze.[bold type]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "As you walk into the first warehouse of warehouse row, the sound of barking greets you.  Cages are everywhere, lining every wall with thousands of dogs in them. Looking closer it seems like they are pleading for help, most of them sitting there purposely trying to meet your gaze.";ParaContent(); style bold; .L_Say905; .L_SayX903;
    rtrue;
];
[ R_TX_S_166 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Tinman... well that's a creepy name.  You stare up at the enormous foreboding letters on the outside of the warehouse, your mind creating all sorts of terrifying witchrelated acts that can happen to you the second you step in that warehouse.  Jeez, you already spooked yourself.[bold type]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Tinman... well that's a creepy name.  You stare up at the enormous foreboding letters on the outside of the warehouse, your mind creating all sorts of terrifying witchrelated acts that can happen to you the second you step in that warehouse.  Jeez, you already spooked yourself.";ParaContent(); style bold; .L_Say906; .L_SayX904;
    rtrue;
];
[ R_TX_S_167 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~A cold, brisk wind whistles past as you walk across the divider to the most recent addition to the warehouse district.  I mean, it was 20 years ago they added this, but still the most recent.  And ever so rusty.. damn this place is old.[bold type]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "A cold, brisk wind whistles past as you walk across the divider to the most recent addition to the warehouse district.  I mean, it was 20 years ago they added this, but still the most recent.  And ever so rusty.. damn this place is old.";ParaContent(); style bold; .L_Say907; .L_SayX905;
    rtrue;
];
[ R_TX_S_168 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Tinman isn't as terrifying as your thought it was going to be.  In fact, its one of the only places around here that seem normal.  Arthur Tinmans picture is on the wall, and he looks like a hard working, good hearted boss.  Wow, everything turned out alright in here.  Maybe you can use this place as a place to rest safely from the apparent hostile witch takeover that's happening.[bold type]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Tinman isn't as terrifying as your thought it was going to be.  In fact, its one of the only places around here that seem normal.  Arthur Tinmans picture is on the wall, and he looks like a hard working, good hearted boss.  Wow, everything turned out alright in here.  Maybe you can use this place as a place to rest safely from the apparent hostile witch takeover that's happening.";ParaContent(); style bold; .L_Say908; .L_SayX906;
    rtrue;
];
[ R_TX_S_169 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~A portal... or what you can only assume is a portal, as youre kinda new to this whole magic thing.. sits in the middle of the darkened culdesac.  Through the small localized black hole of terrifyingness, you can begin to make out some structures on the other side.  It seems like a bright and happy day there, in some sort of junglelike, perhaps savannahlike, environment.  Looking closer you can see people, dozens of them, standing on the other side of a cage.  Jeez.. what are these witches up to?[bold type]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "A portal... or what you can only assume is a portal, as youre kinda new to this whole magic thing.. sits in the middle of the darkened culdesac.  Through the small localized black hole of terrifyingness, you can begin to make out some structures on the other side.  It seems like a bright and happy day there, in some sort of junglelike, perhaps savannahlike, environment.  Looking closer you can see people, dozens of them, standing on the other side of a cage.  Jeez.. what are these witches up to?";ParaContent(); style bold; .L_Say909; .L_SayX907;
    rtrue;
];
[ R_TX_S_170 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~The second part of the warehouse district starts here, everything looking slightly newer and less worn by the ocean water and winds.  A security checkpoint looms ahead with a sleeping guard in it, and several newer companies have their warehouses up ahead.  Ooo the sense of exploration, isnt it fantastic?[bold type]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "The second part of the warehouse district starts here, everything looking slightly newer and less worn by the ocean water and winds.  A security checkpoint looms ahead with a sleeping guard in it, and several newer companies have their warehouses up ahead.  Ooo the sense of exploration, isnt it fantastic?";ParaContent(); style bold; .L_Say910; .L_SayX908;
    rtrue;
];
[ R_TX_S_171 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~ Looking down the unused dock, you can see two women conversing in the water.. weird.  Past that is the massive expanse of the ocean, its dark depths striking fear and excitement into your heart.  Okay, you can hardly look at that terrifying amount of water wtihout being scared, how the hell are those women fine sitting in it?[bold type]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print " Looking down the unused dock, you can see two women conversing in the water.. weird.  Past that is the massive expanse of the ocean, its dark depths striking fear and excitement into your heart.  Okay, you can hardly look at that terrifying amount of water wtihout being scared, how the hell are those women fine sitting in it?";ParaContent(); style bold; .L_Say911; .L_SayX909;
    rtrue;
];
[ R_TX_S_172 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~The sleeping guard is snoring about as loud as a human can.  You can see a button panel in front of him, as well as a mug of coffee and a porno mag laying on the desk  The rusty metal structure of the security checkpoint is pretty compact, and it looks like the door doesnt even close, so you could sneak in easy.  Of course, the guard appears to have a taser on his utility belt so be careful.[bold type]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "The sleeping guard is snoring about as loud as a human can.  You can see a button panel in front of him, as well as a mug of coffee and a porno mag laying on the desk  The rusty metal structure of the security checkpoint is pretty compact, and it looks like the door doesnt even close, so you could sneak in easy.  Of course, the guard appears to have a taser on his utility belt so be careful.";ParaContent(); style bold; .L_Say912; .L_SayX910;
    rtrue;
];
[ R_TX_S_173 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~What you see when you walk into Farm Co makes your jaw drop.  'CHRISTINE!' you yell as you run to your girlfriend, her naked body chained there in the middle of the room.  Shes knocked out cold, but breathing.  What the hell is she doing here?  Looking around you can see several doors to the offices of the warehouse, another door outside and the walls.. which are covered with devices made of hoses.  You have no clue what those are for but you really dont want to find out.  Maybe looking around for some more info on Farm Co will help you out, or at least find the key to save your girlfriend.[bold type]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "What you see when you walk into Farm Co makes your jaw drop.  ~CHRISTINE!~ you yell as you run to your girlfriend, her naked body chained there in the middle of the room.  Shes knocked out cold, but breathing.  What the hell is she doing here?  Looking around you can see several doors to the offices of the warehouse, another door outside and the walls.. which are covered with devices made of hoses.  You have no clue what those are for but you really dont want to find out.  Maybe looking around for some more info on Farm Co will help you out, or at least find the key to save your girlfriend.";ParaContent(); style bold; .L_Say913; .L_SayX911;
    rtrue;
];
[ R_TX_S_174 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~The night is quiet and restless, and the crashing waves don't help your already strong feeling of uneasiness.  The slanted slope of the ramp leads down to a dangerous current, so you cant go any farther this way.[bold type]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "The night is quiet and restless, and the crashing waves don't help your already strong feeling of uneasiness.  The slanted slope of the ramp leads down to a dangerous current, so you cant go any farther this way.";ParaContent(); style bold; .L_Say914; .L_SayX912;
    rtrue;
];
[ R_TX_S_175 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~The hidden door behind the bull opens to the lavish chamber of the Headmistress, which is mostly a bed with pillows and the softest silk covering it.  A table nearby has a horn sitting on it, as well as a note and another one of the wands youve seen around.[bold type]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "The hidden door behind the bull opens to the lavish chamber of the Headmistress, which is mostly a bed with pillows and the softest silk covering it.  A table nearby has a horn sitting on it, as well as a note and another one of the wands youve seen around.";ParaContent(); style bold; .L_Say915; .L_SayX913;
    rtrue;
];
[ R_TX_S_176 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~The primary intersection on Main Street sits right across the Kelmers bridge.  It's about halfway up the giant hill that the Business District is located on, so you can see substantially far south.[bold type]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "The primary intersection on Main Street sits right across the Kelmers bridge.  It's about halfway up the giant hill that the Business District is located on, so you can see substantially far south.";ParaContent(); style bold; .L_Say916; .L_SayX914;
    rtrue;
];
[ R_TX_S_177 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~A little bit below the halfway mark of the large hill the Business District is on is another large intersection that breaks off to the winding roads through various businesses.  The skyscrapers tower above you, impervious to the incline it seems. Who knows how many people work in each one.[bold type]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "A little bit below the halfway mark of the large hill the Business District is on is another large intersection that breaks off to the winding roads through various businesses.  The skyscrapers tower above you, impervious to the incline it seems. Who knows how many people work in each one.";ParaContent(); style bold; .L_Say917; .L_SayX915;
    rtrue;
];
[ R_TX_S_178 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~A little farther up the hill, Haven Street begins to zig zag in a tiered spiraling road lined with beautiful trees and few gardens.  This is one of the nicer areas of the district and fairly new.  Though it looks like a large restaurant called The Pigsty Bar N Grill has set up shop on the bottom floor of a nearby building, so the intersection and road are kind of dominated by the greasy bar.[bold type]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "A little farther up the hill, Haven Street begins to zig zag in a tiered spiraling road lined with beautiful trees and few gardens.  This is one of the nicer areas of the district and fairly new.  Though it looks like a large restaurant called The Pigsty Bar N Grill has set up shop on the bottom floor of a nearby building, so the intersection and road are kind of dominated by the greasy bar.";ParaContent(); style bold; .L_Say918; .L_SayX916;
    rtrue;
];
[ R_TX_S_179 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~A small side road leads to the second biggest street in the District, Haven.  It's a bit newer then Main Street so the businesses are a bit higher tech, but its deep within the cluster of skyscrapers and usually shady and therefore a bit more foreboding.[bold type]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "A small side road leads to the second biggest street in the District, Haven.  It's a bit newer then Main Street so the businesses are a bit higher tech, but its deep within the cluster of skyscrapers and usually shady and therefore a bit more foreboding.";ParaContent(); style bold; .L_Say919; .L_SayX917;
    rtrue;
];
[ R_TX_S_180 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~One of the southernmost intersections in the business District, 130 Main Street is in one of the older parts of the Business District, so a few more potholes and crumbling concrete are present.  But it's still busy as hell, and looking up the hill it may have one of the coolest views of the city.[bold type]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "One of the southernmost intersections in the business District, 130 Main Street is in one of the older parts of the Business District, so a few more potholes and crumbling concrete are present.  But it's still busy as hell, and looking up the hill it may have one of the coolest views of the city.";ParaContent(); style bold; .L_Say920; .L_SayX918;
    rtrue;
];
[ R_TX_S_181 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Import Inc, a pawn shop thats always been a mysterious shop shrouded by myths, sits here.  It's closed and decrepit.  The door is just propped up to prevent wild animals from getting in, and dust and dirt cover every inch of its dark recesses.  You never believed those myths your childhood friends used to say though... nows your chance to prove them wrong.  You can finally get behind the back counter and see what all the fuss was about.[bold type]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Import Inc, a pawn shop thats always been a mysterious shop shrouded by myths, sits here.  It's closed and decrepit.  The door is just propped up to prevent wild animals from getting in, and dust and dirt cover every inch of its dark recesses.  You never believed those myths your childhood friends used to say though... nows your chance to prove them wrong.  You can finally get behind the back counter and see what all the fuss was about.";ParaContent(); style bold; .L_Say921; .L_SayX919;
    rtrue;
];
[ R_TX_S_182 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~The back room of Import has walls lined with exotic goodies.  All seem to be very expensive though, so maybe you should watch yourself.  You cant afford to pay for the ticket if youre caught, let alone one of these priceless artifacts.[bold type]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "The back room of Import has walls lined with exotic goodies.  All seem to be very expensive though, so maybe you should watch yourself.  You cant afford to pay for the ticket if youre caught, let alone one of these priceless artifacts.";ParaContent(); style bold; .L_Say922; .L_SayX920;
    rtrue;
];
[ R_TX_S_183 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[roman type]You can see countless artifacts in no particular order.  Maybe a Wand is on there? Maybe you should [italic type]examine[roman type] it?~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); style roman;ParaContent(); print "You can see countless artifacts in no particular order.  Maybe a Wand is on there? Maybe you should ";ParaContent(); style underline;ParaContent(); print "examine";ParaContent(); style roman;ParaContent(); print " it?"; .L_Say923; .L_SayX921;
    rtrue;
];
[ R_TX_S_184 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Alright, this is where the weird signal was coming from, maybe it's best to ask around.  The sound of laughter and clinking glasses meets you as you enter.  A bar with a... large breasted woman is on the side of the apartment, with a stage in the middle surrounded by all the tables.  You notice all the employees are rather large breasted women, wait a second... this is just a Hooters![bold type]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Alright, this is where the weird signal was coming from, maybe it's best to ask around.  The sound of laughter and clinking glasses meets you as you enter.  A bar with a... large breasted woman is on the side of the apartment, with a stage in the middle surrounded by all the tables.  You notice all the employees are rather large breasted women, wait a second... this is just a Hooters!";ParaContent(); style bold; .L_Say924; .L_SayX922;
    rtrue;
];
[ R_TX_S_185 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~It's nothing more then another dingy alley out here, with the leftover food and kegs from the Pigsty thrown on the terrible smelling trash pile nearby.  What a excellent pseudo metaphor for the city and its inhabitants.[bold type]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "It's nothing more then another dingy alley out here, with the leftover food and kegs from the Pigsty thrown on the terrible smelling trash pile nearby.  What a excellent pseudo metaphor for the city and its inhabitants.";ParaContent(); style bold; .L_Say925; .L_SayX923;
    rtrue;
];
[ R_TX_S_186 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~The alleyway comes to a T shaped end, with both sides just leading back into the maze of alleyways.  Theres a fence in front of you though, with a hole cut in it and a noticeable path leading into the woods far away.[bold type]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "The alleyway comes to a T shaped end, with both sides just leading back into the maze of alleyways.  Theres a fence in front of you though, with a hole cut in it and a noticeable path leading into the woods far away.";ParaContent(); style bold; .L_Say926; .L_SayX924;
    rtrue;
];
[ R_TX_S_187 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~The woods are tranquil and quiet, a nice break from the bustling city.  Or you guess you can say 'disastrous city' now that.. everything happened.  The deeper you go in the forest, the darker it seems to get though, so maybe you should head towards the city or somewhere else.[bold type]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "The woods are tranquil and quiet, a nice break from the bustling city.  Or you guess you can say ~disastrous city~ now that.. everything happened.  The deeper you go in the forest, the darker it seems to get though, so maybe you should head towards the city or somewhere else.";ParaContent(); style bold; .L_Say927; .L_SayX925;
    rtrue;
];
[ R_TX_S_188 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~The dark, silent woods break out to a small road on a hilly stretch of woodland.  The path continues across the road, and with how empty the road looks, the path may be more used.[bold type]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "The dark, silent woods break out to a small road on a hilly stretch of woodland.  The path continues across the road, and with how empty the road looks, the path may be more used.";ParaContent(); style bold; .L_Say928; .L_SayX926;
    rtrue;
];
[ R_TX_S_189 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~The chambers are empty other then a giant inset socket in the middle of the ground.  It looks like it can fit the box you used to capture the essences of the other covens!  Maybe if you have them all you can place it there.. that must be what the woman in the park meant when she said you could end the disaster.[bold type]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "The chambers are empty other then a giant inset socket in the middle of the ground.  It looks like it can fit the box you used to capture the essences of the other covens!  Maybe if you have them all you can place it there.. that must be what the woman in the park meant when she said you could end the disaster.";ParaContent(); style bold; .L_Say929; .L_SayX927;
    rtrue;
];
[ R_TX_S_190 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Farther north main street turns into shops and restaurants, with the larger business behind and down the hill.  You have a pretty good view from here of the city, with the City Park and Warehouse District far to the southwest.[bold type]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Farther north main street turns into shops and restaurants, with the larger business behind and down the hill.  You have a pretty good view from here of the city, with the City Park and Warehouse District far to the southwest.";ParaContent(); style bold; .L_Say930; .L_SayX928;
    rtrue;
];
[ R_TX_S_191 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~fToy  A receptionist area sits here, and you can see the top of the receptionists head behind her computer screen.  A door with a key card lock sits to the right, and the waiting room is dotted with various chairs and fake trees.[bold type]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "fToy  A receptionist area sits here, and you can see the top of the receptionists head behind her computer screen.  A door with a key card lock sits to the right, and the waiting room is dotted with various chairs and fake trees.";ParaContent(); style bold; .L_Say931; .L_SayX929;
    rtrue;
];
[ R_TX_S_192 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Ah, Sloppys.  Your favorite place as a kid.  Screw ChuckECheeses (okay sorry Chucky, you were awesome) this place was the best.  You didn't even need a play place as a kid when you had this good of food.  The best burgers and hot dogs in town, and as much as you wanted for the low price of 3 bucks.  Which kind of puts the quality into question, now that you think about it..[bold type]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Ah, Sloppys.  Your favorite place as a kid.  Screw ChuckECheeses (okay sorry Chucky, you were awesome) this place was the best.  You didn't even need a play place as a kid when you had this good of food.  The best burgers and hot dogs in town, and as much as you wanted for the low price of 3 bucks.  Which kind of puts the quality into question, now that you think about it..";ParaContent(); style bold; .L_Say932; .L_SayX930;
    rtrue;
];
[ R_TX_S_193 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~What a surprise, another disgusting alleyway.  You almost hope this witch outbreak succeeds, as it can't really get worse then this.  Maybe they'll clean up the city somewhat.  You jerk and let out a croaking cough at the smell of the nearby trashcan. Ugh, gross.[bold type]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "What a surprise, another disgusting alleyway.  You almost hope this witch outbreak succeeds, as it can't really get worse then this.  Maybe they'll clean up the city somewhat.  You jerk and let out a croaking cough at the smell of the nearby trashcan. Ugh, gross.";ParaContent(); style bold; .L_Say933; .L_SayX931;
    rtrue;
];
[ R_TX_S_194 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~One of the primary roads that wind through the hills northeast of the city, you can see it spiral off into the distance.  It sure is tempting to just run out of the city and see where the road goes.  But there seems to be some sort of blockade, certainly not a normal one too.  Soldiers and police officers are stopping people and filing them into a nearby building.  It's probably best to avoid that confrontation.[bold type]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "One of the primary roads that wind through the hills northeast of the city, you can see it spiral off into the distance.  It sure is tempting to just run out of the city and see where the road goes.  But there seems to be some sort of blockade, certainly not a normal one too.  Soldiers and police officers are stopping people and filing them into a nearby building.  It's probably best to avoid that confrontation.";ParaContent(); style bold; .L_Say934; .L_SayX932;
    rtrue;
];
[ R_TX_S_195 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~The sewers stretch out in front of the small entrance you just came through.  Maybe you can find a way out of this city, and a way past those guards, if you explore the winding tunnels of the Sewers.  Of course, it is a veritable labyrinth... so good luck.[bold type]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "The sewers stretch out in front of the small entrance you just came through.  Maybe you can find a way out of this city, and a way past those guards, if you explore the winding tunnels of the Sewers.  Of course, it is a veritable labyrinth... so good luck.";ParaContent(); style bold; .L_Say935; .L_SayX933;
    rtrue;
];
[ R_TX_S_196 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Party. Freaking. Avenue.  You remember when you were 21 and used to be here every night.  With how expensive the bars are here, thats probably why you're scrambling for money now.  Looking down the row you can see all the locales you used to consume alcohol in.  It looks like not much has changed.[bold type]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Party. Freaking. Avenue.  You remember when you were 21 and used to be here every night.  With how expensive the bars are here, thats probably why you're scrambling for money now.  Looking down the row you can see all the locales you used to consume alcohol in.  It looks like not much has changed.";ParaContent(); style bold; .L_Say936; .L_SayX934;
    rtrue;
];
[ R_TX_S_197 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Walter Havens fountains lead to a beautifully lit garden area.  Behind the trees lining the garden, you can see a door into a wall of stone.  It's unmarked, but the nearby tree has that Weird Logo you've been seeing.[bold type]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Walter Havens fountains lead to a beautifully lit garden area.  Behind the trees lining the garden, you can see a door into a wall of stone.  It's unmarked, but the nearby tree has that Weird Logo you've been seeing.";ParaContent(); style bold; .L_Say937; .L_SayX935;
    rtrue;
];
[ R_TX_S_198 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~The garden curls around into a little side road/path.  Its easy to get around Uptown with all these winding paths through gardens and other city beautification projects.  Much better then the business district, thats for sure.[bold type]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "The garden curls around into a little side road/path.  Its easy to get around Uptown with all these winding paths through gardens and other city beautification projects.  Much better then the business district, thats for sure.";ParaContent(); style bold; .L_Say938; .L_SayX936;
    rtrue;
];
[ R_TX_S_199 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Ah, the Country Club.  You certainly can't afford to go in here but you can imagine how awesome it is as you sit in the parking lot.  Maybe one day.[bold type]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Ah, the Country Club.  You certainly can't afford to go in here but you can imagine how awesome it is as you sit in the parking lot.  Maybe one day.";ParaContent(); style bold; .L_Say939; .L_SayX937;
    rtrue;
];
[ R_TX_S_200 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Upper Class Arts is this gimicky thing for rich couples to drink wine and make paintings Bob Ross style.  Of course, they're drunk and not artists so they typically turn out terrible, but they're rich, so they aren't worried about what they spend their money on.[bold type]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Upper Class Arts is this gimicky thing for rich couples to drink wine and make paintings Bob Ross style.  Of course, they're drunk and not artists so they typically turn out terrible, but they're rich, so they aren't worried about what they spend their money on.";ParaContent(); style bold; .L_Say940; .L_SayX938;
    rtrue;
];
[ R_TX_S_201 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~fZebra.[bold type]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "fZebra.";ParaContent(); style bold; .L_Say941; .L_SayX939;
    rtrue;
];
[ R_TX_S_202 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[current menu title]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (TEXT_TY_Say) (Global_Vars-->18); .L_Say942; .L_SayX940;
    rtrue;
];
[ R_TX_S_203 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[current menu title]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (TEXT_TY_Say) (Global_Vars-->18); .L_Say943; .L_SayX941;
    rtrue;
];
[ R_TX_S_204 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Q = [if menu depth > 1]Last Menu[otherwise]Quit Menu[end if]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Q = ";
    	if (~~(((((Global_Vars-->16) > 1))))) jump L_Say944;ParaContent(); print "Last Menu";
    	jump L_SayX942; .L_Say944;ParaContent(); print "Quit Menu";
    	.L_Say945; .L_SayX942; .L_Say946; .L_SayX943;
    rtrue;
];
[ R_TX_S_205 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[location]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (PrintShortName) real_location; .L_Say947; .L_SayX944;
    rtrue;
];
[ R_TX_S_206 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[score]/[turn count]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (say__n=score);ParaContent(); print "/";ParaContent(); print (say__n=turns); .L_Say948; .L_SayX945;
    rtrue;
];
[ R_TX_S_477 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[bold type]Game Over.  [italic type]'Mess With the Bull And You'll Get The Horns'  [roman type]Male Human to Bull.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); style bold;ParaContent(); print "Game Over.  ";ParaContent(); style underline;ParaContent(); print "~Mess With the Bull And You'll Get The Horns~  ";ParaContent(); style roman;ParaContent(); print "Male Human to Bull."; .L_Say949; .L_SayX946;
    rtrue;
];
Array TX_S_477 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_477;
[ R_TX_S_478 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[bold type]Game Over.  [italic type]'Good girl!'  [roman type]Male Human to Female Dog.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); style bold;ParaContent(); print "Game Over.  ";ParaContent(); style underline;ParaContent(); print "~Good girl!~  ";ParaContent(); style roman;ParaContent(); print "Male Human to Female Dog."; .L_Say950; .L_SayX947;
    rtrue;
];
Array TX_S_478 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_478;
[ R_TX_S_479 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[bold type]Game Over.  [italic type]'Joining The Herd'  [roman type]Female Human to Breeding Mare.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); style bold;ParaContent(); print "Game Over.  ";ParaContent(); style underline;ParaContent(); print "~Joining The Herd~  ";ParaContent(); style roman;ParaContent(); print "Female Human to Breeding Mare."; .L_Say951; .L_SayX948;
    rtrue;
];
Array TX_S_479 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_479;
[ R_TX_S_480 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[bold type]Game Over.  [italic type]'Ummm... Lesbian Giraffes?!'  [roman type]Male Human to Female Giraffe.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); style bold;ParaContent(); print "Game Over.  ";ParaContent(); style underline;ParaContent(); print "~Ummm... Lesbian Giraffes?!~  ";ParaContent(); style roman;ParaContent(); print "Male Human to Female Giraffe."; .L_Say952; .L_SayX949;
    rtrue;
];
Array TX_S_480 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_480;
[ R_TX_S_481 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[bold type]Game Over.  [italic type]'Dont Spit'  [roman type]Male Human to Female Camel.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); style bold;ParaContent(); print "Game Over.  ";ParaContent(); style underline;ParaContent(); print "~Dont Spit~  ";ParaContent(); style roman;ParaContent(); print "Male Human to Female Camel."; .L_Say953; .L_SayX950;
    rtrue;
];
Array TX_S_481 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_481;
[ R_TX_S_482 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~A massive amount of manure splurts out of your new fat elephant ass, your personality gone forever, wiped away completely by your new urges to mate and impregnate all the females you can find.[bold type]Game Over.  [italic type]'Size Increase'  [roman type]Male Human to Bull Elephant.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "A massive amount of manure splurts out of your new fat elephant ass, your personality gone forever, wiped away completely by your new urges to mate and impregnate all the females you can find.^^";ParaContent(); style bold;ParaContent(); print "Game Over.  ";ParaContent(); style underline;ParaContent(); print "~Size Increase~  ";ParaContent(); style roman;ParaContent(); print "Male Human to Bull Elephant."; .L_Say954; .L_SayX951;
    rtrue;
];
Array TX_S_482 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_482;
[ R_TX_S_483 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[bold type]Game Over.  [italic type]'PLBBBBBPPPP'  [roman type]Male Human to Female Frog.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); style bold;ParaContent(); print "Game Over.  ";ParaContent(); style underline;ParaContent(); print "~PLBBBBBPPPP~  ";ParaContent(); style roman;ParaContent(); print "Male Human to Female Frog."; .L_Say955; .L_SayX952;
    rtrue;
];
Array TX_S_483 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_483;
[ R_TX_S_484 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Your whinnies of resistance cease as you can feel your thoughts turn to being a good submissive mare for your stallion, so that you can experience what its like to be claimed as his mate again.[bold type]Game Over.  [italic type]'Let's Get Mare-ied!'  [roman type]Male Human to Mare.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Your whinnies of resistance cease as you can feel your thoughts turn to being a good submissive mare for your stallion, so that you can experience what its like to be claimed as his mate again.^^";ParaContent(); style bold;ParaContent(); print "Game Over.  ";ParaContent(); style underline;ParaContent(); print "~Let's Get Mare-ied!~  ";ParaContent(); style roman;ParaContent(); print "Male Human to Mare."; .L_Say956; .L_SayX953;
    rtrue;
];
Array TX_S_484 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_484;
[ R_TX_S_485 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[bold type]Game Over.  [italic type]'DOH!!!'  [roman type]Male Human to Doe.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); style bold;ParaContent(); print "Game Over.  ";ParaContent(); style underline;ParaContent(); print "~DOH!!!~  ";ParaContent(); style roman;ParaContent(); print "Male Human to Doe."; .L_Say957; .L_SayX954;
    rtrue;
];
Array TX_S_485 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_485;
[ R_TX_S_486 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[bold type]Game Over.  [italic type]'Good girl!'  [roman type]Female Human to Dog.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); style bold;ParaContent(); print "Game Over.  ";ParaContent(); style underline;ParaContent(); print "~Good girl!~  ";ParaContent(); style roman;ParaContent(); print "Female Human to Dog."; .L_Say958; .L_SayX955;
    rtrue;
];
Array TX_S_486 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_486;
[ R_TX_S_487 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[bold type]Game Over.  [italic type]'Good boy!'  [roman type]Male Human to Dog.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); style bold;ParaContent(); print "Game Over.  ";ParaContent(); style underline;ParaContent(); print "~Good boy!~  ";ParaContent(); style roman;ParaContent(); print "Male Human to Dog."; .L_Say959; .L_SayX956;
    rtrue;
];
Array TX_S_487 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_487;
[ R_TX_S_488 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[bold type]Game Over.  [italic type]'A Lot More Children Then What You Were Expecting'  [roman type]Female Human to Frog.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); style bold;ParaContent(); print "Game Over.  ";ParaContent(); style underline;ParaContent(); print "~A Lot More Children Then What You Were Expecting~  ";ParaContent(); style roman;ParaContent(); print "Female Human to Frog."; .L_Say960; .L_SayX957;
    rtrue;
];
Array TX_S_488 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_488;
[ R_TX_S_489 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[bold type]Game Over.  [italic type]'Sticky Icky'  [roman type]Male Human to Female Skunk.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); style bold;ParaContent(); print "Game Over.  ";ParaContent(); style underline;ParaContent(); print "~Sticky Icky~  ";ParaContent(); style roman;ParaContent(); print "Male Human to Female Skunk."; .L_Say961; .L_SayX958;
    rtrue;
];
Array TX_S_489 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_489;
[ R_TX_S_490 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~The last thought fades from your mind as you impregnate the now mindless mare. Eventually you reluctantly pull out, knowing Courtney is ready to bear your young for the rest of her life.[bold type]Game Over.  [italic type]'Now Thats A Stallion'  [roman type]Male Human to Stallion.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "The last thought fades from your mind as you impregnate the now mindless mare. Eventually you reluctantly pull out, knowing Courtney is ready to bear your young for the rest of her life.^^";ParaContent(); style bold;ParaContent(); print "Game Over.  ";ParaContent(); style underline;ParaContent(); print "~Now Thats A Stallion~  ";ParaContent(); style roman;ParaContent(); print "Male Human to Stallion."; .L_Say962; .L_SayX959;
    rtrue;
];
Array TX_S_490 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_490;
[ R_TX_S_491 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[bold type]Game Over.  [italic type]'Sniffing for Truffles'  [roman type]Male Human to Sow.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); style bold;ParaContent(); print "Game Over.  ";ParaContent(); style underline;ParaContent(); print "~Sniffing for Truffles~  ";ParaContent(); style roman;ParaContent(); print "Male Human to Sow."; .L_Say963; .L_SayX960;
    rtrue;
];
Array TX_S_491 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_491;
[ R_TX_S_492 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[bold type]Game Over.  [italic type]'Raped Into a Mindless Sow'  [roman type]Male Human to Sow.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); style bold;ParaContent(); print "Game Over.  ";ParaContent(); style underline;ParaContent(); print "~Raped Into a Mindless Sow~  ";ParaContent(); style roman;ParaContent(); print "Male Human to Sow."; .L_Say964; .L_SayX961;
    rtrue;
];
Array TX_S_492 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_492;
[ R_TX_S_493 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[bold type]Game Over.  [italic type]'Mare Milk'  [roman type]Male Human to Stallion.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); style bold;ParaContent(); print "Game Over.  ";ParaContent(); style underline;ParaContent(); print "~Mare Milk~  ";ParaContent(); style roman;ParaContent(); print "Male Human to Stallion."; .L_Say965; .L_SayX962;
    rtrue;
];
Array TX_S_493 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_493;
[ R_TX_S_494 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[bold type]Game Over.  [italic type]'Doggie Love'  [roman type]Male Human to Husky.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); style bold;ParaContent(); print "Game Over.  ";ParaContent(); style underline;ParaContent(); print "~Doggie Love~  ";ParaContent(); style roman;ParaContent(); print "Male Human to Husky."; .L_Say966; .L_SayX963;
    rtrue;
];
Array TX_S_494 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_494;
! Find next x satisfying:
! [ thing(x) ]
[ Prop_0 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK2_First: x: x=x.IK2_Link){
        return x;
        .NextOuterLoop_4;
    }
    return nothing;
];
! True or false?
! [ Card=2 x IN[ drawer(x) IN] : 'explored'(x) ]
[ Prop_1 
    x ! internal use only
    x_ix ! internal use only
    qcy_0 ! internal use only
    qcn_0 ! internal use only
    ;
    ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK23_First: x: x=x.IK23_Link){
        qcn_0++;
        if (((Adj_98_t1_v10(x)))){
            qcy_0++;
        }
    }
    if (qcy_0 == 2){
        rtrue;
    }
    rfalse;
];
! True or false?
! [ Card>=1 x IN[ drawer(x) IN] : 'unexplored'(x) ]
[ Prop_2 
    x ! internal use only
    x_ix ! internal use only
    qcy_0 ! internal use only
    qcn_0 ! internal use only
    ;
    ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK23_First: x: x=x.IK23_Link){
        qcn_0++;
        if (((Adj_99_t1_v10(x)))){
            qcy_0++;
        }
    }
    if (qcy_0 >= 1){
        rtrue;
    }
    rfalse;
];
! Find a random x satisfying:
! [ drawer(x) & 'unexplored'(x) ]
[ Prop_3 
    x ! internal use only
    x_ix ! internal use only
    counter ! internal use only
    selection ! internal use only
    ;
    ;
    selection = -1;
    while (true) {
        counter = 0;
        for (x=IK23_First: x: x=x.IK23_Link){
            if (((Adj_99_t1_v10(x)))){
                counter++;
                if (counter == selection) return x;
                jump NextOuterLoop_7;
            }
            .NextOuterLoop_7;
        }
        if ((counter == 0) || (selection >= 0)) return nothing;
        selection = random(counter);
    }
];
! True or false?
! [ DoesNotExist x IN[ drawer(x) IN] : 'explored'(x) ]
[ Prop_4 
    x ! internal use only
    x_ix ! internal use only
    qcy_0 ! internal use only
    qcn_0 ! internal use only
    ;
    ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK23_First: x: x=x.IK23_Link){
        qcn_0++;
        if (((Adj_98_t1_v10(x)))){
            qcy_0++;
        }
    }
    if (qcy_0 == 0){
        rtrue;
    }
    rfalse;
];
! True or false?
! [ Card>=1 x IN[ drawer(x) IN] : 'unexplored'(x) ]
[ Prop_5 
    x ! internal use only
    x_ix ! internal use only
    qcy_0 ! internal use only
    qcn_0 ! internal use only
    ;
    ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK23_First: x: x=x.IK23_Link){
        qcn_0++;
        if (((Adj_99_t1_v10(x)))){
            qcy_0++;
        }
    }
    if (qcy_0 >= 1){
        rtrue;
    }
    rfalse;
];
! True or false?
! [ ForAll x IN[ drawer(x) IN] : 'explored'(x) ]
[ Prop_6 
    x ! internal use only
    x_ix ! internal use only
    qcy_0 ! internal use only
    qcn_0 ! internal use only
    ;
    ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK23_First: x: x=x.IK23_Link){
        qcn_0++;
        if (((Adj_98_t1_v10(x)))){
            qcy_0++;
        }
    }
    if (qcy_0 == qcn_0){
        rtrue;
    }
    rfalse;
];
! True or false?
! [ Card>=1 x IN[ drawer(x) IN] : 'unexplored'(x) ]
[ Prop_7 
    x ! internal use only
    x_ix ! internal use only
    qcy_0 ! internal use only
    qcn_0 ! internal use only
    ;
    ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK23_First: x: x=x.IK23_Link){
        qcn_0++;
        if (((Adj_99_t1_v10(x)))){
            qcy_0++;
        }
    }
    if (qcy_0 >= 1){
        rtrue;
    }
    rfalse;
];
! True or false?
! [ DoesNotExist x IN[ drawer(x) IN] : 'explored'(x) ]
[ Prop_8 
    x ! internal use only
    x_ix ! internal use only
    qcy_0 ! internal use only
    qcn_0 ! internal use only
    ;
    ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK23_First: x: x=x.IK23_Link){
        qcn_0++;
        if (((Adj_98_t1_v10(x)))){
            qcy_0++;
        }
    }
    if (qcy_0 == 0){
        rtrue;
    }
    rfalse;
];
! True or false?
! [ Card=2 x IN[ drawer(x) IN] : 'unexplored'(x) ]
[ Prop_9 
    x ! internal use only
    x_ix ! internal use only
    qcy_0 ! internal use only
    qcn_0 ! internal use only
    ;
    ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK23_First: x: x=x.IK23_Link){
        qcn_0++;
        if (((Adj_99_t1_v10(x)))){
            qcy_0++;
        }
    }
    if (qcy_0 == 2){
        rtrue;
    }
    rfalse;
];
! True or false?
! [ Card=1 x IN[ drawer(x) IN] : 'unexplored'(x) ]
[ Prop_10 
    x ! internal use only
    x_ix ! internal use only
    qcy_0 ! internal use only
    qcn_0 ! internal use only
    ;
    ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK23_First: x: x=x.IK23_Link){
        qcn_0++;
        if (((Adj_99_t1_v10(x)))){
            qcy_0++;
        }
    }
    if (qcy_0 == 1){
        rtrue;
    }
    rfalse;
];
! Force this to be true via 'now':
! [ ForAll x IN[ drawer(x) IN] : 'explored'(x) ]
[ Prop_11 
    x ! internal use only
    x_ix ! internal use only
    qcy_0 ! internal use only
    qcn_0 ! internal use only
    ;
    ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK23_First: x: x=x.IK23_Link){
        qcn_0++;
        (Adj_98_t2_v10(x));
        qcy_0++;
    }
    if (qcy_0 == qcn_0){
    }
];
! True or false?
! [ Card=1 x IN[ drawer(x) IN] : 'explored'(x) ]
[ Prop_12 
    x ! internal use only
    x_ix ! internal use only
    qcy_0 ! internal use only
    qcn_0 ! internal use only
    ;
    ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK23_First: x: x=x.IK23_Link){
        qcn_0++;
        if (((Adj_98_t1_v10(x)))){
            qcy_0++;
        }
    }
    if (qcy_0 == 1){
        rtrue;
    }
    rfalse;
];
! True or false?
! [ DoesNotExist x IN[ drawer(x) IN] : 'explored'(x) ]
[ Prop_13 
    x ! internal use only
    x_ix ! internal use only
    qcy_0 ! internal use only
    qcn_0 ! internal use only
    ;
    ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK23_First: x: x=x.IK23_Link){
        qcn_0++;
        if (((Adj_98_t1_v10(x)))){
            qcy_0++;
        }
    }
    if (qcy_0 == 0){
        rtrue;
    }
    rfalse;
];
! How many x satisfy this?
! [ room(x) & 'adjacent'(x) ]
[ Prop_14 
    x ! internal use only
    x_ix ! internal use only
    counter ! internal use only
    ;
    ;
    for (x=IK1_First: x: x=x.IK1_Link){
        if (((Adj_12_t1_v10(x)))){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];
! Find next x satisfying:
! [ room(x) & 'adjacent'(x) ]
[ Prop_15 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK1_First: x: x=x.IK1_Link){
        if (((Adj_12_t1_v10(x)))){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];
! True or false?
! [ Exists x : thing(x) & called='box'(thing)(x) & 'enterable'(x) & is('location', ContainerOf(x)) ]
[ Prop_16 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    for (x=TestContainmentRange(real_location): x: x=TestContainmentRange(real_location,x)){
        if ((x ofclass K2_thing) && ((Adj_71_t1_v10(x)))){
            deferred_calling_list-->0 = x;
            rtrue;
        }
    }
    rfalse;
];
! Find next x satisfying:
! [ thing(x) ]
[ Prop_17 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK2_First: x: x=x.IK2_Link){
        return x;
        .NextOuterLoop_4;
    }
    return nothing;
];
! Find next x satisfying:
! [ thing(x) ]
[ Prop_18 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK2_First: x: x=x.IK2_Link){
        return x;
        .NextOuterLoop_4;
    }
    return nothing;
];
! How many x satisfy this?
! [ thing(x) & 'marked for listing'(x) ]
[ Prop_19 
    x ! internal use only
    x_ix ! internal use only
    counter ! internal use only
    ;
    ;
    for (x=IK2_First: x: x=x.IK2_Link){
        if (((Adj_67_t1_v10(x)))){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];
! Find next x satisfying:
! [ thing(x) & 'marked for listing'(x) ]
[ Prop_20 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK2_First: x: x=x.IK2_Link){
        if (((Adj_67_t1_v10(x)))){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];
! Abstraction for set of x such that:
! [ thing(x) & thing(x) & 'unmentioned'(x) ]
[ Prop_21 
    reason ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    total ! internal use only
    counter ! internal use only
    selection ! internal use only
    best ! internal use only
    best_with ! internal use only
    ;
    ;
    if (reason >= 0) { x = reason; reason = -1; }
    switch (reason) {
        -6: ! Find the extremal x satisfying:
            if (property_loop_sign>0) best=MIN_NEGATIVE_NUMBER;
            else best=MAX_POSITIVE_NUMBER;
            for (x=IK2_First: x: x=x.IK2_Link){
                if ((x ofclass K2_thing) && ((Adj_70_t1_v10(x)))){
                    if (property_loop_sign>0) {
                        if (x.property_to_be_totalled >= best) {
                            best = x.property_to_be_totalled;
                            best_with = x;
                        }
                    } else {
                        if (x.property_to_be_totalled <= best) {
                            best = x.property_to_be_totalled;
                            best_with = x;
                        }
                    }
                }
                .NextOuterLoop_3;
            }
            return best_with;
        -5: ! Find a total property value over all x satisfying:
            for (x=IK2_First: x: x=x.IK2_Link){
                if ((x ofclass K2_thing) && ((Adj_70_t1_v10(x)))){
                    total = total + x.property_to_be_totalled;
                    jump NextOuterLoop_6;
                }
                .NextOuterLoop_6;
            }
            return total;
        -4: ! Find a random x satisfying:
            selection = -1;
            while (true) {
                counter = 0;
                for (x=IK2_First: x: x=x.IK2_Link){
                    if ((x ofclass K2_thing) && ((Adj_70_t1_v10(x)))){
                        counter++;
                        if (counter == selection) return x;
                        jump NextOuterLoop_7;
                    }
                    .NextOuterLoop_7;
                }
                if ((counter == 0) || (selection >= 0)) return nothing;
                selection = random(counter);
            }
        -3: ! How many x satisfy this?
            for (x=IK2_First: x: x=x.IK2_Link){
                if ((x ofclass K2_thing) && ((Adj_70_t1_v10(x)))){
                    counter++;
                    jump NextOuterLoop_5;
                }
                .NextOuterLoop_5;
            }
            return counter;
        -2: ! Find next x satisfying:
            if (x_ix > 0) {
                x_ix--;
                jump NextOuterLoop_4;
            }
            if (x) jump NextOuterLoop_4;
            for (x=IK2_First: x: x=x.IK2_Link){
                if ((x ofclass K2_thing) && ((Adj_70_t1_v10(x)))){
                    return x;
                }
                .NextOuterLoop_4;
            }
            return nothing;
        -1: ! True or false?
            if ((x ofclass K2_thing) && (x ofclass K2_thing) && ((Adj_70_t1_v10(x)))){
                rtrue;
            }
            rfalse;
    }
];
! Find next x satisfying:
! [ thing(x) & not-'handled'(x) & supporter(const_0) & provides(const_1, 'the property initial appearance') & is(const_2, SupporterOf(x)) ]
[ Prop_22 
    const_0 ! Implied call parameter
    const_1 ! Implied call parameter
    const_2 ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    objectloop (x in const_2) if (SupporterOf(x)==parent(x)){
        if ((x ofclass K2_thing) && (~~((Adj_64_t1_v10(x)))) && (const_0 ofclass K6_supporter) && (WhetherProvides(const_1, false, initial))){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];
! True or false?
! [ Exists x : thing(x) & 'locale-supportable'(x) & is(const_0, SupporterOf(x)) ]
[ Prop_23 
    const_0 ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    objectloop (x in const_0) if (SupporterOf(x)==parent(x)){
        if ((x ofclass K2_thing) && ((Adj_41_t1_v10(x)))){
            rtrue;
        }
    }
    rfalse;
];
! Find next x satisfying:
! [ thing(x) & is(const_0, SupporterOf(x)) ]
[ Prop_24 
    const_0 ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    objectloop (x in const_0) if (SupporterOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];
! True or false?
! [ Exists x : thing(x) & 'locale-supportable'(x) & is(const_0, SupporterOf(x)) ]
[ Prop_25 
    const_0 ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    objectloop (x in const_0) if (SupporterOf(x)==parent(x)){
        if ((x ofclass K2_thing) && ((Adj_41_t1_v10(x)))){
            rtrue;
        }
    }
    rfalse;
];
! Find next x satisfying:
! [ thing(x) & is(const_0, SupporterOf(x)) ]
[ Prop_26 
    const_0 ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    objectloop (x in const_0) if (SupporterOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];
! How many x satisfy this?
! [ thing(x) & is('actor', CarrierOf(x)) ]
[ Prop_27 
    x ! internal use only
    x_ix ! internal use only
    counter ! internal use only
    ;
    ;
    objectloop (x in actor) if (CarrierOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];
! True or false?
! [ Exists x : player's holdall(x) & called='current working sack'(player's holdall)(x) & is('actor', HolderOf(x)) ]
[ Prop_28 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    for (x=nothing: false: ){
        if ((actor == HolderOf(x))){
            deferred_calling_list-->0 = x;
            rtrue;
        }
    }
    rfalse;
];
! Find next x satisfying:
! [ thing(x) & is('actor', CarrierOf(x)) ]
[ Prop_29 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    objectloop (x in actor) if (CarrierOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];
! How many x satisfy this?
! [ thing(x) & is('actor', CarrierOf(x)) ]
[ Prop_30 
    x ! internal use only
    x_ix ! internal use only
    counter ! internal use only
    ;
    ;
    objectloop (x in actor) if (CarrierOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];
! How many x satisfy this?
! [ thing(x) & is(const_0, SupporterOf(x)) ]
[ Prop_31 
    const_0 ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    counter ! internal use only
    ;
    ;
    objectloop (x in const_0) if (SupporterOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];
! How many x satisfy this?
! [ thing(x) & is(const_0, ContainerOf(x)) ]
[ Prop_32 
    const_0 ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    counter ! internal use only
    ;
    ;
    for (x=TestContainmentRange(const_0): x: x=TestContainmentRange(const_0,x)){
        if ((x ofclass K2_thing)){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];
! How many x satisfy this?
! [ thing(x) & is('second noun', SupporterOf(x)) ]
[ Prop_33 
    x ! internal use only
    x_ix ! internal use only
    counter ! internal use only
    ;
    ;
    objectloop (x in second) if (SupporterOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];
! How many x satisfy this?
! [ thing(x) & is('second noun', ContainerOf(x)) ]
[ Prop_34 
    x ! internal use only
    x_ix ! internal use only
    counter ! internal use only
    ;
    ;
    for (x=TestContainmentRange(second): x: x=TestContainmentRange(second,x)){
        if ((x ofclass K2_thing)){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];
! True or false?
! [ Exists x : person(x) & called='owner'(person)(x) & NOT[ is(x, 'actor') NOT] & encloses(x, 'noun') ]
[ Prop_35 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    for (x=IK8_First: x: x=x.IK8_Link){
        if (~~((x == actor))){
            if ((IndirectlyContains(x,noun))){
                deferred_calling_list-->0 = x;
                rtrue;
            }
        }
    }
    rfalse;
];
! How many x satisfy this?
! [ thing(x) & is('noun', SupporterOf(x)) ]
[ Prop_36 
    x ! internal use only
    x_ix ! internal use only
    counter ! internal use only
    ;
    ;
    objectloop (x in noun) if (SupporterOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];
! How many x satisfy this?
! [ thing(x) & is('noun', ContainerOf(x)) ]
[ Prop_37 
    x ! internal use only
    x_ix ! internal use only
    counter ! internal use only
    ;
    ;
    for (x=TestContainmentRange(noun): x: x=TestContainmentRange(noun,x)){
        if ((x ofclass K2_thing)){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];
! Find next x satisfying:
! [ thing(x) ]
[ Prop_38 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK2_First: x: x=x.IK2_Link){
        return x;
        .NextOuterLoop_4;
    }
    return nothing;
];
! True or false?
! [ Exists x : thing(x) & 'described'(x) & NOT[ 'scenery'(x) NOT] & is('noun', ContainerOf(x)) ]
[ Prop_39 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    for (x=TestContainmentRange(noun): x: x=TestContainmentRange(noun,x)){
        if ((x ofclass K2_thing) && ((Adj_65_t1_v10(x)))){
            if (~~(((Adj_61_t1_v10(x))))){
                rtrue;
            }
        }
    }
    rfalse;
];
! True or false?
! [ Exists x : thing(x) & NOT[ is(x, 'player') NOT] & is('noun', ContainerOf(x)) ]
[ Prop_40 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    for (x=TestContainmentRange(noun): x: x=TestContainmentRange(noun,x)){
        if ((x ofclass K2_thing)){
            if (~~((x == player))){
                rtrue;
            }
        }
    }
    rfalse;
];
! True or false?
! [ Exists x : thing(x) & 'described'(x) & NOT[ 'scenery'(x) NOT] & is('noun', SupporterOf(x)) ]
[ Prop_41 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    objectloop (x in noun) if (SupporterOf(x)==parent(x)){
        if ((x ofclass K2_thing) && ((Adj_65_t1_v10(x)))){
            if (~~(((Adj_61_t1_v10(x))))){
                rtrue;
            }
        }
    }
    rfalse;
];
! True or false?
! [ Exists x : thing(x) & NOT[ is(x, 'player') NOT] & is('noun', SupporterOf(x)) ]
[ Prop_42 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    objectloop (x in noun) if (SupporterOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            if (~~((x == player))){
                rtrue;
            }
        }
    }
    rfalse;
];
! True or false?
! [ Exists x : thing(x) & 'described'(x) & NOT[ 'scenery'(x) NOT] & is('noun', ContainerOf(x)) ]
[ Prop_43 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    for (x=TestContainmentRange(noun): x: x=TestContainmentRange(noun,x)){
        if ((x ofclass K2_thing) && ((Adj_65_t1_v10(x)))){
            if (~~(((Adj_61_t1_v10(x))))){
                rtrue;
            }
        }
    }
    rfalse;
];
! True or false?
! [ Exists x : thing(x) & 'described'(x) & NOT[ 'scenery'(x) NOT] & is('noun', SupporterOf(x)) ]
[ Prop_44 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    objectloop (x in noun) if (SupporterOf(x)==parent(x)){
        if ((x ofclass K2_thing) && ((Adj_65_t1_v10(x)))){
            if (~~(((Adj_61_t1_v10(x))))){
                rtrue;
            }
        }
    }
    rfalse;
];
! How many x satisfy this?
! [ thing(x) & is('actor', CarrierOf(x)) ]
[ Prop_45 
    x ! internal use only
    x_ix ! internal use only
    counter ! internal use only
    ;
    ;
    objectloop (x in actor) if (CarrierOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];
! How many x satisfy this?
! [ thing(x) & is('second noun', CarrierOf(x)) ]
[ Prop_46 
    x ! internal use only
    x_ix ! internal use only
    counter ! internal use only
    ;
    ;
    objectloop (x in second) if (CarrierOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];
! True or false?
! [ Exists x : thing(x) & is(const_0, (RGuard_f0_2(x))) ]
[ Prop_47 
    const_0 ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    for (x=IK2_First: x: x=x.IK2_Link){
        if ((const_0 == (RGuard_f0_2(x)))){
            rtrue;
        }
    }
    rfalse;
];
! True or false?
! [ Exists x : thing(x) & is('witch', CarrierOf(x)) ]
[ Prop_48 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    objectloop (x in I157_witch) if (CarrierOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            rtrue;
        }
    }
    rfalse;
];
! True or false?
! [ Exists x : thing(x) & is('equestrian mistress', CarrierOf(x)) ]
[ Prop_49 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    objectloop (x in I270_equestrian_mistress) if (CarrierOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            rtrue;
        }
    }
    rfalse;
];
! True or false?
! [ Exists x : thing(x) & is('becky', CarrierOf(x)) ]
[ Prop_50 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    objectloop (x in I271_becky) if (CarrierOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            rtrue;
        }
    }
    rfalse;
];

Constant R_38_RESP_A = 1;
Constant R_39_RESP_A = 2;
Constant R_40_RESP_A = 3;
Constant R_40_RESP_B = 4;
Constant R_41_RESP_A = 5;
Constant R_45_RESP_A = 6;
Constant R_45_RESP_B = 7;
Constant R_45_RESP_C = 8;
Constant R_45_RESP_D = 9;
Constant R_45_RESP_E = 10;
Constant R_45_RESP_F = 11;
Constant R_52_RESP_A = 12;
Constant R_54_RESP_A = 13;
Constant R_55_RESP_A = 14;
Constant R_56_RESP_A = 15;
Constant R_57_RESP_A = 16;
Constant R_58_RESP_A = 17;
Constant R_59_RESP_A = 18;
Constant R_60_RESP_A = 19;
Constant R_61_RESP_A = 20;
Constant R_62_RESP_A = 21;
Constant R_63_RESP_A = 22;
Constant R_64_RESP_A = 23;
Constant R_65_RESP_A = 24;
Constant R_66_RESP_A = 25;
Constant R_67_RESP_A = 26;
Constant R_68_RESP_A = 27;
Constant R_69_RESP_A = 28;
Constant R_71_RESP_A = 29;
Constant R_71_RESP_B = 30;
Constant R_72_RESP_A = 31;
Constant R_73_RESP_A = 32;
Constant R_75_RESP_A = 33;
Constant R_76_RESP_A = 34;
Constant R_77_RESP_A = 35;
Constant R_78_RESP_A = 36;
Constant R_79_RESP_A = 37;
Constant R_80_RESP_A = 38;
Constant R_80_RESP_B = 39;
Constant R_82_RESP_A = 40;
Constant R_82_RESP_B = 41;
Constant R_85_RESP_A = 42;
Constant R_86_RESP_A = 43;
Constant R_87_RESP_A = 44;
Constant R_88_RESP_A = 45;
Constant R_90_RESP_A = 46;
Constant R_91_RESP_A = 47;
Constant R_94_RESP_A = 48;
Constant R_95_RESP_A = 49;
Constant R_96_RESP_A = 50;
Constant R_97_RESP_A = 51;
Constant R_98_RESP_A = 52;
Constant R_100_RESP_A = 53;
Constant R_101_RESP_A = 54;
Constant R_102_RESP_A = 55;
Constant R_103_RESP_A = 56;
Constant R_104_RESP_A = 57;
Constant R_107_RESP_A = 58;
Constant R_107_RESP_B = 59;
Constant R_109_RESP_A = 60;
Constant R_110_RESP_A = 61;
Constant R_110_RESP_B = 62;
Constant R_111_RESP_A = 63;
Constant R_112_RESP_A = 64;
Constant R_114_RESP_A = 65;
Constant R_114_RESP_B = 66;
Constant R_118_RESP_A = 67;
Constant R_118_RESP_B = 68;
Constant R_118_RESP_C = 69;
Constant R_118_RESP_D = 70;
Constant R_118_RESP_E = 71;
Constant R_118_RESP_F = 72;
Constant R_118_RESP_G = 73;
Constant R_118_RESP_H = 74;
Constant R_118_RESP_I = 75;
Constant R_118_RESP_J = 76;
Constant R_118_RESP_K = 77;
Constant R_118_RESP_L = 78;
Constant R_118_RESP_M = 79;
Constant R_118_RESP_N = 80;
Constant R_118_RESP_O = 81;
Constant R_118_RESP_P = 82;
Constant R_118_RESP_Q = 83;
Constant R_118_RESP_R = 84;
Constant R_118_RESP_S = 85;
Constant R_122_RESP_A = 86;
Constant R_122_RESP_B = 87;
Constant R_123_RESP_A = 88;
Constant R_123_RESP_B = 89;
Constant R_123_RESP_C = 90;
Constant R_123_RESP_D = 91;
Constant R_124_RESP_A = 92;
Constant R_125_RESP_A = 93;
Constant R_125_RESP_B = 94;
Constant R_126_RESP_A = 95;
Constant R_127_RESP_A = 96;
Constant R_127_RESP_B = 97;
Constant R_127_RESP_C = 98;
Constant R_127_RESP_D = 99;
Constant R_127_RESP_E = 100;
Constant R_129_RESP_A = 101;
Constant R_129_RESP_B = 102;
Constant R_129_RESP_C = 103;
Constant R_129_RESP_D = 104;
Constant R_132_RESP_A = 105;
Constant R_133_RESP_A = 106;
Constant R_136_RESP_A = 107;
Constant R_136_RESP_B = 108;
Constant R_136_RESP_C = 109;
Constant R_138_RESP_A = 110;
Constant R_140_RESP_A = 111;
Constant R_144_RESP_A = 112;
Constant R_144_RESP_B = 113;
Constant R_144_RESP_C = 114;
Constant R_145_RESP_A = 115;
Constant R_148_RESP_A = 116;
Constant R_150_RESP_A = 117;
Constant R_151_RESP_A = 118;
Constant R_151_RESP_B = 119;
Constant R_152_RESP_A = 120;
Constant R_153_RESP_A = 121;
Constant R_154_RESP_A = 122;
Constant R_155_RESP_A = 123;
Constant R_156_RESP_A = 124;
Constant R_157_RESP_A = 125;
Constant R_158_RESP_A = 126;
Constant R_159_RESP_A = 127;
Constant R_160_RESP_A = 128;
Constant R_160_RESP_B = 129;
Constant R_161_RESP_A = 130;
Constant R_161_RESP_B = 131;
Constant R_162_RESP_A = 132;
Constant R_163_RESP_A = 133;
Constant R_163_RESP_B = 134;
Constant R_164_RESP_A = 135;
Constant R_165_RESP_A = 136;
Constant R_166_RESP_A = 137;
Constant R_167_RESP_A = 138;
Constant R_169_RESP_A = 139;
Constant R_169_RESP_B = 140;
Constant R_170_RESP_A = 141;
Constant R_171_RESP_A = 142;
Constant R_172_RESP_A = 143;
Constant R_174_RESP_A = 144;
Constant R_174_RESP_B = 145;
Constant R_175_RESP_A = 146;
Constant R_176_RESP_A = 147;
Constant R_178_RESP_A = 148;
Constant R_179_RESP_A = 149;
Constant R_180_RESP_A = 150;
Constant R_182_RESP_A = 151;
Constant R_183_RESP_A = 152;
Constant R_184_RESP_A = 153;
Constant R_185_RESP_A = 154;
Constant R_187_RESP_A = 155;
Constant R_188_RESP_A = 156;
Constant R_188_RESP_B = 157;
Constant R_188_RESP_C = 158;
Constant R_189_RESP_A = 159;
Constant R_190_RESP_A = 160;
Constant R_192_RESP_A = 161;
Constant R_192_RESP_B = 162;
Constant R_192_RESP_C = 163;
Constant R_193_RESP_A = 164;
Constant R_194_RESP_A = 165;
Constant R_195_RESP_A = 166;
Constant R_197_RESP_A = 167;
Constant R_197_RESP_B = 168;
Constant R_198_RESP_A = 169;
Constant R_199_RESP_A = 170;
Constant R_201_RESP_A = 171;
Constant R_201_RESP_B = 172;
Constant R_202_RESP_A = 173;
Constant R_203_RESP_A = 174;
Constant R_204_RESP_A = 175;
Constant R_205_RESP_A = 176;
Constant R_206_RESP_A = 177;
Constant R_207_RESP_A = 178;
Constant R_209_RESP_A = 179;
Constant R_209_RESP_B = 180;
Constant R_209_RESP_C = 181;
Constant R_210_RESP_A = 182;
Constant R_212_RESP_A = 183;
Constant R_213_RESP_A = 184;
Constant R_214_RESP_A = 185;
Constant R_215_RESP_A = 186;
Constant R_216_RESP_A = 187;
Constant R_217_RESP_A = 188;
Constant R_218_RESP_A = 189;
Constant R_219_RESP_A = 190;
Constant R_220_RESP_A = 191;
Constant R_221_RESP_A = 192;
Constant R_222_RESP_A = 193;
Constant R_223_RESP_A = 194;
Constant R_226_RESP_A = 195;
Constant R_226_RESP_B = 196;
Constant R_227_RESP_A = 197;
Constant R_227_RESP_B = 198;
Constant R_228_RESP_A = 199;
Constant R_228_RESP_B = 200;
Constant R_228_RESP_C = 201;
Constant R_229_RESP_A = 202;
Constant R_229_RESP_B = 203;
Constant R_230_RESP_A = 204;
Constant R_231_RESP_A = 205;
Constant R_231_RESP_B = 206;
Constant R_232_RESP_A = 207;
Constant R_233_RESP_A = 208;
Constant R_234_RESP_A = 209;
Constant R_235_RESP_A = 210;
Constant R_235_RESP_B = 211;
Constant R_236_RESP_A = 212;
Constant R_237_RESP_A = 213;
Constant R_238_RESP_A = 214;
Constant R_239_RESP_A = 215;
Constant R_239_RESP_B = 216;
Constant R_240_RESP_A = 217;
Constant R_241_RESP_A = 218;
Constant R_242_RESP_A = 219;
Constant R_243_RESP_A = 220;
Constant R_243_RESP_B = 221;
Constant R_244_RESP_A = 222;
Constant R_245_RESP_A = 223;
Constant R_246_RESP_A = 224;
Constant R_247_RESP_A = 225;
Constant R_249_RESP_A = 226;
Constant R_250_RESP_A = 227;
Constant R_251_RESP_A = 228;
Constant R_251_RESP_B = 229;
Constant R_252_RESP_A = 230;
Constant R_253_RESP_A = 231;
Constant R_254_RESP_A = 232;
Constant R_255_RESP_A = 233;
Constant R_256_RESP_A = 234;
Constant R_257_RESP_A = 235;
Constant R_257_RESP_B = 236;
Constant R_258_RESP_A = 237;
Constant R_258_RESP_B = 238;
Constant R_259_RESP_A = 239;
Constant R_259_RESP_B = 240;
Constant R_260_RESP_A = 241;
Constant R_261_RESP_A = 242;
Constant R_261_RESP_B = 243;
Constant R_262_RESP_A = 244;
Constant R_263_RESP_A = 245;
Constant R_264_RESP_A = 246;
Constant R_265_RESP_A = 247;
Constant R_266_RESP_A = 248;
Constant R_267_RESP_A = 249;
Constant R_267_RESP_B = 250;
Constant R_268_RESP_A = 251;
Constant R_269_RESP_A = 252;
Constant R_269_RESP_B = 253;
Constant R_270_RESP_A = 254;
Constant R_271_RESP_A = 255;
Constant R_272_RESP_A = 256;
Constant R_274_RESP_A = 257;
Constant R_275_RESP_A = 258;
Constant R_276_RESP_A = 259;
Constant R_277_RESP_A = 260;
Constant R_283_RESP_A = 261;
Constant R_285_RESP_A = 262;
Constant R_287_RESP_A = 263;
Constant R_289_RESP_A = 264;
Constant R_290_RESP_A = 265;
Constant R_291_RESP_A = 266;
Constant R_296_RESP_A = 267;
Constant R_303_RESP_A = 268;
Constant R_304_RESP_A = 269;
Constant R_312_RESP_A = 270;
Constant R_319_RESP_A = 271;
Constant R_321_RESP_A = 272;
Constant R_321_RESP_B = 273;
Constant R_328_RESP_A = 274;
Constant R_329_RESP_A = 275;
Constant R_331_RESP_A = 276;
Constant R_332_RESP_A = 277;
Constant R_335_RESP_A = 278;
Constant R_336_RESP_A = 279;
Constant R_337_RESP_A = 280;
Constant R_338_RESP_A = 281;
Constant R_339_RESP_A = 282;
Constant R_339_RESP_B = 283;
Constant R_339_RESP_C = 284;
Constant R_339_RESP_D = 285;
Constant R_339_RESP_E = 286;
Constant R_339_RESP_F = 287;
Constant R_339_RESP_G = 288;
Constant R_339_RESP_H = 289;
Constant R_339_RESP_I = 290;
Constant R_339_RESP_J = 291;
Constant R_339_RESP_K = 292;
Constant R_339_RESP_L = 293;
Constant R_339_RESP_M = 294;
Constant R_339_RESP_N = 295;
Constant R_339_RESP_O = 296;
Constant R_339_RESP_P = 297;
Constant R_339_RESP_Q = 298;
Constant R_339_RESP_R = 299;
Constant R_339_RESP_S = 300;
Constant R_339_RESP_T = 301;
Constant R_339_RESP_U = 302;
Constant R_339_RESP_V = 303;
Constant R_339_RESP_W = 304;
Constant R_339_RESP_X = 305;
Constant R_339_RESP_Y = 306;
Constant R_340_RESP_A = 307;
Constant R_340_RESP_B = 308;
Constant R_340_RESP_C = 309;
Constant R_340_RESP_D = 310;
Constant R_340_RESP_E = 311;
Constant R_340_RESP_F = 312;
Constant R_340_RESP_G = 313;
Constant R_340_RESP_H = 314;
Constant R_340_RESP_I = 315;
Constant R_340_RESP_J = 316;
Constant R_341_RESP_A = 317;
Constant R_341_RESP_B = 318;
Constant R_341_RESP_C = 319;
Constant R_341_RESP_D = 320;
Constant R_341_RESP_E = 321;
Constant R_341_RESP_F = 322;
Constant R_341_RESP_G = 323;
Constant R_341_RESP_H = 324;
Constant R_341_RESP_I = 325;
Constant R_341_RESP_J = 326;
Constant R_341_RESP_K = 327;
Constant R_341_RESP_L = 328;
Constant R_341_RESP_M = 329;
Constant R_341_RESP_N = 330;
Constant R_341_RESP_O = 331;
Constant R_341_RESP_P = 332;
Constant R_341_RESP_Q = 333;
Constant R_341_RESP_R = 334;
Constant R_341_RESP_S = 335;
Constant R_341_RESP_T = 336;
Constant R_341_RESP_U = 337;
Constant R_341_RESP_V = 338;
Constant R_341_RESP_W = 339;
Constant R_341_RESP_X = 340;
Constant R_342_RESP_A = 341;
Constant R_342_RESP_B = 342;
Constant R_342_RESP_C = 343;
Constant R_342_RESP_D = 344;
Constant R_342_RESP_E = 345;
Constant R_342_RESP_F = 346;
Constant R_343_RESP_A = 347;
Constant R_344_RESP_A = 348;
Constant R_344_RESP_B = 349;
Constant R_344_RESP_C = 350;
Constant R_344_RESP_D = 351;
Constant R_345_RESP_A = 352;
Constant R_345_RESP_B = 353;
Constant R_345_RESP_C = 354;
Constant R_345_RESP_D = 355;
Constant R_345_RESP_E = 356;
Constant R_345_RESP_F = 357;
Constant R_345_RESP_G = 358;
Constant R_345_RESP_H = 359;
Constant R_346_RESP_A = 360;
Constant R_347_RESP_A = 361;
Constant R_347_RESP_B = 362;
Constant R_347_RESP_C = 363;
Constant R_350_RESP_A = 364;
Constant R_350_RESP_B = 365;
Constant R_352_RESP_A = 366;
Constant R_352_RESP_B = 367;
Constant R_352_RESP_C = 368;
Constant R_358_RESP_A = 369;
Constant R_358_RESP_B = 370;
Constant R_358_RESP_C = 371;
Constant R_358_RESP_D = 372;
Constant R_358_RESP_E = 373;
Constant R_361_RESP_A = 374;
Constant R_362_RESP_A = 375;
Constant R_362_RESP_B = 376;
Constant R_363_RESP_A = 377;
Constant R_363_RESP_B = 378;
Constant R_364_RESP_A = 379;
Constant R_364_RESP_B = 380;
Constant R_365_RESP_A = 381;
Constant R_365_RESP_B = 382;
Constant R_366_RESP_A = 383;
Constant R_366_RESP_B = 384;
Constant R_366_RESP_C = 385;
Constant R_367_RESP_A = 386;
Constant R_367_RESP_B = 387;
Constant R_367_RESP_C = 388;
Constant R_369_RESP_A = 389;
Constant R_369_RESP_B = 390;
Constant R_369_RESP_C = 391;
Constant R_369_RESP_D = 392;
Constant R_369_RESP_E = 393;
Constant R_371_RESP_A = 394;
Constant R_373_RESP_A = 395;
Constant R_375_RESP_A = 396;
Constant R_377_RESP_A = 397;
Constant R_379_RESP_A = 398;
Constant R_380_RESP_A = 399;
Constant R_380_RESP_B = 400;
Constant R_380_RESP_C = 401;
Constant R_380_RESP_D = 402;
Constant NO_RESPONSES = 402;
Array ResponseTexts -->
    TX_S_214 TX_S_217 TX_S_215 TX_S_216 TX_S_218 TX_S_219 TX_S_220 TX_S_221 TX_S_222 TX_S_223 TX_S_224 TX_S_225 TX_S_226 TX_S_227 TX_S_228 TX_S_229 TX_S_230 TX_S_231 TX_S_232 TX_S_233 TX_S_234 TX_S_235 TX_S_236 TX_S_237 TX_S_238 TX_S_239 TX_S_240 TX_S_241 TX_S_242 TX_S_243 TX_S_244 TX_S_245 TX_S_247 TX_S_246 TX_S_248 TX_S_249 TX_S_250 TX_S_251 TX_S_252 TX_S_253 TX_S_254 TX_S_255 TX_S_256 TX_S_257 TX_S_258 TX_S_259 TX_S_260 TX_S_261 TX_S_262 TX_S_263 TX_S_264 TX_S_265 TX_S_266 TX_S_267 TX_S_268 TX_S_269 TX_S_270 TX_S_271 TX_S_272 TX_S_273 TX_S_274 TX_S_275 TX_S_276 TX_S_277 TX_S_278 TX_S_279 TX_S_280 TX_S_281 TX_S_282 TX_S_283 TX_S_284 TX_S_285 TX_S_286 TX_S_287 TX_S_288 TX_S_289 TX_S_290 TX_S_291 TX_S_292 TX_S_293 TX_S_294 TX_S_295 TX_S_296 TX_S_297 TX_S_298 TX_S_299 TX_S_300 TX_S_301 TX_S_302 TX_S_303 TX_S_304 TX_S_305 TX_S_306 TX_S_307 TX_S_308 TX_S_309 TX_S_310 TX_S_311 TX_S_312 TX_S_313 TX_S_314 TX_S_315 TX_S_316 TX_S_317 TX_S_318 TX_S_319 TX_S_320 TX_S_321 TX_S_322 TX_S_323 TX_S_324 TX_S_325 TX_S_326 TX_S_327 TX_S_328 TX_S_329 TX_S_330 TX_S_331 TX_S_332 TX_S_333 TX_S_334 TX_S_335 TX_S_336 TX_S_337 TX_S_338 TX_S_339 TX_S_340 TX_S_341 TX_S_342 TX_S_343 TX_S_344 TX_S_345 TX_S_346 TX_S_347 TX_S_348 TX_S_349 TX_S_350 TX_S_473 TX_S_352 TX_S_353 TX_S_354 TX_S_355 TX_S_474 TX_S_356 TX_S_357 TX_S_358 TX_S_359 TX_S_360 TX_S_361 TX_S_362 TX_S_363 TX_S_364 TX_S_365 TX_S_366 TX_S_367 TX_S_368 TX_S_369 TX_S_370 TX_S_371 TX_S_372 TX_S_373 TX_S_374 TX_S_375 TX_S_376 TX_S_377 TX_S_378 TX_S_379 TX_S_380 TX_S_381 TX_S_382 TX_S_383 TX_S_384 TX_S_385 TX_S_386 TX_S_387 TX_S_388 TX_S_389 TX_S_390 TX_S_391 TX_S_392 TX_S_393 TX_S_394 TX_S_395 TX_S_396 TX_S_397 TX_S_398 TX_S_399 TX_S_400 TX_S_401 TX_S_402 TX_S_403 TX_S_404 TX_S_405 TX_S_406 TX_S_407 TX_S_408 TX_S_409 TX_S_410 TX_S_411 TX_S_412 TX_S_413 TX_S_414 TX_S_415 TX_S_416 TX_S_417 TX_S_418 TX_S_419 TX_S_420 TX_S_421 TX_S_422 TX_S_423 TX_S_424 TX_S_425 TX_S_426 TX_S_427 TX_S_428 TX_S_429 TX_S_430 TX_S_431 TX_S_432 TX_S_433 TX_S_434 TX_S_435 TX_S_436 TX_S_437 TX_S_438 TX_S_439 TX_S_440 TX_S_441 TX_S_442 TX_S_443 TX_S_444 TX_S_445 TX_S_446 TX_S_447 TX_S_448 TX_S_449 TX_S_450 TX_S_451 TX_S_452 TX_S_453 TX_S_454 TX_S_455 TX_S_456 TX_S_457 TX_S_458 TX_S_459 TX_S_460 TX_S_461 TX_S_462 TX_S_463 TX_S_464 TX_S_465 TX_S_466 TX_S_467 TX_S_468 TX_S_207 TX_S_208 TX_S_209 TX_S_210 TX_S_469 TX_S_351 TX_S_470 TX_S_471 TX_S_213 TX_S_212 TX_S_211 TX_S_475 TX_S_476 TX_S_472 TX_S_0 TX_S_1 TX_S_2 TX_S_3 TX_S_4 TX_S_5 TX_S_6 TX_S_7 TX_S_8 TX_S_9 TX_S_10 TX_S_11 TX_S_12 TX_S_13 TX_S_14 TX_S_15 TX_S_16 TX_S_17 TX_S_18 TX_S_19 TX_S_20 TX_S_21 TX_S_22 TX_S_23 TX_S_24 TX_S_25 TX_S_26 TX_S_27 TX_S_28 TX_S_29 TX_S_30 TX_S_31 TX_S_32 TX_S_33 TX_S_34 TX_S_35 TX_S_36 TX_S_37 TX_S_38 TX_S_39 TX_S_40 TX_S_41 TX_S_42 TX_S_43 TX_S_44 TX_S_45 TX_S_46 TX_S_47 TX_S_48 TX_S_49 TX_S_50 TX_S_51 TX_S_52 TX_S_53 TX_S_54 TX_S_55 TX_S_56 TX_S_57 TX_S_58 TX_S_59 TX_S_60 TX_S_61 TX_S_62 TX_S_63 TX_S_64 TX_S_65 TX_S_66 TX_S_67 TX_S_68 TX_S_69 TX_S_70 TX_S_71 TX_S_72 TX_S_73 TX_S_74 TX_S_75 TX_S_76 TX_S_77 TX_S_78 TX_S_79 TX_S_80 TX_S_81 TX_S_82 TX_S_83 TX_S_84 TX_S_85 TX_S_86 TX_S_87 TX_S_88 TX_S_89 TX_S_90 TX_S_91 TX_S_92 TX_S_93 TX_S_94 TX_S_95 TX_S_96 TX_S_97 TX_S_98 TX_S_99 TX_S_100 TX_S_101 TX_S_102 TX_S_103 TX_S_104 TX_S_105 TX_S_106 TX_S_107 TX_S_108 TX_S_109 TX_S_110 TX_S_111 TX_S_112 TX_S_113 TX_S_114 TX_S_115 TX_S_116 TX_S_117 TX_S_118 TX_S_119 TX_S_120 TX_S_121 TX_S_122 TX_S_123 TX_S_124 TX_S_125 TX_S_126 TX_S_127 TX_S_128 TX_S_129 TX_S_130 TX_S_131 0 0;
[ PrintResponse 
    R ! Implied call parameter
    ;
    if (R == R_319_RESP_A) print (RulePrintingRule) ADJUST_LIGHT_R, " response (A)";
    if (R == R_321_RESP_A) print (RulePrintingRule) GENERATE_ACTION_R, " response (A)";
    if (R == R_321_RESP_B) print (RulePrintingRule) GENERATE_ACTION_R, " response (B)";
    if (R == R_328_RESP_A) print (RulePrintingRule) BASIC_ACCESSIBILITY_R, " response (A)";
    if (R == R_329_RESP_A) print (RulePrintingRule) BASIC_VISIBILITY_R, " response (A)";
    if (R == R_331_RESP_A) print (RulePrintingRule) REQUESTED_ACTIONS_REQUIRE_R, " response (A)";
    if (R == R_332_RESP_A) print (RulePrintingRule) CARRY_OUT_REQUESTED_ACTIONS_R, " response (A)";
    if (R == R_335_RESP_A) print (RulePrintingRule) ACCESS_THROUGH_BARRIERS_R, " response (A)";
    if (R == R_336_RESP_A) print (RulePrintingRule) CANT_REACH_INSIDE_CLOSED_R, " response (A)";
    if (R == R_337_RESP_A) print (RulePrintingRule) CANT_REACH_INSIDE_ROOMS_R, " response (A)";
    if (R == R_338_RESP_A) print (RulePrintingRule) CANT_REACH_OUTSIDE_CLOSED_R, " response (A)";
    if (R == R_339_RESP_A) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (A)";
    if (R == R_339_RESP_B) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (B)";
    if (R == R_339_RESP_C) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (C)";
    if (R == R_339_RESP_D) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (D)";
    if (R == R_339_RESP_E) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (E)";
    if (R == R_339_RESP_F) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (F)";
    if (R == R_339_RESP_G) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (G)";
    if (R == R_339_RESP_H) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (H)";
    if (R == R_339_RESP_I) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (I)";
    if (R == R_339_RESP_J) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (J)";
    if (R == R_339_RESP_K) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (K)";
    if (R == R_339_RESP_L) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (L)";
    if (R == R_339_RESP_M) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (M)";
    if (R == R_339_RESP_N) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (N)";
    if (R == R_339_RESP_O) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (O)";
    if (R == R_339_RESP_P) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (P)";
    if (R == R_339_RESP_Q) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (Q)";
    if (R == R_339_RESP_R) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (R)";
    if (R == R_339_RESP_S) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (S)";
    if (R == R_339_RESP_T) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (T)";
    if (R == R_339_RESP_U) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (U)";
    if (R == R_339_RESP_V) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (V)";
    if (R == R_339_RESP_W) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (W)";
    if (R == R_339_RESP_X) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (X)";
    if (R == R_339_RESP_Y) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (Y)";
    if (R == R_340_RESP_A) print (RulePrintingRule) ACTION_PROCESSING_INTERNAL_R, " response (A)";
    if (R == R_340_RESP_B) print (RulePrintingRule) ACTION_PROCESSING_INTERNAL_R, " response (B)";
    if (R == R_340_RESP_C) print (RulePrintingRule) ACTION_PROCESSING_INTERNAL_R, " response (C)";
    if (R == R_340_RESP_D) print (RulePrintingRule) ACTION_PROCESSING_INTERNAL_R, " response (D)";
    if (R == R_340_RESP_E) print (RulePrintingRule) ACTION_PROCESSING_INTERNAL_R, " response (E)";
    if (R == R_340_RESP_F) print (RulePrintingRule) ACTION_PROCESSING_INTERNAL_R, " response (F)";
    if (R == R_340_RESP_G) print (RulePrintingRule) ACTION_PROCESSING_INTERNAL_R, " response (G)";
    if (R == R_340_RESP_H) print (RulePrintingRule) ACTION_PROCESSING_INTERNAL_R, " response (H)";
    if (R == R_340_RESP_I) print (RulePrintingRule) ACTION_PROCESSING_INTERNAL_R, " response (I)";
    if (R == R_340_RESP_J) print (RulePrintingRule) ACTION_PROCESSING_INTERNAL_R, " response (J)";
    if (R == R_341_RESP_A) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (A)";
    if (R == R_341_RESP_B) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (B)";
    if (R == R_341_RESP_C) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (C)";
    if (R == R_341_RESP_D) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (D)";
    if (R == R_341_RESP_E) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (E)";
    if (R == R_341_RESP_F) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (F)";
    if (R == R_341_RESP_G) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (G)";
    if (R == R_341_RESP_H) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (H)";
    if (R == R_341_RESP_I) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (I)";
    if (R == R_341_RESP_J) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (J)";
    if (R == R_341_RESP_K) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (K)";
    if (R == R_341_RESP_L) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (L)";
    if (R == R_341_RESP_M) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (M)";
    if (R == R_341_RESP_N) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (N)";
    if (R == R_341_RESP_O) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (O)";
    if (R == R_341_RESP_P) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (P)";
    if (R == R_341_RESP_Q) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (Q)";
    if (R == R_341_RESP_R) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (R)";
    if (R == R_341_RESP_S) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (S)";
    if (R == R_341_RESP_T) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (T)";
    if (R == R_341_RESP_U) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (U)";
    if (R == R_341_RESP_V) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (V)";
    if (R == R_341_RESP_W) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (W)";
    if (R == R_341_RESP_X) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (X)";
    if (R == R_342_RESP_A) print (RulePrintingRule) PARSER_N_ERROR_INTERNAL_R, " response (A)";
    if (R == R_342_RESP_B) print (RulePrintingRule) PARSER_N_ERROR_INTERNAL_R, " response (B)";
    if (R == R_342_RESP_C) print (RulePrintingRule) PARSER_N_ERROR_INTERNAL_R, " response (C)";
    if (R == R_342_RESP_D) print (RulePrintingRule) PARSER_N_ERROR_INTERNAL_R, " response (D)";
    if (R == R_342_RESP_E) print (RulePrintingRule) PARSER_N_ERROR_INTERNAL_R, " response (E)";
    if (R == R_342_RESP_F) print (RulePrintingRule) PARSER_N_ERROR_INTERNAL_R, " response (F)";
    if (R == R_343_RESP_A) print (RulePrintingRule) DARKNESS_NAME_INTERNAL_R, " response (A)";
    if (R == R_344_RESP_A) print (RulePrintingRule) PARSER_COMMAND_INTERNAL_R, " response (A)";
    if (R == R_344_RESP_B) print (RulePrintingRule) PARSER_COMMAND_INTERNAL_R, " response (B)";
    if (R == R_344_RESP_C) print (RulePrintingRule) PARSER_COMMAND_INTERNAL_R, " response (C)";
    if (R == R_344_RESP_D) print (RulePrintingRule) PARSER_COMMAND_INTERNAL_R, " response (D)";
    if (R == R_345_RESP_A) print (RulePrintingRule) PARSER_CLARIF_INTERNAL_R, " response (A)";
    if (R == R_345_RESP_B) print (RulePrintingRule) PARSER_CLARIF_INTERNAL_R, " response (B)";
    if (R == R_345_RESP_C) print (RulePrintingRule) PARSER_CLARIF_INTERNAL_R, " response (C)";
    if (R == R_345_RESP_D) print (RulePrintingRule) PARSER_CLARIF_INTERNAL_R, " response (D)";
    if (R == R_345_RESP_E) print (RulePrintingRule) PARSER_CLARIF_INTERNAL_R, " response (E)";
    if (R == R_345_RESP_F) print (RulePrintingRule) PARSER_CLARIF_INTERNAL_R, " response (F)";
    if (R == R_345_RESP_G) print (RulePrintingRule) PARSER_CLARIF_INTERNAL_R, " response (G)";
    if (R == R_345_RESP_H) print (RulePrintingRule) PARSER_CLARIF_INTERNAL_R, " response (H)";
    if (R == R_346_RESP_A) print (RulePrintingRule) YES_OR_NO_QUESTION_INTERNAL_R, " response (A)";
    if (R == R_347_RESP_A) print (RulePrintingRule) PRINT_PROTAGONIST_INTERNAL_R, " response (A)";
    if (R == R_347_RESP_B) print (RulePrintingRule) PRINT_PROTAGONIST_INTERNAL_R, " response (B)";
    if (R == R_347_RESP_C) print (RulePrintingRule) PRINT_PROTAGONIST_INTERNAL_R, " response (C)";
    if (R == R_350_RESP_A) print (RulePrintingRule) STANDARD_IMPLICIT_TAKING_R, " response (A)";
    if (R == R_350_RESP_B) print (RulePrintingRule) STANDARD_IMPLICIT_TAKING_R, " response (B)";
    if (R == R_352_RESP_A) print (RulePrintingRule) PRINT_OBITUARY_HEADLINE_R, " response (A)";
    if (R == R_352_RESP_B) print (RulePrintingRule) PRINT_OBITUARY_HEADLINE_R, " response (B)";
    if (R == R_352_RESP_C) print (RulePrintingRule) PRINT_OBITUARY_HEADLINE_R, " response (C)";
    if (R == R_358_RESP_A) print (RulePrintingRule) IMMEDIATELY_UNDO_R, " response (A)";
    if (R == R_358_RESP_B) print (RulePrintingRule) IMMEDIATELY_UNDO_R, " response (B)";
    if (R == R_358_RESP_C) print (RulePrintingRule) IMMEDIATELY_UNDO_R, " response (C)";
    if (R == R_358_RESP_D) print (RulePrintingRule) IMMEDIATELY_UNDO_R, " response (D)";
    if (R == R_358_RESP_E) print (RulePrintingRule) IMMEDIATELY_UNDO_R, " response (E)";
    if (R == R_361_RESP_A) print (RulePrintingRule) QUIT_THE_GAME_R, " response (A)";
    if (R == R_362_RESP_A) print (RulePrintingRule) SAVE_THE_GAME_R, " response (A)";
    if (R == R_362_RESP_B) print (RulePrintingRule) SAVE_THE_GAME_R, " response (B)";
    if (R == R_363_RESP_A) print (RulePrintingRule) RESTORE_THE_GAME_R, " response (A)";
    if (R == R_363_RESP_B) print (RulePrintingRule) RESTORE_THE_GAME_R, " response (B)";
    if (R == R_364_RESP_A) print (RulePrintingRule) RESTART_THE_GAME_R, " response (A)";
    if (R == R_364_RESP_B) print (RulePrintingRule) RESTART_THE_GAME_R, " response (B)";
    if (R == R_365_RESP_A) print (RulePrintingRule) VERIFY_THE_STORY_FILE_R, " response (A)";
    if (R == R_365_RESP_B) print (RulePrintingRule) VERIFY_THE_STORY_FILE_R, " response (B)";
    if (R == R_366_RESP_A) print (RulePrintingRule) SWITCH_TRANSCRIPT_ON_R, " response (A)";
    if (R == R_366_RESP_B) print (RulePrintingRule) SWITCH_TRANSCRIPT_ON_R, " response (B)";
    if (R == R_366_RESP_C) print (RulePrintingRule) SWITCH_TRANSCRIPT_ON_R, " response (C)";
    if (R == R_367_RESP_A) print (RulePrintingRule) SWITCH_TRANSCRIPT_OFF_R, " response (A)";
    if (R == R_367_RESP_B) print (RulePrintingRule) SWITCH_TRANSCRIPT_OFF_R, " response (B)";
    if (R == R_367_RESP_C) print (RulePrintingRule) SWITCH_TRANSCRIPT_OFF_R, " response (C)";
    if (R == R_369_RESP_A) print (RulePrintingRule) ANNOUNCE_SCORE_R, " response (A)";
    if (R == R_369_RESP_B) print (RulePrintingRule) ANNOUNCE_SCORE_R, " response (B)";
    if (R == R_369_RESP_C) print (RulePrintingRule) ANNOUNCE_SCORE_R, " response (C)";
    if (R == R_369_RESP_D) print (RulePrintingRule) ANNOUNCE_SCORE_R, " response (D)";
    if (R == R_369_RESP_E) print (RulePrintingRule) ANNOUNCE_SCORE_R, " response (E)";
    if (R == R_371_RESP_A) print (RulePrintingRule) REP_PREFER_ABBREVIATED_R, " response (A)";
    if (R == R_373_RESP_A) print (RulePrintingRule) REP_PREFER_UNABBREVIATED_R, " response (A)";
    if (R == R_375_RESP_A) print (RulePrintingRule) REP_PREFER_SOMETIMES_ABBR_R, " response (A)";
    if (R == R_377_RESP_A) print (RulePrintingRule) REP_SWITCH_NOTIFY_ON_R, " response (A)";
    if (R == R_379_RESP_A) print (RulePrintingRule) REP_SWITCH_NOTIFY_OFF_R, " response (A)";
    if (R == R_380_RESP_A) print (RulePrintingRule) ANNOUNCE_PRONOUN_MEANINGS_R, " response (A)";
    if (R == R_380_RESP_B) print (RulePrintingRule) ANNOUNCE_PRONOUN_MEANINGS_R, " response (B)";
    if (R == R_380_RESP_C) print (RulePrintingRule) ANNOUNCE_PRONOUN_MEANINGS_R, " response (C)";
    if (R == R_380_RESP_D) print (RulePrintingRule) ANNOUNCE_PRONOUN_MEANINGS_R, " response (D)";
    if (R == R_274_RESP_A) print (RulePrintingRule) R_811, " response (A)";
    if (R == R_275_RESP_A) print (RulePrintingRule) R_812, " response (A)";
    if (R == R_276_RESP_A) print (RulePrintingRule) R_813, " response (A)";
    if (R == R_277_RESP_A) print (RulePrintingRule) R_814, " response (A)";
    if (R == R_296_RESP_A) print (RulePrintingRule) R_837, " response (A)";
    if (R == R_291_RESP_A) print (RulePrintingRule) R_832, " response (A)";
    if (R == R_290_RESP_A) print (RulePrintingRule) R_831, " response (A)";
    if (R == R_38_RESP_A) print (RulePrintingRule) R_76, " response (A)";
    if (R == R_40_RESP_A) print (RulePrintingRule) R_78, " response (A)";
    if (R == R_40_RESP_B) print (RulePrintingRule) R_78, " response (B)";
    if (R == R_39_RESP_A) print (RulePrintingRule) R_77, " response (A)";
    if (R == R_41_RESP_A) print (RulePrintingRule) R_79, " response (A)";
    if (R == R_45_RESP_A) print (RulePrintingRule) R_85, " response (A)";
    if (R == R_45_RESP_B) print (RulePrintingRule) R_85, " response (B)";
    if (R == R_45_RESP_C) print (RulePrintingRule) R_85, " response (C)";
    if (R == R_45_RESP_D) print (RulePrintingRule) R_85, " response (D)";
    if (R == R_45_RESP_E) print (RulePrintingRule) R_85, " response (E)";
    if (R == R_45_RESP_F) print (RulePrintingRule) R_85, " response (F)";
    if (R == R_52_RESP_A) print (RulePrintingRule) R_92, " response (A)";
    if (R == R_54_RESP_A) print (RulePrintingRule) R_95, " response (A)";
    if (R == R_55_RESP_A) print (RulePrintingRule) R_96, " response (A)";
    if (R == R_56_RESP_A) print (RulePrintingRule) R_97, " response (A)";
    if (R == R_57_RESP_A) print (RulePrintingRule) R_98, " response (A)";
    if (R == R_58_RESP_A) print (RulePrintingRule) R_99, " response (A)";
    if (R == R_59_RESP_A) print (RulePrintingRule) R_100, " response (A)";
    if (R == R_60_RESP_A) print (RulePrintingRule) R_101, " response (A)";
    if (R == R_61_RESP_A) print (RulePrintingRule) R_102, " response (A)";
    if (R == R_62_RESP_A) print (RulePrintingRule) R_103, " response (A)";
    if (R == R_63_RESP_A) print (RulePrintingRule) R_104, " response (A)";
    if (R == R_64_RESP_A) print (RulePrintingRule) R_105, " response (A)";
    if (R == R_65_RESP_A) print (RulePrintingRule) R_106, " response (A)";
    if (R == R_66_RESP_A) print (RulePrintingRule) R_107, " response (A)";
    if (R == R_67_RESP_A) print (RulePrintingRule) R_108, " response (A)";
    if (R == R_68_RESP_A) print (RulePrintingRule) R_109, " response (A)";
    if (R == R_69_RESP_A) print (RulePrintingRule) R_110, " response (A)";
    if (R == R_71_RESP_A) print (RulePrintingRule) R_112, " response (A)";
    if (R == R_71_RESP_B) print (RulePrintingRule) R_112, " response (B)";
    if (R == R_72_RESP_A) print (RulePrintingRule) R_113, " response (A)";
    if (R == R_73_RESP_A) print (RulePrintingRule) R_114, " response (A)";
    if (R == R_76_RESP_A) print (RulePrintingRule) R_117, " response (A)";
    if (R == R_75_RESP_A) print (RulePrintingRule) R_116, " response (A)";
    if (R == R_77_RESP_A) print (RulePrintingRule) R_118, " response (A)";
    if (R == R_78_RESP_A) print (RulePrintingRule) R_119, " response (A)";
    if (R == R_79_RESP_A) print (RulePrintingRule) R_120, " response (A)";
    if (R == R_80_RESP_A) print (RulePrintingRule) R_121, " response (A)";
    if (R == R_80_RESP_B) print (RulePrintingRule) R_121, " response (B)";
    if (R == R_82_RESP_A) print (RulePrintingRule) R_123, " response (A)";
    if (R == R_82_RESP_B) print (RulePrintingRule) R_123, " response (B)";
    if (R == R_85_RESP_A) print (RulePrintingRule) R_126, " response (A)";
    if (R == R_86_RESP_A) print (RulePrintingRule) R_127, " response (A)";
    if (R == R_87_RESP_A) print (RulePrintingRule) R_128, " response (A)";
    if (R == R_88_RESP_A) print (RulePrintingRule) R_129, " response (A)";
    if (R == R_90_RESP_A) print (RulePrintingRule) R_131, " response (A)";
    if (R == R_91_RESP_A) print (RulePrintingRule) R_132, " response (A)";
    if (R == R_94_RESP_A) print (RulePrintingRule) R_135, " response (A)";
    if (R == R_95_RESP_A) print (RulePrintingRule) R_136, " response (A)";
    if (R == R_96_RESP_A) print (RulePrintingRule) R_137, " response (A)";
    if (R == R_97_RESP_A) print (RulePrintingRule) R_138, " response (A)";
    if (R == R_98_RESP_A) print (RulePrintingRule) R_139, " response (A)";
    if (R == R_100_RESP_A) print (RulePrintingRule) R_141, " response (A)";
    if (R == R_101_RESP_A) print (RulePrintingRule) R_142, " response (A)";
    if (R == R_102_RESP_A) print (RulePrintingRule) R_143, " response (A)";
    if (R == R_103_RESP_A) print (RulePrintingRule) R_144, " response (A)";
    if (R == R_104_RESP_A) print (RulePrintingRule) R_145, " response (A)";
    if (R == R_107_RESP_A) print (RulePrintingRule) R_148, " response (A)";
    if (R == R_107_RESP_B) print (RulePrintingRule) R_148, " response (B)";
    if (R == R_109_RESP_A) print (RulePrintingRule) R_150, " response (A)";
    if (R == R_110_RESP_A) print (RulePrintingRule) R_151, " response (A)";
    if (R == R_110_RESP_B) print (RulePrintingRule) R_151, " response (B)";
    if (R == R_111_RESP_A) print (RulePrintingRule) R_152, " response (A)";
    if (R == R_112_RESP_A) print (RulePrintingRule) R_153, " response (A)";
    if (R == R_114_RESP_A) print (RulePrintingRule) R_155, " response (A)";
    if (R == R_114_RESP_B) print (RulePrintingRule) R_155, " response (B)";
    if (R == R_118_RESP_A) print (RulePrintingRule) R_159, " response (A)";
    if (R == R_118_RESP_B) print (RulePrintingRule) R_159, " response (B)";
    if (R == R_118_RESP_C) print (RulePrintingRule) R_159, " response (C)";
    if (R == R_118_RESP_D) print (RulePrintingRule) R_159, " response (D)";
    if (R == R_118_RESP_E) print (RulePrintingRule) R_159, " response (E)";
    if (R == R_118_RESP_F) print (RulePrintingRule) R_159, " response (F)";
    if (R == R_118_RESP_G) print (RulePrintingRule) R_159, " response (G)";
    if (R == R_118_RESP_H) print (RulePrintingRule) R_159, " response (H)";
    if (R == R_118_RESP_I) print (RulePrintingRule) R_159, " response (I)";
    if (R == R_118_RESP_J) print (RulePrintingRule) R_159, " response (J)";
    if (R == R_118_RESP_K) print (RulePrintingRule) R_159, " response (K)";
    if (R == R_118_RESP_L) print (RulePrintingRule) R_159, " response (L)";
    if (R == R_118_RESP_M) print (RulePrintingRule) R_159, " response (M)";
    if (R == R_118_RESP_N) print (RulePrintingRule) R_159, " response (N)";
    if (R == R_118_RESP_O) print (RulePrintingRule) R_159, " response (O)";
    if (R == R_118_RESP_P) print (RulePrintingRule) R_159, " response (P)";
    if (R == R_118_RESP_Q) print (RulePrintingRule) R_159, " response (Q)";
    if (R == R_118_RESP_R) print (RulePrintingRule) R_159, " response (R)";
    if (R == R_118_RESP_S) print (RulePrintingRule) R_159, " response (S)";
    if (R == R_122_RESP_A) print (RulePrintingRule) R_163, " response (A)";
    if (R == R_122_RESP_B) print (RulePrintingRule) R_163, " response (B)";
    if (R == R_123_RESP_A) print (RulePrintingRule) R_164, " response (A)";
    if (R == R_123_RESP_B) print (RulePrintingRule) R_164, " response (B)";
    if (R == R_123_RESP_C) print (RulePrintingRule) R_164, " response (C)";
    if (R == R_123_RESP_D) print (RulePrintingRule) R_164, " response (D)";
    if (R == R_124_RESP_A) print (RulePrintingRule) R_165, " response (A)";
    if (R == R_125_RESP_A) print (RulePrintingRule) R_166, " response (A)";
    if (R == R_125_RESP_B) print (RulePrintingRule) R_166, " response (B)";
    if (R == R_126_RESP_A) print (RulePrintingRule) R_167, " response (A)";
    if (R == R_127_RESP_A) print (RulePrintingRule) R_168, " response (A)";
    if (R == R_127_RESP_B) print (RulePrintingRule) R_168, " response (B)";
    if (R == R_127_RESP_C) print (RulePrintingRule) R_168, " response (C)";
    if (R == R_127_RESP_D) print (RulePrintingRule) R_168, " response (D)";
    if (R == R_127_RESP_E) print (RulePrintingRule) R_168, " response (E)";
    if (R == R_129_RESP_A) print (RulePrintingRule) R_170, " response (A)";
    if (R == R_129_RESP_B) print (RulePrintingRule) R_170, " response (B)";
    if (R == R_129_RESP_C) print (RulePrintingRule) R_170, " response (C)";
    if (R == R_129_RESP_D) print (RulePrintingRule) R_170, " response (D)";
    if (R == R_132_RESP_A) print (RulePrintingRule) R_174, " response (A)";
    if (R == R_133_RESP_A) print (RulePrintingRule) R_175, " response (A)";
    if (R == R_136_RESP_A) print (RulePrintingRule) R_178, " response (A)";
    if (R == R_136_RESP_B) print (RulePrintingRule) R_178, " response (B)";
    if (R == R_136_RESP_C) print (RulePrintingRule) R_178, " response (C)";
    if (R == R_138_RESP_A) print (RulePrintingRule) R_180, " response (A)";
    if (R == R_140_RESP_A) print (RulePrintingRule) R_182, " response (A)";
    if (R == R_144_RESP_A) print (RulePrintingRule) R_186, " response (A)";
    if (R == R_144_RESP_B) print (RulePrintingRule) R_186, " response (B)";
    if (R == R_144_RESP_C) print (RulePrintingRule) R_186, " response (C)";
    if (R == R_145_RESP_A) print (RulePrintingRule) R_187, " response (A)";
    if (R == R_148_RESP_A) print (RulePrintingRule) R_190, " response (A)";
    if (R == R_150_RESP_A) print (RulePrintingRule) R_192, " response (A)";
    if (R == R_151_RESP_A) print (RulePrintingRule) R_193, " response (A)";
    if (R == R_151_RESP_B) print (RulePrintingRule) R_193, " response (B)";
    if (R == R_152_RESP_A) print (RulePrintingRule) R_194, " response (A)";
    if (R == R_153_RESP_A) print (RulePrintingRule) R_195, " response (A)";
    if (R == R_154_RESP_A) print (RulePrintingRule) R_196, " response (A)";
    if (R == R_155_RESP_A) print (RulePrintingRule) R_197, " response (A)";
    if (R == R_156_RESP_A) print (RulePrintingRule) R_198, " response (A)";
    if (R == R_157_RESP_A) print (RulePrintingRule) R_199, " response (A)";
    if (R == R_158_RESP_A) print (RulePrintingRule) R_200, " response (A)";
    if (R == R_159_RESP_A) print (RulePrintingRule) R_201, " response (A)";
    if (R == R_160_RESP_A) print (RulePrintingRule) R_202, " response (A)";
    if (R == R_160_RESP_B) print (RulePrintingRule) R_202, " response (B)";
    if (R == R_161_RESP_A) print (RulePrintingRule) R_203, " response (A)";
    if (R == R_161_RESP_B) print (RulePrintingRule) R_203, " response (B)";
    if (R == R_162_RESP_A) print (RulePrintingRule) R_204, " response (A)";
    if (R == R_163_RESP_A) print (RulePrintingRule) R_205, " response (A)";
    if (R == R_163_RESP_B) print (RulePrintingRule) R_205, " response (B)";
    if (R == R_164_RESP_A) print (RulePrintingRule) R_206, " response (A)";
    if (R == R_165_RESP_A) print (RulePrintingRule) R_207, " response (A)";
    if (R == R_166_RESP_A) print (RulePrintingRule) R_208, " response (A)";
    if (R == R_285_RESP_A) print (RulePrintingRule) R_824, " response (A)";
    if (R == R_169_RESP_A) print (RulePrintingRule) R_211, " response (A)";
    if (R == R_169_RESP_B) print (RulePrintingRule) R_211, " response (B)";
    if (R == R_170_RESP_A) print (RulePrintingRule) R_212, " response (A)";
    if (R == R_171_RESP_A) print (RulePrintingRule) R_213, " response (A)";
    if (R == R_174_RESP_A) print (RulePrintingRule) R_216, " response (A)";
    if (R == R_174_RESP_B) print (RulePrintingRule) R_216, " response (B)";
    if (R == R_175_RESP_A) print (RulePrintingRule) R_217, " response (A)";
    if (R == R_176_RESP_A) print (RulePrintingRule) R_218, " response (A)";
    if (R == R_178_RESP_A) print (RulePrintingRule) R_220, " response (A)";
    if (R == R_179_RESP_A) print (RulePrintingRule) R_221, " response (A)";
    if (R == R_180_RESP_A) print (RulePrintingRule) R_222, " response (A)";
    if (R == R_182_RESP_A) print (RulePrintingRule) R_224, " response (A)";
    if (R == R_183_RESP_A) print (RulePrintingRule) R_225, " response (A)";
    if (R == R_184_RESP_A) print (RulePrintingRule) R_226, " response (A)";
    if (R == R_185_RESP_A) print (RulePrintingRule) R_227, " response (A)";
    if (R == R_187_RESP_A) print (RulePrintingRule) R_229, " response (A)";
    if (R == R_188_RESP_A) print (RulePrintingRule) R_230, " response (A)";
    if (R == R_188_RESP_B) print (RulePrintingRule) R_230, " response (B)";
    if (R == R_188_RESP_C) print (RulePrintingRule) R_230, " response (C)";
    if (R == R_189_RESP_A) print (RulePrintingRule) R_231, " response (A)";
    if (R == R_190_RESP_A) print (RulePrintingRule) R_232, " response (A)";
    if (R == R_192_RESP_A) print (RulePrintingRule) R_234, " response (A)";
    if (R == R_192_RESP_B) print (RulePrintingRule) R_234, " response (B)";
    if (R == R_192_RESP_C) print (RulePrintingRule) R_234, " response (C)";
    if (R == R_193_RESP_A) print (RulePrintingRule) R_235, " response (A)";
    if (R == R_194_RESP_A) print (RulePrintingRule) R_236, " response (A)";
    if (R == R_195_RESP_A) print (RulePrintingRule) R_237, " response (A)";
    if (R == R_197_RESP_A) print (RulePrintingRule) R_239, " response (A)";
    if (R == R_197_RESP_B) print (RulePrintingRule) R_239, " response (B)";
    if (R == R_198_RESP_A) print (RulePrintingRule) R_241, " response (A)";
    if (R == R_199_RESP_A) print (RulePrintingRule) R_242, " response (A)";
    if (R == R_201_RESP_A) print (RulePrintingRule) R_244, " response (A)";
    if (R == R_201_RESP_B) print (RulePrintingRule) R_244, " response (B)";
    if (R == R_202_RESP_A) print (RulePrintingRule) R_245, " response (A)";
    if (R == R_203_RESP_A) print (RulePrintingRule) R_246, " response (A)";
    if (R == R_204_RESP_A) print (RulePrintingRule) R_247, " response (A)";
    if (R == R_205_RESP_A) print (RulePrintingRule) R_248, " response (A)";
    if (R == R_206_RESP_A) print (RulePrintingRule) R_249, " response (A)";
    if (R == R_207_RESP_A) print (RulePrintingRule) R_250, " response (A)";
    if (R == R_209_RESP_A) print (RulePrintingRule) R_252, " response (A)";
    if (R == R_209_RESP_B) print (RulePrintingRule) R_252, " response (B)";
    if (R == R_209_RESP_C) print (RulePrintingRule) R_252, " response (C)";
    if (R == R_210_RESP_A) print (RulePrintingRule) R_253, " response (A)";
    if (R == R_212_RESP_A) print (RulePrintingRule) R_255, " response (A)";
    if (R == R_213_RESP_A) print (RulePrintingRule) R_256, " response (A)";
    if (R == R_214_RESP_A) print (RulePrintingRule) R_257, " response (A)";
    if (R == R_215_RESP_A) print (RulePrintingRule) R_258, " response (A)";
    if (R == R_216_RESP_A) print (RulePrintingRule) R_259, " response (A)";
    if (R == R_217_RESP_A) print (RulePrintingRule) R_260, " response (A)";
    if (R == R_218_RESP_A) print (RulePrintingRule) R_261, " response (A)";
    if (R == R_219_RESP_A) print (RulePrintingRule) R_262, " response (A)";
    if (R == R_220_RESP_A) print (RulePrintingRule) R_263, " response (A)";
    if (R == R_221_RESP_A) print (RulePrintingRule) R_264, " response (A)";
    if (R == R_222_RESP_A) print (RulePrintingRule) R_265, " response (A)";
    if (R == R_223_RESP_A) print (RulePrintingRule) R_266, " response (A)";
    if (R == R_226_RESP_A) print (RulePrintingRule) R_269, " response (A)";
    if (R == R_226_RESP_B) print (RulePrintingRule) R_269, " response (B)";
    if (R == R_227_RESP_A) print (RulePrintingRule) R_270, " response (A)";
    if (R == R_227_RESP_B) print (RulePrintingRule) R_270, " response (B)";
    if (R == R_228_RESP_A) print (RulePrintingRule) R_271, " response (A)";
    if (R == R_228_RESP_B) print (RulePrintingRule) R_271, " response (B)";
    if (R == R_228_RESP_C) print (RulePrintingRule) R_271, " response (C)";
    if (R == R_229_RESP_A) print (RulePrintingRule) R_272, " response (A)";
    if (R == R_229_RESP_B) print (RulePrintingRule) R_272, " response (B)";
    if (R == R_230_RESP_A) print (RulePrintingRule) R_273, " response (A)";
    if (R == R_231_RESP_A) print (RulePrintingRule) R_274, " response (A)";
    if (R == R_231_RESP_B) print (RulePrintingRule) R_274, " response (B)";
    if (R == R_232_RESP_A) print (RulePrintingRule) R_275, " response (A)";
    if (R == R_233_RESP_A) print (RulePrintingRule) R_276, " response (A)";
    if (R == R_234_RESP_A) print (RulePrintingRule) R_277, " response (A)";
    if (R == R_235_RESP_A) print (RulePrintingRule) R_278, " response (A)";
    if (R == R_235_RESP_B) print (RulePrintingRule) R_278, " response (B)";
    if (R == R_236_RESP_A) print (RulePrintingRule) R_279, " response (A)";
    if (R == R_237_RESP_A) print (RulePrintingRule) R_280, " response (A)";
    if (R == R_238_RESP_A) print (RulePrintingRule) R_281, " response (A)";
    if (R == R_239_RESP_A) print (RulePrintingRule) R_282, " response (A)";
    if (R == R_239_RESP_B) print (RulePrintingRule) R_282, " response (B)";
    if (R == R_240_RESP_A) print (RulePrintingRule) R_283, " response (A)";
    if (R == R_241_RESP_A) print (RulePrintingRule) R_284, " response (A)";
    if (R == R_242_RESP_A) print (RulePrintingRule) R_285, " response (A)";
    if (R == R_243_RESP_A) print (RulePrintingRule) R_286, " response (A)";
    if (R == R_243_RESP_B) print (RulePrintingRule) R_286, " response (B)";
    if (R == R_244_RESP_A) print (RulePrintingRule) R_287, " response (A)";
    if (R == R_245_RESP_A) print (RulePrintingRule) R_288, " response (A)";
    if (R == R_246_RESP_A) print (RulePrintingRule) R_289, " response (A)";
    if (R == R_247_RESP_A) print (RulePrintingRule) R_290, " response (A)";
    if (R == R_249_RESP_A) print (RulePrintingRule) R_292, " response (A)";
    if (R == R_250_RESP_A) print (RulePrintingRule) R_293, " response (A)";
    if (R == R_251_RESP_A) print (RulePrintingRule) R_294, " response (A)";
    if (R == R_251_RESP_B) print (RulePrintingRule) R_294, " response (B)";
    if (R == R_252_RESP_A) print (RulePrintingRule) R_295, " response (A)";
    if (R == R_253_RESP_A) print (RulePrintingRule) R_296, " response (A)";
    if (R == R_254_RESP_A) print (RulePrintingRule) R_297, " response (A)";
    if (R == R_255_RESP_A) print (RulePrintingRule) R_298, " response (A)";
    if (R == R_256_RESP_A) print (RulePrintingRule) R_299, " response (A)";
    if (R == R_257_RESP_A) print (RulePrintingRule) R_300, " response (A)";
    if (R == R_257_RESP_B) print (RulePrintingRule) R_300, " response (B)";
    if (R == R_258_RESP_A) print (RulePrintingRule) R_301, " response (A)";
    if (R == R_258_RESP_B) print (RulePrintingRule) R_301, " response (B)";
    if (R == R_259_RESP_A) print (RulePrintingRule) R_302, " response (A)";
    if (R == R_259_RESP_B) print (RulePrintingRule) R_302, " response (B)";
    if (R == R_260_RESP_A) print (RulePrintingRule) R_303, " response (A)";
    if (R == R_261_RESP_A) print (RulePrintingRule) R_304, " response (A)";
    if (R == R_261_RESP_B) print (RulePrintingRule) R_304, " response (B)";
    if (R == R_262_RESP_A) print (RulePrintingRule) R_305, " response (A)";
    if (R == R_263_RESP_A) print (RulePrintingRule) R_306, " response (A)";
    if (R == R_264_RESP_A) print (RulePrintingRule) R_307, " response (A)";
    if (R == R_265_RESP_A) print (RulePrintingRule) R_308, " response (A)";
    if (R == R_266_RESP_A) print (RulePrintingRule) R_309, " response (A)";
    if (R == R_267_RESP_A) print (RulePrintingRule) R_310, " response (A)";
    if (R == R_267_RESP_B) print (RulePrintingRule) R_310, " response (B)";
    if (R == R_268_RESP_A) print (RulePrintingRule) R_311, " response (A)";
    if (R == R_269_RESP_A) print (RulePrintingRule) R_312, " response (A)";
    if (R == R_269_RESP_B) print (RulePrintingRule) R_312, " response (B)";
    if (R == R_270_RESP_A) print (RulePrintingRule) R_313, " response (A)";
    if (R == R_271_RESP_A) print (RulePrintingRule) R_314, " response (A)";
    if (R == R_272_RESP_A) print (RulePrintingRule) R_315, " response (A)";
    if (R == R_283_RESP_A) print (RulePrintingRule) R_821, " response (A)";
    if (R == R_287_RESP_A) print (RulePrintingRule) R_826, " response (A)";
    if (R == R_289_RESP_A) print (RulePrintingRule) R_829, " response (A)";
    if (R == R_312_RESP_A) print (RulePrintingRule) R_910, " response (A)";
    if (R == R_167_RESP_A) print (RulePrintingRule) R_209, " response (A)";
    if (R == R_172_RESP_A) print (RulePrintingRule) R_214, " response (A)";
    if (R == R_303_RESP_A) print (RulePrintingRule) R_844, " response (A)";
    if (R == R_304_RESP_A) print (RulePrintingRule) R_845, " response (A)";
];
[ STANDARD_RESPONSE_ISSUING_R ;
    RegardingSingleObject(); TEXT_TY_Say(ResponseTexts-->(parameter_value-1));
];
Array ResponseDivisions -->
    "Standard Rules" 1 256
    EMPTY_TEXT_PACKED 271 401
    "Locksmith by Emily Short" 257 269
    "Basic Screen Effects by Emily Short" 270 270
    0 0 0;
[ R_TX_S_0 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[It] [are] [if story tense is present tense]now [end if]pitch dark in
    [if story tense is present tense]here[else]there[end if]!~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_800_r67 ());ParaContent(); print " ";ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " ";
    	if (~~((((story_tense == I105_present_tense))))) jump L_Say967;ParaContent(); print "now ";
    	.L_Say967; .L_SayX964;ParaContent(); print "pitch dark in ";
    	if (~~((((story_tense == I105_present_tense))))) jump L_Say968;ParaContent(); print "here";
    	jump L_SayX965; .L_Say968;ParaContent(); print "there";
    	.L_Say969; .L_SayX965;ParaContent(); print "!"; .L_Say970; .L_SayX966;
    rtrue;
];
Array TX_S_0 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_0;
[ R_TX_S_1 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~(considering the first sixteen objects only)[command clarification break]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "(considering the first sixteen objects only)";ParaContent(); CommandClarificationBreak(); .L_Say971; .L_SayX967;
    rtrue;
];
Array TX_S_1 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_1;
[ R_TX_S_2 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Nothing to do!~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Nothing to do!"; .L_Say972; .L_SayX968;
    rtrue;
];
Array TX_S_2 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_2;
[ R_TX_S_3 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~You must name something more substantial.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "You must name something more substantial."; .L_Say973; .L_SayX969;
    rtrue;
];
Array TX_S_3 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_3;
[ R_TX_S_4 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~It is pitch dark, and you can't see a thing.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "It is pitch dark, and you can't see a thing."; .L_Say974; .L_SayX970;
    rtrue;
];
Array TX_S_4 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_4;
[ R_TX_S_5 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The noun] [have] better things to do.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) noun;ParaContent(); print " ";ConjugateVerb_2(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " better things to do."; .L_Say975; .L_SayX971;
    rtrue;
];
Array TX_S_5 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_5;
[ R_TX_S_6 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The noun] [are] unable to do that.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) noun;ParaContent(); print " ";ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " unable to do that."; .L_Say976; .L_SayX972;
    rtrue;
];
Array TX_S_6 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_6;
[ R_TX_S_7 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][Those] [aren't] available.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); RegardingSingleObject(noun);ParaContent(); (PHR_785_r52 ());ParaContent(); print " ";ConjugateVerb_76(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " available."; .L_Say977; .L_SayX973;
    rtrue;
];
Array TX_S_7 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_7;
[ R_TX_S_8 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The noun] [aren't] open.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) noun;ParaContent(); print " ";ConjugateVerb_76(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " open."; .L_Say978; .L_SayX974;
    rtrue;
];
Array TX_S_8 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_8;
[ R_TX_S_9 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [can't] reach into [the noun].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ParaContent(); print " ";ConjugateVerb_77(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " reach into ";ParaContent(); print (the) noun;ParaContent(); print "."; .L_Say979; .L_SayX975;
    rtrue;
];
Array TX_S_9 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_9;
[ R_TX_S_10 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The noun] [aren't] open.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) noun;ParaContent(); print " ";ConjugateVerb_76(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " open."; .L_Say980; .L_SayX976;
    rtrue;
];
Array TX_S_10 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_10;
[ R_TX_S_11 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~ (~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print " ("; .L_Say981; .L_SayX977;
    rtrue;
];
Array TX_S_11 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_11;
[ R_TX_S_12 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~)~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print ")"; .L_Say982; .L_SayX978;
    rtrue;
];
Array TX_S_12 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_12;
[ R_TX_S_13 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~ and ~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print " and "; .L_Say983; .L_SayX979;
    rtrue;
];
Array TX_S_13 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_13;
[ R_TX_S_14 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~providing light~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "providing light"; .L_Say984; .L_SayX980;
    rtrue;
];
Array TX_S_14 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_14;
[ R_TX_S_15 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~closed~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "closed"; .L_Say985; .L_SayX981;
    rtrue;
];
Array TX_S_15 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_15;
[ R_TX_S_16 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~empty~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "empty"; .L_Say986; .L_SayX982;
    rtrue;
];
Array TX_S_16 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_16;
[ R_TX_S_17 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~closed and empty~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "closed and empty"; .L_Say987; .L_SayX983;
    rtrue;
];
Array TX_S_17 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_17;
[ R_TX_S_18 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~closed and providing light~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "closed and providing light"; .L_Say988; .L_SayX984;
    rtrue;
];
Array TX_S_18 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_18;
[ R_TX_S_19 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~empty and providing light~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "empty and providing light"; .L_Say989; .L_SayX985;
    rtrue;
];
Array TX_S_19 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_19;
[ R_TX_S_20 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~closed, empty[if serial comma option is active],[end if] and providing light~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "closed, empty";
    	if (~~(((((Adj_25_t1_v16(6))))))) jump L_Say990;ParaContent(); print ",";
    	.L_Say990; .L_SayX986;ParaContent(); print " and providing light"; .L_Say991; .L_SayX987;
    rtrue;
];
Array TX_S_20 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_20;
[ R_TX_S_21 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~providing light and being worn~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "providing light and being worn"; .L_Say992; .L_SayX988;
    rtrue;
];
Array TX_S_21 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_21;
[ R_TX_S_22 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~being worn~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "being worn"; .L_Say993; .L_SayX989;
    rtrue;
];
Array TX_S_22 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_22;
[ R_TX_S_23 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~open~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "open"; .L_Say994; .L_SayX990;
    rtrue;
];
Array TX_S_23 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_23;
[ R_TX_S_24 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~open but empty~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "open but empty"; .L_Say995; .L_SayX991;
    rtrue;
];
Array TX_S_24 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_24;
[ R_TX_S_25 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~closed~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "closed"; .L_Say996; .L_SayX992;
    rtrue;
];
Array TX_S_25 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_25;
[ R_TX_S_26 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~closed and locked~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "closed and locked"; .L_Say997; .L_SayX993;
    rtrue;
];
Array TX_S_26 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_26;
[ R_TX_S_27 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~containing~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "containing"; .L_Say998; .L_SayX994;
    rtrue;
];
Array TX_S_27 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_27;
[ R_TX_S_28 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~on [if the noun is a person]whom[otherwise]which[end if] ~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "on ";
    	if (~~((((noun ofclass K8_person))))) jump L_Say999;ParaContent(); print "whom";
    	jump L_SayX995; .L_Say999;ParaContent(); print "which";
    	.L_Say1000; .L_SayX995;ParaContent(); print " "; .L_Say1001; .L_SayX996;
    rtrue;
];
Array TX_S_28 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_28;
[ R_TX_S_29 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~, on top of [if the noun is a person]whom[otherwise]which[end if] ~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print ", on top of ";
    	if (~~((((noun ofclass K8_person))))) jump L_Say1002;ParaContent(); print "whom";
    	jump L_SayX997; .L_Say1002;ParaContent(); print "which";
    	.L_Say1003; .L_SayX997;ParaContent(); print " "; .L_Say1004; .L_SayX998;
    rtrue;
];
Array TX_S_29 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_29;
[ R_TX_S_30 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~in [if the noun is a person]whom[otherwise]which[end if] ~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "in ";
    	if (~~((((noun ofclass K8_person))))) jump L_Say1005;ParaContent(); print "whom";
    	jump L_SayX999; .L_Say1005;ParaContent(); print "which";
    	.L_Say1006; .L_SayX999;ParaContent(); print " "; .L_Say1007; .L_SayX1000;
    rtrue;
];
Array TX_S_30 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_30;
[ R_TX_S_31 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~, inside [if the noun is a person]whom[otherwise]which[end if] ~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print ", inside ";
    	if (~~((((noun ofclass K8_person))))) jump L_Say1008;ParaContent(); print "whom";
    	jump L_SayX1001; .L_Say1008;ParaContent(); print "which";
    	.L_Say1009; .L_SayX1001;ParaContent(); print " "; .L_Say1010; .L_SayX1002;
    rtrue;
];
Array TX_S_31 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_31;
[ R_TX_S_32 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding list writer internals][are]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); RegardingLWI();ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1;  .L_Say1011; .L_SayX1003;
    rtrue;
];
Array TX_S_32 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_32;
[ R_TX_S_33 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding list writer internals][are] nothing~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); RegardingLWI();ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " nothing"; .L_Say1012; .L_SayX1004;
    rtrue;
];
Array TX_S_33 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_33;
[ R_TX_S_34 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Nothing~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Nothing"; .L_Say1013; .L_SayX1005;
    rtrue;
];
Array TX_S_34 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_34;
[ R_TX_S_35 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~nothing~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "nothing"; .L_Say1014; .L_SayX1006;
    rtrue;
];
Array TX_S_35 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_35;
[ R_TX_S_36 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[bracket]That command asks to do something outside of play, so it can
    only make sense from you to me. [The noun] cannot be asked to do this.[close
    bracket]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "[";ParaContent(); print "That command asks to do something outside of play, so it can only make sense from you to me. ";ParaContent(); print (The) noun;ParaContent(); print " cannot be asked to do this.";ParaContent(); print "]"; .L_Say1015; .L_SayX1007;
    rtrue;
];
Array TX_S_36 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_36;
[ R_TX_S_37 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~You must name an object.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "You must name an object."; .L_Say1016; .L_SayX1008;
    rtrue;
];
Array TX_S_37 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_37;
[ R_TX_S_38 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~You may not name an object.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "You may not name an object."; .L_Say1017; .L_SayX1009;
    rtrue;
];
Array TX_S_38 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_38;
[ R_TX_S_39 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~You must supply a noun.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "You must supply a noun."; .L_Say1018; .L_SayX1010;
    rtrue;
];
Array TX_S_39 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_39;
[ R_TX_S_40 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~You may not supply a noun.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "You may not supply a noun."; .L_Say1019; .L_SayX1011;
    rtrue;
];
Array TX_S_40 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_40;
[ R_TX_S_41 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~You must name a second object.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "You must name a second object."; .L_Say1020; .L_SayX1012;
    rtrue;
];
Array TX_S_41 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_41;
[ R_TX_S_42 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~You may not name a second object.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "You may not name a second object."; .L_Say1021; .L_SayX1013;
    rtrue;
];
Array TX_S_42 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_42;
[ R_TX_S_43 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~You must supply a second noun.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "You must supply a second noun."; .L_Say1022; .L_SayX1014;
    rtrue;
];
Array TX_S_43 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_43;
[ R_TX_S_44 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~You may not supply a second noun.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "You may not supply a second noun."; .L_Say1023; .L_SayX1015;
    rtrue;
];
Array TX_S_44 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_44;
[ R_TX_S_45 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~(Since something dramatic has happened, your list of commands has been
    cut short.)~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "(Since something dramatic has happened, your list of commands has been cut short.)"; .L_Say1024; .L_SayX1016;
    rtrue;
];
Array TX_S_45 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_45;
[ R_TX_S_46 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~I didn't understand that sentence.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "I didn't understand that sentence."; .L_Say1025; .L_SayX1017;
    rtrue;
];
Array TX_S_46 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_46;
[ R_TX_S_47 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~I only understood you as far as wanting to ~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "I only understood you as far as wanting to "; .L_Say1026; .L_SayX1018;
    rtrue;
];
Array TX_S_47 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_47;
[ R_TX_S_48 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~I only understood you as far as wanting to (go) ~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "I only understood you as far as wanting to (go) "; .L_Say1027; .L_SayX1019;
    rtrue;
];
Array TX_S_48 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_48;
[ R_TX_S_49 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~I didn't understand that number.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "I didn't understand that number."; .L_Say1028; .L_SayX1020;
    rtrue;
];
Array TX_S_49 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_49;
[ R_TX_S_50 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [can't] see any such thing.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ParaContent(); print " ";ConjugateVerb_77(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " see any such thing."; .L_Say1029; .L_SayX1021;
    rtrue;
];
Array TX_S_50 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_50;
[ R_TX_S_51 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~You seem to have said too little!~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "You seem to have said too little!"; .L_Say1030; .L_SayX1022;
    rtrue;
];
Array TX_S_51 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_51;
[ R_TX_S_52 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [aren't] holding that!~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ParaContent(); print " ";ConjugateVerb_76(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " holding that!"; .L_Say1031; .L_SayX1023;
    rtrue;
];
Array TX_S_52 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_52;
[ R_TX_S_53 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~You can't use multiple objects with that verb.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "You can't use multiple objects with that verb."; .L_Say1032; .L_SayX1024;
    rtrue;
];
Array TX_S_53 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_53;
[ R_TX_S_54 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~You can only use multiple objects once on a line.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "You can only use multiple objects once on a line."; .L_Say1033; .L_SayX1025;
    rtrue;
];
Array TX_S_54 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_54;
[ R_TX_S_55 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~I'm not sure what ['][pronoun i6 dictionary word]['] refers to.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "I'm not sure what ";ParaContent(); print "'";ParaContent(); print (address) pronoun_word;ParaContent(); print "'";ParaContent(); print " refers to."; .L_Say1034; .L_SayX1026;
    rtrue;
];
Array TX_S_55 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_55;
[ R_TX_S_56 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [can't] see ['][pronoun i6 dictionary word]['] ([the noun]) at the moment.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ParaContent(); print " ";ConjugateVerb_77(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " see ";ParaContent(); print "'";ParaContent(); print (address) pronoun_word;ParaContent(); print "'";ParaContent(); print " (";ParaContent(); print (the) noun;ParaContent(); print ") at the moment."; .L_Say1035; .L_SayX1027;
    rtrue;
];
Array TX_S_56 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_56;
[ R_TX_S_57 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~You excepted something not included anyway!~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "You excepted something not included anyway!"; .L_Say1036; .L_SayX1028;
    rtrue;
];
Array TX_S_57 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_57;
[ R_TX_S_58 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~You can only do that to something animate.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "You can only do that to something animate."; .L_Say1037; .L_SayX1029;
    rtrue;
];
Array TX_S_58 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_58;
[ R_TX_S_59 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~That's not a verb I [if American dialect option is
    active]recognize[otherwise]recognise[end if].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "That's not a verb I ";
    	if (~~(((((Adj_25_t1_v16(5))))))) jump L_Say1038;ParaContent(); print "recognize";
    	jump L_SayX1030; .L_Say1038;ParaContent(); print "recognise";
    	.L_Say1039; .L_SayX1030;ParaContent(); print "."; .L_Say1040; .L_SayX1031;
    rtrue;
];
Array TX_S_59 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_59;
[ R_TX_S_60 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~That's not something you need to refer to in the course of this game.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "That's not something you need to refer to in the course of this game."; .L_Say1041; .L_SayX1032;
    rtrue;
];
Array TX_S_60 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_60;
[ R_TX_S_61 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~I didn't understand the way that finished.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "I didn't understand the way that finished."; .L_Say1042; .L_SayX1033;
    rtrue;
];
Array TX_S_61 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_61;
[ R_TX_S_62 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[if number understood is 0]None[otherwise]Only [number understood][end if]
    of those [are] available.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;
    	if (~~((((parsed_number == 0))))) jump L_Say1043;ParaContent(); print "None";
    	jump L_SayX1034; .L_Say1043;ParaContent(); print "Only ";ParaContent(); print (say__n=parsed_number);
    	.L_Say1044; .L_SayX1034;ParaContent(); print " of those ";ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " available."; .L_Say1045; .L_SayX1035;
    rtrue;
];
Array TX_S_62 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_62;
[ R_TX_S_63 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~That noun did not make sense in this context.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "That noun did not make sense in this context."; .L_Say1046; .L_SayX1036;
    rtrue;
];
Array TX_S_63 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_63;
[ R_TX_S_64 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~To repeat a command like 'frog, jump', just say 'again', not 'frog, again'.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "To repeat a command like ~frog, jump~, just say ~again~, not ~frog, again~."; .L_Say1047; .L_SayX1037;
    rtrue;
];
Array TX_S_64 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_64;
[ R_TX_S_65 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~You can't begin with a comma.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "You can't begin with a comma."; .L_Say1048; .L_SayX1038;
    rtrue;
];
Array TX_S_65 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_65;
[ R_TX_S_66 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~You seem to want to talk to someone, but I can't see whom.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "You seem to want to talk to someone, but I can't see whom."; .L_Say1049; .L_SayX1039;
    rtrue;
];
Array TX_S_66 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_66;
[ R_TX_S_67 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~You can't talk to [the noun].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "You can't talk to ";ParaContent(); print (the) noun;ParaContent(); print "."; .L_Say1050; .L_SayX1040;
    rtrue;
];
Array TX_S_67 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_67;
[ R_TX_S_68 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~To talk to someone, try 'someone, hello' or some such.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "To talk to someone, try ~someone, hello~ or some such."; .L_Say1051; .L_SayX1041;
    rtrue;
];
Array TX_S_68 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_68;
[ R_TX_S_69 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~I beg your pardon?~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "I beg your pardon?"; .L_Say1052; .L_SayX1042;
    rtrue;
];
Array TX_S_69 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_69;
[ R_TX_S_70 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Nothing to do!~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Nothing to do!"; .L_Say1053; .L_SayX1043;
    rtrue;
];
Array TX_S_70 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_70;
[ R_TX_S_71 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~There are none at all available!~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "There are none at all available!"; .L_Say1054; .L_SayX1044;
    rtrue;
];
Array TX_S_71 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_71;
[ R_TX_S_72 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][Those] [seem] to belong to [the noun].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); RegardingSingleObject(noun);ParaContent(); (PHR_785_r52 ());ParaContent(); print " ";ConjugateVerb_55(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " to belong to ";ParaContent(); print (the) noun;ParaContent(); print "."; .L_Say1055; .L_SayX1045;
    rtrue;
];
Array TX_S_72 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_72;
[ R_TX_S_73 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][Those] [can't] contain things.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); RegardingSingleObject(noun);ParaContent(); (PHR_785_r52 ());ParaContent(); print " ";ConjugateVerb_77(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " contain things."; .L_Say1056; .L_SayX1046;
    rtrue;
];
Array TX_S_73 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_73;
[ R_TX_S_74 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The noun] [aren't] open.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) noun;ParaContent(); print " ";ConjugateVerb_76(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " open."; .L_Say1057; .L_SayX1047;
    rtrue;
];
Array TX_S_74 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_74;
[ R_TX_S_75 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The noun] [are] empty.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) noun;ParaContent(); print " ";ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " empty."; .L_Say1058; .L_SayX1048;
    rtrue;
];
Array TX_S_75 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_75;
[ R_TX_S_76 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Darkness~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Darkness"; .L_Say1059; .L_SayX1049;
    rtrue;
];
Array TX_S_76 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_76;
[ R_TX_S_77 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Sorry, that can't be corrected.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Sorry, that can't be corrected."; .L_Say1060; .L_SayX1050;
    rtrue;
];
Array TX_S_77 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_77;
[ R_TX_S_78 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Think nothing of it.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Think nothing of it."; .L_Say1061; .L_SayX1051;
    rtrue;
];
Array TX_S_78 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_78;
[ R_TX_S_79 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~'Oops' can only correct a single word.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "~Oops~ can only correct a single word."; .L_Say1062; .L_SayX1052;
    rtrue;
];
Array TX_S_79 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_79;
[ R_TX_S_80 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~You can hardly repeat that.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "You can hardly repeat that."; .L_Say1063; .L_SayX1053;
    rtrue;
];
Array TX_S_80 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_80;
[ R_TX_S_81 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Who do you mean, ~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Who do you mean, "; .L_Say1064; .L_SayX1054;
    rtrue;
];
Array TX_S_81 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_81;
[ R_TX_S_82 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Which do you mean, ~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Which do you mean, "; .L_Say1065; .L_SayX1055;
    rtrue;
];
Array TX_S_82 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_82;
[ R_TX_S_83 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Sorry, you can only have one item here. Which exactly?~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Sorry, you can only have one item here. Which exactly?"; .L_Say1066; .L_SayX1056;
    rtrue;
];
Array TX_S_83 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_83;
[ R_TX_S_84 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Whom do you want [if the noun is not the player][the noun] [end if]to
    [parser command so far]?~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Whom do you want ";
    	if (~~((((~~((noun == player))))))) jump L_Say1067;ParaContent(); print (the) noun;ParaContent(); print " ";
    	.L_Say1067; .L_SayX1057;ParaContent(); print "to ";ParaContent(); PrintCommand();ParaContent(); print "?"; .L_Say1068; .L_SayX1058;
    rtrue;
];
Array TX_S_84 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_84;
[ R_TX_S_85 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~What do you want [if the noun is not the player][the noun] [end if]to
    [parser command so far]?~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "What do you want ";
    	if (~~((((~~((noun == player))))))) jump L_Say1069;ParaContent(); print (the) noun;ParaContent(); print " ";
    	.L_Say1069; .L_SayX1059;ParaContent(); print "to ";ParaContent(); PrintCommand();ParaContent(); print "?"; .L_Say1070; .L_SayX1060;
    rtrue;
];
Array TX_S_85 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_85;
[ R_TX_S_86 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~those things~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "those things"; .L_Say1071; .L_SayX1061;
    rtrue;
];
Array TX_S_86 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_86;
[ R_TX_S_87 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~that~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "that"; .L_Say1072; .L_SayX1062;
    rtrue;
];
Array TX_S_87 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_87;
[ R_TX_S_88 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~ or ~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print " or "; .L_Say1073; .L_SayX1063;
    rtrue;
];
Array TX_S_88 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_88;
[ R_TX_S_89 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Please answer yes or no.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Please answer yes or no."; .L_Say1074; .L_SayX1064;
    rtrue;
];
Array TX_S_89 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_89;
[ R_TX_S_90 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ()); .L_Say1075; .L_SayX1065;
    rtrue;
];
Array TX_S_90 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_90;
[ R_TX_S_91 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[ourselves]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_777_r44 ()); .L_Say1076; .L_SayX1066;
    rtrue;
];
Array TX_S_91 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_91;
[ R_TX_S_92 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[our] former self~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_778_r45 ());ParaContent(); print " former self"; .L_Say1077; .L_SayX1067;
    rtrue;
];
Array TX_S_92 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_92;
[ R_TX_S_93 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~(first taking [the noun])[command clarification break]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "(first taking ";ParaContent(); print (the) noun;ParaContent(); print ")";ParaContent(); CommandClarificationBreak(); .L_Say1078; .L_SayX1068;
    rtrue;
];
Array TX_S_93 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_93;
[ R_TX_S_94 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~([the second noun] first taking [the noun])[command clarification break]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "(";ParaContent(); print (the) second;ParaContent(); print " first taking ";ParaContent(); print (the) noun;ParaContent(); print ")";ParaContent(); CommandClarificationBreak(); .L_Say1079; .L_SayX1069;
    rtrue;
];
Array TX_S_94 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_94;
[ R_TX_S_95 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~ You have died ~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print " You have died "; .L_Say1080; .L_SayX1070;
    rtrue;
];
Array TX_S_95 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_95;
[ R_TX_S_96 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~ You have won ~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print " You have won "; .L_Say1081; .L_SayX1071;
    rtrue;
];
Array TX_S_96 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_96;
[ R_TX_S_97 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~ The End ~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print " The End "; .L_Say1082; .L_SayX1072;
    rtrue;
];
Array TX_S_97 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_97;
[ R_TX_S_98 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~The use of 'undo' is forbidden in this game.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "The use of ~undo~ is forbidden in this game."; .L_Say1083; .L_SayX1073;
    rtrue;
];
Array TX_S_98 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_98;
[ R_TX_S_99 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~You can't 'undo' what hasn't been done!~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "You can't ~undo~ what hasn't been done!"; .L_Say1084; .L_SayX1074;
    rtrue;
];
Array TX_S_99 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_99;
[ R_TX_S_100 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Your interpreter does not provide 'undo'. Sorry!~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Your interpreter does not provide ~undo~. Sorry!"; .L_Say1085; .L_SayX1075;
    rtrue;
];
Array TX_S_100 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_100;
[ R_TX_S_101 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~'Undo' failed. Sorry!~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "~Undo~ failed. Sorry!"; .L_Say1086; .L_SayX1076;
    rtrue;
];
Array TX_S_101 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_101;
[ R_TX_S_102 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[bracket]Previous turn undone.[close bracket]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "[";ParaContent(); print "Previous turn undone.";ParaContent(); print "]"; .L_Say1087; .L_SayX1077;
    rtrue;
];
Array TX_S_102 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_102;
[ R_TX_S_103 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Are you sure you want to quit? ~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Are you sure you want to quit? "; .L_Say1088; .L_SayX1078;
    rtrue;
];
Array TX_S_103 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_103;
[ R_TX_S_104 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Save failed.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Save failed."; .L_Say1089; .L_SayX1079;
    rtrue;
];
Array TX_S_104 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_104;
[ R_TX_S_105 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Ok.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Ok."; .L_Say1090; .L_SayX1080;
    rtrue;
];
Array TX_S_105 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_105;
[ R_TX_S_106 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Restore failed.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Restore failed."; .L_Say1091; .L_SayX1081;
    rtrue;
];
Array TX_S_106 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_106;
[ R_TX_S_107 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Ok.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Ok."; .L_Say1092; .L_SayX1082;
    rtrue;
];
Array TX_S_107 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_107;
[ R_TX_S_108 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Are you sure you want to restart? ~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Are you sure you want to restart? "; .L_Say1093; .L_SayX1083;
    rtrue;
];
Array TX_S_108 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_108;
[ R_TX_S_109 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Failed.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Failed."; .L_Say1094; .L_SayX1084;
    rtrue;
];
Array TX_S_109 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_109;
[ R_TX_S_110 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~The game file has verified as intact.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "The game file has verified as intact."; .L_Say1095; .L_SayX1085;
    rtrue;
];
Array TX_S_110 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_110;
[ R_TX_S_111 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~The game file did not verify as intact, and may be corrupt.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "The game file did not verify as intact, and may be corrupt."; .L_Say1096; .L_SayX1086;
    rtrue;
];
Array TX_S_111 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_111;
[ R_TX_S_112 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Transcripting is already on.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Transcripting is already on."; .L_Say1097; .L_SayX1087;
    rtrue;
];
Array TX_S_112 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_112;
[ R_TX_S_113 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Start of a transcript of~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Start of a transcript of"; .L_Say1098; .L_SayX1088;
    rtrue;
];
Array TX_S_113 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_113;
[ R_TX_S_114 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Attempt to begin transcript failed.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Attempt to begin transcript failed."; .L_Say1099; .L_SayX1089;
    rtrue;
];
Array TX_S_114 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_114;
[ R_TX_S_115 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Transcripting is already off.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Transcripting is already off."; .L_Say1100; .L_SayX1090;
    rtrue;
];
Array TX_S_115 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_115;
[ R_TX_S_116 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[line break]End of transcript.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); new_line;ParaContent(); print "End of transcript."; .L_Say1101; .L_SayX1091;
    rtrue;
];
Array TX_S_116 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_116;
[ R_TX_S_117 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Attempt to end transcript failed.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Attempt to end transcript failed."; .L_Say1102; .L_SayX1092;
    rtrue;
];
Array TX_S_117 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_117;
[ R_TX_S_118 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[if the story has ended]In that game you scored[otherwise]You have so far scored[end if]
    [score] out of a possible [maximum score], in [turn count] turn[s]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;
    	if (~~((((deadflag~=0))))) jump L_Say1103;ParaContent(); print "In that game you scored";
    	jump L_SayX1093; .L_Say1103;ParaContent(); print "You have so far scored";
    	.L_Say1104; .L_SayX1093;ParaContent(); print " ";ParaContent(); print (say__n=score);ParaContent(); print " out of a possible ";ParaContent(); print (say__n=MAX_SCORE);ParaContent(); print ", in ";ParaContent(); print (say__n=turns);ParaContent(); print " turn";ParaContent(); STextSubstitution(); .L_Say1105; .L_SayX1094;
    rtrue;
];
Array TX_S_118 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_118;
[ R_TX_S_119 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~, earning you the rank of ~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print ", earning you the rank of "; .L_Say1106; .L_SayX1095;
    rtrue;
];
Array TX_S_119 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_119;
[ R_TX_S_120 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[There] [are] no score in this story.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_801_r68 ());ParaContent(); print " ";ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " no score in this story."; .L_Say1107; .L_SayX1096;
    rtrue;
];
Array TX_S_120 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_120;
[ R_TX_S_121 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[bracket]Your score has just gone up by [number understood in words]
    point[s].[close bracket]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "[";ParaContent(); print "Your score has just gone up by ";ParaContent(); print (number) say__n=(parsed_number);ParaContent(); print " point";ParaContent(); STextSubstitution();ParaContent(); print ".";ParaContent(); print "]"; .L_Say1108; .L_SayX1097;
    rtrue;
];
Array TX_S_121 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_121;
[ R_TX_S_122 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[bracket]Your score has just gone down by [number understood in words]
    point[s].[close bracket]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "[";ParaContent(); print "Your score has just gone down by ";ParaContent(); print (number) say__n=(parsed_number);ParaContent(); print " point";ParaContent(); STextSubstitution();ParaContent(); print ".";ParaContent(); print "]"; .L_Say1109; .L_SayX1098;
    rtrue;
];
Array TX_S_122 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_122;
[ R_TX_S_123 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~ is now in its 'superbrief' mode, which always gives short descriptions
    of locations (even if you haven't been there before).~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print " is now in its ~superbrief~ mode, which always gives short descriptions of locations (even if you haven't been there before)."; .L_Say1110; .L_SayX1099;
    rtrue;
];
Array TX_S_123 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_123;
[ R_TX_S_124 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~ is now in its 'verbose' mode, which always gives long descriptions of
    locations (even if you've been there before).~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print " is now in its ~verbose~ mode, which always gives long descriptions of locations (even if you've been there before)."; .L_Say1111; .L_SayX1100;
    rtrue;
];
Array TX_S_124 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_124;
[ R_TX_S_125 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~ is now in its 'brief' printing mode, which gives long descriptions
    of places never before visited and short descriptions otherwise.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print " is now in its ~brief~ printing mode, which gives long descriptions of places never before visited and short descriptions otherwise."; .L_Say1112; .L_SayX1101;
    rtrue;
];
Array TX_S_125 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_125;
[ R_TX_S_126 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Score notification on.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Score notification on."; .L_Say1113; .L_SayX1102;
    rtrue;
];
Array TX_S_126 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_126;
[ R_TX_S_127 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Score notification off.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Score notification off."; .L_Say1114; .L_SayX1103;
    rtrue;
];
Array TX_S_127 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_127;
[ R_TX_S_128 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~At the moment, ~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "At the moment, "; .L_Say1115; .L_SayX1104;
    rtrue;
];
Array TX_S_128 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_128;
[ R_TX_S_129 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~means ~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "means "; .L_Say1116; .L_SayX1105;
    rtrue;
];
Array TX_S_129 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_129;
[ R_TX_S_130 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~is unset~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "is unset"; .L_Say1117; .L_SayX1106;
    rtrue;
];
Array TX_S_130 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_130;
[ R_TX_S_131 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~no pronouns are known to the game.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "no pronouns are known to the game."; .L_Say1118; .L_SayX1107;
    rtrue;
];
Array TX_S_131 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_131;
[ R_TX_S_207 
    tmp_0 ! Let/loop value, e.g., 'blocking door': door
    ;
    tmp_0=LocalParking-->0;
#ifdef DEBUG; if (suppress_text_substitution) { print "~(first opening [the blocking door])[command clarification break]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "(first opening ";ParaContent(); print (the) tmp_0;ParaContent(); print ")";ParaContent(); CommandClarificationBreak(); .L_Say1119; .L_SayX1108;
    rtrue;
];
Array TX_S_207 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_207;
[ R_TX_S_208 
    tmp_0 ! Let/loop value, e.g., 'door ajar': thing
    ;
    tmp_0=LocalParking-->0;
#ifdef DEBUG; if (suppress_text_substitution) { print "~(first closing [the door ajar])[command clarification break]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "(first closing ";ParaContent(); print (the) tmp_0;ParaContent(); print ")";ParaContent(); CommandClarificationBreak(); .L_Say1120; .L_SayX1109;
    rtrue;
];
Array TX_S_208 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_208;
[ R_TX_S_209 
    tmp_0 ! Let/loop value, e.g., 'door ajar': thing
    ;
    tmp_0=LocalParking-->0;
#ifdef DEBUG; if (suppress_text_substitution) { print "~(first closing [the door ajar])[command clarification break]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "(first closing ";ParaContent(); print (the) tmp_0;ParaContent(); print ")";ParaContent(); CommandClarificationBreak(); .L_Say1121; .L_SayX1110;
    rtrue;
];
Array TX_S_209 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_209;
[ R_TX_S_210 
    tmp_0 ! Let/loop value, e.g., 'sealed chest': thing
    ;
    tmp_0=LocalParking-->0;
#ifdef DEBUG; if (suppress_text_substitution) { print "~(first unlocking [the sealed chest])[command clarification break]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "(first unlocking ";ParaContent(); print (the) tmp_0;ParaContent(); print ")";ParaContent(); CommandClarificationBreak(); .L_Say1122; .L_SayX1111;
    rtrue;
];
Array TX_S_210 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_210;
[ R_TX_S_211 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The noun] [are] not a key.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) noun;ParaContent(); print " ";ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " not a key."; .L_Say1123; .L_SayX1112;
    rtrue;
];
Array TX_S_211 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_211;
[ R_TX_S_212 
    tmp_0 ! Let/loop value, e.g., '?-1,-1?'(deallocated by end of phrase)
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The noun] [unlock] [the list of things unbolted by the noun].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) noun;ParaContent(); print " ";ConjugateVerb_20(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " ";ParaContent(); objectloop(tmp_0 ofclass Object)
    			if (((tmp_0 ofclass K2_thing) && (noun == (RGuard_f0_2(tmp_0)))))
    				give tmp_0 workflag2;
    			else
    				give tmp_0 ~workflag2;
    		WriteListOfMarkedObjects(ENGLISH_BIT+DEFART_BIT);ParaContent(); print "."; .L_Say1124; .L_SayX1113;
    rtrue;
];
Array TX_S_212 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_212;
[ R_TX_S_213 
    tmp_0 ! Let/loop value, e.g., 'item': passkey
    tmp_1 ! Let/loop value, e.g., '?-1,-1?'(deallocated by end of phrase)
    ;
    tmp_0=LocalParking-->0;
#ifdef DEBUG; if (suppress_text_substitution) { print "~ (which [open] [the list of things unbolted by the item])~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print " (which ";ConjugateVerb_45(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " ";ParaContent(); objectloop(tmp_1 ofclass Object)
    			if (((tmp_1 ofclass K2_thing) && (tmp_0 == (RGuard_f0_2(tmp_1)))))
    				give tmp_1 workflag2;
    			else
    				give tmp_1 ~workflag2;
    		WriteListOfMarkedObjects(ENGLISH_BIT+DEFART_BIT);ParaContent(); print ")"; .L_Say1125; .L_SayX1114;
    rtrue;
];
Array TX_S_213 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_213;
[ R_TX_S_214 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~You'll have to say which compass direction to go in.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "You'll have to say which compass direction to go in."; .L_Say1126; .L_SayX1115;
    rtrue;
];
Array TX_S_214 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_214;
[ R_TX_S_215 
    tmp_0 ! Let/loop value, e.g., 'named options count': number
    tmp_1 ! Let/loop value, e.g., '?-1,-1?': object
    tmp_2 ! Let/loop value, e.g., '?-1,-1?': object
    ct_0 ! internal use only
    ct_1 ! internal use only
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Would you like to ~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Would you like to "; .L_Say1127; .L_SayX1116;
    rtrue;
];
Array TX_S_215 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_215;
[ R_TX_S_216 
    tmp_0 ! Let/loop value, e.g., 'named options count': number
    tmp_1 ! Let/loop value, e.g., '?-1,-1?': object
    tmp_2 ! Let/loop value, e.g., '?-1,-1?': object
    ct_0 ! internal use only
    ct_1 ! internal use only
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~ or ~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print " or "; .L_Say1128; .L_SayX1117;
    rtrue;
];
Array TX_S_216 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_216;
[ R_TX_S_217 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~> [run paragraph on]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "> ";ParaContent(); RunParagraphOn(); .L_Say1129; .L_SayX1118;
    rtrue;
];
Array TX_S_217 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_217;
[ R_TX_S_218 
    tmp_0 ! Let/loop value, e.g., '?-1,-1?': object
    tmp_1 ! Let/loop value, e.g., '?-1,-1?': object
    ct_0 ! internal use only
    ct_1 ! internal use only
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Please give one of the answers above.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Please give one of the answers above."; .L_Say1130; .L_SayX1119;
    rtrue;
];
Array TX_S_218 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_218;
[ R_TX_S_219 
    tmp_0 ! Let/loop value, e.g., 'domain': object
    tmp_1 ! Let/loop value, e.g., 'mentionable count': number
    tmp_2 ! Let/loop value, e.g., '?-1,-1?': thing
    tmp_3 ! Let/loop value, e.g., '?-1,-1?': thing
    ct_0 ! internal use only
    ct_1 ! internal use only
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] ~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ParaContent(); print " "; .L_Say1131; .L_SayX1120;
    rtrue;
];
Array TX_S_219 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_219;
[ R_TX_S_220 
    tmp_0 ! Let/loop value, e.g., 'domain': object
    tmp_1 ! Let/loop value, e.g., 'mentionable count': number
    tmp_2 ! Let/loop value, e.g., '?-1,-1?': thing
    tmp_3 ! Let/loop value, e.g., '?-1,-1?': thing
    ct_0 ! internal use only
    ct_1 ! internal use only
    ;
    tmp_0=LocalParking-->0;
tmp_1=LocalParking-->1;
tmp_2=LocalParking-->2;
tmp_3=LocalParking-->3;
ct_0=LocalParking-->4;
ct_1=LocalParking-->5;
#ifdef DEBUG; if (suppress_text_substitution) { print "~On [the domain] [we] ~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "On ";ParaContent(); print (the) tmp_0;ParaContent(); print " ";ParaContent(); (PHR_774_r41 ());ParaContent(); print " "; .L_Say1132; .L_SayX1121;
    rtrue;
];
Array TX_S_220 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_220;
[ R_TX_S_221 
    tmp_0 ! Let/loop value, e.g., 'domain': object
    tmp_1 ! Let/loop value, e.g., 'mentionable count': number
    tmp_2 ! Let/loop value, e.g., '?-1,-1?': thing
    tmp_3 ! Let/loop value, e.g., '?-1,-1?': thing
    ct_0 ! internal use only
    ct_1 ! internal use only
    ;
    tmp_0=LocalParking-->0;
tmp_1=LocalParking-->1;
tmp_2=LocalParking-->2;
tmp_3=LocalParking-->3;
ct_0=LocalParking-->4;
ct_1=LocalParking-->5;
#ifdef DEBUG; if (suppress_text_substitution) { print "~In [the domain] [we] ~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "In ";ParaContent(); print (the) tmp_0;ParaContent(); print " ";ParaContent(); (PHR_774_r41 ());ParaContent(); print " "; .L_Say1133; .L_SayX1122;
    rtrue;
];
Array TX_S_221 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_221;
[ R_TX_S_222 
    tmp_0 ! Let/loop value, e.g., 'domain': object
    tmp_1 ! Let/loop value, e.g., 'mentionable count': number
    tmp_2 ! Let/loop value, e.g., '?-1,-1?': thing
    tmp_3 ! Let/loop value, e.g., '?-1,-1?': thing
    ct_0 ! internal use only
    ct_1 ! internal use only
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[can] also see ~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ConjugateVerb_15(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " also see "; .L_Say1134; .L_SayX1123;
    rtrue;
];
Array TX_S_222 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_222;
[ R_TX_S_223 
    tmp_0 ! Let/loop value, e.g., 'domain': object
    tmp_1 ! Let/loop value, e.g., 'mentionable count': number
    tmp_2 ! Let/loop value, e.g., '?-1,-1?': thing
    tmp_3 ! Let/loop value, e.g., '?-1,-1?': thing
    ct_0 ! internal use only
    ct_1 ! internal use only
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[can] see ~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ConjugateVerb_15(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " see "; .L_Say1135; .L_SayX1124;
    rtrue;
];
Array TX_S_223 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_223;
[ R_TX_S_224 
    tmp_0 ! Let/loop value, e.g., 'domain': object
    tmp_1 ! Let/loop value, e.g., 'mentionable count': number
    tmp_2 ! Let/loop value, e.g., 'common holder': object
    tmp_3 ! Let/loop value, e.g., 'contents form of list': truth state
    tmp_4 ! Let/loop value, e.g., '?-1,-1?': object
    tmp_5 ! Let/loop value, e.g., '?-1,-1?': thing
    ct_0 ! internal use only
    ct_1 ! internal use only
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~ here~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print " here"; .L_Say1136; .L_SayX1125;
    rtrue;
];
Array TX_S_224 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_224;
[ R_TX_S_225 
    tmp_0 ! Let/loop value, e.g., 'item': thing
    tmp_1 ! Let/loop value, e.g., '?-1,-1?': thing
    tmp_2 ! Let/loop value, e.g., '?-1,-1?': thing
    ;
    tmp_0=LocalParking-->0;
tmp_1=LocalParking-->1;
tmp_2=LocalParking-->2;
#ifdef DEBUG; if (suppress_text_substitution) { print "~On [the item] ~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "On ";ParaContent(); print (the) tmp_0;ParaContent(); print " "; .L_Say1137; .L_SayX1126;
    rtrue;
];
Array TX_S_225 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_225;
[ R_TX_S_226 
    tmp_0 ! Let/loop value, e.g., 'item': thing
    tmp_1 ! Let/loop value, e.g., '?-1,-1?': thing
    tmp_2 ! Let/loop value, e.g., '?-1,-1?': thing
    ;
    tmp_0=LocalParking-->0;
tmp_1=LocalParking-->1;
tmp_2=LocalParking-->2;
#ifdef DEBUG; if (suppress_text_substitution) { print "~On [the item] ~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "On ";ParaContent(); print (the) tmp_0;ParaContent(); print " "; .L_Say1138; .L_SayX1127;
    rtrue;
];
Array TX_S_226 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_226;
[ R_TX_S_227 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [are] carrying nothing.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ParaContent(); print " ";ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " carrying nothing."; .L_Say1139; .L_SayX1128;
    rtrue;
];
Array TX_S_227 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_227;
[ R_TX_S_228 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [are] carrying:[line break]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ParaContent(); print " ";ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " carrying:";ParaContent(); new_line; .L_Say1140; .L_SayX1129;
    rtrue;
];
Array TX_S_228 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_228;
[ R_TX_S_229 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [look] through [their] possessions.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) actor;ParaContent(); print " ";ConjugateVerb_43(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " through ";ParaContent(); (PHR_790_r57 ());ParaContent(); print " possessions."; .L_Say1141; .L_SayX1130;
    rtrue;
];
Array TX_S_229 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_229;
[ R_TX_S_230 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [are] always self-possessed.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ParaContent(); print " ";ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " always self-possessed."; .L_Say1142; .L_SayX1131;
    rtrue;
];
Array TX_S_230 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_230;
[ R_TX_S_231 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~I don't suppose [the noun] [would care] for that.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "I don't suppose ";ParaContent(); print (the) noun;ParaContent(); print " ";ConjugateVerb_73(CV_POS, PNToVP(), story_tense, ConjugateVerb_24); say__p=1; ParaContent(); print " for that."; .L_Say1143; .L_SayX1132;
    rtrue;
];
Array TX_S_231 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_231;
[ R_TX_S_232 
    tmp_0 ! Let/loop value, e.g., 'whole': thing
    ;
    tmp_0=LocalParking-->0;
#ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][Those] [seem] to be a part of [the whole].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); RegardingSingleObject(noun);ParaContent(); (PHR_785_r52 ());ParaContent(); print " ";ConjugateVerb_55(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " to be a part of ";ParaContent(); print (the) tmp_0;ParaContent(); print "."; .L_Say1144; .L_SayX1133;
    rtrue;
];
Array TX_S_232 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_232;
[ R_TX_S_233 
    tmp_0 ! Let/loop value, e.g., 'local ceiling': object
    tmp_1 ! Let/loop value, e.g., 'owner': object
    ;
    tmp_0=LocalParking-->0;
tmp_1=LocalParking-->1;
#ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][Those] [seem] to belong to [the owner].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); RegardingSingleObject(noun);ParaContent(); (PHR_785_r52 ());ParaContent(); print " ";ConjugateVerb_55(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " to belong to ";ParaContent(); print (the) tmp_1;ParaContent(); print "."; .L_Say1145; .L_SayX1134;
    rtrue;
];
Array TX_S_233 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_233;
[ R_TX_S_234 
    tmp_0 ! Let/loop value, e.g., 'H': object
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][Those] [aren't] available.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); RegardingSingleObject(noun);ParaContent(); (PHR_785_r52 ());ParaContent(); print " ";ConjugateVerb_76(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " available."; .L_Say1146; .L_SayX1135;
    rtrue;
];
Array TX_S_234 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_234;
[ R_TX_S_235 
    tmp_0 ! Let/loop value, e.g., 'local ceiling': object
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [would have] to get
    [if noun is a supporter]off[otherwise]out of[end if] [the noun] first.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ParaContent(); print " ";ConjugateVerb_73(CV_POS, PNToVP(), story_tense, ConjugateVerb_2); say__p=1; ParaContent(); print " to get ";
    	if (~~((((noun ofclass K6_supporter))))) jump L_Say1147;ParaContent(); print "off";
    	jump L_SayX1136; .L_Say1147;ParaContent(); print "out of";
    	.L_Say1148; .L_SayX1136;ParaContent(); print " ";ParaContent(); print (the) noun;ParaContent(); print " first."; .L_Say1149; .L_SayX1137;
    rtrue;
];
Array TX_S_235 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_235;
[ R_TX_S_236 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] already [have] [regarding the noun][those].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ParaContent(); print " already ";ConjugateVerb_2(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " ";ParaContent(); RegardingSingleObject(noun);ParaContent(); (PHR_784_r51 ());ParaContent(); print "."; .L_Say1150; .L_SayX1138;
    rtrue;
];
Array TX_S_236 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_236;
[ R_TX_S_237 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][They're] hardly portable.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); RegardingSingleObject(noun);ParaContent(); (PHR_799_r66 ());ParaContent(); print " hardly portable."; .L_Say1151; .L_SayX1139;
    rtrue;
];
Array TX_S_237 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_237;
[ R_TX_S_238 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [cannot] carry [the noun].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ParaContent(); print " ";ConjugateVerb_15(CV_NEG, PNToVP(), story_tense); say__p=1; ParaContent(); print " carry ";ParaContent(); print (the) noun;ParaContent(); print "."; .L_Say1152; .L_SayX1140;
    rtrue;
];
Array TX_S_238 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_238;
[ R_TX_S_239 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][They're] fixed in place.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); RegardingSingleObject(noun);ParaContent(); (PHR_799_r66 ());ParaContent(); print " fixed in place."; .L_Say1153; .L_SayX1141;
    rtrue;
];
Array TX_S_239 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_239;
[ R_TX_S_240 
    tmp_0 ! Let/loop value, e.g., 'current working sack': player's holdall
    tmp_1 ! Let/loop value, e.g., 'transferred item': object
    tmp_2 ! Let/loop value, e.g., '?-1,-1?': thing
    tmp_3 ! Let/loop value, e.g., '?-1,-1?': thing
    ;
    tmp_0=LocalParking-->0;
tmp_1=LocalParking-->1;
tmp_2=LocalParking-->2;
tmp_3=LocalParking-->3;
#ifdef DEBUG; if (suppress_text_substitution) { print "~(putting [the transferred item] into [the current working sack]
    to make room)[command clarification break]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "(putting ";ParaContent(); print (the) tmp_1;ParaContent(); print " into ";ParaContent(); print (the) tmp_0;ParaContent(); print " to make room)";ParaContent(); CommandClarificationBreak(); .L_Say1154; .L_SayX1142;
    rtrue;
];
Array TX_S_240 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_240;
[ R_TX_S_241 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We]['re] carrying too many things already.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ConjugateVerb_74(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " carrying too many things already."; .L_Say1155; .L_SayX1143;
    rtrue;
];
Array TX_S_241 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_241;
[ R_TX_S_242 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Taken.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Taken."; .L_Say1156; .L_SayX1144;
    rtrue;
];
Array TX_S_242 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_242;
[ R_TX_S_243 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [pick] up [the noun].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) actor;ParaContent(); print " ";ConjugateVerb_47(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " up ";ParaContent(); print (the) noun;ParaContent(); print "."; .L_Say1157; .L_SayX1145;
    rtrue;
];
Array TX_S_243 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_243;
[ R_TX_S_244 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~But [regarding the noun][they] [aren't] there now.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "But ";ParaContent(); RegardingSingleObject(noun);ParaContent(); (PHR_788_r55 ());ParaContent(); print " ";ConjugateVerb_76(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " there now."; .L_Say1158; .L_SayX1146;
    rtrue;
];
Array TX_S_244 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_244;
[ R_TX_S_245 
    tmp_0 ! Let/loop value, e.g., 'owner': object
    ;
    tmp_0=LocalParking-->0;
#ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][Those] [seem] to belong to [the owner].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); RegardingSingleObject(noun);ParaContent(); (PHR_785_r52 ());ParaContent(); print " ";ConjugateVerb_55(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " to belong to ";ParaContent(); print (the) tmp_0;ParaContent(); print "."; .L_Say1159; .L_SayX1147;
    rtrue;
];
Array TX_S_245 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_245;
[ R_TX_S_246 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [can't drop] part of [ourselves].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ParaContent(); print " ";ConjugateVerb_77(CV_POS, PNToVP(), story_tense, ConjugateVerb_28); say__p=1; ParaContent(); print " part of ";ParaContent(); (PHR_777_r44 ());ParaContent(); print "."; .L_Say1160; .L_SayX1148;
    rtrue;
];
Array TX_S_246 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_246;
[ R_TX_S_247 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [lack] the dexterity.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ParaContent(); print " ";ConjugateVerb_38(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " the dexterity."; .L_Say1161; .L_SayX1149;
    rtrue;
];
Array TX_S_247 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_247;
[ R_TX_S_248 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The noun] [are] already here.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) noun;ParaContent(); print " ";ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " already here."; .L_Say1162; .L_SayX1150;
    rtrue;
];
Array TX_S_248 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_248;
[ R_TX_S_249 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [haven't] got [regarding the noun][those].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ParaContent(); print " ";ConjugateVerb_78(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " got ";ParaContent(); RegardingSingleObject(noun);ParaContent(); (PHR_784_r51 ());ParaContent(); print "."; .L_Say1163; .L_SayX1151;
    rtrue;
];
Array TX_S_249 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_249;
[ R_TX_S_250 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~(first taking [the noun] off)[command clarification break]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "(first taking ";ParaContent(); print (the) noun;ParaContent(); print " off)";ParaContent(); CommandClarificationBreak(); .L_Say1164; .L_SayX1152;
    rtrue;
];
Array TX_S_250 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_250;
[ R_TX_S_251 
    tmp_0 ! Let/loop value, e.g., 'receptacle': object
    ;
    tmp_0=LocalParking-->0;
#ifdef DEBUG; if (suppress_text_substitution) { print "~[There] [are] no more room on [the receptacle].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_801_r68 ());ParaContent(); print " ";ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " no more room on ";ParaContent(); print (the) tmp_0;ParaContent(); print "."; .L_Say1165; .L_SayX1153;
    rtrue;
];
Array TX_S_251 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_251;
[ R_TX_S_252 
    tmp_0 ! Let/loop value, e.g., 'receptacle': object
    ;
    tmp_0=LocalParking-->0;
#ifdef DEBUG; if (suppress_text_substitution) { print "~[There] [are] no more room in [the receptacle].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_801_r68 ());ParaContent(); print " ";ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " no more room in ";ParaContent(); print (the) tmp_0;ParaContent(); print "."; .L_Say1166; .L_SayX1154;
    rtrue;
];
Array TX_S_252 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_252;
[ R_TX_S_253 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Dropped.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Dropped."; .L_Say1167; .L_SayX1155;
    rtrue;
];
Array TX_S_253 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_253;
[ R_TX_S_254 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [put] down [the noun].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) actor;ParaContent(); print " ";ConjugateVerb_51(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " down ";ParaContent(); print (the) noun;ParaContent(); print "."; .L_Say1168; .L_SayX1156;
    rtrue;
];
Array TX_S_254 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_254;
[ R_TX_S_255 
    tmp_0 ! Let/loop value, e.g., 'noun-CPC': object
    tmp_1 ! Let/loop value, e.g., 'second-CPC': object
    tmp_2 ! Let/loop value, e.g., 'transfer ceiling': object
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [can't put] something on top of itself.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ParaContent(); print " ";ConjugateVerb_77(CV_POS, PNToVP(), story_tense, ConjugateVerb_51); say__p=1; ParaContent(); print " something on top of itself."; .L_Say1169; .L_SayX1157;
    rtrue;
];
Array TX_S_255 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_255;
[ R_TX_S_256 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Putting things on [the second noun] [would achieve] nothing.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Putting things on ";ParaContent(); print (the) second;ParaContent(); print " ";ConjugateVerb_73(CV_POS, PNToVP(), story_tense, ConjugateVerb_21); say__p=1; ParaContent(); print " nothing."; .L_Say1170; .L_SayX1158;
    rtrue;
];
Array TX_S_256 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_256;
[ R_TX_S_257 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~(first taking [regarding the noun][them] off)[command clarification break]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "(first taking ";ParaContent(); RegardingSingleObject(noun);ParaContent(); (PHR_792_r59 ());ParaContent(); print " off)";ParaContent(); CommandClarificationBreak(); .L_Say1171; .L_SayX1159;
    rtrue;
];
Array TX_S_257 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_257;
[ R_TX_S_258 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[There] [are] no more room on [the second noun].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_801_r68 ());ParaContent(); print " ";ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " no more room on ";ParaContent(); print (the) second;ParaContent(); print "."; .L_Say1172; .L_SayX1160;
    rtrue;
];
Array TX_S_258 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_258;
[ R_TX_S_259 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Done.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Done."; .L_Say1173; .L_SayX1161;
    rtrue;
];
Array TX_S_259 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_259;
[ R_TX_S_260 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [put] [the noun] on [the second noun].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) actor;ParaContent(); print " ";ConjugateVerb_51(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " ";ParaContent(); print (the) noun;ParaContent(); print " on ";ParaContent(); print (the) second;ParaContent(); print "."; .L_Say1174; .L_SayX1162;
    rtrue;
];
Array TX_S_260 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_260;
[ R_TX_S_261 
    tmp_0 ! Let/loop value, e.g., 'noun-CPC': object
    tmp_1 ! Let/loop value, e.g., 'second-CPC': object
    tmp_2 ! Let/loop value, e.g., 'transfer ceiling': object
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [can't put] something inside itself.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ParaContent(); print " ";ConjugateVerb_77(CV_POS, PNToVP(), story_tense, ConjugateVerb_51); say__p=1; ParaContent(); print " something inside itself."; .L_Say1175; .L_SayX1163;
    rtrue;
];
Array TX_S_261 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_261;
[ R_TX_S_262 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The second noun] [are] closed.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) second;ParaContent(); print " ";ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " closed."; .L_Say1176; .L_SayX1164;
    rtrue;
];
Array TX_S_262 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_262;
[ R_TX_S_263 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the second noun][Those] [can't contain] things.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); RegardingSingleObject(second);ParaContent(); (PHR_785_r52 ());ParaContent(); print " ";ConjugateVerb_77(CV_POS, PNToVP(), story_tense, ConjugateVerb_7); say__p=1; ParaContent(); print " things."; .L_Say1177; .L_SayX1165;
    rtrue;
];
Array TX_S_263 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_263;
[ R_TX_S_264 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~(first taking [regarding the noun][them] off)[command clarification break]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "(first taking ";ParaContent(); RegardingSingleObject(noun);ParaContent(); (PHR_792_r59 ());ParaContent(); print " off)";ParaContent(); CommandClarificationBreak(); .L_Say1178; .L_SayX1166;
    rtrue;
];
Array TX_S_264 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_264;
[ R_TX_S_265 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[There] [are] no more room in [the second noun].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_801_r68 ());ParaContent(); print " ";ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " no more room in ";ParaContent(); print (the) second;ParaContent(); print "."; .L_Say1179; .L_SayX1167;
    rtrue;
];
Array TX_S_265 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_265;
[ R_TX_S_266 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Done.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Done."; .L_Say1180; .L_SayX1168;
    rtrue;
];
Array TX_S_266 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_266;
[ R_TX_S_267 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [put] [the noun] into [the second noun].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) actor;ParaContent(); print " ";ConjugateVerb_51(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " ";ParaContent(); print (the) noun;ParaContent(); print " into ";ParaContent(); print (the) second;ParaContent(); print "."; .L_Say1181; .L_SayX1169;
    rtrue;
];
Array TX_S_267 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_267;
[ R_TX_S_268 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][They're] plainly inedible.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); RegardingSingleObject(noun);ParaContent(); (PHR_799_r66 ());ParaContent(); print " plainly inedible."; .L_Say1182; .L_SayX1170;
    rtrue;
];
Array TX_S_268 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_268;
[ R_TX_S_269 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~(first taking [the noun] off)[command clarification break]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "(first taking ";ParaContent(); print (the) noun;ParaContent(); print " off)";ParaContent(); CommandClarificationBreak(); .L_Say1183; .L_SayX1171;
    rtrue;
];
Array TX_S_269 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_269;
[ R_TX_S_270 
    tmp_0 ! Let/loop value, e.g., 'owner': person
    ;
    tmp_0=LocalParking-->0;
#ifdef DEBUG; if (suppress_text_substitution) { print "~[The owner] [might not appreciate] that.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) tmp_0;ParaContent(); print " ";ConjugateVerb_70(CV_NEG, PNToVP(), story_tense, ConjugateVerb_22); say__p=1; ParaContent(); print " that."; .L_Say1184; .L_SayX1172;
    rtrue;
];
Array TX_S_270 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_270;
[ R_TX_S_271 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [eat] [the noun]. Not bad.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ParaContent(); print " ";ConjugateVerb_29(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " ";ParaContent(); print (the) noun;ParaContent(); print ". Not bad."; .L_Say1185; .L_SayX1173;
    rtrue;
];
Array TX_S_271 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_271;
[ R_TX_S_272 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [eat] [the noun].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) actor;ParaContent(); print " ";ConjugateVerb_29(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " ";ParaContent(); print (the) noun;ParaContent(); print "."; .L_Say1186; .L_SayX1174;
    rtrue;
];
Array TX_S_272 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_272;
[ R_TX_S_273 
    tmp_0 ! Let/loop value, e.g., 'chaise': supporter
    ;
    tmp_0=LocalParking-->0;
#ifdef DEBUG; if (suppress_text_substitution) { print "~(first getting off [the chaise])[command clarification break]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "(first getting off ";ParaContent(); print (the) tmp_0;ParaContent(); print ")";ParaContent(); CommandClarificationBreak(); .L_Say1187; .L_SayX1175;
    rtrue;
];
Array TX_S_273 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_273;
[ R_TX_S_274 
    tmp_0 ! Let/loop value, e.g., 'nonvehicle': object
    ;
    tmp_0=LocalParking-->0;
#ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [would have] to get off [the nonvehicle] first.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ParaContent(); print " ";ConjugateVerb_73(CV_POS, PNToVP(), story_tense, ConjugateVerb_2); say__p=1; ParaContent(); print " to get off ";ParaContent(); print (the) tmp_0;ParaContent(); print " first."; .L_Say1188; .L_SayX1176;
    rtrue;
];
Array TX_S_274 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_274;
[ R_TX_S_275 
    tmp_0 ! Let/loop value, e.g., 'nonvehicle': object
    ;
    tmp_0=LocalParking-->0;
#ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [would have] to get out of [the nonvehicle] first.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ParaContent(); print " ";ConjugateVerb_73(CV_POS, PNToVP(), story_tense, ConjugateVerb_2); say__p=1; ParaContent(); print " to get out of ";ParaContent(); print (the) tmp_0;ParaContent(); print " first."; .L_Say1189; .L_SayX1177;
    rtrue;
];
Array TX_S_275 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_275;
[ R_TX_S_276 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [can't go] that way.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ParaContent(); print " ";ConjugateVerb_77(CV_POS, PNToVP(), story_tense, ConjugateVerb_34); say__p=1; ParaContent(); print " that way."; .L_Say1190; .L_SayX1178;
    rtrue;
];
Array TX_S_276 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_276;
[ R_TX_S_277 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~(first opening [the door gone through])[command clarification break]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "(first opening ";ParaContent(); print (the) (MStack-->MstVO(20007,2));ParaContent(); print ")";ParaContent(); CommandClarificationBreak(); .L_Say1191; .L_SayX1179;
    rtrue;
];
Array TX_S_277 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_277;
[ R_TX_S_278 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [can't go] that way.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ParaContent(); print " ";ConjugateVerb_77(CV_POS, PNToVP(), story_tense, ConjugateVerb_34); say__p=1; ParaContent(); print " that way."; .L_Say1192; .L_SayX1180;
    rtrue;
];
Array TX_S_278 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_278;
[ R_TX_S_279 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [can't], since [the door gone through] [lead] nowhere.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ParaContent(); print " ";ConjugateVerb_77(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print ", since ";ParaContent(); print (the) (MStack-->MstVO(20007,2));ParaContent(); print " ";ConjugateVerb_39(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " nowhere."; .L_Say1193; .L_SayX1181;
    rtrue;
];
Array TX_S_279 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_279;
[ R_TX_S_280 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [go] up~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) actor;ParaContent(); print " ";ConjugateVerb_34(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " up"; .L_Say1194; .L_SayX1182;
    rtrue;
];
Array TX_S_280 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_280;
[ R_TX_S_281 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [go] down~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) actor;ParaContent(); print " ";ConjugateVerb_34(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " down"; .L_Say1195; .L_SayX1183;
    rtrue;
];
Array TX_S_281 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_281;
[ R_TX_S_282 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [go] [noun]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) actor;ParaContent(); print " ";ConjugateVerb_34(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " ";ParaContent(); print (PrintShortName) noun; .L_Say1196; .L_SayX1184;
    rtrue;
];
Array TX_S_282 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_282;
[ R_TX_S_283 
    tmp_0 ! Let/loop value, e.g., 'back way': object
    tmp_1 ! Let/loop value, e.g., 'room back the other way': object
    tmp_2 ! Let/loop value, e.g., 'room normally this way': object
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [arrive] from above~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) actor;ParaContent(); print " ";ConjugateVerb_23(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " from above"; .L_Say1197; .L_SayX1185;
    rtrue;
];
Array TX_S_283 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_283;
[ R_TX_S_284 
    tmp_0 ! Let/loop value, e.g., 'back way': object
    tmp_1 ! Let/loop value, e.g., 'room back the other way': object
    tmp_2 ! Let/loop value, e.g., 'room normally this way': object
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [arrive] from below~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) actor;ParaContent(); print " ";ConjugateVerb_23(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " from below"; .L_Say1198; .L_SayX1186;
    rtrue;
];
Array TX_S_284 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_284;
[ R_TX_S_285 
    tmp_0 ! Let/loop value, e.g., 'back way': object
    tmp_1 ! Let/loop value, e.g., 'room back the other way': object
    tmp_2 ! Let/loop value, e.g., 'room normally this way': object
    ;
    tmp_0=LocalParking-->0;
tmp_1=LocalParking-->1;
tmp_2=LocalParking-->2;
#ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [arrive] from [the back way]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) actor;ParaContent(); print " ";ConjugateVerb_23(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " from ";ParaContent(); print (the) tmp_0; .L_Say1199; .L_SayX1187;
    rtrue;
];
Array TX_S_285 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_285;
[ R_TX_S_286 
    tmp_0 ! Let/loop value, e.g., 'back way': object
    tmp_1 ! Let/loop value, e.g., 'room back the other way': object
    tmp_2 ! Let/loop value, e.g., 'room normally this way': object
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [arrive]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) actor;ParaContent(); print " ";ConjugateVerb_23(CV_POS, PNToVP(), story_tense); say__p=1;  .L_Say1200; .L_SayX1188;
    rtrue;
];
Array TX_S_286 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_286;
[ R_TX_S_287 
    tmp_0 ! Let/loop value, e.g., 'back way': object
    tmp_1 ! Let/loop value, e.g., '?-1,-1?': object
    tmp_2 ! Let/loop value, e.g., '?-1,-1?': object
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [arrive] at [the room gone to] from above~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) actor;ParaContent(); print " ";ConjugateVerb_23(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " at ";ParaContent(); print (the) (MStack-->MstVO(20007,1));ParaContent(); print " from above"; .L_Say1201; .L_SayX1189;
    rtrue;
];
Array TX_S_287 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_287;
[ R_TX_S_288 
    tmp_0 ! Let/loop value, e.g., 'back way': object
    tmp_1 ! Let/loop value, e.g., '?-1,-1?': object
    tmp_2 ! Let/loop value, e.g., '?-1,-1?': object
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [arrive] at [the room gone to] from below~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) actor;ParaContent(); print " ";ConjugateVerb_23(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " at ";ParaContent(); print (the) (MStack-->MstVO(20007,1));ParaContent(); print " from below"; .L_Say1202; .L_SayX1190;
    rtrue;
];
Array TX_S_288 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_288;
[ R_TX_S_289 
    tmp_0 ! Let/loop value, e.g., 'back way': object
    tmp_1 ! Let/loop value, e.g., '?-1,-1?': object
    tmp_2 ! Let/loop value, e.g., '?-1,-1?': object
    ;
    tmp_0=LocalParking-->0;
tmp_1=LocalParking-->1;
tmp_2=LocalParking-->2;
#ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [arrive] at [the room gone to] from [the back way]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) actor;ParaContent(); print " ";ConjugateVerb_23(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " at ";ParaContent(); print (the) (MStack-->MstVO(20007,1));ParaContent(); print " from ";ParaContent(); print (the) tmp_0; .L_Say1203; .L_SayX1191;
    rtrue;
];
Array TX_S_289 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_289;
[ R_TX_S_290 
    tmp_0 ! Let/loop value, e.g., '?-1,-1?': object
    tmp_1 ! Let/loop value, e.g., '?-1,-1?': object
    tmp_2 ! Let/loop value, e.g., '?-1,-1?': object
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [go] through [the noun]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) actor;ParaContent(); print " ";ConjugateVerb_34(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " through ";ParaContent(); print (the) noun; .L_Say1204; .L_SayX1192;
    rtrue;
];
Array TX_S_290 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_290;
[ R_TX_S_291 
    tmp_0 ! Let/loop value, e.g., '?-1,-1?': object
    tmp_1 ! Let/loop value, e.g., '?-1,-1?': object
    tmp_2 ! Let/loop value, e.g., '?-1,-1?': object
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [arrive] from [the noun]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) actor;ParaContent(); print " ";ConjugateVerb_23(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " from ";ParaContent(); print (the) noun; .L_Say1205; .L_SayX1193;
    rtrue;
];
Array TX_S_291 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_291;
[ R_TX_S_292 
    tmp_0 ! Let/loop value, e.g., '?-1,-1?': object
    tmp_1 ! Let/loop value, e.g., '?-1,-1?': object
    tmp_2 ! Let/loop value, e.g., '?-1,-1?': object
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~on [the vehicle gone by]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "on ";ParaContent(); print (the) (MStack-->MstVO(20007,3)); .L_Say1206; .L_SayX1194;
    rtrue;
];
Array TX_S_292 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_292;
[ R_TX_S_293 
    tmp_0 ! Let/loop value, e.g., '?-1,-1?': object
    tmp_1 ! Let/loop value, e.g., '?-1,-1?': object
    tmp_2 ! Let/loop value, e.g., '?-1,-1?': object
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~in [the vehicle gone by]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "in ";ParaContent(); print (the) (MStack-->MstVO(20007,3)); .L_Say1207; .L_SayX1195;
    rtrue;
];
Array TX_S_293 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_293;
[ R_TX_S_294 
    tmp_0 ! Let/loop value, e.g., '?-1,-1?': object
    tmp_1 ! Let/loop value, e.g., '?-1,-1?': object
    tmp_2 ! Let/loop value, e.g., '?-1,-1?': object
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~, pushing [the thing gone with] in front, and [us] along too~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print ", pushing ";ParaContent(); print (the) (MStack-->MstVO(20007,4));ParaContent(); print " in front, and ";ParaContent(); (PHR_775_r42 ());ParaContent(); print " along too"; .L_Say1208; .L_SayX1196;
    rtrue;
];
Array TX_S_294 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_294;
[ R_TX_S_295 
    tmp_0 ! Let/loop value, e.g., '?-1,-1?': object
    tmp_1 ! Let/loop value, e.g., '?-1,-1?': object
    tmp_2 ! Let/loop value, e.g., '?-1,-1?': object
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~, pushing [the thing gone with] in front~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print ", pushing ";ParaContent(); print (the) (MStack-->MstVO(20007,4));ParaContent(); print " in front"; .L_Say1209; .L_SayX1197;
    rtrue;
];
Array TX_S_295 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_295;
[ R_TX_S_296 
    tmp_0 ! Let/loop value, e.g., '?-1,-1?': object
    tmp_1 ! Let/loop value, e.g., '?-1,-1?': object
    tmp_2 ! Let/loop value, e.g., '?-1,-1?': object
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~, pushing [the thing gone with] away~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print ", pushing ";ParaContent(); print (the) (MStack-->MstVO(20007,4));ParaContent(); print " away"; .L_Say1210; .L_SayX1198;
    rtrue;
];
Array TX_S_296 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_296;
[ R_TX_S_297 
    tmp_0 ! Let/loop value, e.g., '?-1,-1?': object
    tmp_1 ! Let/loop value, e.g., '?-1,-1?': object
    tmp_2 ! Let/loop value, e.g., '?-1,-1?': object
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~, pushing [the thing gone with] in~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print ", pushing ";ParaContent(); print (the) (MStack-->MstVO(20007,4));ParaContent(); print " in"; .L_Say1211; .L_SayX1199;
    rtrue;
];
Array TX_S_297 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_297;
[ R_TX_S_298 
    tmp_0 ! Let/loop value, e.g., '?-1,-1?': object
    tmp_1 ! Let/loop value, e.g., '?-1,-1?': object
    tmp_2 ! Let/loop value, e.g., '?-1,-1?': object
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~, taking [us] along~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print ", taking ";ParaContent(); (PHR_775_r42 ());ParaContent(); print " along"; .L_Say1212; .L_SayX1200;
    rtrue;
];
Array TX_S_298 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_298;
[ R_TX_S_299 
    tmp_0 ! Let/loop value, e.g., 'local ceiling': object
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~But [we]['re] already on [the noun].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "But ";ParaContent(); (PHR_774_r41 ());ConjugateVerb_74(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " already on ";ParaContent(); print (the) noun;ParaContent(); print "."; .L_Say1213; .L_SayX1201;
    rtrue;
];
Array TX_S_299 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_299;
[ R_TX_S_300 
    tmp_0 ! Let/loop value, e.g., 'local ceiling': object
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~But [we]['re] already in [the noun].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "But ";ParaContent(); (PHR_774_r41 ());ConjugateVerb_74(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " already in ";ParaContent(); print (the) noun;ParaContent(); print "."; .L_Say1214; .L_SayX1202;
    rtrue;
];
Array TX_S_300 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_300;
[ R_TX_S_301 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][They're] not something [we] [can] stand on.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); RegardingSingleObject(noun);ParaContent(); (PHR_799_r66 ());ParaContent(); print " not something ";ParaContent(); (PHR_774_r41 ());ParaContent(); print " ";ConjugateVerb_15(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " stand on."; .L_Say1215; .L_SayX1203;
    rtrue;
];
Array TX_S_301 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_301;
[ R_TX_S_302 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][They're] not something [we] [can] sit down on.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); RegardingSingleObject(noun);ParaContent(); (PHR_799_r66 ());ParaContent(); print " not something ";ParaContent(); (PHR_774_r41 ());ParaContent(); print " ";ConjugateVerb_15(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " sit down on."; .L_Say1216; .L_SayX1204;
    rtrue;
];
Array TX_S_302 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_302;
[ R_TX_S_303 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][They're] not something [we] [can] lie down on.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); RegardingSingleObject(noun);ParaContent(); (PHR_799_r66 ());ParaContent(); print " not something ";ParaContent(); (PHR_774_r41 ());ParaContent(); print " ";ConjugateVerb_15(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " lie down on."; .L_Say1217; .L_SayX1205;
    rtrue;
];
Array TX_S_303 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_303;
[ R_TX_S_304 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][They're] not something [we] [can] enter.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); RegardingSingleObject(noun);ParaContent(); (PHR_799_r66 ());ParaContent(); print " not something ";ParaContent(); (PHR_774_r41 ());ParaContent(); print " ";ConjugateVerb_15(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " enter."; .L_Say1218; .L_SayX1206;
    rtrue;
];
Array TX_S_304 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_304;
[ R_TX_S_305 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [can't get] into the closed [noun].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ParaContent(); print " ";ConjugateVerb_77(CV_POS, PNToVP(), story_tense, ConjugateVerb_32); say__p=1; ParaContent(); print " into the closed ";ParaContent(); print (PrintShortName) noun;ParaContent(); print "."; .L_Say1219; .L_SayX1207;
    rtrue;
];
Array TX_S_305 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_305;
[ R_TX_S_306 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[There] [are] no more room on [the noun].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_801_r68 ());ParaContent(); print " ";ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " no more room on ";ParaContent(); print (the) noun;ParaContent(); print "."; .L_Say1220; .L_SayX1208;
    rtrue;
];
Array TX_S_306 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_306;
[ R_TX_S_307 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[There] [are] no more room in [the noun].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_801_r68 ());ParaContent(); print " ";ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " no more room in ";ParaContent(); print (the) noun;ParaContent(); print "."; .L_Say1221; .L_SayX1209;
    rtrue;
];
Array TX_S_307 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_307;
[ R_TX_S_308 
    tmp_0 ! Let/loop value, e.g., 'local ceiling': object
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [can] only get into something free-standing.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ParaContent(); print " ";ConjugateVerb_15(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " only get into something free-standing."; .L_Say1222; .L_SayX1210;
    rtrue;
];
Array TX_S_308 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_308;
[ R_TX_S_309 
    tmp_0 ! Let/loop value, e.g., 'local ceiling': object
    tmp_1 ! Let/loop value, e.g., 'current home': object
    ;
    tmp_0=LocalParking-->0;
tmp_1=LocalParking-->1;
#ifdef DEBUG; if (suppress_text_substitution) { print "~(getting off [the current home])[command clarification break]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "(getting off ";ParaContent(); print (the) tmp_1;ParaContent(); print ")";ParaContent(); CommandClarificationBreak(); .L_Say1223; .L_SayX1211;
    rtrue;
];
Array TX_S_309 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_309;
[ R_TX_S_310 
    tmp_0 ! Let/loop value, e.g., 'local ceiling': object
    tmp_1 ! Let/loop value, e.g., 'current home': object
    ;
    tmp_0=LocalParking-->0;
tmp_1=LocalParking-->1;
#ifdef DEBUG; if (suppress_text_substitution) { print "~(getting out of [the current home])[command clarification break]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "(getting out of ";ParaContent(); print (the) tmp_1;ParaContent(); print ")";ParaContent(); CommandClarificationBreak(); .L_Say1224; .L_SayX1212;
    rtrue;
];
Array TX_S_310 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_310;
[ R_TX_S_311 
    tmp_0 ! Let/loop value, e.g., 'local ceiling': object
    tmp_1 ! Let/loop value, e.g., 'target': object
    ;
    tmp_0=LocalParking-->0;
tmp_1=LocalParking-->1;
#ifdef DEBUG; if (suppress_text_substitution) { print "~(getting onto [the target])[command clarification break]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "(getting onto ";ParaContent(); print (the) tmp_1;ParaContent(); print ")";ParaContent(); CommandClarificationBreak(); .L_Say1225; .L_SayX1213;
    rtrue;
];
Array TX_S_311 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_311;
[ R_TX_S_312 
    tmp_0 ! Let/loop value, e.g., 'local ceiling': object
    tmp_1 ! Let/loop value, e.g., 'target': object
    ;
    tmp_0=LocalParking-->0;
tmp_1=LocalParking-->1;
#ifdef DEBUG; if (suppress_text_substitution) { print "~(getting into [the target])[command clarification break]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "(getting into ";ParaContent(); print (the) tmp_1;ParaContent(); print ")";ParaContent(); CommandClarificationBreak(); .L_Say1226; .L_SayX1214;
    rtrue;
];
Array TX_S_312 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_312;
[ R_TX_S_313 
    tmp_0 ! Let/loop value, e.g., 'local ceiling': object
    tmp_1 ! Let/loop value, e.g., 'target': object
    ;
    tmp_0=LocalParking-->0;
tmp_1=LocalParking-->1;
#ifdef DEBUG; if (suppress_text_substitution) { print "~(entering [the target])[command clarification break]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "(entering ";ParaContent(); print (the) tmp_1;ParaContent(); print ")";ParaContent(); CommandClarificationBreak(); .L_Say1227; .L_SayX1215;
    rtrue;
];
Array TX_S_313 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_313;
[ R_TX_S_314 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [get] onto [the noun].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ParaContent(); print " ";ConjugateVerb_32(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " onto ";ParaContent(); print (the) noun;ParaContent(); print "."; .L_Say1228; .L_SayX1216;
    rtrue;
];
Array TX_S_314 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_314;
[ R_TX_S_315 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [get] into [the noun].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ParaContent(); print " ";ConjugateVerb_32(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " into ";ParaContent(); print (the) noun;ParaContent(); print "."; .L_Say1229; .L_SayX1217;
    rtrue;
];
Array TX_S_315 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_315;
[ R_TX_S_316 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [get] into [the noun].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) actor;ParaContent(); print " ";ConjugateVerb_32(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " into ";ParaContent(); print (the) noun;ParaContent(); print "."; .L_Say1230; .L_SayX1218;
    rtrue;
];
Array TX_S_316 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_316;
[ R_TX_S_317 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [get] onto [the noun].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) actor;ParaContent(); print " ";ConjugateVerb_32(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " onto ";ParaContent(); print (the) noun;ParaContent(); print "."; .L_Say1231; .L_SayX1219;
    rtrue;
];
Array TX_S_317 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_317;
[ R_TX_S_318 
    tmp_0 ! Let/loop value, e.g., 'local room': object
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~But [we] [aren't] in anything at the [if story tense is present
    tense]moment[otherwise]time[end if].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "But ";ParaContent(); (PHR_774_r41 ());ParaContent(); print " ";ConjugateVerb_76(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " in anything at the ";
    	if (~~((((story_tense == I105_present_tense))))) jump L_Say1232;ParaContent(); print "moment";
    	jump L_SayX1220; .L_Say1232;ParaContent(); print "time";
    	.L_Say1233; .L_SayX1220;ParaContent(); print "."; .L_Say1234; .L_SayX1221;
    rtrue;
];
Array TX_S_318 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_318;
[ R_TX_S_319 
    tmp_0 ! Let/loop value, e.g., 'cage': container
    ;
    tmp_0=LocalParking-->0;
#ifdef DEBUG; if (suppress_text_substitution) { print "~You can't get out of the closed [cage].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "You can't get out of the closed ";ParaContent(); print (PrintShortName) tmp_0;ParaContent(); print "."; .L_Say1235; .L_SayX1222;
    rtrue;
];
Array TX_S_319 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_319;
[ R_TX_S_320 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [get] off [the container exited from].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ParaContent(); print " ";ConjugateVerb_32(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " off ";ParaContent(); print (the) (MStack-->MstVO(20009,0));ParaContent(); print "."; .L_Say1236; .L_SayX1223;
    rtrue;
];
Array TX_S_320 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_320;
[ R_TX_S_321 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [get] out of [the container exited from].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ParaContent(); print " ";ConjugateVerb_32(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " out of ";ParaContent(); print (the) (MStack-->MstVO(20009,0));ParaContent(); print "."; .L_Say1237; .L_SayX1224;
    rtrue;
];
Array TX_S_321 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_321;
[ R_TX_S_322 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [get] out of [the container exited from].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) actor;ParaContent(); print " ";ConjugateVerb_32(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " out of ";ParaContent(); print (the) (MStack-->MstVO(20009,0));ParaContent(); print "."; .L_Say1238; .L_SayX1225;
    rtrue;
];
Array TX_S_322 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_322;
[ R_TX_S_323 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~But [we] [aren't] on [the noun] at the [if story tense is present
    tense]moment[otherwise]time[end if].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "But ";ParaContent(); (PHR_774_r41 ());ParaContent(); print " ";ConjugateVerb_76(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " on ";ParaContent(); print (the) noun;ParaContent(); print " at the ";
    	if (~~((((story_tense == I105_present_tense))))) jump L_Say1239;ParaContent(); print "moment";
    	jump L_SayX1226; .L_Say1239;ParaContent(); print "time";
    	.L_Say1240; .L_SayX1226;ParaContent(); print "."; .L_Say1241; .L_SayX1227;
    rtrue;
];
Array TX_S_323 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_323;
[ R_TX_S_324 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [get] off [the noun].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) actor;ParaContent(); print " ";ConjugateVerb_32(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " off ";ParaContent(); print (the) noun;ParaContent(); print "."; .L_Say1242; .L_SayX1228;
    rtrue;
];
Array TX_S_324 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_324;
[ R_TX_S_325 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Darkness~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Darkness"; .L_Say1243; .L_SayX1229;
    rtrue;
];
Array TX_S_325 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_325;
[ R_TX_S_326 
    tmp_0 ! Let/loop value, e.g., 'intermediate level': object
    tmp_1 ! Let/loop value, e.g., 'intermediate level count': number
    ;
    tmp_0=LocalParking-->0;
tmp_1=LocalParking-->1;
#ifdef DEBUG; if (suppress_text_substitution) { print "~ (on [the intermediate level])~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print " (on ";ParaContent(); print (the) tmp_0;ParaContent(); print ")"; .L_Say1244; .L_SayX1230;
    rtrue;
];
Array TX_S_326 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_326;
[ R_TX_S_327 
    tmp_0 ! Let/loop value, e.g., 'intermediate level': object
    tmp_1 ! Let/loop value, e.g., 'intermediate level count': number
    ;
    tmp_0=LocalParking-->0;
tmp_1=LocalParking-->1;
#ifdef DEBUG; if (suppress_text_substitution) { print "~ (in [the intermediate level])~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print " (in ";ParaContent(); print (the) tmp_0;ParaContent(); print ")"; .L_Say1245; .L_SayX1231;
    rtrue;
];
Array TX_S_327 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_327;
[ R_TX_S_328 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[It] [are] pitch dark, and [we] [can't see] a thing.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_800_r67 ());ParaContent(); print " ";ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " pitch dark, and ";ParaContent(); (PHR_774_r41 ());ParaContent(); print " ";ConjugateVerb_77(CV_POS, PNToVP(), story_tense, ConjugateVerb_16); say__p=1; ParaContent(); print " a thing."; .L_Say1246; .L_SayX1232;
    rtrue;
];
Array TX_S_328 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_328;
[ R_TX_S_329 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [look] around.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) actor;ParaContent(); print " ";ConjugateVerb_43(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " around."; .L_Say1247; .L_SayX1233;
    rtrue;
];
Array TX_S_329 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_329;
[ R_TX_S_330 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [see] nothing unexpected in that direction.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ParaContent(); print " ";ConjugateVerb_16(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " nothing unexpected in that direction."; .L_Say1248; .L_SayX1234;
    rtrue;
];
Array TX_S_330 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_330;
[ R_TX_S_331 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~In [the noun] ~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "In ";ParaContent(); print (the) noun;ParaContent(); print " "; .L_Say1249; .L_SayX1235;
    rtrue;
];
Array TX_S_331 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_331;
[ R_TX_S_332 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The noun] [are] empty.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) noun;ParaContent(); print " ";ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " empty."; .L_Say1250; .L_SayX1236;
    rtrue;
];
Array TX_S_332 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_332;
[ R_TX_S_333 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~On [the noun] ~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "On ";ParaContent(); print (the) noun;ParaContent(); print " "; .L_Say1251; .L_SayX1237;
    rtrue;
];
Array TX_S_333 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_333;
[ R_TX_S_334 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The noun] [are] [if story tense is present tense]currently [end if]switched
    [if the noun is switched on]on[otherwise]off[end if].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) noun;ParaContent(); print " ";ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " ";
    	if (~~((((story_tense == I105_present_tense))))) jump L_Say1252;ParaContent(); print "currently ";
    	.L_Say1252; .L_SayX1238;ParaContent(); print "switched ";
    	if (~~(((((Adj_84_t1_v10(noun))))))) jump L_Say1253;ParaContent(); print "on";
    	jump L_SayX1239; .L_Say1253;ParaContent(); print "off";
    	.L_Say1254; .L_SayX1239;ParaContent(); print "."; .L_Say1255; .L_SayX1240;
    rtrue;
];
Array TX_S_334 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_334;
[ R_TX_S_335 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [see] nothing special about [the noun].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ParaContent(); print " ";ConjugateVerb_16(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " nothing special about ";ParaContent(); print (the) noun;ParaContent(); print "."; .L_Say1256; .L_SayX1241;
    rtrue;
];
Array TX_S_335 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_335;
[ R_TX_S_336 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [look] closely at [the noun].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) actor;ParaContent(); print " ";ConjugateVerb_43(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " closely at ";ParaContent(); print (the) noun;ParaContent(); print "."; .L_Say1257; .L_SayX1242;
    rtrue;
];
Array TX_S_336 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_336;
[ R_TX_S_337 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [find] nothing of interest.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ParaContent(); print " ";ConjugateVerb_31(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " nothing of interest."; .L_Say1258; .L_SayX1243;
    rtrue;
];
Array TX_S_337 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_337;
[ R_TX_S_338 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [look] under [the noun].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) actor;ParaContent(); print " ";ConjugateVerb_43(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " under ";ParaContent(); print (the) noun;ParaContent(); print "."; .L_Say1259; .L_SayX1244;
    rtrue;
];
Array TX_S_338 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_338;
[ R_TX_S_339 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [find] nothing of interest.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ParaContent(); print " ";ConjugateVerb_31(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " nothing of interest."; .L_Say1260; .L_SayX1245;
    rtrue;
];
Array TX_S_339 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_339;
[ R_TX_S_340 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [can't see] inside, since [the noun] [are] closed.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ParaContent(); print " ";ConjugateVerb_77(CV_POS, PNToVP(), story_tense, ConjugateVerb_16); say__p=1; ParaContent(); print " inside, since ";ParaContent(); print (the) noun;ParaContent(); print " ";ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " closed."; .L_Say1261; .L_SayX1246;
    rtrue;
];
Array TX_S_340 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_340;
[ R_TX_S_341 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~In [the noun] ~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "In ";ParaContent(); print (the) noun;ParaContent(); print " "; .L_Say1262; .L_SayX1247;
    rtrue;
];
Array TX_S_341 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_341;
[ R_TX_S_342 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The noun] [are] empty.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) noun;ParaContent(); print " ";ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " empty."; .L_Say1263; .L_SayX1248;
    rtrue;
];
Array TX_S_342 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_342;
[ R_TX_S_343 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~On [the noun] ~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "On ";ParaContent(); print (the) noun;ParaContent(); print " "; .L_Say1264; .L_SayX1249;
    rtrue;
];
Array TX_S_343 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_343;
[ R_TX_S_344 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[There] [are] nothing on [the noun].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_801_r68 ());ParaContent(); print " ";ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " nothing on ";ParaContent(); print (the) noun;ParaContent(); print "."; .L_Say1265; .L_SayX1250;
    rtrue;
];
Array TX_S_344 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_344;
[ R_TX_S_345 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [search] [the noun].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) actor;ParaContent(); print " ";ConjugateVerb_54(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " ";ParaContent(); print (the) noun;ParaContent(); print "."; .L_Say1266; .L_SayX1251;
    rtrue;
];
Array TX_S_345 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_345;
[ R_TX_S_346 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [discover] nothing of interest in [the noun].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ParaContent(); print " ";ConjugateVerb_27(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " nothing of interest in ";ParaContent(); print (the) noun;ParaContent(); print "."; .L_Say1267; .L_SayX1252;
    rtrue;
];
Array TX_S_346 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_346;
[ R_TX_S_347 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [look] at [the noun].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) actor;ParaContent(); print " ";ConjugateVerb_43(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " at ";ParaContent(); print (the) noun;ParaContent(); print "."; .L_Say1268; .L_SayX1253;
    rtrue;
];
Array TX_S_347 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_347;
[ R_TX_S_348 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][Those] [don't] seem to be something [we] [can] lock.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); RegardingSingleObject(noun);ParaContent(); (PHR_785_r52 ());ParaContent(); print " ";ConjugateVerb_79(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " seem to be something ";ParaContent(); (PHR_774_r41 ());ParaContent(); print " ";ConjugateVerb_15(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " lock."; .L_Say1269; .L_SayX1254;
    rtrue;
];
Array TX_S_348 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_348;
[ R_TX_S_349 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][They're] locked at the [if story tense is present
    tense]moment[otherwise]time[end if].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); RegardingSingleObject(noun);ParaContent(); (PHR_799_r66 ());ParaContent(); print " locked at the ";
    	if (~~((((story_tense == I105_present_tense))))) jump L_Say1270;ParaContent(); print "moment";
    	jump L_SayX1255; .L_Say1270;ParaContent(); print "time";
    	.L_Say1271; .L_SayX1255;ParaContent(); print "."; .L_Say1272; .L_SayX1256;
    rtrue;
];
Array TX_S_349 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_349;
[ R_TX_S_350 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~First [we] [would have] to close [the noun].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "First ";ParaContent(); (PHR_774_r41 ());ParaContent(); print " ";ConjugateVerb_73(CV_POS, PNToVP(), story_tense, ConjugateVerb_2); say__p=1; ParaContent(); print " to close ";ParaContent(); print (the) noun;ParaContent(); print "."; .L_Say1273; .L_SayX1257;
    rtrue;
];
Array TX_S_350 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_350;
[ R_TX_S_351 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The second noun] [do not fit] [the noun].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) second;ParaContent(); print " ";ConjugateVerb_87(CV_NEG, PNToVP(), story_tense); say__p=1; ParaContent(); print " ";ParaContent(); print (the) noun;ParaContent(); print "."; .L_Say1274; .L_SayX1258;
    rtrue;
];
Array TX_S_351 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_351;
[ R_TX_S_352 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [lock] [the noun].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ParaContent(); print " ";ConjugateVerb_42(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " ";ParaContent(); print (the) noun;ParaContent(); print "."; .L_Say1275; .L_SayX1259;
    rtrue;
];
Array TX_S_352 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_352;
[ R_TX_S_353 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [lock] [the noun].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) actor;ParaContent(); print " ";ConjugateVerb_42(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " ";ParaContent(); print (the) noun;ParaContent(); print "."; .L_Say1276; .L_SayX1260;
    rtrue;
];
Array TX_S_353 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_353;
[ R_TX_S_354 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][Those] [don't] seem to be something [we] [can] unlock.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); RegardingSingleObject(noun);ParaContent(); (PHR_785_r52 ());ParaContent(); print " ";ConjugateVerb_79(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " seem to be something ";ParaContent(); (PHR_774_r41 ());ParaContent(); print " ";ConjugateVerb_15(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " unlock."; .L_Say1277; .L_SayX1261;
    rtrue;
];
Array TX_S_354 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_354;
[ R_TX_S_355 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][They're] unlocked at the [if story tense is present
    tense]moment[otherwise]time[end if].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); RegardingSingleObject(noun);ParaContent(); (PHR_799_r66 ());ParaContent(); print " unlocked at the ";
    	if (~~((((story_tense == I105_present_tense))))) jump L_Say1278;ParaContent(); print "moment";
    	jump L_SayX1262; .L_Say1278;ParaContent(); print "time";
    	.L_Say1279; .L_SayX1262;ParaContent(); print "."; .L_Say1280; .L_SayX1263;
    rtrue;
];
Array TX_S_355 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_355;
[ R_TX_S_356 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [unlock] [the noun].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ParaContent(); print " ";ConjugateVerb_20(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " ";ParaContent(); print (the) noun;ParaContent(); print "."; .L_Say1281; .L_SayX1264;
    rtrue;
];
Array TX_S_356 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_356;
[ R_TX_S_357 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [unlock] [the noun].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) actor;ParaContent(); print " ";ConjugateVerb_20(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " ";ParaContent(); print (the) noun;ParaContent(); print "."; .L_Say1282; .L_SayX1265;
    rtrue;
];
Array TX_S_357 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_357;
[ R_TX_S_358 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][They] [aren't] something [we] [can] switch.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); RegardingSingleObject(noun);ParaContent(); (PHR_789_r56 ());ParaContent(); print " ";ConjugateVerb_76(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " something ";ParaContent(); (PHR_774_r41 ());ParaContent(); print " ";ConjugateVerb_15(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " switch."; .L_Say1283; .L_SayX1266;
    rtrue;
];
Array TX_S_358 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_358;
[ R_TX_S_359 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][They're] already on.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); RegardingSingleObject(noun);ParaContent(); (PHR_799_r66 ());ParaContent(); print " already on."; .L_Say1284; .L_SayX1267;
    rtrue;
];
Array TX_S_359 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_359;
[ R_TX_S_360 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [switch] [the noun] on.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) actor;ParaContent(); print " ";ConjugateVerb_60(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " ";ParaContent(); print (the) noun;ParaContent(); print " on."; .L_Say1285; .L_SayX1268;
    rtrue;
];
Array TX_S_360 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_360;
[ R_TX_S_361 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][They] [aren't] something [we] [can] switch.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); RegardingSingleObject(noun);ParaContent(); (PHR_789_r56 ());ParaContent(); print " ";ConjugateVerb_76(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " something ";ParaContent(); (PHR_774_r41 ());ParaContent(); print " ";ConjugateVerb_15(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " switch."; .L_Say1286; .L_SayX1269;
    rtrue;
];
Array TX_S_361 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_361;
[ R_TX_S_362 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][They're] already off.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); RegardingSingleObject(noun);ParaContent(); (PHR_799_r66 ());ParaContent(); print " already off."; .L_Say1287; .L_SayX1270;
    rtrue;
];
Array TX_S_362 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_362;
[ R_TX_S_363 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [switch] [the noun] off.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) actor;ParaContent(); print " ";ConjugateVerb_60(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " ";ParaContent(); print (the) noun;ParaContent(); print " off."; .L_Say1288; .L_SayX1271;
    rtrue;
];
Array TX_S_363 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_363;
[ R_TX_S_364 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][They] [aren't] something [we] [can] open.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); RegardingSingleObject(noun);ParaContent(); (PHR_789_r56 ());ParaContent(); print " ";ConjugateVerb_76(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " something ";ParaContent(); (PHR_774_r41 ());ParaContent(); print " ";ConjugateVerb_15(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " open."; .L_Say1289; .L_SayX1272;
    rtrue;
];
Array TX_S_364 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_364;
[ R_TX_S_365 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][They] [seem] to be locked.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); RegardingSingleObject(noun);ParaContent(); (PHR_789_r56 ());ParaContent(); print " ";ConjugateVerb_55(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " to be locked."; .L_Say1290; .L_SayX1273;
    rtrue;
];
Array TX_S_365 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_365;
[ R_TX_S_366 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][They're] already open.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); RegardingSingleObject(noun);ParaContent(); (PHR_799_r66 ());ParaContent(); print " already open."; .L_Say1291; .L_SayX1274;
    rtrue;
];
Array TX_S_366 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_366;
[ R_TX_S_367 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [open] [the noun], revealing ~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ParaContent(); print " ";ConjugateVerb_45(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " ";ParaContent(); print (the) noun;ParaContent(); print ", revealing "; .L_Say1292; .L_SayX1275;
    rtrue;
];
Array TX_S_367 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_367;
[ R_TX_S_368 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [open] [the noun].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ParaContent(); print " ";ConjugateVerb_45(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " ";ParaContent(); print (the) noun;ParaContent(); print "."; .L_Say1293; .L_SayX1276;
    rtrue;
];
Array TX_S_368 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_368;
[ R_TX_S_369 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [open] [the noun].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) actor;ParaContent(); print " ";ConjugateVerb_45(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " ";ParaContent(); print (the) noun;ParaContent(); print "."; .L_Say1294; .L_SayX1277;
    rtrue;
];
Array TX_S_369 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_369;
[ R_TX_S_370 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The noun] [open].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) noun;ParaContent(); print " ";ConjugateVerb_45(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print "."; .L_Say1295; .L_SayX1278;
    rtrue;
];
Array TX_S_370 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_370;
[ R_TX_S_371 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][They] [aren't] something [we] [can] close.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); RegardingSingleObject(noun);ParaContent(); (PHR_789_r56 ());ParaContent(); print " ";ConjugateVerb_76(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " something ";ParaContent(); (PHR_774_r41 ());ParaContent(); print " ";ConjugateVerb_15(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " close."; .L_Say1296; .L_SayX1279;
    rtrue;
];
Array TX_S_371 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_371;
[ R_TX_S_372 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][They're] already closed.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); RegardingSingleObject(noun);ParaContent(); (PHR_799_r66 ());ParaContent(); print " already closed."; .L_Say1297; .L_SayX1280;
    rtrue;
];
Array TX_S_372 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_372;
[ R_TX_S_373 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [close] [the noun].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ParaContent(); print " ";ConjugateVerb_25(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " ";ParaContent(); print (the) noun;ParaContent(); print "."; .L_Say1298; .L_SayX1281;
    rtrue;
];
Array TX_S_373 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_373;
[ R_TX_S_374 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [close] [the noun].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) actor;ParaContent(); print " ";ConjugateVerb_25(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " ";ParaContent(); print (the) noun;ParaContent(); print "."; .L_Say1299; .L_SayX1282;
    rtrue;
];
Array TX_S_374 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_374;
[ R_TX_S_375 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The noun] [close].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) noun;ParaContent(); print " ";ConjugateVerb_25(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print "."; .L_Say1300; .L_SayX1283;
    rtrue;
];
Array TX_S_375 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_375;
[ R_TX_S_376 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [can't wear] [regarding the noun][those]!~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ParaContent(); print " ";ConjugateVerb_77(CV_POS, PNToVP(), story_tense, ConjugateVerb_13); say__p=1; ParaContent(); print " ";ParaContent(); RegardingSingleObject(noun);ParaContent(); (PHR_784_r51 ());ParaContent(); print "!"; .L_Say1301; .L_SayX1284;
    rtrue;
];
Array TX_S_376 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_376;
[ R_TX_S_377 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [aren't] holding [regarding the noun][those]!~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ParaContent(); print " ";ConjugateVerb_76(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " holding ";ParaContent(); RegardingSingleObject(noun);ParaContent(); (PHR_784_r51 ());ParaContent(); print "!"; .L_Say1302; .L_SayX1285;
    rtrue;
];
Array TX_S_377 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_377;
[ R_TX_S_378 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We]['re] already wearing [regarding the noun][those]!~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ConjugateVerb_74(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " already wearing ";ParaContent(); RegardingSingleObject(noun);ParaContent(); (PHR_784_r51 ());ParaContent(); print "!"; .L_Say1303; .L_SayX1286;
    rtrue;
];
Array TX_S_378 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_378;
[ R_TX_S_379 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [put] on [the noun].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ParaContent(); print " ";ConjugateVerb_51(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " on ";ParaContent(); print (the) noun;ParaContent(); print "."; .L_Say1304; .L_SayX1287;
    rtrue;
];
Array TX_S_379 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_379;
[ R_TX_S_380 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [put] on [the noun].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) actor;ParaContent(); print " ";ConjugateVerb_51(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " on ";ParaContent(); print (the) noun;ParaContent(); print "."; .L_Say1305; .L_SayX1288;
    rtrue;
];
Array TX_S_380 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_380;
[ R_TX_S_381 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [aren't] wearing [the noun].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ParaContent(); print " ";ConjugateVerb_76(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " wearing ";ParaContent(); print (the) noun;ParaContent(); print "."; .L_Say1306; .L_SayX1289;
    rtrue;
];
Array TX_S_381 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_381;
[ R_TX_S_382 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We]['re] carrying too many things already.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ConjugateVerb_74(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " carrying too many things already."; .L_Say1307; .L_SayX1290;
    rtrue;
];
Array TX_S_382 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_382;
[ R_TX_S_383 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [take] off [the noun].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ParaContent(); print " ";ConjugateVerb_61(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " off ";ParaContent(); print (the) noun;ParaContent(); print "."; .L_Say1308; .L_SayX1291;
    rtrue;
];
Array TX_S_383 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_383;
[ R_TX_S_384 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [take] off [the noun].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) actor;ParaContent(); print " ";ConjugateVerb_61(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " off ";ParaContent(); print (the) noun;ParaContent(); print "."; .L_Say1309; .L_SayX1292;
    rtrue;
];
Array TX_S_384 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_384;
[ R_TX_S_385 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [aren't] holding [the noun].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ParaContent(); print " ";ConjugateVerb_76(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " holding ";ParaContent(); print (the) noun;ParaContent(); print "."; .L_Say1310; .L_SayX1293;
    rtrue;
];
Array TX_S_385 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_385;
[ R_TX_S_386 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [can't give] [the noun] to [ourselves].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ParaContent(); print " ";ConjugateVerb_77(CV_POS, PNToVP(), story_tense, ConjugateVerb_33); say__p=1; ParaContent(); print " ";ParaContent(); print (the) noun;ParaContent(); print " to ";ParaContent(); (PHR_777_r44 ());ParaContent(); print "."; .L_Say1311; .L_SayX1294;
    rtrue;
];
Array TX_S_386 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_386;
[ R_TX_S_387 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The second noun] [aren't] able to receive things.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) second;ParaContent(); print " ";ConjugateVerb_76(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " able to receive things."; .L_Say1312; .L_SayX1295;
    rtrue;
];
Array TX_S_387 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_387;
[ R_TX_S_388 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~(first taking [the noun] off)[command clarification break]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "(first taking ";ParaContent(); print (the) noun;ParaContent(); print " off)";ParaContent(); CommandClarificationBreak(); .L_Say1313; .L_SayX1296;
    rtrue;
];
Array TX_S_388 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_388;
[ R_TX_S_389 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The second noun] [don't] seem interested.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) second;ParaContent(); print " ";ConjugateVerb_79(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " seem interested."; .L_Say1314; .L_SayX1297;
    rtrue;
];
Array TX_S_389 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_389;
[ R_TX_S_390 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The second noun] [are] carrying too many things already.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) second;ParaContent(); print " ";ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " carrying too many things already."; .L_Say1315; .L_SayX1298;
    rtrue;
];
Array TX_S_390 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_390;
[ R_TX_S_391 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [give] [the noun] to [the second noun].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ParaContent(); print " ";ConjugateVerb_33(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " ";ParaContent(); print (the) noun;ParaContent(); print " to ";ParaContent(); print (the) second;ParaContent(); print "."; .L_Say1316; .L_SayX1299;
    rtrue;
];
Array TX_S_391 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_391;
[ R_TX_S_392 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [give] [the noun] to [us].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) actor;ParaContent(); print " ";ConjugateVerb_33(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " ";ParaContent(); print (the) noun;ParaContent(); print " to ";ParaContent(); (PHR_775_r42 ());ParaContent(); print "."; .L_Say1317; .L_SayX1300;
    rtrue;
];
Array TX_S_392 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_392;
[ R_TX_S_393 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [give] [the noun] to [the second noun].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) actor;ParaContent(); print " ";ConjugateVerb_33(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " ";ParaContent(); print (the) noun;ParaContent(); print " to ";ParaContent(); print (the) second;ParaContent(); print "."; .L_Say1318; .L_SayX1301;
    rtrue;
];
Array TX_S_393 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_393;
[ R_TX_S_394 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [aren't] holding [the noun].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ParaContent(); print " ";ConjugateVerb_76(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " holding ";ParaContent(); print (the) noun;ParaContent(); print "."; .L_Say1319; .L_SayX1302;
    rtrue;
];
Array TX_S_394 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_394;
[ R_TX_S_395 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The second noun] [are] unimpressed.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) second;ParaContent(); print " ";ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " unimpressed."; .L_Say1320; .L_SayX1303;
    rtrue;
];
Array TX_S_395 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_395;
[ R_TX_S_396 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~That [seem] unnecessary.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "That ";ConjugateVerb_55(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " unnecessary."; .L_Say1321; .L_SayX1304;
    rtrue;
];
Array TX_S_396 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_396;
[ R_TX_S_397 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~(first taking [the noun] off)[command clarification break]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "(first taking ";ParaContent(); print (the) noun;ParaContent(); print " off)";ParaContent(); CommandClarificationBreak(); .L_Say1322; .L_SayX1305;
    rtrue;
];
Array TX_S_397 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_397;
[ R_TX_S_398 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Futile.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Futile."; .L_Say1323; .L_SayX1306;
    rtrue;
];
Array TX_S_398 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_398;
[ R_TX_S_399 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [lack] the nerve when it [if story tense is the past
    tense]came[otherwise]comes[end if] to the crucial moment.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ParaContent(); print " ";ConjugateVerb_38(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " the nerve when it ";
    	if (~~((((story_tense == I106_past_tense))))) jump L_Say1324;ParaContent(); print "came";
    	jump L_SayX1307; .L_Say1324;ParaContent(); print "comes";
    	.L_Say1325; .L_SayX1307;ParaContent(); print " to the crucial moment."; .L_Say1326; .L_SayX1308;
    rtrue;
];
Array TX_S_399 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_399;
[ R_TX_S_400 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Violence [aren't] the answer to this one.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Violence ";ConjugateVerb_76(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " the answer to this one."; .L_Say1327; .L_SayX1309;
    rtrue;
];
Array TX_S_400 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_400;
[ R_TX_S_401 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [don't] get much from that.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ParaContent(); print " ";ConjugateVerb_79(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " get much from that."; .L_Say1328; .L_SayX1310;
    rtrue;
];
Array TX_S_401 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_401;
[ R_TX_S_402 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The noun] [might not] like that.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) noun;ParaContent(); print " ";ConjugateVerb_70(CV_NEG, PNToVP(), story_tense); say__p=1; ParaContent(); print " like that."; .L_Say1329; .L_SayX1311;
    rtrue;
];
Array TX_S_402 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_402;
[ R_TX_S_403 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[There] [are] no reply.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_801_r68 ());ParaContent(); print " ";ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " no reply."; .L_Say1330; .L_SayX1312;
    rtrue;
];
Array TX_S_403 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_403;
[ R_TX_S_404 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [talk] to [ourselves] a while.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ParaContent(); print " ";ConjugateVerb_62(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " to ";ParaContent(); (PHR_777_r44 ());ParaContent(); print " a while."; .L_Say1331; .L_SayX1313;
    rtrue;
];
Array TX_S_404 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_404;
[ R_TX_S_405 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~This [provoke] no reaction.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "This ";ConjugateVerb_48(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " no reaction."; .L_Say1332; .L_SayX1314;
    rtrue;
];
Array TX_S_405 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_405;
[ R_TX_S_406 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[There] [are] no reply.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_801_r68 ());ParaContent(); print " ";ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " no reply."; .L_Say1333; .L_SayX1315;
    rtrue;
];
Array TX_S_406 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_406;
[ R_TX_S_407 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Time [pass].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Time ";ConjugateVerb_46(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print "."; .L_Say1334; .L_SayX1316;
    rtrue;
];
Array TX_S_407 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_407;
[ R_TX_S_408 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [wait].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) actor;ParaContent(); print " ";ConjugateVerb_65(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print "."; .L_Say1335; .L_SayX1317;
    rtrue;
];
Array TX_S_408 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_408;
[ R_TX_S_409 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [achieve] nothing by this.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ParaContent(); print " ";ConjugateVerb_21(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " nothing by this."; .L_Say1336; .L_SayX1318;
    rtrue;
];
Array TX_S_409 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_409;
[ R_TX_S_410 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [touch] [themselves].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) actor;ParaContent(); print " ";ConjugateVerb_18(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " ";ParaContent(); (PHR_796_r63 ());ParaContent(); print "."; .L_Say1337; .L_SayX1319;
    rtrue;
];
Array TX_S_410 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_410;
[ R_TX_S_411 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The noun] [might not like] that.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) noun;ParaContent(); print " ";ConjugateVerb_70(CV_NEG, PNToVP(), story_tense, ConjugateVerb_40); say__p=1; ParaContent(); print " that."; .L_Say1338; .L_SayX1320;
    rtrue;
];
Array TX_S_411 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_411;
[ R_TX_S_412 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [touch] [us].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) actor;ParaContent(); print " ";ConjugateVerb_18(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " ";ParaContent(); (PHR_775_r42 ());ParaContent(); print "."; .L_Say1339; .L_SayX1321;
    rtrue;
];
Array TX_S_412 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_412;
[ R_TX_S_413 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [touch] [the noun].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) actor;ParaContent(); print " ";ConjugateVerb_18(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " ";ParaContent(); print (the) noun;ParaContent(); print "."; .L_Say1340; .L_SayX1322;
    rtrue;
];
Array TX_S_413 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_413;
[ R_TX_S_414 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [feel] nothing unexpected.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ParaContent(); print " ";ConjugateVerb_30(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " nothing unexpected."; .L_Say1341; .L_SayX1323;
    rtrue;
];
Array TX_S_414 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_414;
[ R_TX_S_415 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [touch] [the noun].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) actor;ParaContent(); print " ";ConjugateVerb_18(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " ";ParaContent(); print (the) noun;ParaContent(); print "."; .L_Say1342; .L_SayX1324;
    rtrue;
];
Array TX_S_415 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_415;
[ R_TX_S_416 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~But [we] [aren't] holding [regarding the noun][those].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "But ";ParaContent(); (PHR_774_r41 ());ParaContent(); print " ";ConjugateVerb_76(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " holding ";ParaContent(); RegardingSingleObject(noun);ParaContent(); (PHR_784_r51 ());ParaContent(); print "."; .L_Say1343; .L_SayX1325;
    rtrue;
];
Array TX_S_416 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_416;
[ R_TX_S_417 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [wave] [the noun].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ParaContent(); print " ";ConjugateVerb_66(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " ";ParaContent(); print (the) noun;ParaContent(); print "."; .L_Say1344; .L_SayX1326;
    rtrue;
];
Array TX_S_417 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_417;
[ R_TX_S_418 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [wave] [the noun].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) actor;ParaContent(); print " ";ConjugateVerb_66(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " ";ParaContent(); print (the) noun;ParaContent(); print "."; .L_Say1345; .L_SayX1327;
    rtrue;
];
Array TX_S_418 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_418;
[ R_TX_S_419 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][They] [are] fixed in place.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); RegardingSingleObject(noun);ParaContent(); (PHR_789_r56 ());ParaContent(); print " ";ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " fixed in place."; .L_Say1346; .L_SayX1328;
    rtrue;
];
Array TX_S_419 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_419;
[ R_TX_S_420 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [are] unable to.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ParaContent(); print " ";ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " unable to."; .L_Say1347; .L_SayX1329;
    rtrue;
];
Array TX_S_420 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_420;
[ R_TX_S_421 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The noun] [might not like] that.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) noun;ParaContent(); print " ";ConjugateVerb_70(CV_NEG, PNToVP(), story_tense, ConjugateVerb_40); say__p=1; ParaContent(); print " that."; .L_Say1348; .L_SayX1330;
    rtrue;
];
Array TX_S_421 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_421;
[ R_TX_S_422 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Nothing obvious [happen].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Nothing obvious ";ConjugateVerb_35(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print "."; .L_Say1349; .L_SayX1331;
    rtrue;
];
Array TX_S_422 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_422;
[ R_TX_S_423 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [pull] [the noun].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) actor;ParaContent(); print " ";ConjugateVerb_49(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " ";ParaContent(); print (the) noun;ParaContent(); print "."; .L_Say1350; .L_SayX1332;
    rtrue;
];
Array TX_S_423 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_423;
[ R_TX_S_424 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][They] [are] fixed in place.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); RegardingSingleObject(noun);ParaContent(); (PHR_789_r56 ());ParaContent(); print " ";ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " fixed in place."; .L_Say1351; .L_SayX1333;
    rtrue;
];
Array TX_S_424 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_424;
[ R_TX_S_425 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [are] unable to.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ParaContent(); print " ";ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " unable to."; .L_Say1352; .L_SayX1334;
    rtrue;
];
Array TX_S_425 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_425;
[ R_TX_S_426 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The noun] [might not like] that.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) noun;ParaContent(); print " ";ConjugateVerb_70(CV_NEG, PNToVP(), story_tense, ConjugateVerb_40); say__p=1; ParaContent(); print " that."; .L_Say1353; .L_SayX1335;
    rtrue;
];
Array TX_S_426 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_426;
[ R_TX_S_427 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Nothing obvious [happen].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Nothing obvious ";ConjugateVerb_35(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print "."; .L_Say1354; .L_SayX1336;
    rtrue;
];
Array TX_S_427 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_427;
[ R_TX_S_428 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [push] [the noun].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) actor;ParaContent(); print " ";ConjugateVerb_50(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " ";ParaContent(); print (the) noun;ParaContent(); print "."; .L_Say1355; .L_SayX1337;
    rtrue;
];
Array TX_S_428 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_428;
[ R_TX_S_429 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][They] [are] fixed in place.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); RegardingSingleObject(noun);ParaContent(); (PHR_789_r56 ());ParaContent(); print " ";ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " fixed in place."; .L_Say1356; .L_SayX1338;
    rtrue;
];
Array TX_S_429 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_429;
[ R_TX_S_430 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [are] unable to.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ParaContent(); print " ";ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " unable to."; .L_Say1357; .L_SayX1339;
    rtrue;
];
Array TX_S_430 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_430;
[ R_TX_S_431 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The noun] [might not like] that.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) noun;ParaContent(); print " ";ConjugateVerb_70(CV_NEG, PNToVP(), story_tense, ConjugateVerb_40); say__p=1; ParaContent(); print " that."; .L_Say1358; .L_SayX1340;
    rtrue;
];
Array TX_S_431 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_431;
[ R_TX_S_432 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Nothing obvious [happen].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Nothing obvious ";ConjugateVerb_35(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print "."; .L_Say1359; .L_SayX1341;
    rtrue;
];
Array TX_S_432 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_432;
[ R_TX_S_433 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [turn] [the noun].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) actor;ParaContent(); print " ";ConjugateVerb_64(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " ";ParaContent(); print (the) noun;ParaContent(); print "."; .L_Say1360; .L_SayX1342;
    rtrue;
];
Array TX_S_433 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_433;
[ R_TX_S_434 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The noun] [cannot] be pushed from place to place.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) noun;ParaContent(); print " ";ConjugateVerb_15(CV_NEG, PNToVP(), story_tense); say__p=1; ParaContent(); print " be pushed from place to place."; .L_Say1361; .L_SayX1343;
    rtrue;
];
Array TX_S_434 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_434;
[ R_TX_S_435 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][They] [aren't] a direction.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); RegardingSingleObject(noun);ParaContent(); (PHR_789_r56 ());ParaContent(); print " ";ConjugateVerb_76(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " a direction."; .L_Say1362; .L_SayX1344;
    rtrue;
];
Array TX_S_435 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_435;
[ R_TX_S_436 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The noun] [cannot] be pushed up or down.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) noun;ParaContent(); print " ";ConjugateVerb_15(CV_NEG, PNToVP(), story_tense); say__p=1; ParaContent(); print " be pushed up or down."; .L_Say1363; .L_SayX1345;
    rtrue;
];
Array TX_S_436 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_436;
[ R_TX_S_437 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The noun] [cannot] be pushed from here.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) noun;ParaContent(); print " ";ConjugateVerb_15(CV_NEG, PNToVP(), story_tense); say__p=1; ParaContent(); print " be pushed from here."; .L_Say1364; .L_SayX1346;
    rtrue;
];
Array TX_S_437 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_437;
[ R_TX_S_438 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The noun] [cannot] be pushed from place to place.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) noun;ParaContent(); print " ";ConjugateVerb_15(CV_NEG, PNToVP(), story_tense); say__p=1; ParaContent(); print " be pushed from place to place."; .L_Say1365; .L_SayX1347;
    rtrue;
];
Array TX_S_438 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_438;
[ R_TX_S_439 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The noun] [might not like] that.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) noun;ParaContent(); print " ";ConjugateVerb_70(CV_NEG, PNToVP(), story_tense, ConjugateVerb_40); say__p=1; ParaContent(); print " that."; .L_Say1366; .L_SayX1348;
    rtrue;
];
Array TX_S_439 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_439;
[ R_TX_S_440 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [achieve] nothing by this.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ParaContent(); print " ";ConjugateVerb_21(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " nothing by this."; .L_Say1367; .L_SayX1349;
    rtrue;
];
Array TX_S_440 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_440;
[ R_TX_S_441 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [squeeze] [the noun].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) actor;ParaContent(); print " ";ConjugateVerb_59(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " ";ParaContent(); print (the) noun;ParaContent(); print "."; .L_Say1368; .L_SayX1350;
    rtrue;
];
Array TX_S_441 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_441;
[ R_TX_S_442 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~That was a rhetorical question.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "That was a rhetorical question."; .L_Say1369; .L_SayX1351;
    rtrue;
];
Array TX_S_442 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_442;
[ R_TX_S_443 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~That was a rhetorical question.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "That was a rhetorical question."; .L_Say1370; .L_SayX1352;
    rtrue;
];
Array TX_S_443 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_443;
[ R_TX_S_444 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~This dangerous act [would achieve] little.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "This dangerous act ";ConjugateVerb_73(CV_POS, PNToVP(), story_tense, ConjugateVerb_21); say__p=1; ParaContent(); print " little."; .L_Say1371; .L_SayX1353;
    rtrue;
];
Array TX_S_444 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_444;
[ R_TX_S_445 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~The dreadful truth [are], this [are not] a dream.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "The dreadful truth ";ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print ", this ";ConjugateVerb_0(CV_NEG, PNToVP(), story_tense); say__p=1; ParaContent(); print " a dream."; .L_Say1372; .L_SayX1354;
    rtrue;
];
Array TX_S_445 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_445;
[ R_TX_S_446 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~What a good idea.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "What a good idea."; .L_Say1373; .L_SayX1355;
    rtrue;
];
Array TX_S_446 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_446;
[ R_TX_S_447 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [smell] nothing unexpected.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ParaContent(); print " ";ConjugateVerb_57(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " nothing unexpected."; .L_Say1374; .L_SayX1356;
    rtrue;
];
Array TX_S_447 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_447;
[ R_TX_S_448 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [sniff].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) actor;ParaContent(); print " ";ConjugateVerb_58(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print "."; .L_Say1375; .L_SayX1357;
    rtrue;
];
Array TX_S_448 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_448;
[ R_TX_S_449 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [hear] nothing unexpected.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ParaContent(); print " ";ConjugateVerb_36(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " nothing unexpected."; .L_Say1376; .L_SayX1358;
    rtrue;
];
Array TX_S_449 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_449;
[ R_TX_S_450 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [listen].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) actor;ParaContent(); print " ";ConjugateVerb_41(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print "."; .L_Say1377; .L_SayX1359;
    rtrue;
];
Array TX_S_450 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_450;
[ R_TX_S_451 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [taste] nothing unexpected.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ParaContent(); print " ";ConjugateVerb_63(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " nothing unexpected."; .L_Say1378; .L_SayX1360;
    rtrue;
];
Array TX_S_451 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_451;
[ R_TX_S_452 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [taste] [the noun].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) actor;ParaContent(); print " ";ConjugateVerb_63(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " ";ParaContent(); print (the) noun;ParaContent(); print "."; .L_Say1379; .L_SayX1361;
    rtrue;
];
Array TX_S_452 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_452;
[ R_TX_S_453 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Cutting [regarding the noun][them] up [would achieve] little.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Cutting ";ParaContent(); RegardingSingleObject(noun);ParaContent(); (PHR_792_r59 ());ParaContent(); print " up ";ConjugateVerb_73(CV_POS, PNToVP(), story_tense, ConjugateVerb_21); say__p=1; ParaContent(); print " little."; .L_Say1380; .L_SayX1362;
    rtrue;
];
Array TX_S_453 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_453;
[ R_TX_S_454 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [jump] on the spot.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ParaContent(); print " ";ConjugateVerb_37(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " on the spot."; .L_Say1381; .L_SayX1363;
    rtrue;
];
Array TX_S_454 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_454;
[ R_TX_S_455 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [jump] on the spot.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) actor;ParaContent(); print " ";ConjugateVerb_37(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " on the spot."; .L_Say1382; .L_SayX1364;
    rtrue;
];
Array TX_S_455 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_455;
[ R_TX_S_456 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [would achieve] nothing by this.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ParaContent(); print " ";ConjugateVerb_73(CV_POS, PNToVP(), story_tense, ConjugateVerb_21); say__p=1; ParaContent(); print " nothing by this."; .L_Say1383; .L_SayX1365;
    rtrue;
];
Array TX_S_456 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_456;
[ R_TX_S_457 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[There's] nothing suitable to drink here.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_805_r72 ());ParaContent(); print " nothing suitable to drink here."; .L_Say1384; .L_SayX1366;
    rtrue;
];
Array TX_S_457 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_457;
[ R_TX_S_458 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Oh, don't [if American dialect option is
    active]apologize[otherwise]apologise[end if].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Oh, don't ";
    	if (~~(((((Adj_25_t1_v16(5))))))) jump L_Say1385;ParaContent(); print "apologize";
    	jump L_SayX1367; .L_Say1385;ParaContent(); print "apologise";
    	.L_Say1386; .L_SayX1367;ParaContent(); print "."; .L_Say1387; .L_SayX1368;
    rtrue;
];
Array TX_S_458 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_458;
[ R_TX_S_459 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[There's] nothing sensible to swing here.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_805_r72 ());ParaContent(); print " nothing sensible to swing here."; .L_Say1388; .L_SayX1369;
    rtrue;
];
Array TX_S_459 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_459;
[ R_TX_S_460 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The noun] [might not like] that.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) noun;ParaContent(); print " ";ConjugateVerb_70(CV_NEG, PNToVP(), story_tense, ConjugateVerb_40); say__p=1; ParaContent(); print " that."; .L_Say1389; .L_SayX1370;
    rtrue;
];
Array TX_S_460 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_460;
[ R_TX_S_461 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [rub] [the noun].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ParaContent(); print " ";ConjugateVerb_52(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " ";ParaContent(); print (the) noun;ParaContent(); print "."; .L_Say1390; .L_SayX1371;
    rtrue;
];
Array TX_S_461 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_461;
[ R_TX_S_462 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [rub] [the noun].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) actor;ParaContent(); print " ";ConjugateVerb_52(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " ";ParaContent(); print (the) noun;ParaContent(); print "."; .L_Say1391; .L_SayX1372;
    rtrue;
];
Array TX_S_462 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_462;
[ R_TX_S_463 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No, [we] [can't set] [regarding the noun][those] to anything.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "No, ";ParaContent(); (PHR_774_r41 ());ParaContent(); print " ";ConjugateVerb_77(CV_POS, PNToVP(), story_tense, ConjugateVerb_56); say__p=1; ParaContent(); print " ";ParaContent(); RegardingSingleObject(noun);ParaContent(); (PHR_784_r51 ());ParaContent(); print " to anything."; .L_Say1392; .L_SayX1373;
    rtrue;
];
Array TX_S_463 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_463;
[ R_TX_S_464 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [wave].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ParaContent(); print " ";ConjugateVerb_66(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print "."; .L_Say1393; .L_SayX1374;
    rtrue;
];
Array TX_S_464 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_464;
[ R_TX_S_465 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [wave].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print (The) actor;ParaContent(); print " ";ConjugateVerb_66(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print "."; .L_Say1394; .L_SayX1375;
    rtrue;
];
Array TX_S_465 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_465;
[ R_TX_S_466 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Nothing [are] on sale.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Nothing ";ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " on sale."; .L_Say1395; .L_SayX1376;
    rtrue;
];
Array TX_S_466 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_466;
[ R_TX_S_467 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~I don't think much is to be achieved by that.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "I don't think much is to be achieved by that."; .L_Say1396; .L_SayX1377;
    rtrue;
];
Array TX_S_467 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_467;
[ R_TX_S_468 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [aren't] feeling especially drowsy.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ParaContent(); print " ";ConjugateVerb_76(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " feeling especially drowsy."; .L_Say1397; .L_SayX1378;
    rtrue;
];
Array TX_S_468 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_468;
[ R_TX_S_469 
    tmp_0 ! Let/loop value, e.g., 'locked-thing': thing
    ;
    tmp_0=LocalParking-->0;
#ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [lack] a key that fits [the locked-thing].~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); (PHR_779_r46 ());ParaContent(); print " ";ConjugateVerb_38(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " a key that fits ";ParaContent(); print (the) tmp_0;ParaContent(); print "."; .L_Say1398; .L_SayX1379;
    rtrue;
];
Array TX_S_469 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_469;
[ R_TX_S_470 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~(with [the key unlocked with])[command clarification break]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "(with ";ParaContent(); print (the) (MStack-->MstVO(20077,0));ParaContent(); print ")";ParaContent(); CommandClarificationBreak(); .L_Say1399; .L_SayX1380;
    rtrue;
];
Array TX_S_470 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_470;
[ R_TX_S_471 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~(with [the key locked with])[command clarification break]~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "(with ";ParaContent(); print (the) (MStack-->MstVO(20078,0));ParaContent(); print ")";ParaContent(); CommandClarificationBreak(); .L_Say1400; .L_SayX1381;
    rtrue;
];
Array TX_S_471 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_471;
[ R_TX_S_472 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[paragraph break]Please press SPACE to continue.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); DivideParagraphPoint(); new_line;ParaContent(); print "Please press SPACE to continue."; .L_Say1401; .L_SayX1382;
    rtrue;
];
Array TX_S_472 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_472;
[ R_TX_S_473 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the second noun][Those] [don't] seem to fit the lock.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); RegardingSingleObject(second);ParaContent(); (PHR_785_r52 ());ParaContent(); print " ";ConjugateVerb_79(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " seem to fit the lock."; .L_Say1402; .L_SayX1383;
    rtrue;
];
Array TX_S_473 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_473;
[ R_TX_S_474 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the second noun][Those] [don't] seem to fit the lock.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); RegardingSingleObject(second);ParaContent(); (PHR_785_r52 ());ParaContent(); print " ";ConjugateVerb_79(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " seem to fit the lock."; .L_Say1403; .L_SayX1384;
    rtrue;
];
Array TX_S_474 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_474;
[ R_TX_S_475 
    tmp_0 ! Let/loop value, e.g., 'containing keychain': keychain
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Without holding [the noun], [we] [can] do nothing.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Without holding ";ParaContent(); print (the) noun;ParaContent(); print ", ";ParaContent(); (PHR_774_r41 ());ParaContent(); print " ";ConjugateVerb_15(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " do nothing."; .L_Say1404; .L_SayX1385;
    rtrue;
];
Array TX_S_475 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_475;
[ R_TX_S_476 
    tmp_0 ! Let/loop value, e.g., '?-1,-1?': object
    tmp_1 ! Let/loop value, e.g., 'containing keychain': keychain
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Without holding [the second noun], [we] [can] do nothing.~"; rtrue; }
    #endif; ! DEBUG
    say__p=1;ParaContent(); print "Without holding ";ParaContent(); print (the) second;ParaContent(); print ", ";ParaContent(); (PHR_774_r41 ());ParaContent(); print " ";ConjugateVerb_15(CV_POS, PNToVP(), story_tense); say__p=1; ParaContent(); print " do nothing."; .L_Say1405; .L_SayX1386;
    rtrue;
];
Array TX_S_476 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_476;



Array Rel_Record_0 -->
    0 (101515264) RELATION_TY MAX_POSITIVE_NUMBER NULL NULL
    "equality relation"
     RELS_TEST+RELS_LOOKUP_ANY+RELS_LOOKUP_ALL_X+RELS_LOOKUP_ALL_Y+RELS_LIST
     0 KD2_relation_of_values Rel_Handler_0 "is";
[ Rel_Handler_0 
    rr ! Implied call parameter
    task ! Implied call parameter
    X ! Implied call parameter
    Y ! Implied call parameter
    Z1 ! loop counter
    Z2 ! loop counter
    Z3 ! loop counter
    Z4 ! loop counter
    ;
    switch (task) {
        RELS_TEST: if (X == Y) rtrue; rfalse;
        RELS_LOOKUP_ANY: if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(UNKNOWN_TY);
        } else {
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(UNKNOWN_TY);
        }
        RELS_LOOKUP_ALL_X, RELS_LOOKUP_ALL_Y: LIST_OF_TY_SetLength(Y, 0);
        if (task == RELS_LOOKUP_ALL_X) {
        } else {
        }
        return Y;
        RELS_LIST: LIST_OF_TY_SetLength(X, 0);
        if (Y == RLIST_ALL_X) {
        } else if (Y == RLIST_ALL_Y) {
        }
        return X;
    }
    rfalse;
];
Array Rel_Record_1 -->
    0 (101515264) RELATION_TY MAX_POSITIVE_NUMBER NULL NULL
    "provision relation"
     RELS_TEST+RELS_LOOKUP_ANY+RELS_LOOKUP_ALL_X+RELS_LOOKUP_ALL_Y+RELS_LIST
     0 KD3_relation_of_objects Rel_Handler_1 "provides";
[ Rel_Handler_1 
    rr ! Implied call parameter
    task ! Implied call parameter
    X ! Implied call parameter
    Y ! Implied call parameter
    Z1 ! loop counter
    Z2 ! loop counter
    Z3 ! loop counter
    Z4 ! loop counter
    ;
    switch (task) {
        RELS_TEST: if (false) rtrue; rfalse;
        RELS_LOOKUP_ANY: if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(UNKNOWN_TY);
        } else {
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(UNKNOWN_TY);
        }
        RELS_LOOKUP_ALL_X, RELS_LOOKUP_ALL_Y: LIST_OF_TY_SetLength(Y, 0);
        if (task == RELS_LOOKUP_ALL_X) {
        } else {
        }
        return Y;
        RELS_LIST: LIST_OF_TY_SetLength(X, 0);
        if (Y == RLIST_ALL_X) {
        } else if (Y == RLIST_ALL_Y) {
        }
        return X;
    }
    rfalse;
];
Array Rel_Record_3 -->
    0 (101515264) RELATION_TY MAX_POSITIVE_NUMBER NULL NULL
    "universal relation"
     RELS_TEST+RELS_LOOKUP_ANY+RELS_LOOKUP_ALL_X+RELS_LOOKUP_ALL_Y+RELS_LIST
     0 KD3_relation_of_objects Rel_Handler_3 "provides";
[ Rel_Handler_3 
    rr ! Implied call parameter
    task ! Implied call parameter
    X ! Implied call parameter
    Y ! Implied call parameter
    Z1 ! loop counter
    Z2 ! loop counter
    Z3 ! loop counter
    Z4 ! loop counter
    ;
    switch (task) {
        RELS_TEST: if (((RlnGetF(X, RR_HANDLER))(X, RELS_TEST, Y))) rtrue; rfalse;
        RELS_LOOKUP_ANY: if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(UNKNOWN_TY);
        } else {
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(UNKNOWN_TY);
        }
        RELS_LOOKUP_ALL_X, RELS_LOOKUP_ALL_Y: LIST_OF_TY_SetLength(Y, 0);
        if (task == RELS_LOOKUP_ALL_X) {
        } else {
        }
        return Y;
        RELS_LIST: LIST_OF_TY_SetLength(X, 0);
        if (Y == RLIST_ALL_X) {
        } else if (Y == RLIST_ALL_Y) {
        }
        return X;
    }
    rfalse;
];
Array Rel_Record_5 -->
    0 (101515264) RELATION_TY MAX_POSITIVE_NUMBER NULL NULL
    "meaning relation"
     RELS_TEST+RELS_LOOKUP_ANY+RELS_LOOKUP_ALL_X+RELS_LOOKUP_ALL_Y+RELS_LIST
     0 KD3_relation_of_objects Rel_Handler_5 "means";
[ Rel_Handler_5 
    rr ! Implied call parameter
    task ! Implied call parameter
    X ! Implied call parameter
    Y ! Implied call parameter
    Z1 ! loop counter
    Z2 ! loop counter
    Z3 ! loop counter
    Z4 ! loop counter
    ;
    switch (task) {
        RELS_TEST: if ((BlkValueCompare(X(CV_MEANING), Y)==0)) rtrue; rfalse;
        RELS_LOOKUP_ANY: if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(UNKNOWN_TY);
        } else {
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(UNKNOWN_TY);
        }
        RELS_LOOKUP_ALL_X, RELS_LOOKUP_ALL_Y: LIST_OF_TY_SetLength(Y, 0);
        if (task == RELS_LOOKUP_ALL_X) {
        } else {
        }
        return Y;
        RELS_LIST: LIST_OF_TY_SetLength(X, 0);
        if (Y == RLIST_ALL_X) {
        } else if (Y == RLIST_ALL_Y) {
        }
        return X;
    }
    rfalse;
];
Array Rel_Record_15 -->
    0 (101515264) RELATION_TY MAX_POSITIVE_NUMBER NULL NULL
    "containment relation"
     RELS_TEST+RELS_LOOKUP_ANY+RELS_LOOKUP_ALL_X+RELS_LOOKUP_ALL_Y+RELS_LIST+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_LOOKUP_ANY
     0 KD3_relation_of_objects Rel_Handler_15 "contains";
[ Rel_Handler_15 
    rr ! Implied call parameter
    task ! Implied call parameter
    X ! Implied call parameter
    Y ! Implied call parameter
    Z1 ! loop counter
    Z2 ! loop counter
    Z3 ! loop counter
    Z4 ! loop counter
    ;
    switch (task) {
        RELS_TEST: if (X == ContainerOf(Y)) rtrue; rfalse;
        RELS_LOOKUP_ANY: if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
            objectloop (Z1 ofclass Object) {
                if (Rel_Handler_15(rr, RELS_TEST, Z1, X)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(OBJECT_TY);
        } else {
            objectloop (Z1 ofclass Object) {
                if (Rel_Handler_15(rr, RELS_TEST, X, Z1)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(OBJECT_TY);
        }
        RELS_LOOKUP_ALL_X, RELS_LOOKUP_ALL_Y: LIST_OF_TY_SetLength(Y, 0);
        if (task == RELS_LOOKUP_ALL_X) {
            objectloop (Z1 ofclass Object) {
                if (Rel_Handler_15(rr, RELS_TEST, Z1, X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        } else {
            objectloop (Z1 ofclass Object) {
                if (Rel_Handler_15(rr, RELS_TEST, X, Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        }
        return Y;
        RELS_LIST: LIST_OF_TY_SetLength(X, 0);
        if (Y == RLIST_ALL_X) {
            objectloop (Z1 ofclass Object) {
                objectloop (Z3 ofclass Object) {
                    if (Rel_Handler_15(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z1, false, 0, true);
                    }
                }
            }
        } else if (Y == RLIST_ALL_Y) {
            objectloop (Z1 ofclass Object) {
                objectloop (Z3 ofclass Object) {
                    if (Rel_Handler_15(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z3, false, 0, true);
                    }
                }
            }
        }
        return X;
        RELS_ASSERT_TRUE: MoveObject(Y,X); rtrue;
        RELS_ASSERT_FALSE: rfalse; rtrue;
    }
    rfalse;
];
Array Rel_Record_17 -->
    0 (101515264) RELATION_TY MAX_POSITIVE_NUMBER NULL NULL
    "support relation"
     RELS_TEST+RELS_LOOKUP_ANY+RELS_LOOKUP_ALL_X+RELS_LOOKUP_ALL_Y+RELS_LIST+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_LOOKUP_ANY
     0 KD4_relation_of_supporters_to_ Rel_Handler_17 "supports";
[ Rel_Handler_17 
    rr ! Implied call parameter
    task ! Implied call parameter
    X ! Implied call parameter
    Y ! Implied call parameter
    Z1 ! loop counter
    Z2 ! loop counter
    Z3 ! loop counter
    Z4 ! loop counter
    ;
    switch (task) {
        RELS_TEST: if (X == SupporterOf(Y)) rtrue; rfalse;
        RELS_LOOKUP_ANY: if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
            for (Z1=IK6_First: Z1: Z1=Z1.IK6_Link) {
                if (Rel_Handler_17(rr, RELS_TEST, Z1, X)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_17(rr, RELS_TEST, X, Z1)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        }
        RELS_LOOKUP_ALL_X, RELS_LOOKUP_ALL_Y: LIST_OF_TY_SetLength(Y, 0);
        if (task == RELS_LOOKUP_ALL_X) {
            for (Z1=IK6_First: Z1: Z1=Z1.IK6_Link) {
                if (Rel_Handler_17(rr, RELS_TEST, Z1, X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_17(rr, RELS_TEST, X, Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        }
        return Y;
        RELS_LIST: LIST_OF_TY_SetLength(X, 0);
        if (Y == RLIST_ALL_X) {
            for (Z1=IK6_First: Z1: Z1=Z1.IK6_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_17(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z1, false, 0, true);
                    }
                }
            }
        } else if (Y == RLIST_ALL_Y) {
            for (Z1=IK6_First: Z1: Z1=Z1.IK6_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_17(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z3, false, 0, true);
                    }
                }
            }
        }
        return X;
        RELS_ASSERT_TRUE: MoveObject(Y,X); rtrue;
        RELS_ASSERT_FALSE: rfalse; rtrue;
    }
    rfalse;
];
Array Rel_Record_19 -->
    0 (101515264) RELATION_TY MAX_POSITIVE_NUMBER NULL NULL
    "incorporation relation"
     RELS_TEST+RELS_LOOKUP_ANY+RELS_LOOKUP_ALL_X+RELS_LOOKUP_ALL_Y+RELS_LIST+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_LOOKUP_ANY
     0 KD5_relation_of_things Rel_Handler_19 "incorporates";
[ Rel_Handler_19 
    rr ! Implied call parameter
    task ! Implied call parameter
    X ! Implied call parameter
    Y ! Implied call parameter
    Z1 ! loop counter
    Z2 ! loop counter
    Z3 ! loop counter
    Z4 ! loop counter
    ;
    switch (task) {
        RELS_TEST: if (X == (Y.component_parent)) rtrue; rfalse;
        RELS_LOOKUP_ANY: if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_19(rr, RELS_TEST, Z1, X)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_19(rr, RELS_TEST, X, Z1)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        }
        RELS_LOOKUP_ALL_X, RELS_LOOKUP_ALL_Y: LIST_OF_TY_SetLength(Y, 0);
        if (task == RELS_LOOKUP_ALL_X) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_19(rr, RELS_TEST, Z1, X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_19(rr, RELS_TEST, X, Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        }
        return Y;
        RELS_LIST: LIST_OF_TY_SetLength(X, 0);
        if (Y == RLIST_ALL_X) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_19(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z1, false, 0, true);
                    }
                }
            }
        } else if (Y == RLIST_ALL_Y) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_19(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z3, false, 0, true);
                    }
                }
            }
        }
        return X;
        RELS_ASSERT_TRUE: MakePart(Y,X); rtrue;
        RELS_ASSERT_FALSE: rfalse; rtrue;
    }
    rfalse;
];
Array Rel_Record_21 -->
    0 (101515264) RELATION_TY MAX_POSITIVE_NUMBER NULL NULL
    "carrying relation"
     RELS_TEST+RELS_LOOKUP_ANY+RELS_LOOKUP_ALL_X+RELS_LOOKUP_ALL_Y+RELS_LIST+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_LOOKUP_ANY
     0 KD6_relation_of_people_to_thin Rel_Handler_21 "carries";
[ Rel_Handler_21 
    rr ! Implied call parameter
    task ! Implied call parameter
    X ! Implied call parameter
    Y ! Implied call parameter
    Z1 ! loop counter
    Z2 ! loop counter
    Z3 ! loop counter
    Z4 ! loop counter
    ;
    switch (task) {
        RELS_TEST: if (X == CarrierOf(Y)) rtrue; rfalse;
        RELS_LOOKUP_ANY: if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                if (Rel_Handler_21(rr, RELS_TEST, Z1, X)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_21(rr, RELS_TEST, X, Z1)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        }
        RELS_LOOKUP_ALL_X, RELS_LOOKUP_ALL_Y: LIST_OF_TY_SetLength(Y, 0);
        if (task == RELS_LOOKUP_ALL_X) {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                if (Rel_Handler_21(rr, RELS_TEST, Z1, X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_21(rr, RELS_TEST, X, Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        }
        return Y;
        RELS_LIST: LIST_OF_TY_SetLength(X, 0);
        if (Y == RLIST_ALL_X) {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_21(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z1, false, 0, true);
                    }
                }
            }
        } else if (Y == RLIST_ALL_Y) {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_21(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z3, false, 0, true);
                    }
                }
            }
        }
        return X;
        RELS_ASSERT_TRUE: MoveObject(Y,X); rtrue;
        RELS_ASSERT_FALSE: rfalse; rtrue;
    }
    rfalse;
];
Array Rel_Record_23 -->
    0 (101515264) RELATION_TY MAX_POSITIVE_NUMBER NULL NULL
    "holding relation"
     RELS_TEST+RELS_LOOKUP_ANY+RELS_LOOKUP_ALL_X+RELS_LOOKUP_ALL_Y+RELS_LIST+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_LOOKUP_ANY
     0 KD6_relation_of_people_to_thin Rel_Handler_23 "holds";
[ Rel_Handler_23 
    rr ! Implied call parameter
    task ! Implied call parameter
    X ! Implied call parameter
    Y ! Implied call parameter
    Z1 ! loop counter
    Z2 ! loop counter
    Z3 ! loop counter
    Z4 ! loop counter
    ;
    switch (task) {
        RELS_TEST: if (X == HolderOf(Y)) rtrue; rfalse;
        RELS_LOOKUP_ANY: if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                if (Rel_Handler_23(rr, RELS_TEST, Z1, X)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_23(rr, RELS_TEST, X, Z1)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        }
        RELS_LOOKUP_ALL_X, RELS_LOOKUP_ALL_Y: LIST_OF_TY_SetLength(Y, 0);
        if (task == RELS_LOOKUP_ALL_X) {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                if (Rel_Handler_23(rr, RELS_TEST, Z1, X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_23(rr, RELS_TEST, X, Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        }
        return Y;
        RELS_LIST: LIST_OF_TY_SetLength(X, 0);
        if (Y == RLIST_ALL_X) {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_23(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z1, false, 0, true);
                    }
                }
            }
        } else if (Y == RLIST_ALL_Y) {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_23(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z3, false, 0, true);
                    }
                }
            }
        }
        return X;
        RELS_ASSERT_TRUE: MoveObject(Y,X); rtrue;
        RELS_ASSERT_FALSE: rfalse; rtrue;
    }
    rfalse;
];
Array Rel_Record_25 -->
    0 (101515264) RELATION_TY MAX_POSITIVE_NUMBER NULL NULL
    "wearing relation"
     RELS_TEST+RELS_LOOKUP_ANY+RELS_LOOKUP_ALL_X+RELS_LOOKUP_ALL_Y+RELS_LIST+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_LOOKUP_ANY
     0 KD6_relation_of_people_to_thin Rel_Handler_25 "wears";
[ Rel_Handler_25 
    rr ! Implied call parameter
    task ! Implied call parameter
    X ! Implied call parameter
    Y ! Implied call parameter
    Z1 ! loop counter
    Z2 ! loop counter
    Z3 ! loop counter
    Z4 ! loop counter
    ;
    switch (task) {
        RELS_TEST: if (X == WearerOf(Y)) rtrue; rfalse;
        RELS_LOOKUP_ANY: if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                if (Rel_Handler_25(rr, RELS_TEST, Z1, X)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_25(rr, RELS_TEST, X, Z1)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        }
        RELS_LOOKUP_ALL_X, RELS_LOOKUP_ALL_Y: LIST_OF_TY_SetLength(Y, 0);
        if (task == RELS_LOOKUP_ALL_X) {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                if (Rel_Handler_25(rr, RELS_TEST, Z1, X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_25(rr, RELS_TEST, X, Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        }
        return Y;
        RELS_LIST: LIST_OF_TY_SetLength(X, 0);
        if (Y == RLIST_ALL_X) {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_25(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z1, false, 0, true);
                    }
                }
            }
        } else if (Y == RLIST_ALL_Y) {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_25(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z3, false, 0, true);
                    }
                }
            }
        }
        return X;
        RELS_ASSERT_TRUE: WearObject(Y,X); rtrue;
        RELS_ASSERT_FALSE: rfalse; rtrue;
    }
    rfalse;
];
Array Rel_Record_27 -->
    0 (101515264) RELATION_TY MAX_POSITIVE_NUMBER NULL NULL
    "possession relation"
     RELS_TEST+RELS_LOOKUP_ANY+RELS_LOOKUP_ALL_X+RELS_LOOKUP_ALL_Y+RELS_LIST+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_LOOKUP_ANY
     0 KD3_relation_of_objects Rel_Handler_27 "has";
[ Rel_Handler_27 
    rr ! Implied call parameter
    task ! Implied call parameter
    X ! Implied call parameter
    Y ! Implied call parameter
    Z1 ! loop counter
    Z2 ! loop counter
    Z3 ! loop counter
    Z4 ! loop counter
    ;
    switch (task) {
        RELS_TEST: if (X == OwnerOf(Y)) rtrue; rfalse;
        RELS_LOOKUP_ANY: if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(UNKNOWN_TY);
        } else {
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(UNKNOWN_TY);
        }
        RELS_LOOKUP_ALL_X, RELS_LOOKUP_ALL_Y: LIST_OF_TY_SetLength(Y, 0);
        if (task == RELS_LOOKUP_ALL_X) {
        } else {
        }
        return Y;
        RELS_LIST: LIST_OF_TY_SetLength(X, 0);
        if (Y == RLIST_ALL_X) {
        } else if (Y == RLIST_ALL_Y) {
        }
        return X;
        RELS_ASSERT_TRUE: MoveObject(Y,X); rtrue;
        RELS_ASSERT_FALSE: rfalse; rtrue;
    }
    rfalse;
];
Array Rel_Record_31 -->
    0 (101515264) RELATION_TY MAX_POSITIVE_NUMBER NULL NULL
    "visibility relation"
     RELS_TEST+RELS_LOOKUP_ANY+RELS_LOOKUP_ALL_X+RELS_LOOKUP_ALL_Y+RELS_LIST
     0 KD5_relation_of_things Rel_Handler_31 "can-see";
[ Rel_Handler_31 
    rr ! Implied call parameter
    task ! Implied call parameter
    X ! Implied call parameter
    Y ! Implied call parameter
    Z1 ! loop counter
    Z2 ! loop counter
    Z3 ! loop counter
    Z4 ! loop counter
    ;
    switch (task) {
        RELS_TEST: if (TestVisibility(X,Y)) rtrue; rfalse;
        RELS_LOOKUP_ANY: if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_31(rr, RELS_TEST, Z1, X)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_31(rr, RELS_TEST, X, Z1)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        }
        RELS_LOOKUP_ALL_X, RELS_LOOKUP_ALL_Y: LIST_OF_TY_SetLength(Y, 0);
        if (task == RELS_LOOKUP_ALL_X) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_31(rr, RELS_TEST, Z1, X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_31(rr, RELS_TEST, X, Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        }
        return Y;
        RELS_LIST: LIST_OF_TY_SetLength(X, 0);
        if (Y == RLIST_ALL_X) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_31(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z1, false, 0, true);
                    }
                }
            }
        } else if (Y == RLIST_ALL_Y) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_31(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z3, false, 0, true);
                    }
                }
            }
        }
        return X;
    }
    rfalse;
];
Array Rel_Record_33 -->
    0 (101515264) RELATION_TY MAX_POSITIVE_NUMBER NULL NULL
    "touchability relation"
     RELS_TEST+RELS_LOOKUP_ANY+RELS_LOOKUP_ALL_X+RELS_LOOKUP_ALL_Y+RELS_LIST
     0 KD5_relation_of_things Rel_Handler_33 "can-touch";
[ Rel_Handler_33 
    rr ! Implied call parameter
    task ! Implied call parameter
    X ! Implied call parameter
    Y ! Implied call parameter
    Z1 ! loop counter
    Z2 ! loop counter
    Z3 ! loop counter
    Z4 ! loop counter
    ;
    switch (task) {
        RELS_TEST: if (TestTouchability(X,Y)) rtrue; rfalse;
        RELS_LOOKUP_ANY: if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_33(rr, RELS_TEST, Z1, X)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_33(rr, RELS_TEST, X, Z1)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        }
        RELS_LOOKUP_ALL_X, RELS_LOOKUP_ALL_Y: LIST_OF_TY_SetLength(Y, 0);
        if (task == RELS_LOOKUP_ALL_X) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_33(rr, RELS_TEST, Z1, X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_33(rr, RELS_TEST, X, Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        }
        return Y;
        RELS_LIST: LIST_OF_TY_SetLength(X, 0);
        if (Y == RLIST_ALL_X) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_33(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z1, false, 0, true);
                    }
                }
            }
        } else if (Y == RLIST_ALL_Y) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_33(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z3, false, 0, true);
                    }
                }
            }
        }
        return X;
    }
    rfalse;
];
Array Rel_Record_35 -->
    0 (101515264) RELATION_TY MAX_POSITIVE_NUMBER NULL NULL
    "concealment relation"
     RELS_TEST+RELS_LOOKUP_ANY+RELS_LOOKUP_ALL_X+RELS_LOOKUP_ALL_Y+RELS_LIST
     0 KD5_relation_of_things Rel_Handler_35 "conceals";
[ Rel_Handler_35 
    rr ! Implied call parameter
    task ! Implied call parameter
    X ! Implied call parameter
    Y ! Implied call parameter
    Z1 ! loop counter
    Z2 ! loop counter
    Z3 ! loop counter
    Z4 ! loop counter
    ;
    switch (task) {
        RELS_TEST: if (TestConcealment(X,Y)) rtrue; rfalse;
        RELS_LOOKUP_ANY: if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_35(rr, RELS_TEST, Z1, X)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_35(rr, RELS_TEST, X, Z1)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        }
        RELS_LOOKUP_ALL_X, RELS_LOOKUP_ALL_Y: LIST_OF_TY_SetLength(Y, 0);
        if (task == RELS_LOOKUP_ALL_X) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_35(rr, RELS_TEST, Z1, X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_35(rr, RELS_TEST, X, Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        }
        return Y;
        RELS_LIST: LIST_OF_TY_SetLength(X, 0);
        if (Y == RLIST_ALL_X) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_35(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z1, false, 0, true);
                    }
                }
            }
        } else if (Y == RLIST_ALL_Y) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_35(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z3, false, 0, true);
                    }
                }
            }
        }
        return X;
    }
    rfalse;
];
Array Rel_Record_37 -->
    0 (101515264) RELATION_TY MAX_POSITIVE_NUMBER NULL NULL
    "enclosure relation"
     RELS_TEST+RELS_LOOKUP_ANY+RELS_LOOKUP_ALL_X+RELS_LOOKUP_ALL_Y+RELS_LIST
     0 KD3_relation_of_objects Rel_Handler_37 "encloses";
[ Rel_Handler_37 
    rr ! Implied call parameter
    task ! Implied call parameter
    X ! Implied call parameter
    Y ! Implied call parameter
    Z1 ! loop counter
    Z2 ! loop counter
    Z3 ! loop counter
    Z4 ! loop counter
    ;
    switch (task) {
        RELS_TEST: if (IndirectlyContains(X,Y)) rtrue; rfalse;
        RELS_LOOKUP_ANY: if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
            objectloop (Z1 ofclass Object) {
                if (Rel_Handler_37(rr, RELS_TEST, Z1, X)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(OBJECT_TY);
        } else {
            objectloop (Z1 ofclass Object) {
                if (Rel_Handler_37(rr, RELS_TEST, X, Z1)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(OBJECT_TY);
        }
        RELS_LOOKUP_ALL_X, RELS_LOOKUP_ALL_Y: LIST_OF_TY_SetLength(Y, 0);
        if (task == RELS_LOOKUP_ALL_X) {
            objectloop (Z1 ofclass Object) {
                if (Rel_Handler_37(rr, RELS_TEST, Z1, X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        } else {
            objectloop (Z1 ofclass Object) {
                if (Rel_Handler_37(rr, RELS_TEST, X, Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        }
        return Y;
        RELS_LIST: LIST_OF_TY_SetLength(X, 0);
        if (Y == RLIST_ALL_X) {
            objectloop (Z1 ofclass Object) {
                objectloop (Z3 ofclass Object) {
                    if (Rel_Handler_37(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z1, false, 0, true);
                    }
                }
            }
        } else if (Y == RLIST_ALL_Y) {
            objectloop (Z1 ofclass Object) {
                objectloop (Z3 ofclass Object) {
                    if (Rel_Handler_37(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z3, false, 0, true);
                    }
                }
            }
        }
        return X;
    }
    rfalse;
];
Array Rel_Record_67 -->
    0 (101515264) RELATION_TY MAX_POSITIVE_NUMBER NULL NULL
    "leading-through relation"
     RELS_TEST+RELS_LOOKUP_ANY+RELS_LOOKUP_ALL_X+RELS_LOOKUP_ALL_Y+RELS_LIST+RELS_X_UNIQUE+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_SHOW+RELS_ROUTE_FIND
     door_to KD7_relation_of_rooms_to_doors Rel_Handler_67 "Leading-through relates one room ( called the other side ) to various doors";
[ Rel_Handler_67 
    rr ! Implied call parameter
    task ! Implied call parameter
    X ! Implied call parameter
    Y ! Implied call parameter
    Z1 ! loop counter
    Z2 ! loop counter
    Z3 ! loop counter
    Z4 ! loop counter
    ;
    switch (task) {
        RELS_TEST: if (X == (RGuard_f0_0(Y))) rtrue; rfalse;
        RELS_LOOKUP_ANY: if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
            for (Z1=IK1_First: Z1: Z1=Z1.IK1_Link) {
                if (Rel_Handler_67(rr, RELS_TEST, Z1, X)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        } else {
            for (Z1=IK4_First: Z1: Z1=Z1.IK4_Link) {
                if (Rel_Handler_67(rr, RELS_TEST, X, Z1)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        }
        RELS_LOOKUP_ALL_X, RELS_LOOKUP_ALL_Y: LIST_OF_TY_SetLength(Y, 0);
        if (task == RELS_LOOKUP_ALL_X) {
            for (Z1=IK1_First: Z1: Z1=Z1.IK1_Link) {
                if (Rel_Handler_67(rr, RELS_TEST, Z1, X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        } else {
            for (Z1=IK4_First: Z1: Z1=Z1.IK4_Link) {
                if (Rel_Handler_67(rr, RELS_TEST, X, Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        }
        return Y;
        RELS_LIST: LIST_OF_TY_SetLength(X, 0);
        if (Y == RLIST_ALL_X) {
            for (Z1=IK1_First: Z1: Z1=Z1.IK1_Link) {
                for (Z3=IK4_First: Z3: Z3=Z3.IK4_Link) {
                    if (Rel_Handler_67(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z1, false, 0, true);
                    }
                }
            }
        } else if (Y == RLIST_ALL_Y) {
            for (Z1=IK1_First: Z1: Z1=Z1.IK1_Link) {
                for (Z3=IK4_First: Z3: Z3=Z3.IK4_Link) {
                    if (Rel_Handler_67(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z3, false, 0, true);
                    }
                }
            }
        }
        return X;
        RELS_ASSERT_TRUE: (RGuard_MT_0(X,Y)); rtrue;
        RELS_ASSERT_FALSE: (RGuard_MF_0(X,Y)); rtrue;
        RELS_SHOW: Relation_RShowOtoO(rr, false); rtrue;
        RELS_ROUTE_FIND: return OtoVRelRouteTo(RlnGetF(rr, RR_STORAGE), X, Y);
        RELS_ROUTE_FIND_COUNT: return RelFollowVector(OtoVRelRouteTo(RlnGetF(rr, RR_STORAGE), X, Y), X, Y);
    }
    rfalse;
];
Array Rel_Record_69 -->
    0 (101515264) RELATION_TY MAX_POSITIVE_NUMBER NULL NULL
    "lock-fitting relation"
     RELS_TEST+RELS_LOOKUP_ANY+RELS_LOOKUP_ALL_X+RELS_LOOKUP_ALL_Y+RELS_LIST+RELS_X_UNIQUE+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_SHOW+RELS_ROUTE_FIND
     with_key KD5_relation_of_things Rel_Handler_69 "Lock-fitting relates one thing ( called the matching key ) to various things";
[ Rel_Handler_69 
    rr ! Implied call parameter
    task ! Implied call parameter
    X ! Implied call parameter
    Y ! Implied call parameter
    Z1 ! loop counter
    Z2 ! loop counter
    Z3 ! loop counter
    Z4 ! loop counter
    ;
    switch (task) {
        RELS_TEST: if (X == (RGuard_f0_1(Y))) rtrue; rfalse;
        RELS_LOOKUP_ANY: if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_69(rr, RELS_TEST, Z1, X)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_69(rr, RELS_TEST, X, Z1)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        }
        RELS_LOOKUP_ALL_X, RELS_LOOKUP_ALL_Y: LIST_OF_TY_SetLength(Y, 0);
        if (task == RELS_LOOKUP_ALL_X) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_69(rr, RELS_TEST, Z1, X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_69(rr, RELS_TEST, X, Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        }
        return Y;
        RELS_LIST: LIST_OF_TY_SetLength(X, 0);
        if (Y == RLIST_ALL_X) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_69(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z1, false, 0, true);
                    }
                }
            }
        } else if (Y == RLIST_ALL_Y) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_69(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z3, false, 0, true);
                    }
                }
            }
        }
        return X;
        RELS_ASSERT_TRUE: (RGuard_MT_1(X,Y)); rtrue;
        RELS_ASSERT_FALSE: (RGuard_MF_1(X,Y)); rtrue;
        RELS_SHOW: Relation_RShowOtoO(rr, false); rtrue;
        RELS_ROUTE_FIND: return OtoVRelRouteTo(RlnGetF(rr, RR_STORAGE), X, Y);
        RELS_ROUTE_FIND_COUNT: return RelFollowVector(OtoVRelRouteTo(RlnGetF(rr, RR_STORAGE), X, Y), X, Y);
    }
    rfalse;
];
Array Rel_Record_71 -->
    0 (101515264) RELATION_TY MAX_POSITIVE_NUMBER NULL NULL
    "unbolting relation"
     RELS_TEST+RELS_LOOKUP_ANY+RELS_LOOKUP_ALL_X+RELS_LOOKUP_ALL_Y+RELS_LIST+RELS_X_UNIQUE+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_SHOW+RELS_ROUTE_FIND
     p60_unbolting KD8_relation_of_passkeys_to_th Rel_Handler_71 "Unbolting relates one passkey to various things";
[ Rel_Handler_71 
    rr ! Implied call parameter
    task ! Implied call parameter
    X ! Implied call parameter
    Y ! Implied call parameter
    Z1 ! loop counter
    Z2 ! loop counter
    Z3 ! loop counter
    Z4 ! loop counter
    ;
    switch (task) {
        RELS_TEST: if (X == (RGuard_f0_2(Y))) rtrue; rfalse;
        RELS_LOOKUP_ANY: if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
            for (Z1=nothing: false: ) {
                if (Rel_Handler_71(rr, RELS_TEST, Z1, X)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_71(rr, RELS_TEST, X, Z1)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        }
        RELS_LOOKUP_ALL_X, RELS_LOOKUP_ALL_Y: LIST_OF_TY_SetLength(Y, 0);
        if (task == RELS_LOOKUP_ALL_X) {
            for (Z1=nothing: false: ) {
                if (Rel_Handler_71(rr, RELS_TEST, Z1, X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_71(rr, RELS_TEST, X, Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        }
        return Y;
        RELS_LIST: LIST_OF_TY_SetLength(X, 0);
        if (Y == RLIST_ALL_X) {
            for (Z1=nothing: false: ) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_71(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z1, false, 0, true);
                    }
                }
            }
        } else if (Y == RLIST_ALL_Y) {
            for (Z1=nothing: false: ) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_71(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z3, false, 0, true);
                    }
                }
            }
        }
        return X;
        RELS_ASSERT_TRUE: (RGuard_MT_2(X,Y)); rtrue;
        RELS_ASSERT_FALSE: (RGuard_MF_2(X,Y)); rtrue;
        RELS_SHOW: Relation_RShowOtoO(rr, false); rtrue;
        RELS_ROUTE_FIND: return OtoVRelRouteTo(RlnGetF(rr, RR_STORAGE), X, Y);
        RELS_ROUTE_FIND_COUNT: return RelFollowVector(OtoVRelRouteTo(RlnGetF(rr, RR_STORAGE), X, Y), X, Y);
    }
    rfalse;
];
[ CreateDynamicRelations 
    i ! loop counter
    rel ! new relation
    ;
    ];
[ RProperty obj cl pr; if (obj ofclass cl) return obj.pr; return nothing; ];
! Routines guarding leading-through(L, R)
[ RGuard_f0_0 
    X ! which is related to at most one object
    ;
    if (X ofclass K4_door) return (X.door_to);
    return nothing;
];
[ RGuard_f1_0 
    X ! which is related to at most one object
    ;
    return nothing;
];
[ RGuard_T_0 
    L ! left member of pair
    R ! right member of pair
    ;
    rfalse;
];
[ RGuard_MT_0 
    L ! left member of pair
    R ! right member of pair
    ;
    if ((L ofclass K1_room) && (R ofclass K4_door)) {
        R.door_to = L; return;
    }
    RunTimeProblem(RTP_RELKINDVIOLATION, L, R, Rel_Record_67);
];
[ RGuard_MF_0 
    L ! left member of pair
    R ! right member of pair
    ;
    if ((L ofclass K1_room) && (R ofclass K4_door)) {
        Relation_NowN1toV(R,door_to,L); return;
    }
    RunTimeProblem(RTP_RELKINDVIOLATION, L, R, Rel_Record_67);
];
! Routines guarding lock-fitting(L, R)
[ RGuard_f0_1 
    X ! which is related to at most one object
    ;
    if (X ofclass K2_thing) return (X.with_key);
    return nothing;
];
[ RGuard_f1_1 
    X ! which is related to at most one object
    ;
    return nothing;
];
[ RGuard_T_1 
    L ! left member of pair
    R ! right member of pair
    ;
    rfalse;
];
[ RGuard_MT_1 
    L ! left member of pair
    R ! right member of pair
    ;
    if ((L ofclass K2_thing) && (R ofclass K2_thing)) {
        R.with_key = L; return;
    }
    RunTimeProblem(RTP_RELKINDVIOLATION, L, R, Rel_Record_69);
];
[ RGuard_MF_1 
    L ! left member of pair
    R ! right member of pair
    ;
    if ((L ofclass K2_thing) && (R ofclass K2_thing)) {
        Relation_NowN1toV(R,with_key,L); return;
    }
    RunTimeProblem(RTP_RELKINDVIOLATION, L, R, Rel_Record_69);
];
! Routines guarding unbolting(L, R)
[ RGuard_f0_2 
    X ! which is related to at most one object
    ;
    if (X ofclass K2_thing) return (X.p60_unbolting);
    return nothing;
];
[ RGuard_f1_2 
    X ! which is related to at most one object
    ;
    return nothing;
];
[ RGuard_T_2 
    L ! left member of pair
    R ! right member of pair
    ;
    rfalse;
];
[ RGuard_MT_2 
    L ! left member of pair
    R ! right member of pair
    ;
    if ((L ofclass K16_passkey) && (R ofclass K2_thing)) {
        R.p60_unbolting = L; return;
    }
    RunTimeProblem(RTP_RELKINDVIOLATION, L, R, Rel_Record_71);
];
[ RGuard_MF_2 
    L ! left member of pair
    R ! right member of pair
    ;
    if ((L ofclass K16_passkey) && (R ofclass K2_thing)) {
        Relation_NowN1toV(R,p60_unbolting,L); return;
    }
    RunTimeProblem(RTP_RELKINDVIOLATION, L, R, Rel_Record_71);
];






[ Noun_Filter_0 
    x ! saved value of noun
    ;
    x=noun;
    return ((noun ofclass K2_thing) && (noun == I154_wand));
];
[ Noun_Filter_1 
    x ! saved value of noun
    ;
    x=noun;
    return ((noun ofclass K16_passkey));
];
[ Noun_Filter_2 
    x ! saved value of noun
    ;
    x=noun;
    return ((noun ofclass K17_keychain));
];
[ Noun_Filter_3 
    x ! saved value of noun
    ;
    x=noun;
    return ((noun ofclass K3_direction));
];
[ Noun_Filter_4 
    x ! saved value of noun
    ;
    x=noun;
    return ((noun ofclass K3_direction));
];
[ Noun_Filter_5 
    x ! saved value of noun
    ;
    x=noun;
    return ((noun ofclass K3_direction));
];
[ Noun_Filter_6 
    x ! saved value of noun
    ;
    x=noun;
    return ((noun ofclass K2_thing) && ((Adj_84_t1_v10(noun))));
];
[ Noun_Filter_7 
    x ! saved value of noun
    ;
    x=noun;
    return ((noun ofclass K2_thing) && ((Adj_80_t1_v10(noun))) && ((Adj_78_t1_v10(noun))));
];
[ Noun_Filter_8 
    x ! saved value of noun
    ;
    x=noun;
    return ((noun ofclass K2_thing) && ((Adj_78_t1_v10(noun))));
];
[ Noun_Filter_9 
    x ! saved value of noun
    ;
    x=noun;
    return ((noun ofclass K2_thing) && ((Adj_80_t1_v10(noun))) && ((Adj_78_t1_v10(noun))));
];
[ Noun_Filter_10 
    x ! saved value of noun
    ;
    x=noun;
    return ((noun ofclass K2_thing) && ((Adj_78_t1_v10(noun))));
];
[ Noun_Filter_11 
    x ! saved value of noun
    ;
    x=noun;
    return ((noun ofclass K2_thing) && ((Adj_79_t1_v10(noun))) && ((Adj_78_t1_v10(noun))));
];
[ Noun_Filter_12 
    x ! saved value of noun
    ;
    x=noun;
    return ((noun ofclass K2_thing) && ((Adj_78_t1_v10(noun))));
];
[ Noun_Filter_13 
    x ! saved value of noun
    ;
    x=noun;
    return ((noun ofclass K2_thing) && ((Adj_79_t1_v10(noun))) && ((Adj_78_t1_v10(noun))));
];
[ Noun_Filter_14 
    x ! saved value of noun
    ;
    x=noun;
    return ((noun ofclass K2_thing) && ((Adj_78_t1_v10(noun))));
];
[ Noun_Filter_15 
    x ! saved value of noun
    ;
    x=noun;
    return ((noun ofclass K2_thing) && ((Adj_79_t1_v10(noun))) && ((Adj_78_t1_v10(noun))));
];
[ Noun_Filter_16 
    x ! saved value of noun
    ;
    x=noun;
    return ((noun ofclass K2_thing) && ((Adj_78_t1_v10(noun))));
];



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Chronology
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Chronology.i6t: Scheme I
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Chronology.i6t: Present and Past
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Chronology.i6t: Chronology Point
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ChronologyPoint pt;
	for (pt=0:pt<NO_PAST_TENSE_CONDS:pt++)
		past_chronological_record-->pt = present_chronological_record-->pt;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Chronology.i6t: Update Chronological Records Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ UPDATE_CHRONOLOGICAL_RECORDS_R pt;
	for (pt=0: pt<NO_PAST_TENSE_CONDS: pt++) TestSinglePastState(false, pt, true, -1);
	ChronologyPoint();
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Chronology.i6t: Test Single Past State
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PAPR_0 ;
    if ((((action ==##Examine) &&  (actor==player) && ((noun == I184_cherry_desk) && (true))))) rtrue;
    rfalse;
];
Array PastActionsI6Routines --> PAPR_0 0 0;

Constant NO_PAST_TENSE_CONDS 0;
Constant NO_PAST_TENSE_ACTIONS 1;

[ TestSinglePastState 
    past_flag ! Implied call parameter
    pt ! Implied call parameter
    turn_end ! Implied call parameter
    wanted ! Implied call parameter
    old ! internal use only
    new ! internal use only
    trips ! internal use only
    consecutives ! internal use only
    ;
    if (past_flag) {
        new = (past_chronological_record-->pt) & 1;
        trips = ((past_chronological_record-->pt) & $$11111110)/2;
        consecutives = ((past_chronological_record-->pt) & $$111111100000000)/256;
    } else {
        old = (present_chronological_record-->pt) & 1;
        trips = ((present_chronological_record-->pt) & $$11111110)/2;
        consecutives = ((present_chronological_record-->pt) & $$111111100000000)/256;
        switch(pt) {
            default: print "*** No such past tense condition ***^"; new = false;
        }
        if (new) {
            if (old == false) { trips++; if (trips > 127) trips = 127; }
            if (turn_end) { consecutives++; if (consecutives > 127) consecutives = 127; }
        } else {
            consecutives = 0;
        }
        present_chronological_record-->pt = new + 2*trips + 256*consecutives;
    }
    switch(wanted) {
        0: if (new) return new;
        1: if (new) return trips;
        2: if (new) return consecutives+1; ! Plus one because we count the current turn
        4: return new;
        5: return trips;
        6: return consecutives;
    }
    return 0;
];



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Chronology.i6t: Scheme II
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Chronology.i6t: Past Action Routines
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Chronology.i6t: Track Actions
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TrackActions readjust oow i;
	for (i=0: PastActionsI6Routines-->i: i++) {
		if ((PastActionsI6Routines-->i).call()) {
			! Yes, the current action matches action pattern i:
			if (readjust) continue;
			(TimesActionHasHappened-->i)++;
			if (LastTurnActionHappenedOn-->i ~= turns + 5) {
				LastTurnActionHappenedOn-->i = turns + 5;
				ActionCurrentlyHappeningFlag->i = 1;
				if (keep_silent == false)
					(TurnsActionHasBeenHappening-->i)++;
			}
		} else {
			! No, the current action doesn't match action pattern i:
			if (oow == false) {
				if (keep_silent == false) { TurnsActionHasBeenHappening-->i = 0; }
				if (LastTurnActionHappenedOn-->i ~= turns + 5)
					ActionCurrentlyHappeningFlag->i = 0;
			}
		}
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Chronology.i6t: Storage
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Array TimesActionHasHappened-->(NO_PAST_TENSE_ACTIONS+1);
Array TurnsActionHasBeenHappening-->(NO_PAST_TENSE_ACTIONS+1);
Array LastTurnActionHappenedOn-->(NO_PAST_TENSE_ACTIONS+1);
Array ActionCurrentlyHappeningFlag->(NO_PAST_TENSE_ACTIONS+1);

Array past_chronological_record-->(NO_PAST_TENSE_CONDS+1);
Array present_chronological_record-->(NO_PAST_TENSE_CONDS+1);




! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Grammar
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


[ Parse_Name_GV1 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV2 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV3 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV4 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV5 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV6 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV7 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV8 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV9 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV10 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV11 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV12 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV95 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                if (NextWordStopped() ~= 'small') jump Fail_1;
                if (NextWordStopped() ~= 'crowd') jump Fail_1;
                if (NextWordStopped() ~= 'of') jump Fail_1;
                if (NextWordStopped() ~= 'teenagers') jump Fail_1;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
                if (NextWordStopped() ~= 'group') jump Fail_2;
                if (NextWordStopped() ~= 'of') jump Fail_2;
                if (NextWordStopped() ~= 'people') jump Fail_2;
                try_from_wn = wn; f = true; continue;
                .Fail_2; wn = try_from_wn;
                if (NextWordStopped() ~= 'gaggle') jump Fail_3;
                if (NextWordStopped() ~= 'of') jump Fail_3;
                if (NextWordStopped() ~= 'girls') jump Fail_3;
                try_from_wn = wn; f = true; continue;
                .Fail_3; wn = try_from_wn;
                if (NextWordStopped() ~= 'crowd') jump Fail_4;
                if (NextWordStopped() ~= 'of') jump Fail_4;
                if (NextWordStopped() ~= 'people') jump Fail_4;
                try_from_wn = wn; f = true; continue;
                .Fail_4; wn = try_from_wn;
                if (NextWordStopped() ~= 'traveling') jump Fail_5;
                if (NextWordStopped() ~= 'actors') jump Fail_5;
                try_from_wn = wn; f = true; continue;
                .Fail_5; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV96 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                if (NextWordStopped() ~= 'some') jump Fail_1;
                if (NextWordStopped() ~= 'trees') jump Fail_1;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV97 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                if (NextWordStopped() ~= 'beautiful') jump Fail_1;
                if (NextWordStopped() ~= 'woman') jump Fail_1;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV98 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                if (NextWordStopped() ~= 'resist') jump Fail_1;
                if (NextWordStopped() ~= 'the') jump Fail_1;
                if (NextWordStopped() ~= 'elephant') jump Fail_1;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
                if (NextWordStopped() ~= 'how') jump Fail_2;
                if (NextWordStopped() ~= 'to') jump Fail_2;
                try_from_wn = wn; f = true; continue;
                .Fail_2; wn = try_from_wn;
                if (NextWordStopped() ~= 'underwitch') jump Fail_3;
                if (NextWordStopped() ~= 'kristen') jump Fail_3;
                try_from_wn = wn; f = true; continue;
                .Fail_3; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Consult_Grammar_99 
    range_from ! call parameter: word number of snippet start

    range_words ! call parameter: snippet length

    original_wn ! first word of text parsed

    group_wn ! first word matched against A/B/C/... disjunction

    w ! for use by individual grammar lines

    rv ! for use by individual grammar lines

    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'restart') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];
[ Consult_Grammar_100 
    range_from ! call parameter: word number of snippet start

    range_words ! call parameter: snippet length

    original_wn ! first word of text parsed

    group_wn ! first word matched against A/B/C/... disjunction

    w ! for use by individual grammar lines

    rv ! for use by individual grammar lines

    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'restore') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];
[ Consult_Grammar_101 
    range_from ! call parameter: word number of snippet start

    range_words ! call parameter: snippet length

    original_wn ! first word of text parsed

    group_wn ! first word matched against A/B/C/... disjunction

    w ! for use by individual grammar lines

    rv ! for use by individual grammar lines

    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'amusing') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];
[ Consult_Grammar_102 
    range_from ! call parameter: word number of snippet start

    range_words ! call parameter: snippet length

    original_wn ! first word of text parsed

    group_wn ! first word matched against A/B/C/... disjunction

    w ! for use by individual grammar lines

    rv ! for use by individual grammar lines

    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'quit') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];
[ Consult_Grammar_103 
    range_from ! call parameter: word number of snippet start

    range_words ! call parameter: snippet length

    original_wn ! first word of text parsed

    group_wn ! first word matched against A/B/C/... disjunction

    w ! for use by individual grammar lines

    rv ! for use by individual grammar lines

    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'undo') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];
[ Consult_Grammar_104 
    range_from ! call parameter: word number of snippet start

    range_words ! call parameter: snippet length

    original_wn ! first word of text parsed

    group_wn ! first word matched against A/B/C/... disjunction

    w ! for use by individual grammar lines

    rv ! for use by individual grammar lines

    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        w = ParseTokenStopped(GPR_TT, Kind_GPR_52);
        if (w ~= GPR_NUMBER) jump Fail_1; rv = GPR_NUMBER;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];
[ Consult_Grammar_105 
    range_from ! call parameter: word number of snippet start

    range_words ! call parameter: snippet length

    original_wn ! first word of text parsed

    group_wn ! first word matched against A/B/C/... disjunction

    w ! for use by individual grammar lines

    rv ! for use by individual grammar lines

    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'change') jump Fail_1;
        if (NextWordStopped() ~= 'is') jump Fail_1;
        if (NextWordStopped() ~= 'the') jump Fail_1;
        if (NextWordStopped() ~= 'root') jump Fail_1;
        if (NextWordStopped() ~= 'of') jump Fail_1;
        if (NextWordStopped() ~= 'all') jump Fail_1;
        if (NextWordStopped() ~= 'creation') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];
[ Consult_Grammar_106 
    range_from ! call parameter: word number of snippet start

    range_words ! call parameter: snippet length

    original_wn ! first word of text parsed

    group_wn ! first word matched against A/B/C/... disjunction

    w ! for use by individual grammar lines

    rv ! for use by individual grammar lines

    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'yes') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];
[ Consult_Grammar_107 
    range_from ! call parameter: word number of snippet start

    range_words ! call parameter: snippet length

    original_wn ! first word of text parsed

    group_wn ! first word matched against A/B/C/... disjunction

    w ! for use by individual grammar lines

    rv ! for use by individual grammar lines

    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'y//') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];
[ Consult_Grammar_108 
    range_from ! call parameter: word number of snippet start

    range_words ! call parameter: snippet length

    original_wn ! first word of text parsed

    group_wn ! first word matched against A/B/C/... disjunction

    w ! for use by individual grammar lines

    rv ! for use by individual grammar lines

    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'no') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];
[ Consult_Grammar_109 
    range_from ! call parameter: word number of snippet start

    range_words ! call parameter: snippet length

    original_wn ! first word of text parsed

    group_wn ! first word matched against A/B/C/... disjunction

    w ! for use by individual grammar lines

    rv ! for use by individual grammar lines

    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'n//') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];
[ Consult_Grammar_110 
    range_from ! call parameter: word number of snippet start

    range_words ! call parameter: snippet length

    original_wn ! first word of text parsed

    group_wn ! first word matched against A/B/C/... disjunction

    w ! for use by individual grammar lines

    rv ! for use by individual grammar lines

    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'stand') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];
[ Consult_Grammar_111 
    range_from ! call parameter: word number of snippet start

    range_words ! call parameter: snippet length

    original_wn ! first word of text parsed

    group_wn ! first word matched against A/B/C/... disjunction

    w ! for use by individual grammar lines

    rv ! for use by individual grammar lines

    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'sit') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];
[ Consult_Grammar_112 
    range_from ! call parameter: word number of snippet start

    range_words ! call parameter: snippet length

    original_wn ! first word of text parsed

    group_wn ! first word matched against A/B/C/... disjunction

    w ! for use by individual grammar lines

    rv ! for use by individual grammar lines

    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'lie') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];
Verb 'take' 'carry' 'hold'
    * 'inventory'  -> Inv
    * noun=Noun_Filter_0  -> Examine
    * multi  -> Take
    * 'off' noun  -> Disrobe
    * noun 'off'  -> Disrobe
    * multiinside 'from' noun  -> Remove
    * multiinside 'off' noun  -> Remove
;
Verb 'get'
    * 'out' / 'off' / 'down' / 'up'  -> Exit
    * 'in' / 'on'  -> Enter
    * multi  -> Take
    * 'in' / 'into' / 'on' / 'onto' noun  -> Enter
    * 'off' / 'down' noun  -> GetOff
    * multiinside 'from' noun  -> Remove
;
Verb 'pick'
    * 'up' multi  -> Take
    * multi 'up'  -> Take
;
Verb 'stand'
    *  -> Exit
    * 'up'  -> Exit
    * 'on' noun  -> Enter
;
Verb 'remove'
    * held  -> Disrobe
    * multiinside 'from' noun  -> Remove
;
Verb 'shed' 'doff' 'disrobe'
    * held  -> Disrobe
;
Verb 'wear' 'don'
    * held  -> Wear
;
Verb 'put'
    * 'on' held  -> Wear
    * held 'on'  -> Wear
    * 'down' multiheld  -> Drop
    * multiheld 'down'  -> Drop
    * noun=Noun_Filter_1 'on' noun=Noun_Filter_2  -> PutOn
    * multiexcept 'in' / 'inside' / 'into' noun  -> Insert
    * multiexcept 'on' / 'onto' noun  -> PutOn
;
Verb 'insert'
    * multiexcept 'in' / 'into' noun  -> Insert
;
Verb 'drop' 'throw' 'discard'
    * multiheld  -> Drop
    * held 'at' / 'against' noun  -> ThrowAt
    * multiexcept 'in' / 'into' / 'down' noun  -> Insert
    * multiexcept 'on' / 'onto' noun  -> PutOn
;
Verb 'give' 'pay' 'offer' 'feed'
    * creature held  -> Give reverse
    * held 'to' creature  -> Give
;
Verb 'show' 'present' 'display'
    * creature held  -> Show reverse
    * held 'to' creature  -> Show
;
Verb 'go' 'walk' 'run'
    *  -> Go
    * noun=Noun_Filter_3  -> Go
    * noun  -> Enter
    * 'into' / 'in' / 'inside' / 'through' noun  -> Enter
;
Verb 'inventory' 'i//' 'inv'
    *  -> Inv
;
Verb 'look' 'l//'
    *  -> Look
    * noun  -> Examine
    * 'at' noun  -> Examine
    * 'inside' / 'in' / 'into' / 'through' noun  -> Search
    * 'under' noun  -> LookUnder
    * 'up' topic 'in' noun  -> Consult reverse
;
Verb 'consult'
    * noun 'on' / 'about' topic  -> Consult
;
Verb 'unwrap'
    * noun  -> Open
;
Verb 'close' 'shut' 'cover'
    * noun  -> Close
    * 'up' noun  -> Close
    * 'off' noun  -> SwitchOff
;
Verb 'enter' 'cross'
    *  -> Enter
    * noun  -> Enter
;
Verb 'sit'
    * 'on' / 'in' / 'inside' noun  -> Enter
    * 'on' 'top' 'of' noun  -> Enter
;
Verb 'exit' 'leave' 'out'
    *  -> Exit
;
Verb 'examine' 'x//' 'watch' 'describe' 'check'
    * noun  -> Examine
;
Verb 'read'
    * noun  -> A79_reading
;
Verb 'yes' 'y//'
    *  -> Yes
;
Verb 'no'
    *  -> No
;
Verb 'sorry'
    *  -> Sorry
;
Verb 'search'
    * noun  -> Search
;
Verb 'wave'
    *  -> WaveHands
    * noun  -> Wave
;
Verb 'set' 'adjust'
    * noun 'to' topic  -> SetTo
;
Verb 'pull' 'drag'
    * noun  -> Pull
;
Verb 'push' 'move' 'shift' 'clear' 'press'
    * noun  -> Push
    * noun noun=Noun_Filter_4  -> PushDir
    * noun 'to' noun=Noun_Filter_5  -> PushDir
;
Verb 'turn' 'rotate' 'twist' 'unscrew' 'screw'
    * noun  -> Turn
    * noun 'on'  -> SwitchOn
    * 'on' noun  -> SwitchOn
    * noun 'off'  -> SwitchOff
    * 'off' noun  -> SwitchOff
;
Verb 'switch'
    * noun=Noun_Filter_6  -> SwitchOff
    * noun  -> SwitchOn
    * 'on' noun  -> SwitchOn
    * noun 'on'  -> SwitchOn
    * noun 'off'  -> SwitchOff
    * 'off' noun  -> SwitchOff
;
Verb 'lock'
    * noun=Noun_Filter_9  -> A78_locking_keylessly
    * noun=Noun_Filter_10  -> A78_locking_keylessly
    * noun  -> A78_locking_keylessly
    * noun=Noun_Filter_7 'with' noun  -> Lock
    * noun=Noun_Filter_8 'with' noun  -> Lock
    * noun '|__' 'with' noun  -> Lock
;
Verb 'unlock'
    * noun=Noun_Filter_13  -> A77_unlocking_keylessly
    * noun=Noun_Filter_14  -> A77_unlocking_keylessly
    * noun  -> A77_unlocking_keylessly
    * noun=Noun_Filter_11 'with' noun  -> Unlock
    * noun=Noun_Filter_12 'with' noun  -> Unlock
    * noun 'with' noun  -> Unlock
;
Verb 'attack' 'break' 'smash' 'hit' 'fight' 'torture' 'wreck' 'crack' 'destroy' 'murder' 'kill' 'punch' 'thump'
    * noun  -> Attack
;
Verb 'wait' 'z//'
    *  -> Wait
;
Verb 'answer' 'say' 'shout' 'speak'
    * topic 'to' creature  -> Answer reverse
;
Verb 'tell'
    * creature 'about' topic  -> Tell
;
Verb 'ask'
    * creature 'for' noun  -> AskFor
    * creature 'about' topic  -> Ask
;
Verb 'eat'
    * held  -> Eat
;
Verb 'sleep' 'nap'
    *  -> Sleep
;
Verb 'climb' 'scale'
    * noun  -> Climb
    * 'up' / 'over' noun  -> Climb
;
Verb 'buy' 'purchase'
    * noun  -> Buy
;
Verb 'squeeze' 'squash'
    * noun  -> Squeeze
;
Verb 'swing'
    * noun  -> Swing
    * 'on' noun  -> Swing
;
Verb 'wake' 'awake' 'awaken'
    *  -> Wake
    * 'up'  -> Wake
    * creature  -> WakeOther
    * creature 'up'  -> WakeOther
    * 'up' creature  -> WakeOther
;
Verb 'kiss' 'embrace' 'hug'
    * creature  -> Kiss
;
Verb 'think'
    *  -> Think
;
Verb 'smell' 'sniff'
    *  -> Smell
    * noun  -> Smell
;
Verb 'listen'
    *  -> Listen
    * 'to' noun  -> Listen
;
Verb 'hear'
    * noun  -> Listen
;
Verb 'taste'
    * noun  -> Taste
;
Verb 'touch' 'feel'
    * noun  -> Touch
;
Verb 'rub' 'shine' 'polish' 'sweep' 'clean' 'dust' 'wipe' 'scrub'
    * noun  -> Rub
;
Verb 'tie' 'attach' 'fasten'
    * noun 'to' noun  -> Tie
;
Verb 'burn' 'light'
    * noun  -> Burn
;
Verb 'drink' 'swallow' 'sip'
    * noun  -> Drink
;
Verb 'cut' 'slice' 'prune' 'chop'
    * noun  -> Cut
;
Verb 'jump' 'skip' 'hop'
    *  -> Jump
;
Verb 'score'
    *  -> Score
;
Verb 'quit'
    *  -> Quit
;
Verb 'q//'
    *  -> Quit
;
Verb 'save'
    *  -> Save
;
Verb 'restart'
    *  -> Restart
;
Verb 'restore'
    *  -> Restore
;
Verb 'verify'
    *  -> Verify
;
Verb 'version'
    *  -> Version
;
Verb 'script'
    *  -> ScriptOn
    * 'on'  -> ScriptOn
    * 'off'  -> ScriptOff
;
Verb 'transcript'
    *  -> ScriptOn
    * 'on'  -> ScriptOn
    * 'off'  -> ScriptOff
;
Verb 'superbrief'
    *  -> LMode3
;
Verb 'short'
    *  -> LMode3
;
Verb 'verbose'
    *  -> LMode2
;
Verb 'long'
    *  -> LMode2
;
Verb 'brief'
    *  -> LMode1
;
Verb 'normal'
    *  -> LMode1
;
Verb 'nouns'
    *  -> Pronouns
;
Verb 'pronouns'
    *  -> Pronouns
;
Verb 'notify'
    *  -> NotifyOn
    * 'on'  -> NotifyOn
    * 'off'  -> NotifyOff
;
Verb 'open'
    * noun  -> Open
    * noun=Noun_Filter_15 'with' noun  -> Unlock
    * noun=Noun_Filter_16 'with' noun  -> Unlock
    * noun 'with' noun  -> Unlock
;
Verb 'uncover'
    * noun  -> Open
;





#IFTRUE (0 == 1);
[ UnknownVerb; verb_wordnum = 0; return 'no.verb'; ];
[ PrintVerb v;
	if (v == 'no.verb') { print "do something to"; rtrue; }
	rfalse;
];
#Ifnot;
[ UnknownVerb; rfalse; ]; [ PrintVerb v; rfalse; ];
#ENDIF;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Deferred Propositions
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====







! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Miscellaneous Loose Ends
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====



Constant TX_PS_429 = " ";
Constant TX_PS_427 = " N = Next";
Constant TX_PS_428 = " P = Previous";
Constant TX_PS_416 = " and";
Constant TX_PS_417 = " to";
Constant TX_PS_419 = "%";
Constant TX_PS_221 = "~AJK Supply~ is stamped on the side of the driver door, and a quick look inside reveals that no one has used this truck for quite a while.  Hell, even a few mice have found a home in it.";
Constant TX_PS_179 = ".";
Constant TX_PS_326 = "100 Main Street";
Constant TX_PS_281 = "110 Main Street";
Constant TX_PS_288 = "120 Haven Street";
Constant TX_PS_283 = "120 Main Street";
Constant TX_PS_292 = "130 Haven Street";
Constant TX_PS_296 = "130 Main Street";
Constant TX_PS_73 = "15 Rogers Road";
Constant TX_PS_404 = "2 Dollar chili cheese dogs and a quart of beer is what you remember about this place.  The Palomino is or well... was awesome when you were a bit younger, and drinking copious amounts.  Its good to visit this old place again.";
Constant TX_PS_413 = ">";
Array TX_L_413 --> CONSTANT_PACKED_TEXT_STORAGE TX_PS_413;
Constant TX_PS_244 = "A dark portal, leading to who knows where, is sitting in the Dark Cul-de-sac. Going in would be quite an adventure!";
Constant TX_PS_137 = "A deep, satin-lustrous cherry, with scrollwork legs and gilt touches. The years have not been kind, and it has cracked and split in several places; the finish is damaged, and where there is inlaid mother of pearl, it is beginning to come up from its bed. But it is still a sound piece, and features three drawers.";
Constant TX_PS_120 = "A good looking, blue collar looking man, arms covered in grease as he works through the engine, fixing whatever the issue is.  Despite being older, he's quite deft and agile.";
Constant TX_PS_125 = "A group of girls, all hardly 18 years old, driving their mini SUV's, giggling about boys... what a stereotype.  They may be attractive, but they're dumb.  You think all of this as your eyeline follows their... awesome asses.";
Constant TX_PS_188 = "A group of teenagers, currently going through that always pleasant rebellious stage.  They look like they just left the malls Hot Topic, and were now cruising through the middle of the hall, joking and celebrating their general unruliness.";
Constant TX_PS_93 = "A man in a hoodie stands with his hands in his pockets at the edge of the fence outside the Research Group..  Occasionally he looks at his watch and side to side to see if anyone is coming.  Almost like hes meeting someone.  Ahhhhh hes buying, or selling... drugs.  This is where you buy your green as well.";
Constant TX_PS_122 = "A small Kia sits running in front of the stalled car, its lights still on and door still open as its owner works nearby.";
Constant TX_PS_116 = "A small amount of smoke rises from the engine, as the worried young woman next to it watches the good samaritan work over the engine.  THere are good people in this world.";
Constant TX_PS_170 = "A voice echoes through the store ~You have traveled too far, too fast, adventurer.  Time to pay for your efficiency, like the fool you are.~";
Constant TX_PS_260 = "A woman sits with her back arched to an extreme, leopard spotted bikini covering hardly anything of her body.  The cover reads ~PRIMAL PASSIONS: FUCK ME LIKE AN ANIMAL~.  Hmmm... topical.";
Constant TX_PS_213 = "AJK Supply Entrance";
Constant TX_PS_227 = "AJK Warehouse";
Constant TX_PS_214 = "AJK, an old company based on ship transportation, has a warehouse here.  And from the looks of it, its long abandoned..";
Constant TX_PS_175 = "Abandoned clothing";
Constant TX_PS_340 = "Amazing Meal";
Constant TX_PS_3 = "An Interactive Fiction";
Array TX_L_3 --> CONSTANT_PACKED_TEXT_STORAGE TX_PS_3;
Constant TX_PS_163 = "An acne covered kid looks stressed beyond belief behid the control console for ordering.  The sound of the buttons being pressed keeps returning a loud ~BEEEEEP~, letting you know they are definitely not doing something right.";
Constant TX_PS_409 = "An ex girlfriend of yours, the most beautiful liar you have ever known, it's at front of the bar in the Palomino.  You heard she took over this joint, but certainly didn't want to pursue a congratulations visit.";
Constant TX_PS_100 = "An old rusted sign just reads ~DEAD END~, but some graphiti artist has sprayed a weird looking logo over the faded letters.";
Constant TX_PS_134 = "Apartment 1025";
Constant TX_PS_42 = "As good-looking as ever.";
Constant TX_PS_81 = "Atkin Train Station";
Constant TX_PS_166 = "Aunt Betty herself sits behind the counter, her plump cajun face jovial and smiling at all the passing customers.  But every time she thinks someone isn't looking, it fades enough to show you she is not what she appears, looking mean and hateful.";
Constant TX_PS_165 = "Aunt Betty";
Constant TX_PS_164 = "Aunt Bettys";
Constant TX_PS_309 = "Back Entrance";
Constant TX_PS_300 = "Back Room";
Constant TX_PS_195 = "Badass t-shirts";
Constant TX_PS_146 = "Baek";
Constant TX_PS_230 = "Barking dogs";
Constant TX_PS_202 = "Becky";
Constant TX_PS_204 = "Beckys cage isn't the most complicated cage you've seen, but enough to hold a human... and maybe even a few large animals.";
Constant TX_PS_185 = "Birds of Paradise";
Constant TX_PS_248 = "Boat Ramp 1";
Constant TX_PS_269 = "Boat Ramp 2";
Constant TX_PS_157 = "Bored Employee";
Constant TX_PS_115 = "Broken Down Car";
Constant TX_PS_389 = "Broken wine bottles";
Constant TX_PS_276 = "Bull Horn";
Constant TX_PS_55 = "Bull Statue";
Constant TX_PS_280 = "Business District";
Constant TX_PS_203 = "Cage";
Constant TX_PS_267 = "Chains";
Constant TX_PS_265 = "Christine";
Constant TX_PS_60 = "City Park";
Constant TX_PS_156 = "Cluckin Bell";
Constant TX_PS_108 = "Cobwebs";
Constant TX_PS_123 = "Commercial Intersection";
Constant TX_PS_380 = "Country Club";
Constant TX_PS_408 = "Courtney";
Constant TX_PS_45 = "Create Your Character";
Constant TX_PS_318 = "Cross Road";
Constant TX_PS_297 = "Crowd of People";
Constant TX_PS_127 = "Crowd";
Constant TX_PS_84 = "Crying Man";
Constant TX_PS_192 = "DPC";
Constant TX_PS_242 = "Dark CulDeSac";
Constant TX_PS_97 = "Dead End";
Constant TX_PS_87 = "Decoration Table";
Constant TX_PS_412 = "Disciple, recite the password, that which we keep close to us at night.";
Constant TX_PS_359 = "Disgusting puddles";
Constant TX_PS_246 = "Docks Sign";
Constant TX_PS_159 = "Doctor Food";
Constant TX_PS_320 = "Doe";
Constant TX_PS_303 = "Drink Bar";
Constant TX_PS_357 = "Dripping pipes";
Constant TX_PS_311 = "Drunk Hobo";
Constant TX_PS_111 = "Drunk girl";
Constant TX_PS_113 = "Drunk man";
Constant TX_PS_365 = "Dumb frat boys";
Constant TX_PS_430 = "ENTER = Select";
Constant TX_PS_315 = "Eastern Woods";
Constant TX_PS_51 = "Elephant Statue";
Constant TX_PS_48 = "Elephant Treasure Chest";
Constant TX_PS_145 = "Ellen";
Constant TX_PS_245 = "Entrance to Docks";
Constant TX_PS_198 = "Entrance to Warehouse Row";
Constant TX_PS_201 = "Equestrian Mistress";
Constant TX_PS_325 = "Essence Socket";
Constant TX_PS_415 = "Exits:";
Constant TX_PS_263 = "Farm Co";
Constant TX_PS_322 = "Fawn";
Constant TX_PS_312 = "Fence Out of Town";
Constant TX_PS_414 = "Fiction";
Constant TX_PS_155 = "Food Court";
Constant TX_PS_286 = "Fruit Salesman";
Constant TX_PS_285 = "Fruit Storefront";
Constant TX_PS_131 = "Fulfill Your Destiny";
Constant TX_PS_124 = "Gaggle Of Girls";
Constant TX_PS_178 = "Gellin Like A Vellin";
Constant TX_PS_234 = "Giant Tinman Sign";
Constant TX_PS_323 = "Goddesses Chambers";
Constant TX_PS_119 = "Good Samaritan";
Constant TX_PS_169 = "Grandmistress Witch";
Constant TX_PS_341 = "Grungy Alleyway";
Constant TX_PS_258 = "Guard Desk";
Constant TX_PS_254 = "Guard House";
Constant TX_PS_91 = "HK Research Group";
Constant TX_PS_407 = "Half drunk beers";
Constant TX_PS_109 = "Haverton Bridge";
Constant TX_PS_275 = "Headmistresses Chambers";
Constant TX_PS_121 = "Helpful Mans Car";
Constant TX_PS_118 = "Her short black hair cut low and to the side, the pretty girl appears to be Asian American, her face scrunched in stress and biting her fingernails as she watched the her helpful friend fix her engine.";
Constant TX_PS_128 = "Hermes station";
Constant TX_PS_177 = "Hidden book of notes";
Constant TX_PS_256 = "His snoring is so loud it sounds like an animal growling.  The guard is quite fat and takes up most the guard house, but he has a taser so you better stay clear, bro.";
Constant TX_PS_212 = "Horse whip";
Constant TX_PS_167 = "Hotspot";
Constant TX_PS_85 = "Hunched over, the anonymous man doesn't appear to be homeless or in poor health.  Just crying and holding something in his arms while he rocks back n forth.";
Constant TX_PS_368 = "Illus Design Corp";
Constant TX_PS_369 = "Illus Design sits here, one of the longest standing companies in the city.  They are very down to earth despite their incredible looking locale that spirals into the sky.  There's a window to the basement you can see on the right side of the building, and it appears already slightly open.  Inside you can see a amateur sign next to a closet door that says ~Supply Shop Open~.  Whats even more interesting is the obvious trip wire through the window, showing you this is more then it appears. And definitely a trap.";
Constant TX_PS_299 = "Import Inc";
Constant TX_PS_418 = "Instructions";
Constant TX_PS_133 = "Interesting... the Weird Logo is also on her robe. Something as simple as an icon seems so terrifying to behold.";
Constant TX_PS_350 = "Intimidating soldier";
Constant TX_PS_262 = "It just looks to be cold coffee in a mug that reads ~Worlds #1 Guard~.";
Constant TX_PS_247 = "It reads ~ENTRANCE TO DOCKS: ALL NON PERSONAL PLEASE STAY CLEAR~ in fading words.";
Constant TX_PS_277 = "Its cold to the touch, yet smooth and even... beautiful.  To have one of these one your massively muscled bull body must be dangerous.  But you're only human.";
Constant TX_PS_150 = "Janitor";
Constant TX_PS_77 = "Junkyard";
Constant TX_PS_147 = "Jupiter Hall";
Constant TX_PS_114 = "Kelmers Road";
Constant TX_PS_308 = "Kim";
Constant TX_PS_232 = "Kinky sex items";
Constant TX_PS_226 = "Knocked over trashcan";
Constant TX_PS_86 = "Lackluster Apartments";
Constant TX_PS_360 = "Large Hill";
Constant TX_PS_314 = "Large bushes";
Constant TX_PS_295 = "Large machinery";
Constant TX_PS_287 = "Lindsay";
Constant TX_PS_149 = "Little Brother";
Constant TX_PS_235 = "Looking further, you notice they at once time lit up, but now are only faded letters with broken bulbs.";
Constant TX_PS_90 = "Looking out the window you can see the world moving around you.";
Constant TX_PS_274 = "Lost keys";
Constant TX_PS_441 = "MAYBE";
Array TX_L_441 --> CONSTANT_PACKED_TEXT_STORAGE TX_PS_441;
Constant TX_PS_144 = "Mall Entrance";
Constant TX_PS_191 = "Mall maps";
Constant TX_PS_316 = "Mammoth trees";
Constant TX_PS_334 = "Marble columns";
Constant TX_PS_148 = "Mean Kid";
Constant TX_PS_184 = "Message in slime";
Constant TX_PS_241 = "Metal Desk";
Constant TX_PS_307 = "Mistress Witch";
Constant TX_PS_209 = "Mistresses table";
Constant TX_PS_272 = "Moldy hair brushes";
Constant TX_PS_261 = "Mug";
Constant TX_PS_411 = "Mysterious Door";
Constant TX_PS_443 = "NO";
Array TX_L_443 --> CONSTANT_PACKED_TEXT_STORAGE TX_PS_443;
Constant TX_PS_162 = "New Employee";
Constant TX_PS_47 = "Now the Coven of the Elephant";
Constant TX_PS_54 = "Now the Farm Coven";
Constant TX_PS_196 = "Nympho";
Constant TX_PS_199 = "Ocean Path";
Constant TX_PS_239 = "Old Office";
Constant TX_PS_220 = "Old Truck";
Constant TX_PS_240 = "Old bed";
Constant TX_PS_223 = "Old boots, worn by the sun more then a humans feet, sit on the corner, full of old rain water, their rubber rotting away.";
Constant TX_PS_343 = "Old clothes";
Constant TX_PS_101 = "Old sign";
Constant TX_PS_206 = "Old wooden chairs, held together by rusty nails, their seats worn with the sittings of a thousand butts.";
Constant TX_PS_208 = "On the basic table sits a horse whip, some spurs, some horse shoes and of course the beautiful ass of the kinky mistress.";
Constant TX_PS_403 = "Palomino Bar n Grill";
Constant TX_PS_66 = "Park Entrance";
Constant TX_PS_362 = "Party Avenue";
Constant TX_PS_353 = "Path to the Sewers";
Constant TX_PS_290 = "Patio";
Constant TX_PS_331 = "Perlman Investments";
Constant TX_PS_238 = "Picture of Owner";
Constant TX_PS_367 = "Pile of beer cans";
Constant TX_PS_438 = "Please choose a gender for your character.^^>";
Array TX_L_438 --> CONSTANT_PACKED_TEXT_STORAGE TX_PS_438;
Constant TX_PS_439 = "Please enter the password now. >";
Array TX_L_439 --> CONSTANT_PACKED_TEXT_STORAGE TX_PS_439;
Constant TX_PS_259 = "Porno Mag";
Constant TX_PS_243 = "Portal";
Constant TX_PS_371 = "Possible Trip Wire";
Constant TX_PS_298 = "Potholes";
Constant TX_PS_444 = "Press any key to continue ...";
Array TX_L_444 --> CONSTANT_PACKED_TEXT_STORAGE TX_PS_444;
Constant TX_PS_284 = "Public Mail Box";
Constant TX_PS_423 = "QUIT";
Constant TX_PS_420 = "RESTART";
Constant TX_PS_421 = "RESTORE a saved game";
Constant TX_PS_264 = "Racks of Hose Machines";
Constant TX_PS_249 = "Relaxed Woman";
Constant TX_PS_383 = "Rich executives";
Constant TX_PS_339 = "Riley";
Constant TX_PS_346 = "Roadblock";
Constant TX_PS_345 = "Ross Avenue";
Constant TX_PS_431 = "Sample Hint";
Constant TX_PS_319 = "Scattered leaves";
Constant TX_PS_375 = "Sculpted trees";
Constant TX_PS_394 = "Season 365";
Constant TX_PS_392 = "Secluded Alley";
Constant TX_PS_253 = "Security Checkpoint";
Constant TX_PS_352 = "Several cops";
Constant TX_PS_250 = "She sits there waist deep in the water, smiling with a calm expression on her face, staring out at sea.  She's just chillin, her friend nearby enjoying her time as well.";
Constant TX_PS_200 = "Shed";
Constant TX_PS_252 = "Shes also waist deep, giggling and splashing water at her friend.  Her soft breasts jiggle in her swimsuit with each splashing movement, and you know she knows it as well, and is showing off to whoever happens to be down at a dingy warehouse district at night.";
Constant TX_PS_378 = "Side Pass";
Constant TX_PS_103 = "Silhouetted Trees";
Constant TX_PS_255 = "Sleeping Guard";
Constant TX_PS_338 = "Sloppys Fast Food";
Constant TX_PS_236 = "Small Bridge";
Constant TX_PS_187 = "Small Crowd of teenagers";
Constant TX_PS_168 = "Small Green Pastry";
Constant TX_PS_102 = "Small Trail";
Constant TX_PS_330 = "Smelly sewer gates";
Constant TX_PS_342 = "Smelly trashcan";
Constant TX_PS_217 = "Sounds of barking";
Constant TX_PS_59 = "Southside District";
Constant TX_PS_385 = "Spare golf clubs";
Constant TX_PS_377 = "Spiraling fountains";
Constant TX_PS_251 = "Splashing Woman";
Constant TX_PS_143 = "St Peters Mall";
Constant TX_PS_182 = "Stains on the floor";
Constant TX_PS_337 = "Stairs to Your Office";
Constant TX_PS_171 = "Statuesque";
Constant TX_PS_344 = "Stinking trashpile";
Constant TX_PS_327 = "Stop Sign";
Constant TX_PS_306 = "Storage Room";
Constant TX_PS_410 = "Striped Coven";
Constant TX_PS_89 = "Sunny-drenched Window";
Constant TX_PS_370 = "Supply Shop";
Constant TX_PS_92 = "Suspicious Man";
Constant TX_PS_289 = "Sweeping Garden";
Constant TX_PS_153 = "TV Station";
Constant TX_PS_151 = "TV4U";
Constant TX_PS_58 = "Temp";
Constant TX_PS_2 = "The End of the World - Witches Coven";
Constant TX_PS_390 = "The Long John";
Constant TX_PS_4 = "The Loveable Wendigo";
Constant TX_PS_302 = "The Pigsty Bar n Grill";
Constant TX_PS_279 = "The Wand emits a magical force, making all those near it feel like they possess either the cock of a mating virile bull, or the soft utters of a milk cow.";
Constant TX_PS_393 = "The alley leads around to the nearby restaurant, with the surrounding woods overlooking it.";
Constant TX_PS_305 = "The bartender, clad in very little, is working the bar and the customers wallets with it.  Her nametag says ~Trixie~, an appropriate name for a female bartendar in a sports bar. And... oh oops she caught your vision and winked.  Wow, she is kinda cute, you don't know what you were thinking.";
Constant TX_PS_56 = "The bull sits on his very sexual throne... his worshippers performing felatio on his massive engorged dick, the women looking like they may grow horns and utters and join him in cow life at any moment.";
Constant TX_PS_268 = "The chains appear to be some sort of magic, springing from nothing but as solid as the strongest metals.";
Constant TX_PS_52 = "The enormous elephant stares intimidatingly at anyone that dares enter the coven.  His trunk is reared up with a poor terrified woman held in its clutches.  Its almost too realistic of a depiction.. and then your eyes come to rest on the gigantic phallus under the elephant.  What the fuck was he about to rape the poor statue woman?!  You catch yourself, reminding yourself its just a statue.";
Constant TX_PS_395 = "The entrance to Season 365 is made of rich mahogany with gold insets, a perfect metaphor of how expensive it is to eat here.  Probably the nicest restaurant in the city, Season 365 is the perfect date place for the wealthy young businessman and his high class escort..";
Constant TX_PS_142 = "The front of it just states ~That what we keep close to us at night~.";
Constant TX_PS_104 = "The moon illuminates the plants around you, but the tall trees in the distance are dark and spooky.";
Constant TX_PS_61 = "The path along the park has seemed to come to a small clearing. On one side sits a bench with scattered yellow papers strewn across it. A still smoking crater, obviously made by some sort of falling anomaly, is present right behind it.  The anomaly appears to be some sort of chest or case with several doors, one of which is currently open to allow access to the storage compartment within. The open compartment has what appears to be... wooden sticks?  Or wands... seriously?  Seriously, freaking wands?  Welp, it has been a weird day.  Some bull ran through a china shop today down the road from your work.  Of course, when the cops showed up, they found a whole herd of cattle.  But you crocked that up to it just being the city.^^Weird things happen in the city.^^Eerie silence is all that can be heard this deep in the park, and the slight chill in the air makes you feel uneasy just to be here.";
Constant TX_PS_154 = "The terrifying scenes of the rest of the world are unfolding on the screen, as horrified people stand all around it, almost frozen in fear.";
Constant TX_PS_161 = "The training manager looks flustered and frustrated, rolling her eyes at the new employee as they type in the wrong order over and over.";
Constant TX_PS_18 = "The usual drawer of heavy wood, inadequately smoothed for ease of use.";
Constant TX_PS_211 = "The whip must've been the one used to smack poor Beckys haunches.";
Constant TX_PS_130 = "Three empty benches";
Constant TX_PS_233 = "Tinman Moving Entrance";
Constant TX_PS_237 = "Tinman Warehouse";
Constant TX_PS_83 = "Train Platform";
Constant TX_PS_8 = "Train Platforms";
Constant TX_PS_160 = "Training Manager";
Constant TX_PS_310 = "Trash Pile";
Constant TX_PS_225 = "Trash from a long time ago, long forgotten to be cleaned by the city.";
Constant TX_PS_126 = "Traveling Actors";
Constant TX_PS_304 = "Trixie";
Constant TX_PS_354 = "Tunnels";
Constant TX_PS_348 = "Two cop cars";
Constant TX_PS_205 = "Two wooden chairs";
Constant TX_PS_424 = "UNDO the last command";
Constant TX_PS_317 = "Unseen birds";
Constant TX_PS_386 = "Upper Class Arts";
Constant TX_PS_361 = "Uptown District";
Constant TX_PS_88 = "Vase";
Constant TX_PS_186 = "Venus Hall";
Constant TX_PS_336 = "Waiting room pictures";
Constant TX_PS_398 = "Waitresses";
Constant TX_PS_301 = "Wall Of Artifacts";
Constant TX_PS_373 = "Walter Haven";
Constant TX_PS_278 = "Wand Of The Cow";
Constant TX_PS_49 = "Wand Of The Elephant";
Constant TX_PS_197 = "Warehouse District";
Constant TX_PS_158 = "Wearing a absolutely humiliated chicken hat with the trademark Cluckin Bell Chickie on it, the employee looks like they may die of boredom.";
Constant TX_PS_132 = "Weird Logo";
Constant TX_PS_219 = "Weird footprints";
Constant TX_PS_400 = "Well-kept tables";
Constant TX_PS_105 = "Whispering Cave";
Constant TX_PS_291 = "White plastic chairs";
Constant TX_PS_402 = "White tablecloth";
Constant TX_PS_313 = "Wire fence";
Constant TX_PS_440 = "Would you like to try again? (Yes or No) >";
Array TX_L_440 --> CONSTANT_PACKED_TEXT_STORAGE TX_PS_440;
Constant TX_PS_442 = "YES";
Array TX_L_442 --> CONSTANT_PACKED_TEXT_STORAGE TX_PS_442;
Constant TX_PS_391 = "You enter The Long John, a nearby bar that's usually packed this time of the day.  As you enter, you can see a crowd near bar.  Wait a sec, they're all wearing ski masks..";
Constant TX_PS_117 = "Young Woman";
Constant TX_PS_135 = "Your apartment is rather unimpressive, junk covering almost any flat surface.  The walls are a bland color, per the brand style of Lackluster Inc.";
Constant TX_PS_266 = "Your beautiful girlfriend is chained to the ground, completely naked.  The sight of her like this enrages you beyond belief. Who would do this?!";
Constant TX_PS_43 = "Yourself";
Constant TX_PS_24 = "a few scattered trees.";
Constant TX_PS_174 = "abandoned clothing";
Constant TX_PS_12 = "animals";
Constant TX_PS_324 = "archaic writing tablets";
Constant TX_PS_434 = "average";
Constant TX_PS_19 = "backdrops";
Constant TX_PS_194 = "badass t-shirts";
Constant TX_PS_426 = "bar";
Constant TX_PS_229 = "barking dogs";
Constant TX_PS_82 = "bench";
Constant TX_PS_7 = "benches";
Constant TX_PS_71 = "bent fence";
Constant TX_PS_328 = "blowing trash";
Constant TX_PS_180 = "bottles of slime";
Constant TX_PS_140 = "bottom drawer";
Constant TX_PS_75 = "broken cellphone";
Constant TX_PS_388 = "broken wine bottles";
Constant TX_PS_25 = "busheses";
Constant TX_PS_228 = "cages";
Constant TX_PS_136 = "cherry desk";
Constant TX_PS_363 = "chugging college girls";
Constant TX_PS_405 = "cigarette butts";
Constant TX_PS_107 = "cobwebs";
Constant TX_PS_293 = "construction workers";
Constant TX_PS_14 = "containers";
Constant TX_PS_69 = "couple bushes";
Constant TX_PS_387 = "crappy paintings";
Constant TX_PS_95 = "crumbling sign";
Constant TX_PS_20 = "devices";
Constant TX_PS_27 = "directions";
Constant TX_PS_222 = "disgusting pair of boots";
Constant TX_PS_358 = "disgusting puddles";
Constant TX_PS_13 = "doors";
Constant TX_PS_38 = "down";
Constant TX_PS_17 = "drawers";
Constant TX_PS_356 = "dripping pipes";
Constant TX_PS_110 = "drunk girl";
Constant TX_PS_112 = "drunk man";
Constant TX_PS_364 = "dumb frat boys";
Constant TX_PS_35 = "east";
Constant TX_PS_96 = "electric fence";
Constant TX_PS_70 = "entrance sign";
Constant TX_PS_381 = "expensive cars";
Constant TX_PS_437 = "fair";
Constant TX_PS_321 = "fawn";
Constant TX_PS_64 = "few bushes";
Constant TX_PS_282 = "few parked cars";
Constant TX_PS_270 = "fishing nets";
Constant TX_PS_72 = "flickering streetlight";
Constant TX_PS_425 = "foo";
Constant TX_PS_435 = "good";
Constant TX_PS_57 = "group";
Constant TX_PS_94 = "growing bushes";
Constant TX_PS_406 = "half drunk beers";
Constant TX_PS_176 = "hidden book of notes";
Constant TX_PS_210 = "horse whip";
Constant TX_PS_39 = "inside";
Constant TX_PS_349 = "intimidating soldier";
Constant TX_PS_173 = "ivory human statues";
Constant TX_PS_6 = "keychains";
Constant TX_PS_231 = "kinky sex items";
Constant TX_PS_224 = "knocked over trashcan";
Constant TX_PS_294 = "large machinery";
Constant TX_PS_332 = "lobby plants";
Constant TX_PS_68 = "long robe";
Constant TX_PS_273 = "lost keys";
Constant TX_PS_190 = "mall maps";
Constant TX_PS_189 = "mall plants";
Constant TX_PS_333 = "marble columns";
Constant TX_PS_10 = "men";
Constant TX_PS_183 = "message in slime";
Constant TX_PS_139 = "middle drawer";
Constant TX_PS_207 = "mistresses table";
Constant TX_PS_271 = "moldy hair brushes";
Constant TX_PS_141 = "mysterious passcode";
Constant TX_PS_28 = "north";
Constant TX_PS_30 = "northeast";
Constant TX_PS_31 = "northwest";
Constant TX_PS_50 = "note";
Constant TX_PS_46 = "now the Coven of the Elephant";
Constant TX_PS_53 = "now the Farm Coven";
Constant TX_PS_99 = "old sign";
Constant TX_PS_193 = "old-school records";
Constant TX_PS_80 = "orange container";
Constant TX_PS_40 = "outside";
Constant TX_PS_21 = "passkeys";
Constant TX_PS_74 = "pennies";
Constant TX_PS_9 = "people";
Constant TX_PS_366 = "pile of beer cans";
Constant TX_PS_16 = "player's holdalls";
Constant TX_PS_433 = "poor";
Constant TX_PS_26 = "regions";
Constant TX_PS_382 = "rich executives";
Constant TX_PS_98 = "rusted bench";
Constant TX_PS_374 = "sculpted trees";
Constant TX_PS_422 = "see some suggestions for AMUSING things to do";
Constant TX_PS_351 = "several cops";
Constant TX_PS_44 = "small gold box";
Constant TX_PS_329 = "smelly sewer gates";
Constant TX_PS_215 = "soggy cigarettes";
Constant TX_PS_216 = "sounds of barking";
Constant TX_PS_32 = "south";
Constant TX_PS_33 = "southeast";
Constant TX_PS_34 = "southwest";
Constant TX_PS_384 = "spare golf clubs";
Constant TX_PS_376 = "spiraling fountains";
Constant TX_PS_76 = "squished donut";
Constant TX_PS_181 = "stains on the floor";
Constant TX_PS_172 = "statue.";
Constant TX_PS_65 = "streetlight";
Constant TX_PS_22 = "streetlightss";
Constant TX_PS_5 = "supporters";
Constant TX_PS_372 = "surrounding bushes";
Constant TX_PS_257 = "taser";
Constant TX_PS_379 = "telephone wires";
Constant TX_PS_152 = "televisions";
Constant TX_PS_29 = "the";
Constant TX_PS_129 = "three empty benches";
Constant TX_PS_79 = "toolbox";
Constant TX_PS_138 = "top drawer";
Constant TX_PS_78 = "trash";
Constant TX_PS_63 = "tree";
Constant TX_PS_23 = "treeses";
Constant TX_PS_347 = "two cop cars";
Constant TX_PS_37 = "up";
Constant TX_PS_15 = "vehicles";
Constant TX_PS_436 = "very good";
Constant TX_PS_432 = "very poor";
Constant TX_PS_396 = "waiters";
Constant TX_PS_335 = "waiting room pictures";
Constant TX_PS_397 = "waitresses";
Constant TX_PS_62 = "wand";
Constant TX_PS_218 = "weird footprints";
Constant TX_PS_106 = "weird rocks";
Constant TX_PS_355 = "weird smelling lumps";
Constant TX_PS_399 = "well-kept tables";
Constant TX_PS_36 = "west";
Constant TX_PS_401 = "white tablecloth";
Constant TX_PS_67 = "witch";
Constant TX_PS_11 = "women";
Constant TX_PS_41 = "yourself";

#ifndef p0_specification; Constant p0_specification = 0; #endif;
#ifndef p1_indefinite_appearance_tex; Constant p1_indefinite_appearance_tex = 0; #endif;
#ifndef p2_variable_initial_value; Constant p2_variable_initial_value = 0; #endif;
#ifndef list_together; Constant list_together = 0; #endif;
#ifndef short_name; Constant short_name = 0; #endif;
#ifndef plural; Constant plural = 0; #endif;
#ifndef article; Constant article = 0; #endif;
#ifndef description; Constant description = 0; #endif;
#ifndef map_region; Constant map_region = 0; #endif;
#ifndef initial; Constant initial = 0; #endif;
#ifndef p10_opposite; Constant p10_opposite = 0; #endif;
#ifndef door_to; Constant door_to = 0; #endif;
#ifndef capacity; Constant capacity = 0; #endif;
#ifndef with_key; Constant with_key = 0; #endif;
#ifndef p14_adaptive_text_viewpoint; Constant p14_adaptive_text_viewpoint = 0; #endif;
#ifndef p15_reading_material; Constant p15_reading_material = 0; #endif;
#ifndef pluralname; Constant pluralname = 0; #endif;
#ifndef proper; Constant proper = 0; #endif;
#ifndef ambigpluralname; Constant ambigpluralname = 0; #endif;
#ifndef privately_named; Constant privately_named = 0; #endif;
#ifndef light; Constant light = 0; #endif;
#ifndef visited; Constant visited = 0; #endif;
#ifndef light; Constant light = 0; #endif;
#ifndef edible; Constant edible = 0; #endif;
#ifndef static; Constant static = 0; #endif;
#ifndef scenery; Constant scenery = 0; #endif;
#ifndef clothing; Constant clothing = 0; #endif;
#ifndef pushable; Constant pushable = 0; #endif;
#ifndef moved; Constant moved = 0; #endif;
#ifndef concealed; Constant concealed = 0; #endif;
#ifndef workflag; Constant workflag = 0; #endif;
#ifndef mentioned; Constant mentioned = 0; #endif;
#ifndef enterable; Constant enterable = 0; #endif;
#ifndef transparent; Constant transparent = 0; #endif;
#ifndef open; Constant open = 0; #endif;
#ifndef openable; Constant openable = 0; #endif;
#ifndef lockable; Constant lockable = 0; #endif;
#ifndef locked; Constant locked = 0; #endif;
#ifndef female; Constant female = 0; #endif;
#ifndef male; Constant male = 0; #endif;
#ifndef neuter; Constant neuter = 0; #endif;
#ifndef on; Constant on = 0; #endif;
#ifndef p58_recurring; Constant p58_recurring = 0; #endif;
#ifndef p60_unbolting; Constant p60_unbolting = 0; #endif;
#ifndef p62_gender; Constant p62_gender = 0; #endif;
#ifndef p63_distant; Constant p63_distant = 0; #endif;
#ifndef p65_cursed; Constant p65_cursed = 0; #endif;
#ifndef p67_indoors; Constant p67_indoors = 0; #endif;
#ifndef p69_explored; Constant p69_explored = 0; #endif;
#ifndef worn; Constant worn = 0; #endif;
#ifndef vector; Constant vector = 0; #endif;
#ifndef room_index; Constant room_index = 0; #endif;
#ifndef door_dir; Constant door_dir = 0; #endif;
#ifndef door_to; Constant door_to = 0; #endif;
#ifndef found_in; Constant found_in = 0; #endif;
#ifndef absent; Constant absent = 0; #endif;
#ifndef cap_short_name; Constant cap_short_name = 0; #endif;
#ifndef mark_as_room; Constant mark_as_room = 0; #endif;
#ifndef mark_as_thing; Constant mark_as_thing = 0; #endif;
#ifndef component_parent; Constant component_parent = 0; #endif;
#ifndef component_child; Constant component_child = 0; #endif;
#ifndef component_sibling; Constant component_sibling = 0; #endif;
#ifndef regional_found_in; Constant regional_found_in = 0; #endif;
#ifndef IK1_Count; Constant IK1_Count = 0; #endif;
#ifndef IK1_Link; Constant IK1_Link = 0; #endif;
#ifndef IK2_Count; Constant IK2_Count = 0; #endif;
#ifndef IK2_Link; Constant IK2_Link = 0; #endif;
#ifndef IK3_Count; Constant IK3_Count = 0; #endif;
#ifndef IK3_Link; Constant IK3_Link = 0; #endif;
#ifndef IK4_Count; Constant IK4_Count = 0; #endif;
#ifndef IK4_Link; Constant IK4_Link = 0; #endif;
#ifndef IK5_Count; Constant IK5_Count = 0; #endif;
#ifndef IK5_Link; Constant IK5_Link = 0; #endif;
#ifndef IK6_Count; Constant IK6_Count = 0; #endif;
#ifndef IK6_Link; Constant IK6_Link = 0; #endif;
#ifndef IK7_Count; Constant IK7_Count = 0; #endif;
#ifndef IK7_Link; Constant IK7_Link = 0; #endif;
#ifndef IK8_Count; Constant IK8_Count = 0; #endif;
#ifndef IK8_Link; Constant IK8_Link = 0; #endif;
#ifndef IK9_Count; Constant IK9_Count = 0; #endif;
#ifndef IK9_Link; Constant IK9_Link = 0; #endif;
#ifndef IK10_Count; Constant IK10_Count = 0; #endif;
#ifndef IK10_Link; Constant IK10_Link = 0; #endif;
#ifndef IK11_Count; Constant IK11_Count = 0; #endif;
#ifndef IK11_Link; Constant IK11_Link = 0; #endif;
#ifndef IK12_Count; Constant IK12_Count = 0; #endif;
#ifndef IK12_Link; Constant IK12_Link = 0; #endif;
#ifndef IK13_Count; Constant IK13_Count = 0; #endif;
#ifndef IK13_Link; Constant IK13_Link = 0; #endif;
#ifndef IK14_Count; Constant IK14_Count = 0; #endif;
#ifndef IK14_Link; Constant IK14_Link = 0; #endif;
#ifndef IK15_Count; Constant IK15_Count = 0; #endif;
#ifndef IK15_Link; Constant IK15_Link = 0; #endif;
#ifndef IK16_Count; Constant IK16_Count = 0; #endif;
#ifndef IK16_Link; Constant IK16_Link = 0; #endif;
#ifndef IK17_Count; Constant IK17_Count = 0; #endif;
#ifndef IK17_Link; Constant IK17_Link = 0; #endif;
#ifndef IK18_Count; Constant IK18_Count = 0; #endif;
#ifndef IK18_Link; Constant IK18_Link = 0; #endif;
#ifndef IK19_Count; Constant IK19_Count = 0; #endif;
#ifndef IK19_Link; Constant IK19_Link = 0; #endif;
#ifndef IK20_Count; Constant IK20_Count = 0; #endif;
#ifndef IK20_Link; Constant IK20_Link = 0; #endif;
#ifndef IK21_Count; Constant IK21_Count = 0; #endif;
#ifndef IK21_Link; Constant IK21_Link = 0; #endif;
#ifndef IK22_Count; Constant IK22_Count = 0; #endif;
#ifndef IK22_Link; Constant IK22_Link = 0; #endif;
#ifndef IK23_Count; Constant IK23_Count = 0; #endif;
#ifndef IK23_Link; Constant IK23_Link = 0; #endif;
#ifndef KD_Count; Constant KD_Count = 0; #endif;
#ifndef name; Constant name = 0; #endif;
#ifndef parse_name; Constant parse_name = 0; #endif;
#ifndef action_bitmap; Constant action_bitmap = 0; #endif;

#IFNDEF cap_short_name;
Constant cap_short_name = short_name;
#ENDIF;

Array Runtime_Quotations_Displayed --> 1;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Block Values
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#ifdef TARGET_ZCODE;
Constant MEMORY_HEAP_SIZE = 8192;
#ifnot;
Constant MEMORY_HEAP_SIZE = 32768;
#endif;

Array Closure_0 -->
    KD9_phrase_real_number_to_real ! phrase real number -> real number
    REAL_NUMBER_TY_Abs ! routine to call
    "abs function" ! name
;
Array Closure_1 -->
    KD9_phrase_real_number_to_real ! phrase real number -> real number
    REAL_NUMBER_TY_Root ! routine to call
    "root function" ! name
;
Array Closure_2 -->
    KD9_phrase_real_number_to_real ! phrase real number -> real number
    PHR_425_r35  ! routine to call
    "rsqr function" ! name
;
Array Closure_3 -->
    KD9_phrase_real_number_to_real ! phrase real number -> real number
    REAL_NUMBER_TY_Ceiling ! routine to call
    "ceiling function" ! name
;
Array Closure_4 -->
    KD9_phrase_real_number_to_real ! phrase real number -> real number
    REAL_NUMBER_TY_Floor ! routine to call
    "floor function" ! name
;
Array Closure_5 -->
    KD10_phrase_real_number_to_num ! phrase real number -> number
    REAL_NUMBER_TY_to_NUMBER_TY ! routine to call
    "int function" ! name
;
Array Closure_6 -->
    KD9_phrase_real_number_to_real ! phrase real number -> real number
    REAL_NUMBER_TY_Log ! routine to call
    "log function" ! name
;
Array Closure_7 -->
    KD9_phrase_real_number_to_real ! phrase real number -> real number
    REAL_NUMBER_TY_Exp ! routine to call
    "exp function" ! name
;
Array Closure_8 -->
    KD9_phrase_real_number_to_real ! phrase real number -> real number
    REAL_NUMBER_TY_Sin ! routine to call
    "sin function" ! name
;
Array Closure_9 -->
    KD9_phrase_real_number_to_real ! phrase real number -> real number
    REAL_NUMBER_TY_Cos ! routine to call
    "cos function" ! name
;
Array Closure_10 -->
    KD9_phrase_real_number_to_real ! phrase real number -> real number
    REAL_NUMBER_TY_Tan ! routine to call
    "tan function" ! name
;
Array Closure_11 -->
    KD9_phrase_real_number_to_real ! phrase real number -> real number
    REAL_NUMBER_TY_Arcsin ! routine to call
    "arcsin function" ! name
;
Array Closure_12 -->
    KD9_phrase_real_number_to_real ! phrase real number -> real number
    REAL_NUMBER_TY_Arccos ! routine to call
    "arccos function" ! name
;
Array Closure_13 -->
    KD9_phrase_real_number_to_real ! phrase real number -> real number
    REAL_NUMBER_TY_Arctan ! routine to call
    "arctan function" ! name
;
Array Closure_14 -->
    KD9_phrase_real_number_to_real ! phrase real number -> real number
    REAL_NUMBER_TY_Sinh ! routine to call
    "sinh function" ! name
;
Array Closure_15 -->
    KD9_phrase_real_number_to_real ! phrase real number -> real number
    REAL_NUMBER_TY_Cosh ! routine to call
    "cosh function" ! name
;
Array Closure_16 -->
    KD9_phrase_real_number_to_real ! phrase real number -> real number
    REAL_NUMBER_TY_Tanh ! routine to call
    "tanh function" ! name
;
Array Closure_17 -->
    KD9_phrase_real_number_to_real ! phrase real number -> real number
    PHR_443_r36  ! routine to call
    "arcsinh function" ! name
;
Array Closure_18 -->
    KD9_phrase_real_number_to_real ! phrase real number -> real number
    PHR_444_r37  ! routine to call
    "arccosh function" ! name
;
Array Closure_19 -->
    KD9_phrase_real_number_to_real ! phrase real number -> real number
    PHR_445_r38  ! routine to call
    "arctanh function" ! name
;

Array KD0_rule --> ! rule
    RULE_TY 2 ACTION_NAME_TY NIL_TY;
Array KD1_activity --> ! activity
    ACTIVITY_TY 1 NIL_TY;
Array KD2_relation_of_values --> ! relation of values
    RELATION_TY 2 VALUE_TY VALUE_TY;
Array KD3_relation_of_objects --> ! relation of objects
    RELATION_TY 2 OBJECT_TY OBJECT_TY;
Array KD4_relation_of_supporters_to_ --> ! relation of supporters to things
    RELATION_TY 2 10 10;
Array KD5_relation_of_things --> ! relation of things
    RELATION_TY 2 10 10;
Array KD6_relation_of_people_to_thin --> ! relation of people to things
    RELATION_TY 2 10 10;
Array KD7_relation_of_rooms_to_doors --> ! relation of rooms to doors
    RELATION_TY 2 10 10;
Array KD8_relation_of_passkeys_to_th --> ! relation of passkeys to things
    RELATION_TY 2 10 10;
Array KD9_phrase_real_number_to_real --> ! phrase real number -> real number
    PHRASE_TY 2    REAL_NUMBER_TY;
Array KD10_phrase_real_number_to_num --> ! phrase real number -> number
    PHRASE_TY 2    NUMBER_TY;
[ DefaultValueFinder 
    K ! Implied call parameter
    ;
    return 0;
];



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Flex.i6t: Blocks
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant BLK_HEADER_N = 0;
Constant BLK_HEADER_FLAGS = 1;
Constant BLK_FLAG_MULTIPLE = $$00000001;
Constant BLK_FLAG_16_BIT   = $$00000010;
Constant BLK_FLAG_WORD     = $$00000100;
Constant BLK_FLAG_RESIDENT = $$00001000;
Constant BLK_FLAG_TRUNCMULT = $$00010000;
Constant BLK_HEADER_KOV = 1;
Constant BLK_HEADER_RCOUNT = 2;

Constant BLK_DATA_OFFSET = 3*WORDSIZE;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Flex.i6t: Multiple Blocks
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant BLK_DATA_MULTI_OFFSET = BLK_DATA_OFFSET + 2*WORDSIZE;
Constant BLK_NEXT 3;
Constant BLK_PREV 4;

! Constant BLKVALUE_TRACE = 1; ! Uncomment this for debugging purposes


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Flex.i6t: The Heap
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Array Flex_Heap -> MEMORY_HEAP_SIZE + 16; ! Plus 16 to allow room for head-free-block


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Flex.i6t: Initialisation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ HeapInitialise n bsize blk2;
	blk2 = Flex_Heap + 16;
	Flex_Heap->BLK_HEADER_N = 4;
	Flex_Heap-->BLK_HEADER_KOV = 0;
	Flex_Heap-->BLK_HEADER_RCOUNT = MAX_POSITIVE_NUMBER;
	Flex_Heap->BLK_HEADER_FLAGS = BLK_FLAG_MULTIPLE;
	Flex_Heap-->BLK_NEXT = blk2;
	Flex_Heap-->BLK_PREV = NULL;
	for (bsize=1: bsize < MEMORY_HEAP_SIZE: bsize=bsize*2) n++;
	blk2->BLK_HEADER_N = n;
	blk2-->BLK_HEADER_KOV = 0;
	blk2-->BLK_HEADER_RCOUNT = 0;
	blk2->BLK_HEADER_FLAGS = BLK_FLAG_MULTIPLE;
	blk2-->BLK_NEXT = NULL;
	blk2-->BLK_PREV = Flex_Heap;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Flex.i6t: Net Free Space
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ HeapNetFreeSpace multiple txb asize;
	for (txb=Flex_Heap-->BLK_NEXT: txb~=NULL: txb=txb-->BLK_NEXT) {
		asize = asize + FlexSize(txb);
		if (multiple) asize = asize - BLK_DATA_MULTI_OFFSET;
		else asize = asize - BLK_DATA_OFFSET;
	}
	return asize;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Flex.i6t: Make Space
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant SMALLEST_BLK_WORTH_ALLOCATING = 12; ! i.e. 2^12 = 4096 bytes

[ HeapMakeSpace size multiple  newblocksize newblock B n;
	for (::) {
		if (multiple) {
			if (HeapNetFreeSpace(multiple) >= size) rtrue;
		} else {
			if (HeapLargestFreeBlock(0) >= size) rtrue;
		}
		newblocksize = 1;
		for (n=0: (n<SMALLEST_BLK_WORTH_ALLOCATING) || (newblocksize<size): n++)
			newblocksize = newblocksize*2;
		while (newblocksize < size+16) newblocksize = newblocksize*2;
		newblock = VM_AllocateMemory(newblocksize);
		if (newblock == 0) rfalse;
		newblock->BLK_HEADER_N = n;
		newblock-->BLK_HEADER_KOV = 0;
		newblock-->BLK_HEADER_RCOUNT = 0;
		newblock->BLK_HEADER_FLAGS = BLK_FLAG_MULTIPLE;
		newblock-->BLK_NEXT = NULL;
		newblock-->BLK_PREV = NULL;
		for (B = Flex_Heap-->BLK_NEXT:B ~= NULL:B = B-->BLK_NEXT)
			if (B-->BLK_NEXT == NULL) {
				B-->BLK_NEXT = newblock;
				newblock-->BLK_PREV = B;
				jump Linked;
			}
		Flex_Heap-->BLK_NEXT = newblock;
		newblock-->BLK_PREV = Flex_Heap;
		.Linked; ;
		#ifdef BLKVALUE_TRACE;
		print "Increasing heap to free space map: "; FlexDebugDecomposition(Flex_Heap, 0);
		#endif;
	}
	rtrue;
];

[ HeapLargestFreeBlock multiple txb asize best;
	best = 0;
	for (txb=Flex_Heap-->BLK_NEXT: txb~=NULL: txb=txb-->BLK_NEXT) {
		asize = FlexSize(txb);
		if (multiple) asize = asize - BLK_DATA_MULTI_OFFSET;
		else asize = asize - BLK_DATA_OFFSET;
		if (asize > best) best = asize;
	}
	return best;
];

[ HeapDebug full;
	if (full) {
		print "Managing a heap of initially ", MEMORY_HEAP_SIZE+16, " bytes.^";
		print HeapNetFreeSpace(false), " bytes currently free.^";
		print "Free space decomposition: "; FlexDebugDecomposition(Flex_Heap);
		print "Free space map: "; FlexDebug(Flex_Heap);
	} else {
		print HeapNetFreeSpace(false), " of ", MEMORY_HEAP_SIZE+16, " bytes free.^";
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Flex.i6t: Block Allocation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FlexAllocate size kov flags
	dsize n m free_block min_m max_m smallest_oversized_block secondhalf i hsize head tail;
	
	if (HeapMakeSpace(size, flags & BLK_FLAG_MULTIPLE) == false) FlexError("ran out");

	! Calculate the header size for a block of this KOV
	if (flags & BLK_FLAG_MULTIPLE) hsize = BLK_DATA_MULTI_OFFSET;
	else hsize = BLK_DATA_OFFSET;
	! Calculate the data size
	n=0; for (dsize=1: ((dsize < hsize+size) || (n<3+(WORDSIZE/2))): dsize=dsize*2) n++;

	! Seek a free block closest to the correct size, but starting from the
	! block after the fixed head-free-block, which we can't touch
	min_m = 10000; max_m = 0;
	for (free_block = Flex_Heap-->BLK_NEXT:
		free_block ~= NULL:
		free_block = free_block-->BLK_NEXT) {
		m = free_block->BLK_HEADER_N;
		! Current block the ideal size
		if (m == n) jump CorrectSizeFound;
		! Current block too large: find the smallest which is larger than needed
		if (m > n) {
			if (min_m > m) {
				min_m = m;
				smallest_oversized_block = free_block;
			}
		}
		! Current block too small: find the largest which is smaller than needed
		if (m < n) {
			if (max_m < m) {
				max_m = m;
			}
		}
	}

	if (min_m == 10000) {
		! Case I: No block is large enough to hold the entire size
		if (flags & BLK_FLAG_MULTIPLE == 0) FlexError("too fragmented");
		! Set dsize to the size in bytes if the largest block available
		for (dsize=1: max_m > 0: dsize=dsize*2) max_m--;
		! Split as a head (dsize-hsize), which we can be sure fits into one block,
		! plus a tail (size-(dsize-hsize), which might be a list of blocks
		head = FlexAllocate(dsize-hsize, kov, flags);
		if (head == 0) FlexError("for head block not available");
		tail = FlexAllocate(size-(dsize-hsize), kov, flags);
		if (tail == 0) FlexError("for tail block not available");
		head-->BLK_NEXT = tail;
		tail-->BLK_PREV = head;
		return head;
	}

	! Case II: No block is the right size, but some exist which are too big
	! Set dsize to the size in bytes of the smallest oversized block
	for (dsize=1,m=1: m<=min_m: dsize=dsize*2) m++;
	free_block = smallest_oversized_block;
	while (min_m > n) {
		! Repeatedly halve free_block at the front until the two smallest
		! fragments left are the correct size: then take the frontmost
		dsize = dsize/2;
		! print "Halving size to ", dsize, "^";
		secondhalf = free_block + dsize;
		secondhalf-->BLK_NEXT = free_block-->BLK_NEXT;
		if (secondhalf-->BLK_NEXT ~= NULL)
			(secondhalf-->BLK_NEXT)-->BLK_PREV = secondhalf;
		secondhalf-->BLK_PREV = free_block;
		free_block-->BLK_NEXT = secondhalf;
		free_block->BLK_HEADER_N = (free_block->BLK_HEADER_N) - 1;
		secondhalf->BLK_HEADER_N = free_block->BLK_HEADER_N;
		secondhalf-->BLK_HEADER_KOV = free_block-->BLK_HEADER_KOV;
		secondhalf-->BLK_HEADER_RCOUNT = 0;
		secondhalf->BLK_HEADER_FLAGS = free_block->BLK_HEADER_FLAGS;
		min_m--;
	}
	
	! Once that is done, free_block points to a block which is exactly the
	! right size, so we can fall into...
	
	! Case III: There is a free block which has the correct size.
	.CorrectSizeFound;
	! Delete the free block from the double linked list of free blocks: note
	! that it cannot be the head of this list, which is fixed
	if (free_block-->BLK_NEXT == NULL) {
		! We remove final block, so previous is now final
		(free_block-->BLK_PREV)-->BLK_NEXT = NULL;
	} else {
		! We remove a middle block, so join previous to next
		(free_block-->BLK_PREV)-->BLK_NEXT = free_block-->BLK_NEXT;
		(free_block-->BLK_NEXT)-->BLK_PREV = free_block-->BLK_PREV;
	}
	free_block-->BLK_HEADER_KOV = KindAtomic(kov);
	free_block-->BLK_HEADER_RCOUNT = 1;
	free_block->BLK_HEADER_FLAGS = flags;
	if (flags & BLK_FLAG_MULTIPLE) {
		free_block-->BLK_NEXT = NULL;
		free_block-->BLK_PREV = NULL;
	}
	
	! Zero out the data bytes in the memory allocated
	for (i=hsize:i<dsize:i++) free_block->i=0;
	return free_block;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Flex.i6t: Errors
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FlexError reason;
	print "*** Memory ", (string) reason, " ***^";
	RunTimeProblem(RTP_HEAPERROR);
	@quit;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Flex.i6t: Merging
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FlexMergeInternal block first last pv nx;
	first = block; last = block;
	while (last-->BLK_NEXT == last+FlexSize(last))
		last = last-->BLK_NEXT;
	while ((first-->BLK_PREV + FlexSize(first-->BLK_PREV) == first) &&
		(first-->BLK_PREV ~= Flex_Heap))
		first = first-->BLK_PREV;
	pv = first-->BLK_PREV;
	nx = last-->BLK_NEXT;
	#ifdef BLKVALUE_TRACE;
	print "Merging: "; FlexDebugDecomposition(pv-->BLK_NEXT, nx); print "^";
	#endif;
	if (FlexRecutInternal(first, last)) {
		#ifdef BLKVALUE_TRACE;
		print " --> "; FlexDebugDecomposition(pv-->BLK_NEXT, nx); print "^";
		#endif;
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Flex.i6t: Recutting
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FlexRecutInternal first last tsize backsize mfrom mto bnext backend n dsize fine_so_far;
	if (first == last) rfalse;
	mfrom = first; mto = last + FlexSize(last);
	bnext = last-->BLK_NEXT;
	fine_so_far = true;
	for (:mto>mfrom: mto = mto - backsize) {
		for (n=0, backsize=1: backsize*2 <= mto-mfrom: n++) backsize=backsize*2;
		if ((fine_so_far) && (backsize == FlexSize(last))) {
			bnext = last; last = last-->BLK_PREV;
			bnext-->BLK_PREV = last;
			last-->BLK_NEXT = bnext;
			continue;
		}
		fine_so_far = false; ! From this point, "last" is meaningless
		backend = mto - backsize;
		backend->BLK_HEADER_N = n;
		backend-->BLK_HEADER_KOV = 0;
		backend-->BLK_HEADER_RCOUNT = 0;
		backend->BLK_HEADER_FLAGS = BLK_FLAG_MULTIPLE;
		backend-->BLK_NEXT = bnext;
		if (bnext ~= NULL) {
			bnext-->BLK_PREV = backend;
			bnext = backend;
		}
	}
	if (fine_so_far) rfalse;
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Flex.i6t: Deallocation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FlexFree block fromtxb ptxb;
	if (block == 0) return;
	if ((block->BLK_HEADER_FLAGS) & BLK_FLAG_RESIDENT) return;
	if ((block->BLK_HEADER_N) & $80) return; ! not a flexible block at all
	if ((block->BLK_HEADER_FLAGS) & BLK_FLAG_MULTIPLE) {
		if (block-->BLK_PREV ~= NULL) (block-->BLK_PREV)-->BLK_NEXT = NULL;
		fromtxb = block;
		for (:(block-->BLK_NEXT)~=NULL:block = block-->BLK_NEXT) ;
		while (block ~= fromtxb) {
			ptxb = block-->BLK_PREV; FlexFreeSingleBlockInternal(block); block = ptxb;
		}
	}
	FlexFreeSingleBlockInternal(block);
];

[ FlexFreeSingleBlockInternal block free nx;
	block-->BLK_HEADER_KOV = 0;
	block-->BLK_HEADER_RCOUNT = 0;
	block->BLK_HEADER_FLAGS = BLK_FLAG_MULTIPLE;
	for (free = Flex_Heap:free ~= NULL:free = free-->BLK_NEXT) {
		nx = free-->BLK_NEXT;
		if (nx == NULL) {
			free-->BLK_NEXT = block;
			block-->BLK_PREV = free;
			block-->BLK_NEXT = NULL;
			FlexMergeInternal(block);
			return;
		}
		if (UnsignedCompare(nx, block) == 1) {
			free-->BLK_NEXT = block;
			block-->BLK_PREV = free;
			block-->BLK_NEXT = nx;
			nx-->BLK_PREV = block;
			FlexMergeInternal(block);
			return;
		}
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Flex.i6t: Resizing
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FlexResize block req newsize dsize newblk kov n i otxb flags;
	if (block == 0) FlexError("failed resizing null block");
	kov = block-->BLK_HEADER_KOV;
	flags = block->BLK_HEADER_FLAGS;
	if (flags & BLK_FLAG_MULTIPLE == 0) FlexError("failed resizing inextensible block");
	otxb = block;
	newsize = req;
	for (:: block = block-->BLK_NEXT) {
		n = block->BLK_HEADER_N;
		for (dsize=1: n>0: n--) dsize = dsize*2;
		i = dsize - BLK_DATA_MULTI_OFFSET;
		newsize = newsize - i;
		if (newsize > 0) {
			if (block-->BLK_NEXT ~= NULL) continue;
			newblk = FlexAllocate(newsize, kov, flags);
			if (newblk == 0) rfalse;
			block-->BLK_NEXT = newblk;
			newblk-->BLK_PREV = block;
			return;
		}
		if (block-->BLK_NEXT ~= NULL) {
			FlexFree(block-->BLK_NEXT);
			block-->BLK_NEXT = NULL;
		}
		return;
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Flex.i6t: Block Size
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FlexSize txb bsize n; ! Size of an individual block, including header
	if (txb == 0) return 0;
	for (bsize=1: n<txb->BLK_HEADER_N: bsize=bsize*2) n++;
	return bsize;
];

[ FlexTotalSize txb size_in_bytes; ! Combined size of multiple-blocks for a value
	if (txb == 0) return 0;
	if ((txb->BLK_HEADER_FLAGS) & BLK_FLAG_MULTIPLE == 0)
		return FlexSize(txb) - BLK_DATA_OFFSET;
	for (:txb~=NULL:txb=txb-->BLK_NEXT) {
		size_in_bytes = size_in_bytes + FlexSize(txb) - BLK_DATA_MULTI_OFFSET;
	}
	return size_in_bytes;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Flex.i6t: Debugging Routines
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FlexDebug txb n k i bsize tot dtot kov;
	if (txb == 0) "Block never created.";
	kov = txb-->BLK_HEADER_KOV;
	print "Block ", txb, " (kov ", kov, "): ";
	for (:txb~=NULL:txb = txb-->BLK_NEXT) {
		if (k++ == 100) " ... and so on.";
		if (txb-->BLK_HEADER_KOV ~= kov)
			print "*Wrong kov=", txb-->BLK_HEADER_KOV, "* ";
		n = txb->BLK_HEADER_N;
		for (bsize=1:n>0:n--) bsize=bsize*2;
		i = bsize - BLK_DATA_OFFSET;
		dtot = dtot+i;
		tot = tot+bsize;
		print txb, "(", bsize, ") > ";
	}
	print dtot, " data in ", tot, " bytes^";
];

[ FlexDebugDecomposition from to txb pf;
	if (to==0) to = NULL;
	for (txb=from:(txb~=to) && (txb~=NULL):txb=txb-->BLK_NEXT) {
		if (pf) print "+";
		print FlexSize(txb);
		pf = true;
	}
	print "^";
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Overview
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant RC_INFINITY = MAX_POSITIVE_NUMBER;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Short Block Format
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant BLK_BVBITMAP           = $ff;

Constant BLK_BVBITMAP_LONGBLOCK = $10; ! Word 1 of SB is pointer to LB
Constant BLK_BVBITMAP_TEXT      = $20; ! BV holds a TEXT_TY value
Constant BLK_BVBITMAP_CONSTANT  = $40; ! BV holds a TEXT_TY value

#IFTRUE WORDSIZE == 4;
Constant BLK_BVBITMAP_LONGBLOCKMASK = $ffffff10;
Constant BLK_BVBITMAP_TEXTMASK      = $ffffff20;
Constant BLK_BVBITMAP_CONSTANTMASK  = $ffffff40;
#IFNOT;
Constant BLK_BVBITMAP_LONGBLOCKMASK = $ff10;
Constant BLK_BVBITMAP_TEXTMASK      = $ff20;
Constant BLK_BVBITMAP_CONSTANTMASK  = $ff40;
#ENDIF;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Long Block Access
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueGetLongBlock bv o;
	if (bv) {
		o = bv-->0;
		if (o == 0) return bv + WORDSIZE;
		if (o & BLK_BVBITMAP == o) {
			if (o & BLK_BVBITMAP_LONGBLOCK) return bv-->1;
			return 0;
		}
		return o;
	}
	return bv;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Weak Kind
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueWeakKind bv o;
	if (bv) {
		o = bv-->0;
		if (o == 0) return bv-->(BLK_HEADER_KOV+1);
		if (o & BLK_BVBITMAP == o) {
			if (o & BLK_BVBITMAP_TEXT) return TEXT_TY;
			o = bv-->1;
		}
		return o-->BLK_HEADER_KOV;
	}
	return NIL_TY;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Reference counting
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueGetRefCountPrimitive bv long_block;
	long_block = BlkValueGetLongBlock(bv);
	if (long_block) return long_block-->BLK_HEADER_RCOUNT;
	return RC_INFINITY;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Changing Reference Counts
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueIncRefCountPrimitive bv long_block refc;
	long_block = BlkValueGetLongBlock(bv);
	if (long_block) {
		refc = long_block-->BLK_HEADER_RCOUNT;
		if (refc < RC_INFINITY) long_block-->BLK_HEADER_RCOUNT = refc + 1;
	}
];

[ BlkValueDecRefCountPrimitive bv long_block refc;
	long_block = BlkValueGetLongBlock(bv);
	if (long_block) {
		refc = long_block-->BLK_HEADER_RCOUNT;
		if (refc < RC_INFINITY) {
			refc--;
			if (refc < 0) BlkValueError("reference count negative");
			long_block-->BLK_HEADER_RCOUNT = refc;
		}
		return refc;
	}
	return RC_INFINITY;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Long Block Capacity
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueLBCapacity bv  long_block array_size_in_bytes entry_size_in_bytes flags;
	long_block = BlkValueGetLongBlock(bv);
	if (long_block == 0) return 0;

	array_size_in_bytes = FlexTotalSize(long_block);

	flags = long_block->BLK_HEADER_FLAGS;
	entry_size_in_bytes = 1;
	if (flags & BLK_FLAG_16_BIT) entry_size_in_bytes = 2;
	else if (flags & BLK_FLAG_WORD) entry_size_in_bytes = WORDSIZE;

	return array_size_in_bytes / entry_size_in_bytes;
];

[ BlkValueSetLBCapacity bv new_capacity  long_block flags entry_size_in_bytes;
	if (bv == 0) rfalse;
	BlkMakeMutable(bv);
	long_block = BlkValueGetLongBlock(bv);
	if (long_block == 0) rfalse;

	flags = long_block->BLK_HEADER_FLAGS;
	entry_size_in_bytes = 1;
	if (flags & BLK_FLAG_16_BIT) entry_size_in_bytes = 2;
	else if (flags & BLK_FLAG_WORD) entry_size_in_bytes = WORDSIZE;

	FlexResize(long_block, new_capacity*entry_size_in_bytes);
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Long Block Array Access
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueRead from pos do_not_indirect
	long_block chunk_size_in_bytes header_size_in_bytes flags entry_size_in_bytes seek_byte_position;
	if (from == 0) rfalse;
	if (do_not_indirect)
		long_block = from;
	else
		long_block = BlkValueGetLongBlock(from);

	flags = long_block->BLK_HEADER_FLAGS;
	entry_size_in_bytes = 1;
	if (flags & BLK_FLAG_16_BIT) entry_size_in_bytes = 2;
	else if (flags & BLK_FLAG_WORD) entry_size_in_bytes = WORDSIZE;

	if (flags & BLK_FLAG_MULTIPLE) header_size_in_bytes = BLK_DATA_MULTI_OFFSET;
	else header_size_in_bytes = BLK_DATA_OFFSET;

	seek_byte_position = pos*entry_size_in_bytes;
	for (: long_block~=NULL: long_block=long_block-->BLK_NEXT) {
		chunk_size_in_bytes = FlexSize(long_block) - header_size_in_bytes;
		if ((seek_byte_position >= 0) && (seek_byte_position<chunk_size_in_bytes)) {
			long_block = long_block + header_size_in_bytes + seek_byte_position;
			switch(entry_size_in_bytes) {
				1: return long_block->0;
				2:	#Iftrue (WORDSIZE == 2); return long_block-->0;
					#ifnot; return (long_block->0)*256 + (long_block->1);
					#endif;
				4: return long_block-->0;
			}
		}
		seek_byte_position = seek_byte_position - chunk_size_in_bytes;
	}
	"*** BlkValueRead: reading from index out of range: ", pos, " in ", from, " ***";
];

[ BlkValueWrite to pos val do_not_indirect
	long_block chunk_size_in_bytes header_size_in_bytes flags entry_size_in_bytes seek_byte_position;
	if (to == 0) rfalse;
	if (do_not_indirect)
		long_block = to;
	else {
		BlkMakeMutable(to);
		long_block = BlkValueGetLongBlock(to);
	}

	flags = long_block->BLK_HEADER_FLAGS;
	entry_size_in_bytes = 1;
	if (flags & BLK_FLAG_16_BIT) entry_size_in_bytes = 2;
	else if (flags & BLK_FLAG_WORD) entry_size_in_bytes = WORDSIZE;

	if (flags & BLK_FLAG_MULTIPLE) header_size_in_bytes = BLK_DATA_MULTI_OFFSET;
	else header_size_in_bytes = BLK_DATA_OFFSET;

	seek_byte_position = pos*entry_size_in_bytes;
	for (:long_block~=NULL:long_block=long_block-->BLK_NEXT) {
		chunk_size_in_bytes = FlexSize(long_block) - header_size_in_bytes;
		if ((seek_byte_position >= 0) && (seek_byte_position<chunk_size_in_bytes)) {
			long_block = long_block + header_size_in_bytes + seek_byte_position;
			switch(entry_size_in_bytes) {
				1: long_block->0 = val;
				2:	#Iftrue (WORDSIZE == 2); long_block-->0 = val;
					#ifnot; long_block->0 = (val/256)%256; long_block->1 = val%256;
					#endif;
				4: long_block-->0 = val;
			}
			return;
		}
		seek_byte_position = seek_byte_position - chunk_size_in_bytes;
	}
	"*** BlkValueWrite: writing to index out of range: ", pos, " in ", to, " ***";
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: First Zero Entry
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueSeekZeroEntry from
	long_block chunk_size_in_bytes header_size_in_bytes flags entry_size_in_bytes
	byte_position addr from_addr to_addr;
	if (from == 0) return -1;
	long_block = BlkValueGetLongBlock(from);

	flags = long_block->BLK_HEADER_FLAGS;
	entry_size_in_bytes = 1;
	if (flags & BLK_FLAG_16_BIT) entry_size_in_bytes = 2;
	else if (flags & BLK_FLAG_WORD) entry_size_in_bytes = WORDSIZE;

	if (flags & BLK_FLAG_MULTIPLE) header_size_in_bytes = BLK_DATA_MULTI_OFFSET;
	else header_size_in_bytes = BLK_DATA_OFFSET;

	byte_position = 0;
	for (: long_block~=NULL: long_block=long_block-->BLK_NEXT) {
		chunk_size_in_bytes = FlexSize(long_block) - header_size_in_bytes;
		from_addr = long_block + header_size_in_bytes;
		to_addr = from_addr + chunk_size_in_bytes;
		switch(entry_size_in_bytes) {
			1:
				for (addr = from_addr: addr < to_addr: addr++)
					if (addr->0 == 0)
						return byte_position + addr - from_addr;
			2:
				#iftrue (WORDSIZE == 2);
				for (addr = from_addr: addr < to_addr: addr=addr+2)
					if (addr-->0 == 0)
						return (byte_position + addr - from_addr)/2;
				#ifnot;
				for (addr = from_addr: addr < to_addr: addr=addr+2)
					if ((addr->0 == 0) && (addr->1 == 0))
						return (byte_position + addr - from_addr)/2;
				#endif;
			4:
				for (addr = from_addr: addr < to_addr: addr=addr+4)
					if (addr-->0 == 0)
						return (byte_position + addr - from_addr)/4;
		}
		byte_position = byte_position + chunk_size_in_bytes;
	}
	return -1;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Mass Copy Entries
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueMassCopyEntries to_bv from_bv no_entries_to_copy
	from_long_block from_addr from_bytes_left from_header_size_in_bytes
	to_long_block to_addr to_bytes_left to_header_size_in_bytes
	bytes_to_copy flags entry_size_in_bytes min;

	BlkMakeMutable(to_bv);

	from_long_block = BlkValueGetLongBlock(from_bv);
	to_long_block = BlkValueGetLongBlock(to_bv);

	flags = from_long_block->BLK_HEADER_FLAGS;
	entry_size_in_bytes = 1;
	if (flags & BLK_FLAG_16_BIT) entry_size_in_bytes = 2;
	else if (flags & BLK_FLAG_WORD) entry_size_in_bytes = WORDSIZE;

	if ((flags & (BLK_FLAG_MULTIPLE + BLK_FLAG_TRUNCMULT)) &&
		(BlkValueSetLBCapacity(to_bv, no_entries_to_copy) == false))
		BlkValueError("copy resizing failed");

	if (flags & BLK_FLAG_MULTIPLE) from_header_size_in_bytes = BLK_DATA_MULTI_OFFSET;
	else from_header_size_in_bytes = BLK_DATA_OFFSET;
	flags = to_long_block->BLK_HEADER_FLAGS;
	if (flags & BLK_FLAG_MULTIPLE) to_header_size_in_bytes = BLK_DATA_MULTI_OFFSET;
	else to_header_size_in_bytes = BLK_DATA_OFFSET;

	from_addr = from_long_block + from_header_size_in_bytes;
	from_bytes_left = FlexSize(from_long_block) - from_header_size_in_bytes;
	to_addr = to_long_block + to_header_size_in_bytes;
	to_bytes_left = FlexSize(to_long_block) - to_header_size_in_bytes;

	bytes_to_copy = entry_size_in_bytes*no_entries_to_copy;
	while (true) {
		if (from_bytes_left == 0) {
			from_long_block = from_long_block-->BLK_NEXT;
			if (from_long_block == 0) BlkValueError("copy destination exhausted");
			from_addr = from_long_block + from_header_size_in_bytes;
			from_bytes_left = FlexSize(from_long_block) - from_header_size_in_bytes;
		} else if (to_bytes_left == 0) {
			to_long_block = to_long_block-->BLK_NEXT;
			if (to_long_block == 0) BlkValueError("copy source exhausted");
			to_addr = to_long_block + to_header_size_in_bytes;
			to_bytes_left = FlexSize(to_long_block) - to_header_size_in_bytes;
		} else {
			min = from_bytes_left; if (to_bytes_left < min) min = to_bytes_left;
			if (bytes_to_copy <= min) {
				Memcpy(to_addr, from_addr, bytes_to_copy);
				return;
			}
			Memcpy(to_addr, from_addr, min);
			bytes_to_copy = bytes_to_copy - min;
			from_addr = from_addr + min;
			from_bytes_left = from_bytes_left - min;
			to_addr = to_addr + min;
			to_bytes_left = to_bytes_left - min;
		}
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Mass Copy From Array
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueMassCopyFromArray to_bv from_array from_entry_size no_entries_to_copy
	to_long_block to_addr to_entries_left to_header_size to_entry_size
	flags;

	BlkMakeMutable(to_bv);

	to_long_block = BlkValueGetLongBlock(to_bv);

	flags = to_long_block->BLK_HEADER_FLAGS;
	to_entry_size = 1;
	if (flags & BLK_FLAG_16_BIT) to_entry_size = 2;
	else if (flags & BLK_FLAG_WORD) to_entry_size = WORDSIZE;

	if ((flags & (BLK_FLAG_MULTIPLE + BLK_FLAG_TRUNCMULT)) &&
		(BlkValueSetLBCapacity(to_bv, no_entries_to_copy) == false))
		BlkValueError("copy resizing failed");

	if (flags & BLK_FLAG_MULTIPLE) to_header_size = BLK_DATA_MULTI_OFFSET;
	else to_header_size = BLK_DATA_OFFSET;

	to_addr = to_long_block + to_header_size;
	to_entries_left = (FlexSize(to_long_block) - to_header_size)/to_entry_size;

	while (no_entries_to_copy > to_entries_left) {
		Arrcpy(to_addr, to_entry_size, from_array, from_entry_size, to_entries_left);
		no_entries_to_copy = no_entries_to_copy - to_entries_left;
		from_array = from_array + to_entries_left*from_entry_size;
		to_long_block = to_long_block-->BLK_NEXT;
		if (to_long_block == 0) BlkValueError("copy source exhausted");
		to_addr = to_long_block + to_header_size;
		to_entries_left = (FlexSize(to_long_block) - to_header_size)/to_entry_size;
	}
	if (no_entries_to_copy > 0) {
		Arrcpy(to_addr, to_entry_size, from_array, from_entry_size, no_entries_to_copy);
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: KOVS Routines
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant CREATE_KOVS      = 1;
Constant CAST_KOVS        = 2;
Constant DESTROY_KOVS     = 3;
Constant MAKEMUTABLE_KOVS = 4;
Constant COPYKIND_KOVS    = 5;
Constant EXTENT_KOVS      = 6;
Constant COPYQUICK_KOVS   = 7;
Constant COPYSB_KOVS      = 8;
Constant KINDDATA_KOVS    = 9;
Constant COPY_KOVS        = 10;
Constant COMPARE_KOVS     = 11;
Constant READ_FILE_KOVS   = 12;
Constant WRITE_FILE_KOVS  = 13;
Constant HASH_KOVS        = 14;
Constant DEBUG_KOVS       = 15;

! Constant BLKVALUE_TRACE; ! Uncomment this to expose masses of tracery


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Creation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueCreate strong_kind short_block  kovs;

	kovs = KOVSupportFunction(strong_kind, "impossible allocation");
	short_block = kovs(CREATE_KOVS, strong_kind, short_block);

	#ifdef BLKVALUE_TRACE; print "Created: ", (BlkValueDebug) short_block, "^"; #endif;

	! The new value is represented in I6 as the pointer to its short block:
	return short_block;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Errors
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueError reason;
	print "*** Value handling failed: ", (string) reason, " ***^";
	RunTimeProblem(RTP_HEAPERROR);
	@quit;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Short Block Allocation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueCreateSB1 short_block val;
	if (short_block == 0)
		short_block = FlexAllocate(WORDSIZE, 0, BLK_FLAG_WORD) + BLK_DATA_OFFSET;
	short_block-->0 = val;
	return short_block;
];

[ BlkValueCreateSB2 short_block val1 val2;
	if (short_block == 0)
		short_block = FlexAllocate(2*WORDSIZE, 0, BLK_FLAG_WORD) + BLK_DATA_OFFSET;
	short_block-->0 = val1; short_block-->1 = val2;
	return short_block;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Block Values On Stack
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ StackFramingInitialise;
	I7SFRAME = blockv_stack + WORDSIZE*BLOCKV_STACK_SIZE;
];

[ StackFrameCreate size new;
	new = I7SFRAME - WORDSIZE*size;
	if (new < blockv_stack) { RunTimeProblem(RTP_HEAPERROR); @quit; }
	I7SFRAME = new;
];

[ BlkValueCreateOnStack offset strong_kind;
	BlkValueCreate(strong_kind, I7SFRAME + WORDSIZE*offset);
];

[ BlkValueFreeOnStack offset;
    BlkValueFree(I7SFRAME + WORDSIZE*offset);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Freeing
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueFree bv kovs d;
	if (bv == 0) return;

	! Dispose of any data in the long block
	kovs = KOVSupportFunction(BlkValueWeakKind(bv), "impossible deallocation");
	BlkValueDestroyPrimitive(bv, kovs);

	! Free any heap memory occupied by the short block
	d = bv - Flex_Heap;
	if ((d >= 0) && (d < MEMORY_HEAP_SIZE + 16))
		FlexFree(bv - BLK_DATA_OFFSET);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Quick Copy
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueQuickCopyPrimitive to_bv from_bv kovs;
	BlkValueDestroyPrimitive(to_bv, kovs);
	kovs(COPYSB_KOVS, to_bv, from_bv);
	BlkValueIncRefCountPrimitive(from_bv);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Short Block Copy
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueCopySB1 to_bv from_bv;
	to_bv-->0 = from_bv-->0;
	if (to_bv-->0 == 0) to_bv-->0 = from_bv + WORDSIZE;
];

[ BlkValueCopySB2 to_bv from_bv;
	to_bv-->0 = from_bv-->0;
	to_bv-->1 = from_bv-->1;
	if (to_bv-->1 == 0) to_bv-->1 = from_bv + 2*WORDSIZE;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Slow Copy
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueSlowCopyPrimitive to_bv from_bv kovs recycling
	k from_long_block no_entries_to_copy;
	k = kovs(KINDDATA_KOVS, to_bv, from_bv);

	from_long_block = BlkValueGetLongBlock(from_bv);
	if (from_long_block) {
		if (recycling) BlkValueRecyclePrimitive(to_bv, kovs);
		no_entries_to_copy = kovs(EXTENT_KOVS, from_bv);
		if (no_entries_to_copy == -1) no_entries_to_copy = BlkValueLBCapacity(from_bv);
		BlkValueMassCopyEntries(to_bv, from_bv, no_entries_to_copy);
!print "So to: "; BlkValueDebug(to_bv); print "^";

	}

	kovs(COPY_KOVS, to_bv, from_bv, k);
!print "Whence to: "; BlkValueDebug(to_bv); print "^";
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Copy
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueCopy to_bv from_bv  to_kind from_kind kovs;
	if (to_bv == 0) BlkValueError("copy to null value");
	if (from_bv == 0) BlkValueError("copy from null value");

	#ifdef BLKVALUE_TRACE;
	print "Copy: ", (BlkValueDebug) to_bv, " to equal ", (BlkValueDebug) from_bv, "^";
	#endif;

	to_kind = BlkValueWeakKind(to_bv);
	from_kind = BlkValueWeakKind(from_bv);
	if (to_kind ~= from_kind) BlkValueError("copy incompatible kinds");

	kovs = KOVSupportFunction(to_kind, "impossible copy");
	
	if (kovs(COPYQUICK_KOVS, to_bv, from_bv))
		BlkValueQuickCopyPrimitive(to_bv, from_bv, kovs);
	else
		BlkValueSlowCopyPrimitive(to_bv, from_bv, kovs, true);

	return to_bv;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Destruction
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueDestroyPrimitive bv kovs long_block;
	#ifdef BLKVALUE_TRACE; print "Destroying ", (BlkValueDebug) bv, "^"; #endif;
	if (BlkValueDecRefCountPrimitive(bv) == 0) {
		kovs(DESTROY_KOVS, bv);
		long_block = BlkValueGetLongBlock(bv);
		if (long_block) FlexFree(long_block);
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Recycling
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueRecyclePrimitive bv kovs;
	#ifdef BLKVALUE_TRACE; print "Recycling ", (BlkValueDebug) bv, "^"; #endif;
	if (BlkValueDecRefCountPrimitive(bv) == 0) {
		kovs(DESTROY_KOVS, bv);
		BlkValueIncRefCountPrimitive(bv);
	} else {
		BlkValueCreate(BlkValueWeakKind(bv), bv);
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Mutability
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkMakeMutable bv block bv_kind kovs sb_size;
	if (bv == 0) BlkValueError("tried to make null block mutable");

	if (BlkValueGetRefCountPrimitive(bv) > 1) {
		#ifdef BLKVALUE_TRACE; print "Make mutable: ", (BlkValueDebug) bv, "^"; #endif;

		BlkValueDecRefCountPrimitive(bv);

		bv_kind = BlkValueWeakKind(bv);
		kovs = KOVSupportFunction(bv_kind, "impossible mutability");

		sb_size = kovs(MAKEMUTABLE_KOVS, bv);
		if (sb_size > 0) {
			@push I7SFRAME;
			StackFrameCreate(sb_size);
			BlkValueCreateOnStack(0, bv_kind);
			kovs(COPYKIND_KOVS, I7SFRAME, bv);
			BlkValueSlowCopyPrimitive(I7SFRAME, bv, kovs, false);
			kovs(COPYSB_KOVS, bv, I7SFRAME);
			@pull I7SFRAME;
		}
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Casting
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueCast to_bv original_kind original_value  kovs;
	kovs = KOVSupportFunction(BlkValueWeakKind(to_bv), "impossible cast");
	kovs(CAST_KOVS, to_bv, original_kind, original_value);
	return to_bv;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Comparison
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueCompare bv_left bv_right  kind_left kind_right kovs;
	if ((bv_left == 0) && (bv_right == 0)) return 0;
	if (bv_left == 0) return 1;
	if (bv_right == 0) return -1;

	kind_left = BlkValueWeakKind(bv_left);
	kind_right = BlkValueWeakKind(bv_right);
	if (kind_left ~= kind_right) return kind_left - kind_right;

	kovs = KOVSupportFunction(kind_left, "impossible comparison");
	return kovs(COMPARE_KOVS, bv_left, bv_right);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Hashing
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ GetHashValue kind value;
	if (KOVIsBlockValue(kind)) return BlkValueHash(value);
	return value;
];

[ BlkValueHash bv  bv_kind kovs;
	if (bv == 0) return 0;
	bv_kind = BlkValueWeakKind(bv);
	kovs = KOVSupportFunction(bv_kind, "impossible hashing");
	return kovs(HASH_KOVS, bv);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Serialisation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueReadFromFile bv auxf ch bv_kind  kovs;
	kovs = KOVSupportFunction(bv_kind);
	if (kovs) return kovs(READ_FILE_KOVS, bv, auxf, ch);
	rfalse;
];

[ BlkValueWriteToFile bv bv_kind  kovs;
	kovs = KOVSupportFunction(bv_kind);
	if (kovs) return kovs(WRITE_FILE_KOVS, bv);
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Debugging
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueDebug bv flag refc long_block kovs;
	print "(BV";
	if (bv) {
		BlkDebugAddress(bv, flag);
		long_block = BlkValueGetLongBlock(bv);
		if (long_block) {
			if (bv-->0 == 0) print "..."; else print "-->";
			print "L"; BlkDebugAddress(long_block, flag);
			print " 2**", long_block->BLK_HEADER_N;
			refc = BlkValueGetRefCountPrimitive(bv);
			if (refc == RC_INFINITY) print " resident";
			else { print " ", refc, " ref"; if (refc ~= 1) print "s"; }
		}
		kovs = KOVSupportFunction(BlkValueWeakKind(bv));
		if (kovs) kovs(DEBUG_KOVS, bv);
	}
	print ")";
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Printing Memory Addresses
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkDebugAddress addr flag d;
	if (flag) { print "###"; return; }

	d = addr - blockv_stack;
	if ((d >= 0) && (d <= WORDSIZE*BLOCKV_STACK_SIZE)) {
		print "s+", (BlkPrintHexadecimal) d;
		d = addr - I7SFRAME;
		print "=f"; if (d >= 0) print "+"; print d;
		return;
	}
	
	d = addr - Flex_Heap;
	if ((d >= 0) && (d < MEMORY_HEAP_SIZE + 16)) {
		print "h+", (BlkPrintHexadecimal) d;
		return;
	}

	print (BlkPrintHexadecimal) addr;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Hexadecimal Printing
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkPrintHexadecimal v;
	#iftrue WORDSIZE == 4;
	if (v & $ffff0000) {
		if (v & $ff000000) {
			BlkPrintHexDigit(v / $10000000);
			BlkPrintHexDigit(v / $1000000);
		}
		BlkPrintHexDigit(v / $100000);
		BlkPrintHexDigit(v / $10000);
	}
	#endif;
	BlkPrintHexDigit(v / $1000);
	BlkPrintHexDigit(v / $100);
	BlkPrintHexDigit(v / $10);
	BlkPrintHexDigit(v);
];

[ BlkPrintHexDigit v;
	v = v & $F;
	if (v < 10) print v; else print (char) 'A' + v - 10;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Block Format
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant CONSTANT_PACKED_TEXT_STORAGE     = BLK_BVBITMAP_TEXT + BLK_BVBITMAP_CONSTANT + 1;
Constant CONSTANT_PERISHABLE_TEXT_STORAGE = BLK_BVBITMAP_TEXT + BLK_BVBITMAP_CONSTANT + 2;
Constant PACKED_TEXT_STORAGE              = BLK_BVBITMAP_TEXT + 3;
Constant UNPACKED_TEXT_STORAGE            = BLK_BVBITMAP_TEXT + BLK_BVBITMAP_LONGBLOCK + 4;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Extent Of Long Block
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_Extent arg1 x;
	x = BlkValueSeekZeroEntry(arg1);
	if (x < 0) return -1; ! should not happen, of course
	return x+1;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Character Set
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#IFDEF TARGET_ZCODE;
Constant TEXT_TY_Storage_Flags = BLK_FLAG_MULTIPLE;
Constant ZSCII_Tables;
#IFNOT;
Constant TEXT_TY_Storage_Flags = BLK_FLAG_MULTIPLE + BLK_FLAG_16_BIT;
Constant Large_Unicode_Tables;
#ENDIF;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! UnicodeData.i6t: Source
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant UNIC_NCT = 10000; ! Safe as highest case-change delta is 8383


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! UnicodeData.i6t: ZSCII Casing Tables
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#IFDEF ZSCII_Tables;
Array CharCasingChart0 -->
    $0061 (  26) (     -32) $009b (   3) (       3) $00a1 (   1) (UNIC_NCT)
    $00a4 (   2) (       3) $00a6 (   1) (UNIC_NCT) $00a9 (   6) (       6)
    $00b5 (   5) (       5) $00bf (   5) (       5) $00c9 (  -3) (       1)
    $00cd (   3) (       3) $00d3 (  -3) (       1) $00d7 (   2) (       2)
    $00dc (   1) (       1) $0000
;

Array CharCasingChart1 -->
    $0041 (  26) (      32) $009e (   3) (      -3) $00a7 (   2) (      -3)
    $00af (   6) (      -6) $00ba (   5) (      -5) $00c4 (   5) (      -5)
    $00ca (  -3) (      -1) $00d0 (   3) (      -3) $00d4 (  -3) (      -1)
    $00d9 (   2) (      -2) $00dd (   1) (      -1) $0000
;
#ENDIF; ! ZSCII_Tables


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! UnicodeData.i6t: Small Unicode Casing Tables
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#IFDEF Small_Unicode_Tables;
Array CharCasingChart0 -->
    $0061 (  26) (     -32) $00aa (   1) (UNIC_NCT) $00b5 (   1) (UNIC_NCT) $00ba (   1) (UNIC_NCT)
    $00df (   1) (UNIC_NCT) $00e0 (  23) (     -32) $00f8 (   7) (     -32) $00ff (   1) (UNIC_NCT)
    $0000
;

Array CharCasingChart1 -->
    $0041 (  26) (      32) $00c0 (  23) (      32) $00d8 (   7) (      32) $0000
;

#ENDIF; ! Small_Unicode_Tables


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! UnicodeData.i6t: Large Unicode Casing Tables
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#IFDEF Large_Unicode_Tables;
Array CharCasingChart0 -->
    $0061 (  26) (     -32) $00aa (   1) (UNIC_NCT) $00b5 (   1) (     743) $00ba (   1) (UNIC_NCT)
    $00df (   1) (UNIC_NCT) $00e0 (  23) (     -32) $00f8 (   7) (     -32) $00ff (   1) (     121)
    $0101 ( -47) (      -1) $0131 (   1) (    -232) $0133 (  -5) (      -1) $0138 (   1) (UNIC_NCT)
    $013a ( -15) (      -1) $0149 (   1) (UNIC_NCT) $014b ( -45) (      -1) $017a (  -5) (      -1)
    $017f (   1) (    -300) $0180 (   1) (UNIC_NCT) $0183 (  -3) (      -1) $0188 (   1) (      -1)
    $018c (   1) (      -1) $018d (   1) (UNIC_NCT) $0192 (   1) (      -1) $0195 (   1) (      97)
    $0199 (   1) (      -1) $019a (   2) (UNIC_NCT) $019e (   1) (     130) $01a1 (  -5) (      -1)
    $01a8 (   1) (      -1) $01aa (   2) (UNIC_NCT) $01ad (   1) (      -1) $01b0 (   1) (      -1)
    $01b4 (  -3) (      -1) $01b9 (   1) (      -1) $01ba (   1) (UNIC_NCT) $01bd (   1) (      -1)
    $01be (   1) (UNIC_NCT) $01bf (   1) (      56) $01c6 (   1) (      -2) $01c9 (   1) (      -2)
    $01cc (   1) (      -2) $01ce ( -15) (      -1) $01dd (   1) (     -79) $01df ( -17) (      -1)
    $01f0 (   1) (UNIC_NCT) $01f3 (   1) (      -2) $01f5 (   1) (      -1) $01f9 ( -39) (      -1)
    $0221 (   1) (UNIC_NCT) $0223 ( -17) (      -1) $0234 (   3) (UNIC_NCT) $0250 (   3) (UNIC_NCT)
    $0253 (   1) (    -210) $0254 (   1) (    -206) $0255 (   1) (UNIC_NCT) $0256 (   2) (    -205)
    $0258 (   1) (UNIC_NCT) $0259 (   1) (    -202) $025a (   1) (UNIC_NCT) $025b (   1) (    -203)
    $025c (   4) (UNIC_NCT) $0260 (   1) (    -205) $0261 (   2) (UNIC_NCT) $0263 (   1) (    -207)
    $0264 (   4) (UNIC_NCT) $0268 (   1) (    -209) $0269 (   1) (    -211) $026a (   5) (UNIC_NCT)
    $026f (   1) (    -211) $0270 (   2) (UNIC_NCT) $0272 (   1) (    -213) $0273 (   2) (UNIC_NCT)
    $0275 (   1) (    -214) $0276 (  10) (UNIC_NCT) $0280 (   1) (    -218) $0281 (   2) (UNIC_NCT)
    $0283 (   1) (    -218) $0284 (   4) (UNIC_NCT) $0288 (   1) (    -218) $0289 (   1) (UNIC_NCT)
    $028a (   2) (    -217) $028c (   6) (UNIC_NCT) $0292 (   1) (    -219) $0293 (  29) (UNIC_NCT)
    $0390 (   1) (UNIC_NCT) $03ac (   1) (     -38) $03ad (   3) (     -37) $03b0 (   1) (UNIC_NCT)
    $03b1 (  17) (     -32) $03c2 (   1) (     -31) $03c3 (   9) (     -32) $03cc (   1) (     -64)
    $03cd (   2) (     -63) $03d0 (   1) (     -62) $03d1 (   1) (     -57) $03d5 (   1) (     -47)
    $03d6 (   1) (     -54) $03d7 (   1) (UNIC_NCT) $03d9 ( -23) (      -1) $03f0 (   1) (     -86)
    $03f1 (   1) (     -80) $03f2 (   1) (       7) $03f3 (   1) (UNIC_NCT) $03f5 (   1) (     -96)
    $03f8 (   1) (      -1) $03fb (   1) (      -1) $0430 (  32) (     -32) $0450 (  16) (     -80)
    $0461 ( -33) (      -1) $048b ( -53) (      -1) $04c2 ( -13) (      -1) $04d1 ( -37) (      -1)
    $04f9 (   1) (      -1) $0501 ( -15) (      -1) $0561 (  38) (     -48) $0587 (   1) (UNIC_NCT)
    $1d00 (  44) (UNIC_NCT) $1d62 (  10) (UNIC_NCT) $1e01 (-149) (      -1) $1e96 (   5) (UNIC_NCT)
    $1e9b (   1) (     -59) $1ea1 ( -89) (      -1) $1f00 (   8) (       8) $1f10 (   6) (       8)
    $1f20 (   8) (       8) $1f30 (   8) (       8) $1f40 (   6) (       8) $1f50 (   1) (UNIC_NCT)
    $1f51 (   1) (       8) $1f52 (   1) (UNIC_NCT) $1f53 (   1) (       8) $1f54 (   1) (UNIC_NCT)
    $1f55 (   1) (       8) $1f56 (   1) (UNIC_NCT) $1f57 (   1) (       8) $1f60 (   8) (       8)
    $1f70 (   2) (      74) $1f72 (   4) (      86) $1f76 (   2) (     100) $1f78 (   2) (     128)
    $1f7a (   2) (     112) $1f7c (   2) (     126) $1f80 (   8) (       8) $1f90 (   8) (       8)
    $1fa0 (   8) (       8) $1fb0 (   2) (       8) $1fb2 (   1) (UNIC_NCT) $1fb3 (   1) (       9)
    $1fb4 (  -3) (UNIC_NCT) $1fb7 (   1) (UNIC_NCT) $1fbe (   1) (   -7205) $1fc2 (   1) (UNIC_NCT)
    $1fc3 (   1) (       9) $1fc4 (  -3) (UNIC_NCT) $1fc7 (   1) (UNIC_NCT) $1fd0 (   2) (       8)
    $1fd2 (   2) (UNIC_NCT) $1fd6 (   2) (UNIC_NCT) $1fe0 (   2) (       8) $1fe2 (   3) (UNIC_NCT)
    $1fe5 (   1) (       7) $1fe6 (   2) (UNIC_NCT) $1ff2 (   1) (UNIC_NCT) $1ff3 (   1) (       9)
    $1ff4 (  -3) (UNIC_NCT) $1ff7 (   1) (UNIC_NCT) $2071 (   1) (UNIC_NCT) $207f (   1) (UNIC_NCT)
    $210a (   1) (UNIC_NCT) $210e (   2) (UNIC_NCT) $2113 (   1) (UNIC_NCT) $212f (   1) (UNIC_NCT)
    $2134 (   1) (UNIC_NCT) $2139 (   1) (UNIC_NCT) $213d (   1) (UNIC_NCT) $2146 (   4) (UNIC_NCT)
    $fb00 (   7) (UNIC_NCT) $fb13 (   5) (UNIC_NCT) $ff41 (  26) (     -32) $0000
;

Array CharCasingChart1 -->
    $0041 (  26) (      32) $00c0 (  23) (      32) $00d8 (   7) (      32) $0100 ( -47) (       1)
    $0130 (   1) (    -199) $0132 (  -5) (       1) $0139 ( -15) (       1) $014a ( -45) (       1)
    $0178 (   1) (    -121) $0179 (  -5) (       1) $0181 (   1) (     210) $0182 (  -3) (       1)
    $0186 (   1) (     206) $0187 (   1) (       1) $0189 (   2) (     205) $018b (   1) (       1)
    $018e (   1) (      79) $018f (   1) (     202) $0190 (   1) (     203) $0191 (   1) (       1)
    $0193 (   1) (     205) $0194 (   1) (     207) $0196 (   1) (     211) $0197 (   1) (     209)
    $0198 (   1) (       1) $019c (   1) (     211) $019d (   1) (     213) $019f (   1) (     214)
    $01a0 (  -5) (       1) $01a6 (   1) (     218) $01a7 (   1) (       1) $01a9 (   1) (     218)
    $01ac (   1) (       1) $01ae (   1) (     218) $01af (   1) (       1) $01b1 (   2) (     217)
    $01b3 (  -3) (       1) $01b7 (   1) (     219) $01b8 (   1) (       1) $01bc (   1) (       1)
    $01c4 (   1) (       2) $01c7 (   1) (       2) $01ca (   1) (       2) $01cd ( -15) (       1)
    $01de ( -17) (       1) $01f1 (   1) (       2) $01f4 (   1) (       1) $01f6 (   1) (     -97)
    $01f7 (   1) (     -56) $01f8 ( -39) (       1) $0220 (   1) (    -130) $0222 ( -17) (       1)
    $0386 (   1) (      38) $0388 (   3) (      37) $038c (   1) (      64) $038e (   2) (      63)
    $0391 (  17) (      32) $03a3 (   9) (      32) $03d2 (   3) (UNIC_NCT) $03d8 ( -23) (       1)
    $03f4 (   1) (     -60) $03f7 (   1) (       1) $03f9 (   1) (      -7) $03fa (   1) (       1)
    $0400 (  16) (      80) $0410 (  32) (      32) $0460 ( -33) (       1) $048a ( -53) (       1)
    $04c0 (   1) (UNIC_NCT) $04c1 ( -13) (       1) $04d0 ( -37) (       1) $04f8 (   1) (       1)
    $0500 ( -15) (       1) $0531 (  38) (      48) $10a0 (  38) (UNIC_NCT) $1e00 (-149) (       1)
    $1ea0 ( -89) (       1) $1f08 (   8) (      -8) $1f18 (   6) (      -8) $1f28 (   8) (      -8)
    $1f38 (   8) (      -8) $1f48 (   6) (      -8) $1f59 (  -7) (      -8) $1f68 (   8) (      -8)
    $1fb8 (   2) (      -8) $1fba (   2) (     -74) $1fc8 (   4) (     -86) $1fd8 (   2) (      -8)
    $1fda (   2) (    -100) $1fe8 (   2) (      -8) $1fea (   2) (    -112) $1fec (   1) (      -7)
    $1ff8 (   2) (    -128) $1ffa (   2) (    -126) $2102 (   1) (UNIC_NCT) $2107 (   1) (UNIC_NCT)
    $210b (   3) (UNIC_NCT) $2110 (   3) (UNIC_NCT) $2115 (   1) (UNIC_NCT) $2119 (   5) (UNIC_NCT)
    $2124 (   1) (UNIC_NCT) $2126 (   1) (   -7517) $2128 (   1) (UNIC_NCT) $212a (   1) (   -8383)
    $212b (   1) (   -8262) $212c (   2) (UNIC_NCT) $2130 (   2) (UNIC_NCT) $2133 (   1) (UNIC_NCT)
    $213e (   2) (UNIC_NCT) $2145 (   1) (UNIC_NCT) $ff21 (  26) (      32) $0000
;

#ENDIF; ! Large_Unicode_Tables


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Char.i6t: Char Is Of Case
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ CharIsOfCase c case
	i tab min max len par;
	if (c<'A') rfalse;
	if (case == 0) {
		if ((c >= 'a') && (c <= 'z')) rtrue;
		tab = CharCasingChart0;
	} else {
		if ((c >= 'A') && (c <= 'Z')) rtrue;
		tab = CharCasingChart1;
	}
	if (c<128) rfalse;
	while (tab-->i) {
		min = tab-->i; i++;
		len = tab-->i; i++;
		i++;
		par = 0;
		if (len<0) { par = 1; len = -len; }
		if (c < min) rfalse;
		if (c < min+len) {
			if (par) { if ((c-min) % 2 == 0) rtrue; }
			else { rtrue; }
		}
	}
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Char.i6t: Char To Case
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ CharToCase c case
	i tab min max len par del f;
	if (c<'A') return c;
	if (case == 1) {
		if ((c >= 'a') && (c <= 'z')) return c-32;
		tab = CharCasingChart0;
	} else {
		if ((c >= 'A') && (c <= 'Z')) return c+32;
		tab = CharCasingChart1;
	}
	if (c<128) return c;
	while (tab-->i) {
		min = tab-->i; i++;
		len = tab-->i; i++;
		del = tab-->i; i++;
		par = 0;
		if (len<0) { par = 1; len = -len; }
		if (c < min) return c;
		if (c < min+len) {
			f = false;
			if (par) { if ((c-min) % 2 == 0) f = true; }
			else { f = true; }
			if (f) {
				if (del == UNIC_NCT) return c;
				return c+del;
			}
		}
	}
	return c;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Char.i6t: Reversing Case
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#IFDEF TARGET_ZCODE;
[ TEXT_TY_RevCase ch;
	if (ch<'A') return ch;
	if ((ch >= 'a') && (ch <= 'z')) return ch-'a'+'A';
	if ((ch >= 'A') && (ch <= 'Z')) return ch-'A'+'a';
	if (ch<128) return ch;
	if ((ch >= 155) && (ch <= 157)) return ch+3; ! a, o, u umlaut in ZSCII
	if ((ch >= 158) && (ch <= 160)) return ch-3; ! A, O, U umlaut
	if ((ch >= 164) && (ch <= 165)) return ch+3; ! e, i umlaut
	if ((ch >= 167) && (ch <= 168)) return ch-3; ! E, I umlaut
	if ((ch >= 169) && (ch <= 174)) return ch+6; ! a, e, i, o, u, y acute
	if ((ch >= 175) && (ch <= 180)) return ch-6; ! A, E, I, O, U, Y acute
	if ((ch >= 181) && (ch <= 185)) return ch+5; ! a, e, i, o, u grave
	if ((ch >= 186) && (ch <= 190)) return ch-5; ! A, E, I, O, U grave
	if ((ch >= 191) && (ch <= 195)) return ch+5; ! a, e, i, o, u circumflex
	if ((ch >= 196) && (ch <= 200)) return ch-5; ! A, E, I, O, U circumflex
	if (ch == 201) return 202; ! a circle
	if (ch == 202) return 201; ! A circle
	if (ch == 203) return 204; ! o slash
	if (ch == 204) return 203; ! O slash
	if ((ch >= 205) && (ch <= 207)) return ch+3; ! a, n, o tilde
	if ((ch >= 208) && (ch <= 210)) return ch-3; ! A, N, O tilde
	if (ch == 211) return 212; ! ae ligature
	if (ch == 212) return 211; ! AE ligature
	if (ch == 213) return 214; ! c cedilla
	if (ch == 214) return 213; ! C cedilla
	if (ch == 215 or 216) return ch+2; ! thorn, eth
	if (ch == 217 or 218) return ch-2; ! Thorn, Eth
	if (ch == 220) return 221; ! oe ligature
	if (ch == 221) return 220; ! OE ligature
	return ch;
];
#IFNOT;
[ TEXT_TY_RevCase ch;
	if (ch<'A') return ch;
	if ((ch >= 'a') && (ch <= 'z')) return ch-'a'+'A';
	if ((ch >= 'A') && (ch <= 'Z')) return ch-'A'+'a';
	if (ch<128) return ch;
	if (CharIsOfCase(ch, 0)) return CharToCase(ch, 1);
	if (CharIsOfCase(ch, 1)) return CharToCase(ch, 0);
	return ch;
];
#ENDIF;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Char.i6t: Testing
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ CharTestCases case i j;
	for (i=32: i<$E0; i++) {
		if ((i>=127) && (i<155)) continue;
		print i, " - ", (char) i, " -";
		if (CharIsOfCase(i, 0)) print "  lower";
		if (CharIsOfCase(i, 1)) print "  upper";
		j = CharToCase(i, 0); if (j ~= i) print "  tolower: ", (char) j;
		j = CharToCase(i, 1); if (j ~= i) print "  toupper: ", (char) j;
		print "^";
	}
];



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: KOV Support
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_Support task arg1 arg2 arg3;
	switch(task) {
		CREATE_KOVS:      return TEXT_TY_Create(arg2);
		CAST_KOVS:        TEXT_TY_Cast(arg1, arg2, arg3);
		MAKEMUTABLE_KOVS: return TEXT_TY_Mutable(arg1);
		COPYQUICK_KOVS:   rtrue;
		COPYSB_KOVS:	  TEXT_TY_CopySB(arg1, arg2);
		KINDDATA_KOVS:    return 0;
		EXTENT_KOVS:      return TEXT_TY_Extent(arg1);
		COMPARE_KOVS:     return TEXT_TY_Compare(arg1, arg2);
		READ_FILE_KOVS:   if (arg3 == -1) rtrue;
			              return TEXT_TY_ReadFile(arg1, arg2, arg3);
		WRITE_FILE_KOVS:  return TEXT_TY_WriteFile(arg1);
		HASH_KOVS:        return TEXT_TY_Hash(arg1);
		DEBUG_KOVS:       TEXT_TY_Debug(arg1);
	}
	! We choose not to respond to: DESTROY_KOVS, COPYKIND_KOVS, COPY_KOVS
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Debugging
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_Debug txt;
	switch (txt-->0) {
		CONSTANT_PACKED_TEXT_STORAGE:     print " = cp~", (PrintI6Text) txt-->1, "~";
		CONSTANT_PERISHABLE_TEXT_STORAGE: print " = cp~", (PrintI6Text) txt-->1, "~";
		PACKED_TEXT_STORAGE:              print " = p~", (PrintI6Text) txt-->1, "~";
		UNPACKED_TEXT_STORAGE:            print " = ~", (TEXT_TY_Say) txt, "~";
		default:                          print " broken?";
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Creation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_Create short_block x;
	return BlkValueCreateSB2(short_block, PACKED_TEXT_STORAGE, EMPTY_TEXT_PACKED);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Copy Short Block
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_CopySB to_bv from_bv;
	BlkValueCopySB2(to_bv, from_bv);
	if (to_bv-->0 & BLK_BVBITMAP_CONSTANTMASK) to_bv-->0 = PACKED_TEXT_STORAGE;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Transmutation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_Transmute txt;
	TEXT_TY_Temporarily_Transmute(txt);
];

[ TEXT_TY_Temporarily_Transmute txt  x;
	if ((txt) && (txt-->0 & BLK_BVBITMAP_LONGBLOCKMASK == 0)) {
		x = txt-->1; ! The old value was a packed string
		
		txt-->0 = UNPACKED_TEXT_STORAGE;
		txt-->1 = FlexAllocate(32, TEXT_TY, TEXT_TY_Storage_Flags);
		if (x ~= EMPTY_TEXT_PACKED) TEXT_TY_CastPrimitive(txt, false, x);
		
		return x;
	}
	return 0;
];

[ TEXT_TY_Untransmute txt pk cp x;
	if ((pk) && (txt-->0 == UNPACKED_TEXT_STORAGE)) {
		x = txt-->1; ! The old value was an unpacked string
		FlexFree(x);
		txt-->0 = cp;
		txt-->1 = pk; ! The value earlier returned by TEXT_TY_Temporarily_Transmute
	}
	return txt;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Mutability
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_Mutable txt;
	if (txt-->0 & BLK_BVBITMAP_LONGBLOCKMASK == 0) {
		TEXT_TY_Transmute(txt);
		return 0;
	}
	return 2; ! Tell BlockValue there's a long block pointer
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Casting
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_Cast to_txt from_kind from_value;
	if (from_kind == TEXT_TY) {
		BlkValueCopy(to_txt, from_value);
	} else if (from_kind == SNIPPET_TY) {
		TEXT_TY_Transmute(to_txt);
		TEXT_TY_CastPrimitive(to_txt, true, from_value);
	} else BlkValueError("impossible cast to text");
];

[ SNIPPET_TY_to_TEXT_TY to_txt snippet;
	return BlkValueCast(to_txt, SNIPPET_TY, snippet);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Data Conversion
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#ifndef TEXT_TY_BufferSize;
Constant TEXT_TY_BufferSize = 512;
#endif;
Constant TEXT_TY_NoBuffers = 2;

#ifdef TARGET_ZCODE;
Array TEXT_TY_Buffers -> TEXT_TY_BufferSize*TEXT_TY_NoBuffers; ! Where characters are bytes
#ifnot;
Array TEXT_TY_Buffers --> (TEXT_TY_BufferSize+2)*TEXT_TY_NoBuffers; ! Where characters are words
#endif;

Global RawBufferAddress = TEXT_TY_Buffers;
Global RawBufferSize = TEXT_TY_BufferSize;

Global TEXT_TY_CastPrimitiveNesting = 0;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Z Version
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#ifdef TARGET_ZCODE;
[ TEXT_TY_CastPrimitive to_txt from_snippet from_value  len news buffer;
	if (to_txt == 0) BlkValueError("no destination for cast");
	SuspendRTP();
	buffer = RawBufferAddress + TEXT_TY_CastPrimitiveNesting*TEXT_TY_BufferSize;
	TEXT_TY_CastPrimitiveNesting++;
	if (TEXT_TY_CastPrimitiveNesting > TEXT_TY_NoBuffers)
		FlexError("ran out with too many simultaneous text conversions");

	@push say__p; @push say__pc;
	ClearParagraphing(6);
	@output_stream 3 buffer;
	if (from_value) {
		if (from_snippet) print (PrintSnippet) from_value;
		else print (PrintI6Text) from_value;
	}
	@output_stream -3;
	@pull say__pc; @pull say__p;
	ResumeRTP();

	len = buffer-->0;
	if (len > RawBufferSize-1) len = RawBufferSize-1;
	buffer->(len+2) = 0;

	TEXT_TY_CastPrimitiveNesting--;
	BlkValueMassCopyFromArray(to_txt, buffer+2, 1, len+1);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Glulx Version
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#ifnot; ! TARGET_ZCODE
[ TEXT_TY_CastPrimitive to_txt from_snippet from_value
	len i stream saved_stream news buffer buffer_size memory_to_free results;

	if (to_txt == 0) BlkValueError("no destination for cast");

	buffer_size = (TEXT_TY_BufferSize + 2)*WORDSIZE;
	
	RawBufferSize = TEXT_TY_BufferSize;
	buffer = RawBufferAddress + TEXT_TY_CastPrimitiveNesting*buffer_size;
	TEXT_TY_CastPrimitiveNesting++;
	if (TEXT_TY_CastPrimitiveNesting > TEXT_TY_NoBuffers) {
		buffer = VM_AllocateMemory(buffer_size); memory_to_free = buffer;
		if (buffer == 0)
			FlexError("ran out with too many simultaneous text conversions");
	}

	if (unicode_gestalt_ok) {
		SuspendRTP();
		.RetryWithLargerBuffer;
		saved_stream = glk_stream_get_current();
		stream = glk_stream_open_memory_uni(buffer, RawBufferSize, filemode_Write, 0);
		glk_stream_set_current(stream);

		@push say__p; @push say__pc;
		ClearParagraphing(7);
		if (from_snippet) print (PrintSnippet) from_value;
		else print (PrintI6Text) from_value;
		@pull say__pc; @pull say__p;

		results = buffer + buffer_size - 2*WORDSIZE;
		glk_stream_close(stream, results);
		if (saved_stream) glk_stream_set_current(saved_stream);
		ResumeRTP();

		len = results-->1;
		if (len > RawBufferSize-1) {
			! Glulx had to truncate text output because the buffer ran out:
			! len is the number of characters which it tried to print
			news = RawBufferSize;
			while (news < len) news=news*2;
			i = VM_AllocateMemory(news*WORDSIZE);
			if (i ~= 0) {
				if (memory_to_free) VM_FreeMemory(memory_to_free);
				memory_to_free = i;
				buffer = i;
				RawBufferSize = news;
				buffer_size = (RawBufferSize + 2)*WORDSIZE;
				jump RetryWithLargerBuffer;
			}
			! Memory allocation refused: all we can do is to truncate the text
			len = RawBufferSize-1;
		}
		buffer-->(len) = 0;

		TEXT_TY_CastPrimitiveNesting--;
		BlkValueMassCopyFromArray(to_txt, buffer, 4, len+1);
	} else {
		RunTimeProblem(RTP_NOGLULXUNICODE);
	}
	if (memory_to_free) VM_FreeMemory(memory_to_free);
];
#endif; 


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Comparison
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_Compare left_txt right_txt rv;
	@push say__comp;
	say__comp = true;
	rv = TEXT_TY_Compare_Inner(left_txt, right_txt);
	@pull say__comp;
	return rv;
];

[ TEXT_TY_Compare_Inner left_txt right_txt
	pos ch1 ch2 capacity_left capacity_right fl fr cl cr cpl cpr;
	if (left_txt-->0 & BLK_BVBITMAP_LONGBLOCKMASK == 0) fl = true;
	if (right_txt-->0 & BLK_BVBITMAP_LONGBLOCKMASK == 0) fr = true;

	if (fl && fr) {
		if ((left_txt-->1 ofclass String) && (right_txt-->1 ofclass String))
			return left_txt-->1 - right_txt-->1;
		if ((left_txt-->1 ofclass Routine) && (right_txt-->1 ofclass Routine))
			return left_txt-->1 - right_txt-->1;
		cpl = left_txt-->0; cl = TEXT_TY_Temporarily_Transmute(left_txt);
		cpr = right_txt-->0; cr = TEXT_TY_Temporarily_Transmute(right_txt);		
	} else if (fl) {
		cpl = left_txt-->0; cl = TEXT_TY_Temporarily_Transmute(left_txt);
	} else if (fr) {
		cpr = right_txt-->0; cr = TEXT_TY_Temporarily_Transmute(right_txt);
	}
	if ((cl) || (cr)) {
		pos = TEXT_TY_Compare(left_txt, right_txt);
		TEXT_TY_Untransmute(left_txt, cl, cpl);
		TEXT_TY_Untransmute(right_txt, cr, cpr);
		return pos;
	}
	capacity_left = BlkValueLBCapacity(left_txt);
	capacity_right = BlkValueLBCapacity(right_txt);
	for (pos=0:(pos<capacity_left) && (pos<capacity_right):pos++) {
		ch1 = BlkValueRead(left_txt, pos);
		ch2 = BlkValueRead(right_txt, pos);
		if (ch1 ~= ch2) return ch1-ch2;
		if (ch1 == 0) return 0;
	}
	if (pos == capacity_left) return -1;
	return 1;
];

[ TEXT_TY_Distinguish left_txt right_txt;
	if (TEXT_TY_Compare(left_txt, right_txt) == 0) rfalse;
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Hashing
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_Hash txt  rv len i p cp;
	cp = txt-->0; p = TEXT_TY_Temporarily_Transmute(txt);
	rv = 0;
	len = BlkValueLBCapacity(txt);
	for (i=0: i<len: i++)
		rv = rv * 33 + BlkValueRead(txt, i);
	TEXT_TY_Untransmute(txt, p, cp);
	return rv;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Printing
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_Say txt  ch i dsize;
	if (txt==0) rfalse;
	if (txt-->0 & BLK_BVBITMAP_LONGBLOCKMASK == 0) return PrintI6Text(txt-->1);
	dsize = BlkValueLBCapacity(txt);
	for (i=0: i<dsize: i++) {
		ch = BlkValueRead(txt, i);
		if (ch == 0) break;
		#ifdef TARGET_ZCODE;
		print (char) ch;
		#ifnot; ! TARGET_ZCODE
		@streamunichar ch;
		#endif;
	}
	if (i == 0) rfalse;
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Capitalised printing
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_Say_Capitalised txt mod rc;
	mod = BlkValueCreate(TEXT_TY);
	TEXT_TY_SubstitutedForm(mod, txt);
	if (TEXT_TY_CharacterLength(mod) > 0) {
		BlkValueWrite(mod, 0, CharToCase(BlkValueRead(mod, 0), 1));
		TEXT_TY_Say(mod);
		rc = true;
		say__p = 1;
	}
	BlkValueFree(mod);
	return rc;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Serialisation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_WriteFile txt len pos ch p cp;
	cp = txt-->0; p = TEXT_TY_Temporarily_Transmute(txt);
	len = BlkValueLBCapacity(txt);
	print "S";
	for (pos=0: pos<=len: pos++) {
		if (pos == len) ch = 0; else ch = BlkValueRead(txt, pos);
		if (ch == 0) {
			print "0;"; break;
		} else {
			print ch, ",";
		}
	}
	TEXT_TY_Untransmute(txt, p, cp);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Unserialisation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_ReadFile txt auxf ch i v dg pos tsize p;
	TEXT_TY_Transmute(txt);
	tsize = BlkValueLBCapacity(txt);
	while (ch ~= 32 or 9 or 10 or 13 or 0 or -1) {
		ch = FileIO_GetC(auxf);
		if (ch == ',' or ';') {
			if (pos+1 >= tsize) {
				if (BlkValueSetLBCapacity(txt, 2*pos) == false) break;
				tsize = BlkValueLBCapacity(txt);
			}
			BlkValueWrite(txt, pos++, v);
			v = 0;
			if (ch == ';') break;
		} else {
			dg = ch - '0';
			v = v*10 + dg;
		}
	}
	BlkValueWrite(txt, pos, 0);
	return txt;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Substitution
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_SubstitutedForm to txt;
	if (txt) {
		BlkValueCopy(to, txt);
		TEXT_TY_Transmute(to);
	}
	return to;
];

[ TEXT_TY_IsSubstituted txt;
	if ((txt) &&
		(txt-->0 & BLK_BVBITMAP_LONGBLOCKMASK == 0) &&
		(txt-->1 ofclass Routine)) rfalse;
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Perishability
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_ExpandIfPerishable to from;
	if ((from) && (from-->0 == CONSTANT_PERISHABLE_TEXT_STORAGE))
		return TEXT_TY_SubstitutedForm(to, from);
	return from;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Recognition-only-GPR
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_ROGPR txt p cp r;
	if (txt == 0) return GPR_FAIL;
	cp = txt-->0; p = TEXT_TY_Temporarily_Transmute(txt);
	r = TEXT_TY_ROGPRI(txt);
	TEXT_TY_Untransmute(txt, p, cp);
	return r;
];
[ TEXT_TY_ROGPRI txt
	pos len wa wl wpos bdm ch own;
	bdm = true; own = wn;
	len = BlkValueLBCapacity(txt);
	for (pos=0: pos<=len: pos++) {
		if (pos == len) ch = 0; else ch = BlkValueRead(txt, pos);
		if (ch == 32 or 9 or 10 or 0) {
			if (bdm) continue;
			bdm = true;
			if (wpos ~= wl) return GPR_FAIL;
			if (ch == 0) break;
		} else {
			if (bdm) {
				bdm = false;
				if (NextWordStopped() == -1) return GPR_FAIL;
				wa = WordAddress(wn-1);
				wl = WordLength(wn-1);
				wpos = 0;
			}
			if (wa->wpos ~= ch or TEXT_TY_RevCase(ch)) return GPR_FAIL;
			wpos++;
		}
	}
	if (wn == own) return GPR_FAIL; ! Progress must be made to avoid looping
	return GPR_PREPOSITION;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Blobs
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant CHR_BLOB = 1; ! Construe as an array of characters
Constant WORD_BLOB = 2; ! Of words
Constant PWORD_BLOB = 3; ! Of punctuated words
Constant UWORD_BLOB = 4; ! Of unpunctuated words
Constant PARA_BLOB = 5; ! Of paragraphs
Constant LINE_BLOB = 6; ! Of lines

Constant REGEXP_BLOB = 7; ! Not a blob type as such, but needed as a distinct value


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Blob Access
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant WS_BRM = 1;
Constant SKIPPED_BRM = 2;
Constant ACCEPTED_BRM = 3;
Constant ACCEPTEDP_BRM = 4;
Constant ACCEPTEDN_BRM = 5;
Constant ACCEPTEDPN_BRM = 6;

[ TEXT_TY_BlobAccess txt blobtype ctxt wanted rtxt
	p1 p2 cp1 cp2 r;
	if (txt==0) return 0;
	if (blobtype == CHR_BLOB) return TEXT_TY_CharacterLength(txt);
	cp1 = txt-->0; p1 = TEXT_TY_Temporarily_Transmute(txt);
	cp2 = rtxt-->0; p2 = TEXT_TY_Temporarily_Transmute(rtxt);
	TEXT_TY_Transmute(ctxt);
	r = TEXT_TY_BlobAccessI(txt, blobtype, ctxt, wanted, rtxt);
	TEXT_TY_Untransmute(txt, p1, cp1);
	TEXT_TY_Untransmute(rtxt, p2, cp2);
	return r;
];
[ TEXT_TY_BlobAccessI txt blobtype ctxt wanted rtxt
	brm oldbrm ch i dsize csize blobcount gp cl j;
	dsize = BlkValueLBCapacity(txt);
	if (ctxt) csize = BlkValueLBCapacity(ctxt);
	else if (rtxt) "*** rtxt without ctxt ***";
	brm = WS_BRM;
	for (i=0:i<dsize:i++) {
		ch = BlkValueRead(txt, i);
		if (ch == 0) break;
		oldbrm = brm;
		if (ch == 10 or 13 or 32 or 9) {
			if (oldbrm ~= WS_BRM) {
				gp = 0;
				for (j=i:j<dsize:j++) {
					ch = BlkValueRead(txt, j);
					if (ch == 0) { brm = WS_BRM; break; }
					if (ch == 10 or 13) { gp++; continue; }
					if (ch ~= 32 or 9) break;
				}
				ch = BlkValueRead(txt, i);
				if (j == dsize) brm = WS_BRM;
				switch (blobtype) {
					PARA_BLOB: if (gp >= 2) brm = WS_BRM;
					LINE_BLOB: if (gp >= 1) brm = WS_BRM;
					default: brm = WS_BRM;
				}
			}
		} else {
			gp = false;
			if ((blobtype == WORD_BLOB or PWORD_BLOB or UWORD_BLOB) &&
				(ch == '.' or ',' or '!' or '?'
						or '-' or '/' or '"' or ':' or ';'
						or '(' or ')' or '[' or ']' or '{' or '}'))
				gp = true;
			switch (oldbrm) {
				WS_BRM:
					brm = ACCEPTED_BRM;
					if (blobtype == WORD_BLOB) {
						if (gp) brm = SKIPPED_BRM;
					}
					if (blobtype == PWORD_BLOB) {
						if (gp) brm = ACCEPTEDP_BRM;
					}
				SKIPPED_BRM:
					if (blobtype == WORD_BLOB) {
						if (gp == false) brm = ACCEPTED_BRM;
					}
				ACCEPTED_BRM:
					if (blobtype == WORD_BLOB) {
						if (gp) brm = SKIPPED_BRM;
					}
					if (blobtype == PWORD_BLOB) {
						if (gp) brm = ACCEPTEDP_BRM;
					}
				ACCEPTEDP_BRM:
					if (blobtype == PWORD_BLOB) {
						if (gp == false) brm = ACCEPTED_BRM;
						else {
							if ((ch == BlkValueRead(txt, i-1)) &&
								(ch == '-' or '.')) blobcount--;
							blobcount++;
						}
					}
				ACCEPTEDN_BRM:
					if (blobtype == WORD_BLOB) {
						if (gp) brm = SKIPPED_BRM;
					}
					if (blobtype == PWORD_BLOB) {
						if (gp) brm = ACCEPTEDP_BRM;
					}
				ACCEPTEDPN_BRM:
					if (blobtype == PWORD_BLOB) {
						if (gp == false) brm = ACCEPTED_BRM;
						else {
							if ((ch == BlkValueRead(txt, i-1)) &&
								(ch == '-' or '.')) blobcount--;
							blobcount++;
						}
					}
			}
		}
		if (brm == ACCEPTED_BRM or ACCEPTEDP_BRM) {
			if (oldbrm ~= brm) blobcount++;
			if ((ctxt) && (blobcount == wanted)) {
				if (rtxt) {
					BlkValueWrite(ctxt, cl, 0);
					TEXT_TY_Concatenate(ctxt, rtxt, CHR_BLOB);
					csize = BlkValueLBCapacity(ctxt);
					cl = TEXT_TY_CharacterLength(ctxt);
					if (brm == ACCEPTED_BRM) brm = ACCEPTEDN_BRM;
					if (brm == ACCEPTEDP_BRM) brm = ACCEPTEDPN_BRM;
				} else {
					if (cl+1 >= csize) {
						if (BlkValueSetLBCapacity(ctxt, 2*cl) == false) break;
						csize = BlkValueLBCapacity(ctxt);
					}
					BlkValueWrite(ctxt, cl++, ch);
				}
			} else {
				if (rtxt) {
					if (cl+1 >= csize) {
						if (BlkValueSetLBCapacity(ctxt, 2*cl) == false) break;
						csize = BlkValueLBCapacity(ctxt);
					}
					BlkValueWrite(ctxt, cl++, ch);
				}
			}
		} else {
			if ((rtxt) && (brm ~= ACCEPTEDN_BRM or ACCEPTEDPN_BRM)) {
				if (cl+1 >= csize) {
					if (BlkValueSetLBCapacity(ctxt, 2*cl) == false) break;
					csize = BlkValueLBCapacity(ctxt);
				}
				BlkValueWrite(ctxt, cl++, ch);
			}
		}
	}
	if (ctxt) BlkValueWrite(ctxt, cl++, 0);
	return blobcount;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Get Blob
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_GetBlob ctxt txt wanted blobtype;
	if (txt==0) return;
	if (blobtype == CHR_BLOB) return TEXT_TY_GetCharacter(ctxt, txt, wanted);
	TEXT_TY_BlobAccess(txt, blobtype, ctxt, wanted);
	return ctxt;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Replace Blob
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_ReplaceBlob blobtype txt wanted rtxt ctxt ilen rlen i p cp;
	TEXT_TY_Transmute(txt);
	cp = rtxt-->0; p = TEXT_TY_Temporarily_Transmute(rtxt);
	if (blobtype == CHR_BLOB) {
		ilen = TEXT_TY_CharacterLength(txt);
		rlen = TEXT_TY_CharacterLength(rtxt);
		wanted--;
		if ((wanted >= 0) && (wanted<ilen)) {
			if (rlen == 1) {
				BlkValueWrite(txt, wanted, BlkValueRead(rtxt, 0));
			} else {
				ctxt = BlkValueCreate(TEXT_TY);
				TEXT_TY_Transmute(ctxt);
				if (BlkValueSetLBCapacity(ctxt, ilen+rlen+1)) {
					for (i=0:i<wanted:i++)
						BlkValueWrite(ctxt, i, BlkValueRead(txt, i));
					for (i=0:i<rlen:i++)
						BlkValueWrite(ctxt, wanted+i, BlkValueRead(rtxt, i));
					for (i=wanted+1:i<ilen:i++)
						BlkValueWrite(ctxt, rlen+i-1, BlkValueRead(txt, i));
					BlkValueWrite(ctxt, rlen+ilen, 0);
					BlkValueCopy(txt, ctxt);
				}
				BlkValueFree(ctxt);
			}
		}
	} else {
		ctxt = BlkValueCreate(TEXT_TY);
		TEXT_TY_BlobAccess(txt, blobtype, ctxt, wanted, rtxt);
		BlkValueCopy(txt, ctxt);
		BlkValueFree(ctxt);
	}
	TEXT_TY_Untransmute(rtxt, p, cp);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Replace Text
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_ReplaceText blobtype txt ftxt rtxt
	r p1 p2 cp1 cp2;
	TEXT_TY_Transmute(txt);
	cp1 = ftxt-->0; p1 = TEXT_TY_Temporarily_Transmute(ftxt);
	cp2 = rtxt-->0; p2 = TEXT_TY_Temporarily_Transmute(rtxt);
	r = TEXT_TY_ReplaceTextI(blobtype, txt, ftxt, rtxt);
	TEXT_TY_Untransmute(ftxt, p1, cp1);
	TEXT_TY_Untransmute(rtxt, p2, cp2);
	return r;
];

[ TEXT_TY_ReplaceTextI blobtype txt ftxt rtxt
	ctxt csize ilen flen i cl mpos ch chm whitespace punctuation;
	if (blobtype == REGEXP_BLOB or CHR_BLOB) 
		return TEXT_TY_Replace_RE(blobtype, txt, ftxt, rtxt);
	
	ilen = TEXT_TY_CharacterLength(txt);
	flen = TEXT_TY_CharacterLength(ftxt);
	ctxt = BlkValueCreate(TEXT_TY);
	TEXT_TY_Transmute(ctxt);
	csize = BlkValueLBCapacity(ctxt);
	mpos = 0;

	whitespace = true; punctuation = false;
	for (i=0:i<=ilen:i++) {
		ch = BlkValueRead(txt, i);
		.MoreMatching;
		chm = BlkValueRead(ftxt, mpos++);
		if (mpos == 1) {
			switch (blobtype) {
				WORD_BLOB:
					if ((whitespace == false) && (punctuation == false)) chm = -1;
			}
		}
		whitespace = false;
		if (ch == 10 or 13 or 32 or 9) whitespace = true;
		punctuation = false;
		if (ch == '.' or ',' or '!' or '?'
			or '-' or '/' or '"' or ':' or ';'
			or '(' or ')' or '[' or ']' or '{' or '}') {
			if (blobtype == WORD_BLOB) chm = -1;
			punctuation = true;
		}
		if (ch == chm) {
			if (mpos == flen) {
				if (i == ilen) chm = 0;
				else chm = BlkValueRead(txt, i+1);
				if ((blobtype == CHR_BLOB) ||
					(chm == 0 or 10 or 13 or 32 or 9) ||
					(chm == '.' or ',' or '!' or '?'
						or '-' or '/' or '"' or ':' or ';'
						or '(' or ')' or '[' or ']' or '{' or '}')) {
					mpos = 0;
					cl = cl - (flen-1);
					BlkValueWrite(ctxt, cl, 0);
					TEXT_TY_Concatenate(ctxt, rtxt, CHR_BLOB);
					csize = BlkValueLBCapacity(ctxt);
					cl = TEXT_TY_CharacterLength(ctxt);
					continue;
				}
			}
		} else {
			mpos = 0;
		}
		if (cl+1 >= csize) {
			if (BlkValueSetLBCapacity(ctxt, 2*cl) == false) break;
			csize = BlkValueLBCapacity(ctxt);
		}
		BlkValueWrite(ctxt, cl++, ch);
	}
	BlkValueCopy(txt, ctxt);	
	BlkValueFree(ctxt);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Character Length
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_CharacterLength txt ch i dsize p cp r;
	if (txt==0) return 0;
	cp = txt-->0; p = TEXT_TY_Temporarily_Transmute(txt);
	dsize = BlkValueLBCapacity(txt); r = dsize;
	for (i=0:i<dsize:i++) {
		ch = BlkValueRead(txt, i);
		if (ch == 0) { r = i; break; }
	}
	TEXT_TY_Untransmute(txt, p, cp);
	return r;
];

[ TEXT_TY_Empty txt;
	if (txt==0) rtrue;
	if (txt-->0 & BLK_BVBITMAP_LONGBLOCKMASK == 0) {
		if (txt-->1 == EMPTY_TEXT_PACKED) rtrue;
		rfalse;
	}
	if (TEXT_TY_CharacterLength(txt) == 0) rtrue;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Get Character
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_GetCharacter ctxt txt i ch p cp;
	if (txt==0) return 0;
	cp = txt-->0; p = TEXT_TY_Temporarily_Transmute(txt);
	TEXT_TY_Transmute(ctxt);
	if ((i<=0) || (i>TEXT_TY_CharacterLength(txt))) ch = 0;
	else ch = BlkValueRead(txt, i-1);
	BlkValueWrite(ctxt, 0, ch);
	BlkValueWrite(ctxt, 1, 0);
	TEXT_TY_Untransmute(txt, p, cp);
	return ctxt;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Casing
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_CharactersOfCase txt case i ch len p cp r;
	if (txt==0) return 0;
	cp = txt-->0; p = TEXT_TY_Temporarily_Transmute(txt);
	len = TEXT_TY_CharacterLength(txt);
	r = true;
	for (i=0:i<len:i++) {
		ch = BlkValueRead(txt, i);
		if ((ch) && (CharIsOfCase(ch, case) == false)) { r = false; break; }
	}
	TEXT_TY_Untransmute(txt, p, cp);
	return r;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Change Case
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_CharactersToCase ctxt txt case i ch len bnd pk cp;
	if (txt==0) return 0;
	cp = txt-->0; pk = TEXT_TY_Temporarily_Transmute(txt);
	TEXT_TY_Transmute(ctxt);
	len = TEXT_TY_CharacterLength(txt);
	if (BlkValueSetLBCapacity(ctxt, len+1)) {
		bnd = 1;
		for (i=0:i<len:i++) {
			ch = BlkValueRead(txt, i);
			if (case < 2) {
				BlkValueWrite(ctxt, i, CharToCase(ch, case));
			} else {
				BlkValueWrite(ctxt, i, CharToCase(ch, bnd));
				if (case == 2) {
					bnd = 0;
					if (ch == 0 or 10 or 13 or 32 or 9
						or '.' or ',' or '!' or '?'
						or '-' or '/' or '"' or ':' or ';'
						or '(' or ')' or '[' or ']' or '{' or '}') bnd = 1;
				}
				if (case == 3) {
					if (ch ~= 0 or 10 or 13 or 32 or 9) {
						if (bnd == 1) bnd = 0;
						else {
							if (ch == '.' or '!' or '?') bnd = 1;
						}
					}
				}
			}
		}
		BlkValueWrite(ctxt, len, 0);
	}
	TEXT_TY_Untransmute(txt, pk, cp);
	return ctxt;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Concatenation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_Concatenate to_txt from_txt blobtype ref_txt
	p cp r;
	if (to_txt==0) rfalse;
	if (from_txt==0) return to_txt;
	TEXT_TY_Transmute(to_txt);
	cp = from_txt-->0; p = TEXT_TY_Temporarily_Transmute(from_txt);
	r = TEXT_TY_ConcatenateI(to_txt, from_txt, blobtype, ref_txt);
	TEXT_TY_Untransmute(from_txt, p, cp);
	return r;
];

[ TEXT_TY_ConcatenateI to_txt from_txt blobtype ref_txt
	pos len ch i tosize x y case;
	switch(blobtype) {
		CHR_BLOB, 0:
			pos = TEXT_TY_CharacterLength(to_txt);
			len = TEXT_TY_CharacterLength(from_txt);
			if (BlkValueSetLBCapacity(to_txt, pos+len+1) == false) return to_txt;
			for (i=0:i<len:i++) {
				ch = BlkValueRead(from_txt, i);
				BlkValueWrite(to_txt, i+pos, ch);
			}
			BlkValueWrite(to_txt, len+pos, 0);
			return to_txt;
		REGEXP_BLOB:
			return TEXT_TY_RE_Concatenate(to_txt, from_txt, blobtype, ref_txt);
	}
	print "*** TEXT_TY_Concatenate used on impossible blob type ***^";
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Setting the Player's Command
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SetPlayersCommand from_txt i len at p cp;
	cp = from_txt-->0; p = TEXT_TY_Temporarily_Transmute(from_txt);
	len = TEXT_TY_CharacterLength(from_txt);
	if (len > 118) len = 118;
	#ifdef TARGET_ZCODE;
	buffer->1 = len; at = 2;
	#ifnot;
	buffer-->0 = len; at = 4;
	#endif;
	for (i=0:i<len:i++) buffer->(i+at) = CharToCase(BlkValueRead(from_txt, i), 0);
	for (:at+i<120:i++) buffer->(at+i) = ' ';
	VM_Tokenise(buffer, parse);
	players_command = 100 + WordCount(); ! The snippet variable "player's command"
	TEXT_TY_Untransmute(from_txt, p, cp);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RegExp.i6t: Debugging
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Global TEXT_TY_RE_Trace = false; ! Change to true for (a lot of) debugging data in use
[ TEXT_TY_RE_SetTrace F; TEXT_TY_RE_Trace = F; ];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RegExp.i6t: Algorithm
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RegExp.i6t: Class Codes
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

! Character classes

Constant NEWLINE_RE_CC = -1;
Constant TAB_RE_CC = -2;
Constant DIGIT_RE_CC = -3;
Constant NONDIGIT_RE_CC = -4;
Constant WHITESPACE_RE_CC = -5;
Constant NONWHITESPACE_RE_CC = -6;
Constant PUNCTUATION_RE_CC = -7;
Constant NONPUNCTUATION_RE_CC = -8;
Constant WORD_RE_CC = -9;
Constant NONWORD_RE_CC = -10;
Constant ANYTHING_RE_CC = -11;
Constant NOTHING_RE_CC = -12;
Constant RANGE_RE_CC = -13;
Constant LCASE_RE_CC = -14;
Constant NONLCASE_RE_CC = -15;
Constant UCASE_RE_CC = -16;
Constant NONUCASE_RE_CC = -17;

! Control structures

Constant SUBEXP_RE_CC = -20;
Constant DISJUNCTION_RE_CC = -21;
Constant CHOICE_RE_CC = -22;
Constant QUANTIFIER_RE_CC = -23;
Constant IF_RE_CC = -24;
Constant CONDITION_RE_CC = -25;
Constant THEN_RE_CC = -26;
Constant ELSE_RE_CC = -27;

! Substring matchers

Constant VARIABLE_RE_CC = -30;
Constant LITERAL_RE_CC = -31;

! Positional matchers

Constant START_RE_CC = -40;
Constant END_RE_CC = -41;
Constant BOUNDARY_RE_CC = -42;
Constant NONBOUNDARY_RE_CC = -43;
Constant ALWAYS_RE_CC = -44;
Constant NEVER_RE_CC = -45;

! Mode switches

Constant SENSITIVITY_RE_CC = -50;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RegExp.i6t: Packets
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant RE_MAX_PACKETS = 32;

Constant RE_PACKET_SIZE = 14; ! Words of memory used per packet
Constant RE_PACKET_SIZE_IN_BYTES = WORDSIZE*RE_PACKET_SIZE; ! Bytes used per packet

Array RE_PACKET_space --> RE_MAX_PACKETS*RE_PACKET_SIZE;

Constant RE_CCLASS = 0;      ! One of the class codes defined above
Constant RE_PAR1 = 1;        ! Three parameters whose meaning depends on class code
Constant RE_PAR2 = 2;
Constant RE_PAR3 = 3;
Constant RE_NEXT = 4;        ! Younger sibling in the compiled tree
Constant RE_PREVIOUS = 5;    ! Elder sibling
Constant RE_DOWN = 6;        ! Child
Constant RE_UP = 7;          ! Parent
Constant RE_DATA1 = 8;       ! Backtracking data
Constant RE_DATA2 = 9;
Constant RE_CONSTRAINT = 10;
Constant RE_CACHE1 = 11;
Constant RE_CACHE2 = 12;
Constant RE_MODES = 13;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RegExp.i6t: Nodes
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_RE_Node n cc par1 par2 par3  offset;
	if ((n<0) || (n >= RE_MAX_PACKETS)) rfalse;
	offset = RE_PACKET_space + n*RE_PACKET_SIZE_IN_BYTES;
	offset-->RE_CCLASS = cc;
	offset-->RE_PAR1 = par1;
	offset-->RE_PAR2 = par2;
	offset-->RE_PAR3 = par3;
	offset-->RE_NEXT = NULL;
	offset-->RE_PREVIOUS = NULL;
	offset-->RE_DOWN = NULL;
	offset-->RE_UP = NULL;
	offset-->RE_DATA1 = -1; ! Match start
	offset-->RE_DATA2 = -1; ! Match end
	offset-->RE_CONSTRAINT = -1; ! Rewind edge
	return offset;
];

[ TEXT_TY_RE_NodeAddress n;
	if ((n<0) || (n >= RE_MAX_PACKETS)) return -1;
	return RE_PACKET_space + n*RE_PACKET_SIZE_IN_BYTES;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RegExp.i6t: Match Variables
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Array RE_Subexpressions --> 11; ! Address of node for this subexpression
Array Allocated_Match_Vars --> 10; ! Indexed text to hold values of the variables

[ TEXT_TY_RE_DebugMatchVars txt
	offset n i;
	print RE_Subexpressions-->10, " collecting subexps^";
	for (n=0:(n<RE_Subexpressions-->10) && (n<10): n++) {
		offset = RE_Subexpressions-->n;
		print "Subexp ", offset-->RE_PAR1,
			" = [", offset-->RE_DATA1, ",", offset-->RE_DATA2, "] = ";
		for (i=offset-->RE_DATA1:i<offset-->RE_DATA2:i++)
			print (char) BlkValueRead(txt, i);
		print "^";
	}
];

[ TEXT_TY_RE_CreateMatchVars txt
	offset n i ch ctxt cl csize;
	for (n=0:(n<RE_Subexpressions-->10) && (n<10): n++) {
		offset = RE_Subexpressions-->n;
		if (Allocated_Match_Vars-->n) BlkValueFree(Allocated_Match_Vars-->n);
		Allocated_Match_Vars-->n = BlkValueCreate(TEXT_TY);
		TEXT_TY_Transmute(Allocated_Match_Vars-->n);
		ctxt = Allocated_Match_Vars-->n;
		csize = BlkValueLBCapacity(ctxt);
		cl = 0;
		for (i=offset-->RE_DATA1:i<offset-->RE_DATA2:i++) {
			ch = BlkValueRead(txt, i);
			if (cl+1 >= csize) {
				if (BlkValueSetLBCapacity(ctxt, 2*cl) == false) break;
				csize = BlkValueLBCapacity(ctxt);
			}
			BlkValueWrite(ctxt, cl++, ch);
		}
		BlkValueWrite(ctxt, cl, 0);
	}
];

[ TEXT_TY_RE_EmptyMatchVars txt
	n;
	for (n=0:(n<RE_Subexpressions-->10) && (n<10): n++)
		if (Allocated_Match_Vars-->n ~= 0)
			BlkValueWrite(Allocated_Match_Vars-->n, 0, 0);
];

[ TEXT_TY_RE_GetMatchVar vn
	offset;
	if ((vn<0) || (vn>=10) || (vn >= RE_Subexpressions-->10)) return EMPTY_TEXT_VALUE;
	offset = RE_Subexpressions-->vn;
	if (offset == 0) return EMPTY_TEXT_VALUE;
	if (offset-->RE_DATA1 < 0) return EMPTY_TEXT_VALUE;
	if (Allocated_Match_Vars-->vn == 0) {
		print "*** ", vn, " unallocated! ***^";
		return EMPTY_TEXT_VALUE;
	}
	return Allocated_Match_Vars-->vn;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RegExp.i6t: Markers
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_MV_End n end
	offset;
	offset = RE_Subexpressions-->n;
	if (end==0) return offset-->RE_DATA1;
	return offset-->RE_DATA2;
];

[ TEXT_TY_RE_Clear_Markers token;
	for (: token ~= NULL: token = token-->RE_NEXT) {
		if (token-->RE_DOWN ~= NULL) TEXT_TY_RE_Clear_Markers(token-->RE_DOWN);
		token-->RE_DATA1 = -1;
		token-->RE_DATA2 = -1;
		token-->RE_CONSTRAINT = -1;
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RegExp.i6t: Debugging
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_RE_DebugTree ftxt detail;
	print "Pattern: ", (TEXT_TY_Say) ftxt, "^";
	TEXT_TY_RE_DebugSubtree(ftxt, 1, RE_PACKET_space, detail);
];

[ TEXT_TY_RE_DebugSubtree ftxt depth offset detail
	cup;
	if (offset ~= NULL) {
		cup = offset-->RE_UP;
		if (offset-->RE_PREVIOUS ~= NULL) print "*** broken initial previous ***^";
	}
	while (offset ~= NULL) {
		if (offset-->RE_UP ~= cup) print "*** broken up matching ***^";
		spaces(depth*2);
		TEXT_TY_RE_DebugNode(offset, ftxt, detail);
		if (offset-->RE_DOWN ~= NULL) {
			if ((offset-->RE_DOWN)-->RE_UP ~= offset)
				print "*** broken down/up ***^";
			TEXT_TY_RE_DebugSubtree(ftxt, depth+1, offset-->RE_DOWN, detail);
		}
		if (offset-->RE_NEXT ~= NULL) {
			if ((offset-->RE_NEXT)-->RE_PREVIOUS ~= offset)
				print "*** broken next/previous ***^";
		}
		offset = offset-->RE_NEXT;
	}
];

[ TEXT_TY_RE_DebugNode offset ftxt detail
	i par1 par2 par3;
	if (offset == NULL) "[NULL]";
	print "[", (offset-RE_PACKET_space)/(RE_PACKET_SIZE_IN_BYTES), "] ";
	! for (i=0:i<RE_PACKET_SIZE:i++) print offset-->i, " ";
	par1 = offset-->RE_PAR1;
	par2 = offset-->RE_PAR2;
	par3 = offset-->RE_PAR3;
	switch (offset-->RE_CCLASS) {
		DIGIT_RE_CC: print "DIGIT";
		NONDIGIT_RE_CC: print "NONDIGIT";
		UCASE_RE_CC: print "UCASE";
		NONUCASE_RE_CC: print "NONUCASE";
		LCASE_RE_CC: print "LCASE";
		NONLCASE_RE_CC: print "NONLCASE";
		WHITESPACE_RE_CC: print "WHITESPACE";
		NONWHITESPACE_RE_CC: print "NONWHITESPACE";
		PUNCTUATION_RE_CC: print "PUNCTUATION";
		NONPUNCTUATION_RE_CC: print "NONPUNCTUATION";
		WORD_RE_CC: print "WORD";
		NONWORD_RE_CC: print "NONWORD";
		ALWAYS_RE_CC: print "ALWAYS";
		NEVER_RE_CC: print "NEVER";
		START_RE_CC: print "START";
		END_RE_CC: print "END";
		BOUNDARY_RE_CC: print "BOUNDARY";
		NONBOUNDARY_RE_CC: print "NONBOUNDARY";
		ANYTHING_RE_CC: print "ANYTHING";
		NOTHING_RE_CC: print "NOTHING";
		RANGE_RE_CC: print "RANGE"; if (par3 == true) print " (negated)";
			print " ";
			for (i=par1:i<par2:i++) print (char) BlkValueRead(ftxt, i);
		VARIABLE_RE_CC: print "VARIABLE ", par1;
		SUBEXP_RE_CC:
			if (par1 == 0) print "EXP";
			else print "SUBEXP ";
			if (par1 >= 0) print "= V", par1;
			if (par2 == 1) {
				if (par3 == 0) print " (?=...) lookahead";
				else print " (?<=...) lookbehind of width ", par3;
			}
			if (par2 == 2) {
				if (par3 == 0) print " (?!...) negated lookahead";
				else print " (?<!...) negated lookbehind of width ", par3;
			}
			if (par2 == 3) print " uncollecting";
			if (par2 == 0 or 3) {
				if (par3 == 1) print " forcing case sensitivity";
				if (par3 == 2) print " forcing case insensitivity";
			}
			if (par2 == 4) print " (?>...) possessive";
		NEWLINE_RE_CC: print "NEWLINE";
		TAB_RE_CC: print "TAB";
		QUANTIFIER_RE_CC: print "QUANTIFIER min=", par1, " max=", par2;
			if (par3) print " (lazy)"; else print " (greedy)";
		LITERAL_RE_CC: print "LITERAL";
			print " ";
			for (i=par1:i<par2:i++) print (char) BlkValueRead(ftxt, i);
		DISJUNCTION_RE_CC: print "DISJUNCTION of ", par1, " choices";
		CHOICE_RE_CC: print "CHOICE no ", par1;
		SENSITIVITY_RE_CC: print "SENSITIVITY";
			if (par1) print " off"; else print " on";
		IF_RE_CC: print "IF"; if (par1 >= 1) print " = V", par1;
		CONDITION_RE_CC: print "CONDITION"; if (par1 >= 1) print " = V", par1;
		THEN_RE_CC: print "THEN";
		ELSE_RE_CC: print "ELSE";
	}
	if (detail)
		print ": ", offset-->RE_DATA1, ", ", offset-->RE_DATA2, ", ", offset-->RE_CONSTRAINT;
	print "^";
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RegExp.i6t: Compiling Tree For Substring Search
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_CHR_CompileTree ftxt exactly
	root literal fto no_packets token attach_to;

	fto = TEXT_TY_CharacterLength(ftxt);

	root = TEXT_TY_RE_Node(0, SUBEXP_RE_CC, 0, 0, 0);
	literal = TEXT_TY_RE_Node(1, LITERAL_RE_CC, 0, fto, 0);
	
	root-->RE_DOWN = literal;
	literal-->RE_UP = root;

	if (exactly) {
		no_packets = 2;
		if (no_packets+3 > RE_MAX_PACKETS) return "regexp too complex";
		exactly = RE_PACKET_space-->RE_DOWN;
		token = TEXT_TY_RE_Node(no_packets++, START_RE_CC, 0, 0, 0);
		RE_PACKET_space-->RE_DOWN = token; token-->RE_UP = RE_PACKET_space;
		attach_to = TEXT_TY_RE_Node(no_packets++, SUBEXP_RE_CC, -1, 3, 0);
		token-->RE_NEXT = attach_to; attach_to-->RE_PREVIOUS = token;
		attach_to-->RE_UP = RE_PACKET_space;
		attach_to-->RE_NEXT = TEXT_TY_RE_Node(no_packets++, END_RE_CC, 0, 0, 0);
		(attach_to-->RE_NEXT)-->RE_PREVIOUS = attach_to;
		(attach_to-->RE_NEXT)-->RE_UP = RE_PACKET_space;
		attach_to-->RE_DOWN = exactly;
		while (exactly ~= NULL) {
			exactly-->RE_UP = attach_to; exactly = exactly-->RE_NEXT;
		}
	}
	
	no_packets = TEXT_TY_RE_ExpandChoices(RE_PACKET_space, no_packets);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RegExp.i6t: Compiling Tree For Regexp Search
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Array Subexp_Posns --> 20;
[ TEXT_TY_RE_CompileTree ftxt exactly
	no_packets ffrom fto cc par1 par2 par3
	quantifiable token attach_to no_subs blevel bits;

	fto = TEXT_TY_CharacterLength(ftxt);
	if (fto == 0) {
		TEXT_TY_RE_Node(no_packets++, NEVER_RE_CC, 0, 0, 0); ! Empty regexp never matches
		return 1;
	}

	attach_to = TEXT_TY_RE_Node(no_packets++, SUBEXP_RE_CC, 0, 0, 0);
	RE_Subexpressions-->0 = attach_to; RE_Subexpressions-->10 = 1; no_subs = 1;

	quantifiable = false; blevel = 0;
	
	for (ffrom = 0: ffrom < fto: ) {
		cc = BlkValueRead(ftxt, ffrom++); par1 = 0; par2 = 0; par3 = 0;
		if (cc == '\') {
			if (ffrom == fto) return "Search pattern not terminated";
			cc = BlkValueRead(ftxt, ffrom++);
			switch (cc) {
				'b': cc = BOUNDARY_RE_CC;
				'B': cc = NONBOUNDARY_RE_CC;
				'd': cc = DIGIT_RE_CC;
				'D': cc = NONDIGIT_RE_CC;
				'l': cc = LCASE_RE_CC;
				'L': cc = NONLCASE_RE_CC;
				'n': cc = NEWLINE_RE_CC;
				'p': cc = PUNCTUATION_RE_CC;
				'P': cc = NONPUNCTUATION_RE_CC;
				's': cc = WHITESPACE_RE_CC;
				'S': cc = NONWHITESPACE_RE_CC;
				't': cc = TAB_RE_CC;
				'u': cc = UCASE_RE_CC;
				'U': cc = NONUCASE_RE_CC;
				'w': cc = WORD_RE_CC;
				'W': cc = NONWORD_RE_CC;
				default:
					if ((cc >= '1') && (cc <= '9')) {
						par1 = cc-'0';
						cc = VARIABLE_RE_CC;
					} else {
						if (((cc >= 'a') && (cc <= 'z')) ||
							((cc >= 'A') && (cc <= 'Z'))) return "unknown escape";
						cc = LITERAL_RE_CC;
						par1 = ffrom-1; par2 = ffrom;
					}
			}
			quantifiable = true;
		} else {
			switch (cc) {
				'(': par2 = 0;
					!if (BlkValueRead(ftxt, ffrom) == ')') return "empty subexpression";
					if (BlkValueRead(ftxt, ffrom) == '?') {
						ffrom++;
						bits = true;
						if (BlkValueRead(ftxt, ffrom) == '-') { ffrom++; bits = false; }
						else if (BlkValueRead(ftxt, ffrom) == '<') { ffrom++; bits = false; }
						switch (cc = BlkValueRead(ftxt, ffrom++)) {
							'#': while (BlkValueRead(ftxt, ffrom++) ~= 0 or ')') ;
								if (BlkValueRead(ftxt, ffrom-1) == 0)
									return "comment never ends";
								continue;
							'(': cc = BlkValueRead(ftxt, ffrom);
								if ((cc == '1' or '2' or '3' or '4' or
									'5' or '6' or '7' or '8' or '9') &&
									(BlkValueRead(ftxt, ffrom+1) ==')')) {
									ffrom = ffrom + 2;
									par1 = cc - '0';
								} else ffrom--;
								cc = IF_RE_CC; ! (?(...)...) conditional
								quantifiable = false;
								if (blevel == 20) return "subexpressions too deep";
								Subexp_Posns-->(blevel++) = TEXT_TY_RE_NodeAddress(no_packets);
								jump CClassKnown;
							'=': par2 = 1; ! (?=...) lookahead/behind
								par3 = 0; if (bits == false) par3 = -1;
							'!': par2 = 2; ! (?!...) negated lookahead/behind
								par3 = 0; if (bits == false) par3 = -1;
							':': par2 = 3; ! (?:...) uncollecting subexpression
							'>': par2 = 4; ! (?>...) possessive
							default:
								if (BlkValueRead(ftxt, ffrom) == ')') {
									if (cc == 'i') {
										cc = SENSITIVITY_RE_CC; par1 = bits; ffrom++;
										jump CClassKnown;
									}
								}
								if (BlkValueRead(ftxt, ffrom) == ':') {
									if (cc == 'i') {
										par1 = bits; par2 = 3; par3 = bits+1; ffrom++;
										jump AllowForm;
									}
								}
								return "unknown (?...) form";
						}
					}
					.AllowForm;
					if (par2 == 0) par1 = no_subs++; else par1 = -1;
					cc = SUBEXP_RE_CC; 
					quantifiable = false;
					if (blevel == 20) return "subexpressions too deep";
					Subexp_Posns-->(blevel++) = TEXT_TY_RE_NodeAddress(no_packets);
				')': if (blevel == 0) return "subexpression bracket mismatch";
					blevel--;
					attach_to = Subexp_Posns-->blevel;
					if (attach_to-->RE_DOWN == NULL) {
						if (no_packets >= RE_MAX_PACKETS) return "regexp too complex";
						attach_to-->RE_DOWN =
							TEXT_TY_RE_Node(no_packets++, ALWAYS_RE_CC, 0, 0, 0);
						(attach_to-->RE_DOWN)-->RE_UP = attach_to;
					}
					quantifiable = true;
					continue;
				'.': cc = ANYTHING_RE_CC; quantifiable = true;
				'|': cc = CHOICE_RE_CC; quantifiable = false;
				'^': cc = START_RE_CC; quantifiable = false;
				'$': cc = END_RE_CC; quantifiable = false;
				'{': if (quantifiable == false) return "quantifier misplaced";
					par1 = 0; par2 = -1; bits = 1;
					while ((cc=BlkValueRead(ftxt, ffrom++)) ~= 0 or '}') {
						if (cc == ',') {
							bits++;
							if (bits >= 3) return "too many colons in ?{...}";
							continue;
						}
						if ((cc >= '0') || (cc <= '9')) {
							if (bits == 1) {
								if (par1 < 0) par1 = 0;
								par1 = par1*10 + (cc-'0');
							} else {
								if (par2 < 0) par2 = 0;
								par2 = par2*10 + (cc-'0');
							}
						} else return "non-digit in ?{...}";
					}
					if (cc ~= '}') return "{x,y} quantifier never ends";
					cc = QUANTIFIER_RE_CC;
					if (par2 == -1) {
						if (bits == 2) par2 = 30000;
						else par2 = par1;
					}
					if (par1 > par2) return "{x,y} with x greater than y";
					if (BlkValueRead(ftxt, ffrom) == '?') { ffrom++; par3 = true; }
					quantifiable = false;
				'<', '[': par3 = false; if (cc == '<') bits = '>'; else bits = ']';
					if (BlkValueRead(ftxt, ffrom) == '^') { ffrom++; par3 = true; }
					par1 = ffrom;
					if (BlkValueRead(ftxt, ffrom) == bits) { ffrom++; }
					while (cc ~= bits or 0) {
						cc = BlkValueRead(ftxt, ffrom++);
						if (cc == '\') {
							cc = BlkValueRead(ftxt, ffrom++);
							if (cc ~= 0) cc = BlkValueRead(ftxt, ffrom++);
						}
					}
					if (cc == 0) return "Character range never ends";
					par2 = ffrom-1;
					if ((par2 > par1 + 1) &&
						(BlkValueRead(ftxt, par1) == ':') &&
						(BlkValueRead(ftxt, par2-1) == ':') &&
						(BlkValueRead(ftxt, par2-2) ~= '\'))
						return "POSIX named character classes unsupported";
					bits = TEXT_TY_RE_RangeSyntaxCorrect(ftxt, par1, par2);
					if (bits) return bits;
					if (par1 < par2) cc = RANGE_RE_CC;
					else cc = NOTHING_RE_CC;
					quantifiable = true;
				'*': if (quantifiable == false) return "quantifier misplaced";
					cc = QUANTIFIER_RE_CC;
					par1 = 0; par2 = 30000;
					if (BlkValueRead(ftxt, ffrom) == '?') { ffrom++; par3 = true; }
					quantifiable = false;
				'+': if (quantifiable == false) return "quantifier misplaced";
					cc = QUANTIFIER_RE_CC;
					par1 = 1; par2 = 30000;
					if (BlkValueRead(ftxt, ffrom) == '?') { ffrom++; par3 = true; }
					quantifiable = false;
				'?': if (quantifiable == false) return "quantifier misplaced";
					cc = QUANTIFIER_RE_CC;
					par1 = 0; par2 = 1;
					if (BlkValueRead(ftxt, ffrom) == '?') { ffrom++; par3 = true; }
					quantifiable = false;
			}
		}
		
		.CClassKnown;
		
		if (cc >= 0) {
			quantifiable = true;
			if ((attach_to-->RE_CCLASS == LITERAL_RE_CC) &&
				(BlkValueRead(ftxt, ffrom) ~= '*' or '+' or '?' or '{')) {
				(attach_to-->RE_PAR2)++;
				if (TEXT_TY_RE_Trace == 2) {
					print "Extending literal by ", cc, "=", (char) cc, "^";
				}
				continue;
			}
			cc = LITERAL_RE_CC; par1 = ffrom-1; par2 = ffrom;
		}
		
		if (no_packets >= RE_MAX_PACKETS) return "regexp too complex";

		if (TEXT_TY_RE_Trace == 2) {
			print "Attaching packet ", no_packets+1, " to ";
			TEXT_TY_RE_DebugNode(attach_to, ftxt);
			TEXT_TY_RE_DebugTree(ftxt);
		}

		token = TEXT_TY_RE_Node(no_packets++, cc, par1, par2, par3);

		if ((token-->RE_CCLASS == SUBEXP_RE_CC) && (token-->RE_PAR2 == 0)) {
			RE_Subexpressions-->(token-->RE_PAR1) = token;
			(RE_Subexpressions-->10)++;
		}
		
		if ((attach_to-->RE_CCLASS == SUBEXP_RE_CC or CHOICE_RE_CC or IF_RE_CC) &&
			(attach_to-->RE_DOWN == NULL)) {
			attach_to-->RE_DOWN = token; token-->RE_UP = attach_to;
		} else {
			if ((token-->RE_CCLASS == CHOICE_RE_CC) &&
				((attach_to-->RE_UP)-->RE_CCLASS == CHOICE_RE_CC)) {
				no_packets--; token = attach_to-->RE_UP;
			} else {
				if (token-->RE_CCLASS == CHOICE_RE_CC) {
					while (attach_to-->RE_PREVIOUS ~= NULL)
						attach_to = attach_to-->RE_PREVIOUS;
				}
				if (token-->RE_CCLASS == QUANTIFIER_RE_CC or CHOICE_RE_CC) {
					token-->RE_PREVIOUS = attach_to-->RE_PREVIOUS;
					token-->RE_UP = attach_to-->RE_UP;
					if ((attach_to-->RE_UP ~= NULL) && (attach_to-->RE_PREVIOUS == NULL))
						(attach_to-->RE_UP)-->RE_DOWN = token;
					token-->RE_DOWN = attach_to;
					bits = attach_to;
					while (bits ~= NULL) {
						bits-->RE_UP = token;
						bits = bits-->RE_NEXT;
					}
					attach_to-->RE_PREVIOUS = NULL;
					if (token-->RE_PREVIOUS ~= NULL)
						(token-->RE_PREVIOUS)-->RE_NEXT = token;
				} else {
					attach_to-->RE_NEXT = token; token-->RE_PREVIOUS = attach_to;
					token-->RE_UP = attach_to-->RE_UP;
				}
			}
		}
		
		if (token-->RE_CCLASS == CHOICE_RE_CC) {
			if (no_packets >= RE_MAX_PACKETS) return "regexp too complex";
			token-->RE_NEXT = TEXT_TY_RE_Node(no_packets++, CHOICE_RE_CC, 0, 0, 0);
			(token-->RE_NEXT)-->RE_PREVIOUS = token;
			(token-->RE_NEXT)-->RE_UP = token-->RE_UP;
			token = token-->RE_NEXT;
		}

		attach_to = token;

		if (TEXT_TY_RE_Trace == 2) {
			print "Result:^";
			TEXT_TY_RE_DebugTree(ftxt);
		}

	}
	
	if (blevel ~= 0) return "subexpression bracket mismatch";

	if (exactly) {
		if (no_packets+3 > RE_MAX_PACKETS) return "regexp too complex";
		exactly = RE_PACKET_space-->RE_DOWN;
		token = TEXT_TY_RE_Node(no_packets++, START_RE_CC, 0, 0, 0);
		RE_PACKET_space-->RE_DOWN = token; token-->RE_UP = RE_PACKET_space;
		attach_to = TEXT_TY_RE_Node(no_packets++, SUBEXP_RE_CC, -1, 3, 0);
		token-->RE_NEXT = attach_to; attach_to-->RE_PREVIOUS = token;
		attach_to-->RE_UP = RE_PACKET_space;
		attach_to-->RE_NEXT = TEXT_TY_RE_Node(no_packets++, END_RE_CC, 0, 0, 0);
		(attach_to-->RE_NEXT)-->RE_PREVIOUS = attach_to;
		(attach_to-->RE_NEXT)-->RE_UP = RE_PACKET_space;
		attach_to-->RE_DOWN = exactly;
		while (exactly ~= NULL) {
			exactly-->RE_UP = attach_to; exactly = exactly-->RE_NEXT;
		}
	}
	
	no_packets = TEXT_TY_RE_ExpandChoices(RE_PACKET_space, no_packets);

	if (TEXT_TY_RE_Trace) {
		print "Compiled pattern:^";
		TEXT_TY_RE_DebugTree(ftxt);
	}
	
	bits = TEXT_TY_RE_CheckTree(RE_PACKET_space, no_subs); if (bits) return bits;
	
	return no_packets;
];

[ TEXT_TY_RE_RangeSyntaxCorrect ftxt rf rt
	i chm;
	for (i=rf: i<rt: i++) {
		chm = BlkValueRead(ftxt, i);
		if ((chm == '\') && (i+1<rt)) {
			chm = BlkValueRead(ftxt, ++i);
			if (((chm >= 'a') && (chm <= 'z')) ||
				((chm >= 'A') && (chm <= 'Z'))) {
				if (chm ~= 's' or 'S' or 'p' or 'P' or 'w' or 'W' or 'd'
					or 'D' or 'n' or 't' or 'l' or 'L' or 'u' or 'U')
					return "Invalid escape in {} range";
			}
		}
		if ((i+2<rt) && (BlkValueRead(ftxt, i+1) == '-')) {
			if (chm > BlkValueRead(ftxt, i+2)) return "Invalid {} range";
			i=i+2;
		}
	}
	rfalse;
];

[ TEXT_TY_RE_ExpandChoices token no_packets
	rv prev nex holder new ct n cond_node then_node else_node;
	while (token ~= NULL) {
		if (token-->RE_CCLASS == IF_RE_CC) {
			if ((token-->RE_DOWN)-->RE_CCLASS == CHOICE_RE_CC) {
				for (nex=token-->RE_DOWN, n=0: nex~=NULL: nex=nex-->RE_NEXT) n++;
				if (n~=2) return "conditional has too many clauses";
				if (no_packets >= RE_MAX_PACKETS) return "regexp too complex";
				cond_node = TEXT_TY_RE_Node(no_packets++, CONDITION_RE_CC, 0, 0, 0);
				if (token-->RE_PAR1 >= 1) {
					cond_node-->RE_PAR1 = token-->RE_PAR1;
				}
				then_node = token-->RE_DOWN;
				then_node-->RE_CCLASS = THEN_RE_CC;
				else_node = then_node-->RE_NEXT;
				else_node-->RE_CCLASS = ELSE_RE_CC;
				if (cond_node-->RE_PAR1 < 1) {
					cond_node-->RE_DOWN = then_node-->RE_DOWN;
					then_node-->RE_DOWN = (then_node-->RE_DOWN)-->RE_NEXT;
					if (then_node-->RE_DOWN ~= NULL)
						(then_node-->RE_DOWN)-->RE_PREVIOUS = NULL;
					(cond_node-->RE_DOWN)-->RE_NEXT = NULL;
					(cond_node-->RE_DOWN)-->RE_UP = cond_node;
				}
				token-->RE_DOWN = cond_node; cond_node-->RE_UP = token;
				cond_node-->RE_NEXT = then_node; then_node-->RE_PREVIOUS = cond_node;
			} else {
				if (no_packets >= RE_MAX_PACKETS) return "regexp too complex";
				cond_node = TEXT_TY_RE_Node(no_packets++, CONDITION_RE_CC, 0, 0, 0);
				if (no_packets >= RE_MAX_PACKETS) return "regexp too complex";
				then_node = TEXT_TY_RE_Node(no_packets++, THEN_RE_CC, 0, 0, 0);
				if (token-->RE_PAR1 >= 1) {
					cond_node-->RE_PAR1 = token-->RE_PAR1;
					then_node-->RE_DOWN = token-->RE_DOWN;
				} else {
					cond_node-->RE_DOWN = token-->RE_DOWN;
					then_node-->RE_DOWN = (token-->RE_DOWN)-->RE_NEXT;
					(cond_node-->RE_DOWN)-->RE_NEXT = NULL;
					(cond_node-->RE_DOWN)-->RE_UP = cond_node;
				}
				token-->RE_DOWN = cond_node;
				cond_node-->RE_UP = token; cond_node-->RE_NEXT = then_node;
				then_node-->RE_PREVIOUS = cond_node; then_node-->RE_UP = token;
				then_node-->RE_NEXT = NULL;
				if (then_node-->RE_DOWN ~= NULL)
					(then_node-->RE_DOWN)-->RE_PREVIOUS = NULL;
				for (nex = then_node-->RE_DOWN: nex ~= NULL: nex = nex-->RE_NEXT) {
					nex-->RE_UP = then_node;
				}
			}
			
			if (cond_node-->RE_DOWN ~= NULL) {
				nex = cond_node-->RE_DOWN;
				if ((nex-->RE_CCLASS ~= SUBEXP_RE_CC) ||
					(nex-->RE_NEXT ~= NULL) ||
					(nex-->RE_PAR2 ~= 1 or 2)) {
					!TEXT_TY_RE_DebugSubtree(0, 0, nex, true);
					return "condition not lookahead/behind";
				}
			}
		}
		if ((token-->RE_CCLASS == CHOICE_RE_CC) && (token-->RE_PAR1 < 1)) {
			prev = token-->RE_PREVIOUS;
			nex = token-->RE_NEXT;
			while ((nex ~= NULL) && (nex-->RE_CCLASS == CHOICE_RE_CC))
				nex = nex-->RE_NEXT;
			holder = token-->RE_UP; if (holder == NULL) return "bang";
			if (no_packets >= RE_MAX_PACKETS) return "regexp too complex";
			new = TEXT_TY_RE_Node(no_packets++, DISJUNCTION_RE_CC, 0, 0, 0);
			holder-->RE_DOWN = new; new-->RE_UP = holder;
			if (prev ~= NULL) {
				prev-->RE_NEXT = new; new-->RE_PREVIOUS = prev;
			}
			if (nex ~= NULL) {
				nex-->RE_PREVIOUS = new; new-->RE_NEXT = nex;
			}
			new-->RE_DOWN = token;
			token-->RE_PREVIOUS = NULL;
			ct = 1;
			while (token ~= NULL) {
				token-->RE_PAR1 = ct++;
				token-->RE_UP = new;
				if ((token-->RE_NEXT ~= NULL) &&
					((token-->RE_NEXT)-->RE_CCLASS ~= CHOICE_RE_CC))
					token-->RE_NEXT = NULL;
				token = token-->RE_NEXT;
			}
			new-->RE_PAR1 = ct-1;
			if (token ~= NULL) token-->RE_NEXT = NULL;
			token = new; continue;
		}
		if (token-->RE_DOWN ~= NULL) {
			no_packets = TEXT_TY_RE_ExpandChoices(token-->RE_DOWN, no_packets);
			if ((no_packets<0) || (no_packets >= RE_MAX_PACKETS)) break;
		}
		token = token-->RE_NEXT;
	}
	return no_packets;
];

[ TEXT_TY_RE_CheckTree token no_subs
	rv;
	while (token ~= NULL) {
		if (token-->RE_CCLASS == VARIABLE_RE_CC) {
			if (token-->RE_PAR1 >= no_subs) return "reference to nonexistent group";
		}
		if ((token-->RE_CCLASS == SUBEXP_RE_CC) &&
			(token-->RE_PAR2 == 1 or 2) &&
			(token-->RE_PAR3 == -1)) {
			token-->RE_PAR3 = TEXT_TY_RE_Width(token-->RE_DOWN);
			if (token-->RE_PAR3 == -1) return "variable length lookbehind not implemented";
		}
		if (token-->RE_DOWN ~= NULL) {
			rv = TEXT_TY_RE_CheckTree(token-->RE_DOWN, no_subs);
			if (rv) return rv;
		}
		token = token-->RE_NEXT;
	}
	rfalse;
];

[ TEXT_TY_RE_Width token downwards
	w rv aw choice;
	while (token ~= NULL) {
		switch (token-->RE_CCLASS) {
			DIGIT_RE_CC, NONDIGIT_RE_CC, WHITESPACE_RE_CC, NONWHITESPACE_RE_CC,
			PUNCTUATION_RE_CC, NONPUNCTUATION_RE_CC, WORD_RE_CC, NONWORD_RE_CC,
			ANYTHING_RE_CC, NOTHING_RE_CC, RANGE_RE_CC, NEWLINE_RE_CC, TAB_RE_CC,
			UCASE_RE_CC, NONUCASE_RE_CC, LCASE_RE_CC, NONLCASE_RE_CC:
				w++;
			START_RE_CC, END_RE_CC, BOUNDARY_RE_CC, NONBOUNDARY_RE_CC, ALWAYS_RE_CC:
				;
			LITERAL_RE_CC:
				w = w + token-->RE_PAR2 - token-->RE_PAR1;
			VARIABLE_RE_CC:
				return -1;
			IF_RE_CC:
				rv = TEXT_TY_RE_Width((token-->RE_DOWN)-->RE_NEXT);
				if (rv == -1) return -1;
				if (rv ~= TEXT_TY_RE_Width(((token-->RE_DOWN)-->RE_NEXT)-->RE_NEXT))
					return -1;
				w = w + rv;
			SUBEXP_RE_CC:
				if (token-->RE_PAR2 == 1 or 2) rv = 0;
				else {
					rv = TEXT_TY_RE_Width(token-->RE_DOWN);
					if (rv == -1) return -1;
				}
				w = w + rv;
			QUANTIFIER_RE_CC:
				if (token-->RE_PAR1 ~= token-->RE_PAR2) return -1;
				rv = TEXT_TY_RE_Width(token-->RE_DOWN);
				if (rv == -1) return -1;
				w = w + rv*(token-->RE_PAR1);				
			DISJUNCTION_RE_CC:
				aw = -1;
				for (choice = token-->RE_DOWN: choice ~= NULL: choice = choice-->RE_NEXT) {
					rv = TEXT_TY_RE_Width(choice-->RE_DOWN);
					!print "Option found ", rv, "^";
					if (rv == -1) return -1;
					if ((aw >= 0) && (aw ~= rv)) return -1;
					aw = rv;
				}
				w = w + aw;
			SENSITIVITY_RE_CC:
				;
		}
		if (downwards) return w;
		if (token ~= NULL) token = token-->RE_NEXT;
	}
	return w;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RegExp.i6t: Parser
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Global TEXT_TY_RE_RewindCount;
[ TEXT_TY_RE_PrintNoRewinds; print TEXT_TY_RE_RewindCount; ];

Constant CIS_MFLAG = 1;
Constant ACCUM_MFLAG = 2;

[ TEXT_TY_RE_Parse ftxt txt ipos insens
	ilen rv root i initial_mode;

	ilen = TEXT_TY_CharacterLength(txt);
	if ((ipos<0) || (ipos>ilen)) return -1;
	
	root = RE_PACKET_space;
	
	initial_mode = 0; if (insens) initial_mode = CIS_MFLAG;
	
	TEXT_TY_RE_Clear_Markers(RE_PACKET_space);
	
	for (:ipos<=ilen:ipos++) {
		if ((RE_PACKET_space-->RE_DOWN ~= NULL) &&
			((RE_PACKET_space-->RE_DOWN)-->RE_CCLASS == START_RE_CC) &&
			(ipos>0)) { rv = -1; break; }
		if (ipos > 0) TEXT_TY_RE_EraseConstraints(RE_PACKET_space, initial_mode);
		TEXT_TY_RE_RewindCount = 0;
		rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, ipos, ilen, RE_PACKET_space, initial_mode);
		if (rv >= 0) break;
	}

	if (rv == -1) {
		root-->RE_DATA1 = -1;
		root-->RE_DATA2 = -1;
	} else {
		root-->RE_DATA1 = ipos;
		root-->RE_DATA2 = ipos+rv;
	}
	return rv;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RegExp.i6t: Parse At Position
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_RE_ParseAtPosition ftxt txt ifrom ito token mode_flags
	outcome ipos npos rv i ch edge rewind_this;

	if (ifrom > ito) return -1;

	ipos = ifrom;

	.Rewind;
	while (token ~= NULL) {
		outcome = false;
		if (TEXT_TY_RE_Trace) {
			print "Matching at ", ipos, ": ";
			TEXT_TY_RE_DebugNode(token, ftxt, true);
		}

		if (ipos<ito) ch = BlkValueRead(txt, ipos); else ch = 0;

		token-->RE_MODES = mode_flags; ! Save in case of backtrack

		switch (token-->RE_CCLASS) {
			
			! Should never happen
			
			CHOICE_RE_CC: return "internal error";
			
			! Mode switches
			
			SENSITIVITY_RE_CC:
				if (token-->RE_PAR1) mode_flags = mode_flags | CIS_MFLAG;
				else mode_flags = mode_flags & (~CIS_MFLAG);
				outcome = true;
		
			! Zero-length positional markers
			
			ALWAYS_RE_CC:
				outcome = true;
			NEVER_RE_CC:
			START_RE_CC:
				if (ipos == 0) outcome = true;
			END_RE_CC:
				if (BlkValueRead(txt, ipos) == 0) outcome = true;
			BOUNDARY_RE_CC:
				rv = 0;
				if (BlkValueRead(txt, ipos) == 0 or 10 or 13 or 32 or 9
					or '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}') rv++;
				if (ipos == 0) ch = 0;
				else ch = BlkValueRead(txt, ipos-1);
				if (ch == 0 or 10 or 13 or 32 or 9
					or '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}') rv++;
				if (rv == 1) outcome = true;
			NONBOUNDARY_RE_CC:
				rv = 0;
				if (BlkValueRead(txt, ipos) == 0 or 10 or 13 or 32 or 9
					or '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}') rv++;
				if (ipos == 0) ch = 0;
				else ch = BlkValueRead(txt, ipos-1);
				if (ch == 0 or 10 or 13 or 32 or 9
					or '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}') rv++;
				if (rv ~= 1) outcome = true;

			! Control constructs
		
			IF_RE_CC:
				i = token-->RE_PAR1; ch = false;
				if (TEXT_TY_RE_Trace) {
					print "Trying conditional from ", ipos, ": ";
					TEXT_TY_RE_DebugNode(token, ftxt, true);
				}
				if (i >= 1) {
					 if ((i<RE_Subexpressions-->10) &&
					 	((RE_Subexpressions-->i)-->RE_DATA1 >= 0)) ch = true;
				} else {					 	
					rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, ipos, ito,
						(token-->RE_DOWN)-->RE_DOWN, mode_flags);
					if (rv >= 0) ch = true;
				}
				if (TEXT_TY_RE_Trace) {
					print "Condition found to be ", ch, "^";
				}
				if (ch) {
					rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, ipos, ito,
						((token-->RE_DOWN)-->RE_NEXT)-->RE_DOWN, mode_flags);
					!print "Then clause returned ", rv, "^";
				} else {
					if ((((token-->RE_DOWN)-->RE_NEXT)-->RE_NEXT) == NULL)
						rv = 0; ! The empty else clause matches
					else rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, ipos, ito,
						(((token-->RE_DOWN)-->RE_NEXT)-->RE_NEXT)-->RE_DOWN, mode_flags);
					!print "Else clause returned ", rv, "^";
				}
				if (rv >= 0) {
					outcome = true;
					ipos = ipos + rv;
				}
			DISJUNCTION_RE_CC:
				if (TEXT_TY_RE_Trace) {
					print "Trying disjunction from ", ipos, ": ";
					TEXT_TY_RE_DebugNode(token, ftxt, true);
				}
				for (ch = token-->RE_DOWN: ch ~= NULL: ch = ch-->RE_NEXT) {
					if (ch-->RE_PAR1 <= token-->RE_CONSTRAINT) continue;
					if (TEXT_TY_RE_Trace) {
						print "Trying choice at ", ipos, ": ";
						TEXT_TY_RE_DebugNode(ch, ftxt, true);
					}
					rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, ipos, ito,
						ch-->RE_DOWN, mode_flags);
					if (rv >= 0) {
						token-->RE_DATA1 = ipos; ! Where match was made
						token-->RE_DATA2 = ch-->RE_PAR1; ! Option taken
						ipos = ipos + rv;
						outcome = true;
						if (TEXT_TY_RE_Trace) {
							print "Choice worked with width ", rv, ": ";
							TEXT_TY_RE_DebugNode(ch, ftxt, true);
						}
						break;
					} else {
						if (mode_flags & ACCUM_MFLAG == false)
							TEXT_TY_RE_FailSubexpressions(ch-->RE_DOWN);
					}						
				}
				if (outcome == false) {
					if (TEXT_TY_RE_Trace) {
						print "Failed disjunction from ", ipos, ": ";
						TEXT_TY_RE_DebugNode(token, ftxt, true);
					}
					token-->RE_DATA1 = ipos; ! Where match was tried
					token-->RE_DATA2 = -1; ! No option was taken
				}
			SUBEXP_RE_CC:
				if (token-->RE_PAR2 == 1 or 2) {
					npos = ipos - token-->RE_PAR3;
					if (npos<0) rv = -1; ! Lookbehind fails: nothing behind
					else rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, npos, ito, token-->RE_DOWN,
						mode_flags);
				} else {
					switch (token-->RE_PAR3) {
						0: rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, ipos, ito, token-->RE_DOWN,
							mode_flags);
						1: rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, ipos, ito, token-->RE_DOWN,
							mode_flags & (~CIS_MFLAG));
						2: rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, ipos, ito, token-->RE_DOWN,
							mode_flags | CIS_MFLAG);
					}
				}
				npos = ipos;
				if (rv >= 0) npos = ipos + rv;
				switch (token-->RE_PAR2) {
					1: if (rv >= 0) rv = 0;
					2: if (rv >= 0) rv = -1; else rv = 0;
				}
				if (rv >= 0) {
					token-->RE_DATA1 = ipos;
					ipos = ipos + rv;
					token-->RE_DATA2 = npos;
					outcome = true;
				} else {
					if (mode_flags & ACCUM_MFLAG == false) {
						token-->RE_DATA1 = -1;
						token-->RE_DATA2 = -1;
					}
				}
				if (token-->RE_PAR2 == 2) TEXT_TY_RE_FailSubexpressions(token, true);
			QUANTIFIER_RE_CC:
				token-->RE_DATA1 = ipos;
				if ((token-->RE_DOWN)-->RE_CCLASS == SUBEXP_RE_CC) {
					(token-->RE_DOWN)-->RE_CACHE1 = -1;
					(token-->RE_DOWN)-->RE_CACHE2 = -1;	
				}
				if (TEXT_TY_RE_Trace) {
					print "Trying quantifier from ", ipos, ": ";
					TEXT_TY_RE_DebugNode(token, ftxt, true);
				}
				if (token-->RE_PAR3 == false) { ! Greedy quantifier
					!edge = ito; if (token-->RE_CONSTRAINT >= 0) edge = token-->RE_CONSTRAINT;
					edge = token-->RE_PAR2;
					if (token-->RE_CONSTRAINT >= 0) edge = token-->RE_CONSTRAINT;
					rv = -1;
					for (i=0, npos=ipos: i<edge: i++) {
						if (TEXT_TY_RE_Trace) {
							print "Trying quant rep ", i+1, " at ", npos, ": ";
							TEXT_TY_RE_DebugNode(token, ftxt, true);
						}
						rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, npos, ito, token-->RE_DOWN,
							mode_flags | ACCUM_MFLAG);
						if (rv < 0) break;
						if ((token-->RE_DOWN)-->RE_CCLASS == SUBEXP_RE_CC) {
							(token-->RE_DOWN)-->RE_CACHE1 = (token-->RE_DOWN)-->RE_DATA1;
							(token-->RE_DOWN)-->RE_CACHE2 = (token-->RE_DOWN)-->RE_DATA2;	
						}
						if ((rv == 0) && (token-->RE_PAR2 == 30000) && (i>=1)) { i++; break; }
						npos = npos + rv;
					}
					if ((i >= token-->RE_PAR1) && (i <= token-->RE_PAR2))
						outcome = true;
				} else { ! Lazy quantifier
					edge = token-->RE_PAR1;
					if (token-->RE_CONSTRAINT > edge) edge = token-->RE_CONSTRAINT;
					for (i=0, npos=ipos: (npos<ito) && (i < token-->RE_PAR2): i++) {
						if (i >= edge) break;
						if (TEXT_TY_RE_Trace) {
							print "Trying quant rep ", i+1, " at ", npos, ": ";
							TEXT_TY_RE_DebugNode(token, ftxt, true);
						}
						rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, npos, ito, token-->RE_DOWN,
							mode_flags | ACCUM_MFLAG);
						if (rv < 0) break;
						if ((token-->RE_DOWN)-->RE_CCLASS == SUBEXP_RE_CC) {
							(token-->RE_DOWN)-->RE_CACHE1 = (token-->RE_DOWN)-->RE_DATA1;
							(token-->RE_DOWN)-->RE_CACHE2 = (token-->RE_DOWN)-->RE_DATA2;	
						}
						if ((rv == 0) && (token-->RE_PAR2 == 30000) && (i>=1)) { i++; break; }
						npos = npos + rv;
					}
					if ((i >= edge) && (i <= token-->RE_PAR2))
						outcome = true;
				}
				if (outcome) {
					if (token-->RE_PAR3 == false) { ! Greedy quantifier
						if (i > token-->RE_PAR1) { ! I.e., if we have been greedy
							token-->RE_DATA2 = i-1; ! And its edge limitation
						} else {
							token-->RE_DATA2 = -1;
						}
					} else { ! Lazy quantifier
						if (i < token-->RE_PAR2) { ! I.e., if we have been lazy
							token-->RE_DATA2 = i+1; ! And its edge limitation
						} else {
							token-->RE_DATA2 = -1;
						}
					}
					ipos = npos;
					if ((i == 0) && (mode_flags & ACCUM_MFLAG == false))
						TEXT_TY_RE_FailSubexpressions(token-->RE_DOWN);
					if ((token-->RE_DOWN)-->RE_CCLASS == SUBEXP_RE_CC) {
						(token-->RE_DOWN)-->RE_DATA1 = (token-->RE_DOWN)-->RE_CACHE1;
						(token-->RE_DOWN)-->RE_DATA2 = (token-->RE_DOWN)-->RE_CACHE2;	
					}
					if (TEXT_TY_RE_Trace) {
						print "Successful quant reps ", i, ": ";
						TEXT_TY_RE_DebugNode(token, ftxt, true);
					}
				} else {
					!token-->RE_DATA2 = -1;
					if (mode_flags & ACCUM_MFLAG == false)
						TEXT_TY_RE_FailSubexpressions(token-->RE_DOWN);
					if (TEXT_TY_RE_Trace) {
						print "Failed quant reps ", i, ": ";
						TEXT_TY_RE_DebugNode(token, ftxt, true);
					}
				}
				
			! Character classes
				
			NOTHING_RE_CC: ;
			ANYTHING_RE_CC: if (ch) outcome = true; ipos++;
			WHITESPACE_RE_CC:
				if (ch == 10 or 13 or 32 or 9) { outcome = true; ipos++; }
			NONWHITESPACE_RE_CC:
				if ((ch) && (ch ~= 10 or 13 or 32 or 9)) { outcome = true; ipos++; }
			PUNCTUATION_RE_CC:
				if (ch == '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}') { outcome = true; ipos++; }
			NONPUNCTUATION_RE_CC:
				if ((ch) && (ch ~= '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}')) { outcome = true; ipos++; }
			WORD_RE_CC:
				if ((ch) && (ch ~= 10 or 13 or 32 or 9
					or '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}')) { outcome = true; ipos++; }
			NONWORD_RE_CC:
				if (ch == 10 or 13 or 32 or 9
					or '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}') { outcome = true; ipos++; }
			DIGIT_RE_CC:
				if (ch == '0' or '1' or '2' or '3' or '4'
					or '5' or '6' or '7' or '8' or '9') { outcome = true; ipos++; }
			NONDIGIT_RE_CC:
				if ((ch) && (ch ~= '0' or '1' or '2' or '3' or '4'
					or '5' or '6' or '7' or '8' or '9')) { outcome = true; ipos++; }
			LCASE_RE_CC:
				if (CharIsOfCase(ch, 0)) { outcome = true; ipos++; }
			NONLCASE_RE_CC:
				if ((ch) && (CharIsOfCase(ch, 0) == false)) { outcome = true; ipos++; }
			UCASE_RE_CC:
				if (CharIsOfCase(ch, 1)) { outcome = true; ipos++; }
			NONUCASE_RE_CC:
				if ((ch) && (CharIsOfCase(ch, 1) == false)) { outcome = true; ipos++; }
			NEWLINE_RE_CC: if (ch == 10) { outcome = true; ipos++; }
			TAB_RE_CC: if (ch == 9) { outcome = true; ipos++; }
			RANGE_RE_CC:
				if (TEXT_TY_RE_Range(ch, ftxt,
					token-->RE_PAR1, token-->RE_PAR2, token-->RE_PAR3, mode_flags & CIS_MFLAG))
					{ outcome = true; ipos++; }
			
			! Substring matches
			
			LITERAL_RE_CC:
				rv = TEXT_TY_RE_MatchSubstring(txt, ipos,
					ftxt, token-->RE_PAR1, token-->RE_PAR2, mode_flags & CIS_MFLAG);
				if (rv >= 0) { ipos = ipos + rv; outcome = true; }
			VARIABLE_RE_CC:
				i = token-->RE_PAR1;
				if ((RE_Subexpressions-->i)-->RE_DATA1 >= 0) {
					rv = TEXT_TY_RE_MatchSubstring(txt, ipos,
						txt, (RE_Subexpressions-->i)-->RE_DATA1,
						(RE_Subexpressions-->i)-->RE_DATA2, mode_flags & CIS_MFLAG);
					if (rv >= 0) { ipos = ipos + rv; outcome = true; }
				}
				.NeverMatchIncompleteVar;
		}
		
		if (outcome == false) {
			if (TEXT_TY_RE_RewindCount++ >= 10000) {
				if (TEXT_TY_RE_RewindCount == 10001) {
					style bold; print "OVERFLOW^"; style roman;
				}
				return -1;
			}
			if (TEXT_TY_RE_Trace) {
				print "Rewind sought from failure at pos ", ipos, " with: ";
					TEXT_TY_RE_DebugNode(token, ftxt, true);
			}
			if ((token-->RE_CCLASS == QUANTIFIER_RE_CC) &&
				(TEXT_TY_RE_SeekBacktrack(token-->RE_DOWN, ftxt, false, ito, false)))
				jump RewindFound;
			if (mode_flags & ACCUM_MFLAG == false) TEXT_TY_RE_FailSubexpressions(token);
			token = token-->RE_PREVIOUS;
			while (token ~= NULL) {
				if (TEXT_TY_RE_SeekBacktrack(token, ftxt, true, ito, false)) {
					.RewindFound;
					ipos = token-->RE_DATA1;
					mode_flags = token-->RE_MODES;
					if (mode_flags & ACCUM_MFLAG == false)
						TEXT_TY_RE_FailSubexpressions(token, true);
					if (ipos == -1)
						TEXT_TY_RE_DebugTree(ftxt, true);
					if (TEXT_TY_RE_Trace) {
						print "^[", ifrom, ",", ito, "] rewinding to ", ipos, " at ";
						TEXT_TY_RE_DebugNode(token, ftxt, true);
					}
					jump Rewind;
				}
				token = token-->RE_PREVIOUS;
			}
			if (TEXT_TY_RE_Trace)
				print "^Rewind impossible^";
			return -1;
		}

		token = token-->RE_NEXT;
	}
	return ipos - ifrom;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RegExp.i6t: Backtracking
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_RE_SeekBacktrack token ftxt downwards ito report_only
	untried;
	for (: token ~= NULL: token = token-->RE_NEXT) {
		if ((TEXT_TY_RE_Trace) && (report_only == false)) {
			print "Scan for rewind: ";
			TEXT_TY_RE_DebugNode(token, ftxt, true);
		}
		if ((token-->RE_CCLASS == SUBEXP_RE_CC) &&
			(token-->RE_PAR2 == 1 or 2 or 4)) {
			if (downwards) rfalse;
			continue;
		}
		if (token-->RE_DOWN ~= NULL) {
			if ((TEXT_TY_RE_Trace) && (report_only == false)) print "Descend^";
			if (TEXT_TY_RE_SeekBacktrack(token-->RE_DOWN, ftxt, false, ito, report_only)) rtrue;
		}
		untried = false;
		switch (token-->RE_CCLASS) {
			DISJUNCTION_RE_CC:
				if ((token-->RE_DATA2 >= 1) &&
					(token-->RE_DATA2 < token-->RE_PAR1) &&
					(token-->RE_CONSTRAINT < token-->RE_PAR1)) { ! Matched but earlier than last
					if (report_only) rtrue;
					if (token-->RE_CONSTRAINT == -1)
						token-->RE_CONSTRAINT = 1;
					else
						(token-->RE_CONSTRAINT)++;
					untried = true;
				}
			QUANTIFIER_RE_CC:
				if (token-->RE_CONSTRAINT ~= -2) {
					if ((TEXT_TY_RE_Trace) && (report_only == false)) {
						print "Quant with cons not -2: ";
						TEXT_TY_RE_DebugNode(token, ftxt, true);
					}
					if (token-->RE_DATA2 >= 0) {
						if (report_only) rtrue;
						token-->RE_CONSTRAINT = token-->RE_DATA2;
						untried = true;
					}
				}
		}
		if (untried) {
			if (TEXT_TY_RE_Trace) {
				print "Grounds for rewind at: ";
				TEXT_TY_RE_DebugNode(token, ftxt, true);
			}
			TEXT_TY_RE_EraseConstraints(token-->RE_NEXT);
			TEXT_TY_RE_EraseConstraints(token-->RE_DOWN);
			rtrue;
		}
		if (downwards) rfalse;
	}
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RegExp.i6t: Fail Subexpressions
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_RE_FailSubexpressions token downwards;
	for (: token ~= NULL: token = token-->RE_NEXT) {
		if (token-->RE_DOWN ~= NULL) TEXT_TY_RE_FailSubexpressions(token-->RE_DOWN);
		if (token-->RE_CCLASS == SUBEXP_RE_CC) {
			token-->RE_DATA1 = -1;
			token-->RE_DATA2 = -1;
		}
		if (downwards) break;
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RegExp.i6t: Erasing Constraints
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_RE_EraseConstraints token;
	while (token ~= NULL) {
		switch (token-->RE_CCLASS) {
			DISJUNCTION_RE_CC: token-->RE_CONSTRAINT = -1;
			QUANTIFIER_RE_CC: token-->RE_CONSTRAINT = -1;
		}
		if (token-->RE_DOWN) TEXT_TY_RE_EraseConstraints(token-->RE_DOWN);
		token = token-->RE_NEXT;
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RegExp.i6t: Matching Literal Text
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_RE_MatchSubstring txt ipos mtxt mfrom mto insens
	i ch;
	if (mfrom < 0) return 0;
	if (insens)
		for (i=mfrom:i<mto:i++) {
			ch = BlkValueRead(mtxt, i);
			if (BlkValueRead(txt, ipos++) ~= ch or TEXT_TY_RevCase(ch))
				return -1;
		}
	else
		for (i=mfrom:i<mto:i++)
			if (BlkValueRead(txt, ipos++) ~= BlkValueRead(mtxt, i))
				return -1;
	return mto-mfrom;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RegExp.i6t: Matching Character Range
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_RE_Range ch ftxt rf rt negate insens
	i chm upper crev;
	if (ch == 0) rfalse;
	if (negate == true) {
		if (TEXT_TY_RE_Range(ch, ftxt, rf, rt, false, insens)) rfalse;
		rtrue;
	}
	for (i=rf: i<rt: i++) {
		chm = BlkValueRead(ftxt, i);
		if ((chm == '\') && (i+1<rt)) {
			chm = BlkValueRead(ftxt, ++i);
			switch (chm) {
				's':
					if (ch == 10 or 13 or 32 or 9) rtrue;
				'S':
					if ((ch) && (ch ~= 10 or 13 or 32 or 9)) rtrue;
				'p':
					if (ch == '.' or ',' or '!' or '?'
						or '-' or '/' or '"' or ':' or ';'
						or '(' or ')' or '[' or ']' or '{' or '}') rtrue;
				'P':
					if ((ch) && (ch ~= '.' or ',' or '!' or '?'
						or '-' or '/' or '"' or ':' or ';'
						or '(' or ')' or '[' or ']' or '{' or '}')) rtrue;
				'w':
					if ((ch) && (ch ~= 10 or 13 or 32 or 9
						or '.' or ',' or '!' or '?'
						or '-' or '/' or '"' or ':' or ';'
						or '(' or ')' or '[' or ']' or '{' or '}')) rtrue;
				'W':
					if (ch == 10 or 13 or 32 or 9
						or '.' or ',' or '!' or '?'
						or '-' or '/' or '"' or ':' or ';'
						or '(' or ')' or '[' or ']' or '{' or '}') rtrue;
				'd':
					if (ch == '0' or '1' or '2' or '3' or '4'
						or '5' or '6' or '7' or '8' or '9') rtrue;
				'D':
					if ((ch) && (ch ~= '0' or '1' or '2' or '3' or '4'
						or '5' or '6' or '7' or '8' or '9')) rtrue;
				'l': if (CharIsOfCase(ch, 0)) rtrue;
				'L': if (CharIsOfCase(ch, 0) == false) rtrue;
				'u': if (CharIsOfCase(ch, 1)) rtrue;
				'U': if (CharIsOfCase(ch, 1) == false) rtrue;
				'n': if (ch == 10) rtrue;
				't': if (ch == 9) rtrue;
			}
		} else {
			if ((i+2<rt) && (BlkValueRead(ftxt, i+1) == '-')) {
				upper = BlkValueRead(ftxt, i+2);
				if ((ch >= chm) && (ch <= upper)) rtrue;
				if (insens) {
					crev = TEXT_TY_RevCase(ch);
					if ((crev >= chm) && (crev <= upper)) rtrue;
				}
				i=i+2;
			} else {
				if (chm == ch) rtrue;
				if ((insens) && (chm == TEXT_TY_RevCase(ch))) rtrue;
			}
		}
	}
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RegExp.i6t: Search And Replace
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_Replace_RE ftxtype txt ftxt rtxt insens exactly
	r p p1 p2 cp cp1 cp2;
	!print "Find: "; BlkValueDebug(ftxt); print "^";
	!print "Rep: "; BlkValueDebug(rtxt); print "^";
	!print "In: "; BlkValueDebug(txt); print "^";
	if (rtxt == 0 or 1) { cp = txt-->0; p = TEXT_TY_Temporarily_Transmute(txt); }
	else TEXT_TY_Transmute(txt);
	cp1 = ftxt-->0; p1 = TEXT_TY_Temporarily_Transmute(ftxt);
	cp2 = rtxt-->0; p2 = TEXT_TY_Temporarily_Transmute(rtxt);
	r = TEXT_TY_Replace_REI(ftxtype, txt, ftxt, rtxt, insens, exactly);
	TEXT_TY_Untransmute(ftxt, p1, cp1);
	TEXT_TY_Untransmute(rtxt, p2, cp2);
	if (rtxt == 0 or 1) TEXT_TY_Untransmute(txt, p, cp);
	return r;
];

[ TEXT_TY_Replace_REI ftxtype txt ftxt rtxt insens exactly
	ctxt csize ilen i cl mpos cpos ch chm;

	ilen = TEXT_TY_CharacterLength(txt);

	TEXT_TY_RE_Err = 0;
	switch (ftxtype) {
		REGEXP_BLOB: i = TEXT_TY_RE_CompileTree(ftxt, exactly);
		CHR_BLOB: i = TEXT_TY_CHR_CompileTree(ftxt, exactly);
		default: "*** bad ftxtype ***";
	}
	
	if ((i<0) || (i>RE_MAX_PACKETS)) {
		TEXT_TY_RE_Err = i;
		print "*** Regular expression error: ", (string) TEXT_TY_RE_Err, " ***^";
		RunTimeProblem(RTP_REGEXPSYNTAXERROR);
		return 0;
	}

	if (TEXT_TY_RE_Trace) {
		TEXT_TY_RE_DebugTree(ftxt);
		print "(compiled to ", i, " packets)^";
	}
	
	if (ftxtype == REGEXP_BLOB) TEXT_TY_RE_EmptyMatchVars();
	mpos = 0; chm = 0; cpos = 0;
	while (TEXT_TY_RE_Parse(ftxt, txt, mpos, insens) >= 0) {
		chm++;
		
		if (TEXT_TY_RE_Trace) {
			print "^*** Match ", chm, " found (", RE_PACKET_space-->RE_DATA1, ",",
				RE_PACKET_space-->RE_DATA2, "): ";
			if (RE_PACKET_space-->RE_DATA1 == RE_PACKET_space-->RE_DATA2) {
				print "<empty>";
			}
			for (i=RE_PACKET_space-->RE_DATA1:i<RE_PACKET_space-->RE_DATA2:i++) {
				print (char) BlkValueRead(txt, i);
			}
			print " ***^";
		}
		
		if (rtxt == 0) break; ! Accept only one match, replace nothing
		
		if (rtxt ~= 0 or 1) {
			if (chm == 1) {
				ctxt = BlkValueCreate(TEXT_TY);
				TEXT_TY_Transmute(ctxt);
				csize = BlkValueLBCapacity(ctxt);
			}

			for (i=cpos:i<RE_PACKET_space-->RE_DATA1:i++) {
				ch = BlkValueRead(txt, i);
				if (cl+1 >= csize) {
					if (BlkValueSetLBCapacity(ctxt, 2*cl) == false) break;
					csize = BlkValueLBCapacity(ctxt);
				}
				BlkValueWrite(ctxt, cl++, ch);
			}
			BlkValueWrite(ctxt, cl, 0);
	
			TEXT_TY_Concatenate(ctxt, rtxt, ftxtype, txt);
			csize = BlkValueLBCapacity(ctxt);
			cl = TEXT_TY_CharacterLength(ctxt);			
		}

		mpos = RE_PACKET_space-->RE_DATA2; cpos = mpos;
		if (RE_PACKET_space-->RE_DATA1 == RE_PACKET_space-->RE_DATA2)
			mpos++;

		if (TEXT_TY_RE_Trace) {
			if (chm == 100) { ! Purely to keep the output from being excessive
				print "(Stopping after 100 matches.)^"; break;
			}
		}
	}
	if (chm > 0) {
		if (rtxt ~= 0 or 1) {
			for (i=cpos:i<ilen:i++) {
				ch = BlkValueRead(txt, i);
				if (cl+1 >= csize) {
					if (BlkValueSetLBCapacity(ctxt, 2*cl) == false) break;
					csize = BlkValueLBCapacity(ctxt);
				}
				BlkValueWrite(ctxt, cl++, ch);
			}
		}
		
		if (ftxtype == REGEXP_BLOB) {
			TEXT_TY_RE_CreateMatchVars(txt);
			if (TEXT_TY_RE_Trace)
				TEXT_TY_RE_DebugMatchVars(txt);
		}

		if (rtxt ~= 0 or 1) {
			BlkValueWrite(ctxt, cl, 0);
			BlkValueCopy(txt, ctxt);	
			BlkValueFree(ctxt);
		}
	}
	return chm;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RegExp.i6t: Concatenation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_RE_Concatenate txt_to txt_from blobtype txt_ref
	pos len ch i tosize x y case;
	if ((txt_to==0) || (BlkValueWeakKind(txt_to) ~= TEXT_TY)) rfalse;
	if ((txt_from==0) || (BlkValueWeakKind(txt_from) ~= TEXT_TY)) return txt_to;
	pos = TEXT_TY_CharacterLength(txt_to);
	tosize = BlkValueLBCapacity(txt_to);
	len = TEXT_TY_CharacterLength(txt_from);
	for (i=0:i<len:i++) {
		ch = BlkValueRead(txt_from, i);
		if ((ch == '\') && (i < len-1)) {
			ch = BlkValueRead(txt_from, ++i);
			if (ch == 'n') ch = 10;
			if (ch == 't') ch = 9;
			case = -1;
			if (ch == 'l') case = 0;
			if (ch == 'u') case = 1;
			if (case >= 0) ch = BlkValueRead(txt_from, ++i);
			if ((ch >= '0') && (ch <= '9')) {
				ch = ch - '0';
				if (ch < RE_Subexpressions-->10) {
					x = (RE_Subexpressions-->ch)-->RE_DATA1;
					y = (RE_Subexpressions-->ch)-->RE_DATA2;
					if (x >= 0) {
						for (:x<y:x++) {
							ch = BlkValueRead(txt_ref, x);
							if (pos+1 >= tosize) {
								if (BlkValueSetLBCapacity(txt_to, 2*tosize) == false) break;
								tosize = BlkValueLBCapacity(txt_to);
							}
							if (case >= 0)
								BlkValueWrite(txt_to, pos++, CharToCase(ch, case));
							else
								BlkValueWrite(txt_to, pos++, ch);
						}
					}
				}
				continue;
			}
			
		}
		if (pos+1 >= tosize) {
			if (BlkValueSetLBCapacity(txt_to, 2*tosize) == false) break;
			tosize = BlkValueLBCapacity(txt_to);
		}
		BlkValueWrite(txt_to, pos++, ch);
	}
	BlkValueWrite(txt_to, pos, 0);
	return txt_to;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! StoredAction.i6t: Block Format
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant STORA_ACTION_F = 0;
Constant STORA_NOUN_F = 1;
Constant STORA_SECOND_F = 2;
Constant STORA_ACTOR_F = 3;
Constant STORA_REQUEST_F = 4;
Constant STORA_COMMAND_TEXT_F = 5;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! StoredAction.i6t: KOV Support
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ STORED_ACTION_TY_Support task arg1 arg2 arg3;
	switch(task) {
		CREATE_KOVS:      return STORED_ACTION_TY_Create(arg2);
		DESTROY_KOVS:     STORED_ACTION_TY_Destroy(arg1);
		MAKEMUTABLE_KOVS: return 1;
		COPYQUICK_KOVS:   rtrue;
		COPYSB_KOVS:	  BlkValueCopySB1(arg1, arg2);
		KINDDATA_KOVS:    return 0;
		EXTENT_KOVS:      return 6;
		COPY_KOVS:        STORED_ACTION_TY_Copy(arg1, arg2);
		COMPARE_KOVS:     return STORED_ACTION_TY_Compare(arg1, arg2);
		HASH_KOVS:        return STORED_ACTION_TY_Hash(arg1);
		DEBUG_KOVS:       print " = ", (STORED_ACTION_TY_Say) arg1;
	}
	! We choose not to respond to: CAST_KOVS, COPYKIND_KOVS, READ_FILE_KOVS, WRITE_FILE_KOVS
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! StoredAction.i6t: Creation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ STORED_ACTION_TY_Create sb stora;
	stora = FlexAllocate(6*WORDSIZE, STORED_ACTION_TY, BLK_FLAG_WORD);
	BlkValueWrite(stora, STORA_ACTION_F, ##Wait, true); ! action
	BlkValueWrite(stora, STORA_NOUN_F, 0, true); ! noun
	BlkValueWrite(stora, STORA_SECOND_F, 0, true); ! second
	BlkValueWrite(stora, STORA_ACTOR_F, player, true); ! actor
	BlkValueWrite(stora, STORA_REQUEST_F, false, true); ! whether a request
	BlkValueWrite(stora, STORA_COMMAND_TEXT_F, 0, true); ! text of command if necessary, 0 if not
	return BlkValueCreateSB1(sb, stora);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! StoredAction.i6t: Setting Up
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ STORED_ACTION_TY_New a n s ac req  stora;
	if (stora == 0) stora = BlkValueCreate(STORED_ACTION_TY);
	BlkValueWrite(stora, STORA_ACTION_F, a);
	BlkValueWrite(stora, STORA_NOUN_F, n);
	BlkValueWrite(stora, STORA_SECOND_F, s);
	BlkValueWrite(stora, STORA_ACTOR_F, ac);
	BlkValueWrite(stora, STORA_REQUEST_F, req);
	BlkValueWrite(stora, STORA_COMMAND_TEXT_F, 0);
	return stora;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! StoredAction.i6t: Destruction
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ STORED_ACTION_TY_Destroy stora toc;
	toc = BlkValueRead(stora, STORA_COMMAND_TEXT_F);
	if (toc) BlkValueFree(toc);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! StoredAction.i6t: Copying
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ STORED_ACTION_TY_Copy storato storafrom tocfrom tocto;
	tocfrom = BlkValueRead(storafrom, STORA_COMMAND_TEXT_F);
	if (tocfrom == 0) return;
	tocto = BlkValueCreate(TEXT_TY);
	BlkValueCopy(tocto, tocfrom);
	BlkValueWrite(storato, STORA_COMMAND_TEXT_F, tocto);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! StoredAction.i6t: Comparison
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ STORED_ACTION_TY_Compare storaleft storaright delta itleft itright;
	delta = BlkValueRead(storaleft, STORA_ACTION_F) - BlkValueRead(storaright, STORA_ACTION_F);
	if (delta) return delta;
	delta = BlkValueRead(storaleft, STORA_NOUN_F) - BlkValueRead(storaright, STORA_NOUN_F);
	if (delta) return delta;
	delta = BlkValueRead(storaleft, STORA_SECOND_F) - BlkValueRead(storaright, STORA_SECOND_F);
	if (delta) return delta;
	delta = BlkValueRead(storaleft, STORA_ACTOR_F) - BlkValueRead(storaright, STORA_ACTOR_F);
	if (delta) return delta;
	delta = BlkValueRead(storaleft, STORA_REQUEST_F) - BlkValueRead(storaright, STORA_REQUEST_F);
	if (delta) return delta;
	itleft = BlkValueRead(storaleft, STORA_COMMAND_TEXT_F);
	itright = BlkValueRead(storaright, STORA_COMMAND_TEXT_F);
	if ((itleft ~= 0) && (itright ~= 0))
		return TEXT_TY_Support(COMPARE_KOVS, itleft, itright);
	return itleft - itright;
];

[ STORED_ACTION_TY_Distinguish stora1 stora2;
	if (STORED_ACTION_TY_Compare(stora1, stora2) == 0) rfalse;
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! StoredAction.i6t: Hashing
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ STORED_ACTION_TY_Hash stora  rv it;
	rv = BlkValueRead(stora, STORA_ACTION_F);
	rv = rv * 33 + BlkValueRead(stora, STORA_NOUN_F);
	rv = rv * 33 + BlkValueRead(stora, STORA_SECOND_F);
	rv = rv * 33 + BlkValueRead(stora, STORA_ACTOR_F);
	rv = rv * 33 + BlkValueRead(stora, STORA_REQUEST_F);
	it = BlkValueRead(stora, STORA_COMMAND_TEXT_F);
	if (it ~= 0)
		rv = rv * 33 + TEXT_TY_Support(HASH_KOVS, it);
	return rv;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! StoredAction.i6t: Printing
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ STORED_ACTION_TY_Say stora text_of_command saved_command saved_pn saved_action K1 K2 at;
	if ((stora==0) || (BlkValueWeakKind(stora) ~= STORED_ACTION_TY)) return;
	text_of_command = BlkValueRead(stora, STORA_COMMAND_TEXT_F);
	if (text_of_command) {
		saved_command = BlkValueCreate(TEXT_TY);
		BlkValueCast(saved_command, SNIPPET_TY, players_command);
		SetPlayersCommand(text_of_command);
	}
	saved_pn = parsed_number; saved_action = action;
	action = BlkValueRead(stora, STORA_ACTION_F);
	at = FindAction(-1);
	K1 = ActionData-->(at+AD_NOUN_KOV);
	K2 = ActionData-->(at+AD_SECOND_KOV);
	if (K1 ~= OBJECT_TY) {
		parsed_number = BlkValueRead(stora, STORA_NOUN_F);
		if ((K1 == UNDERSTANDING_TY) && (text_of_command == 0)) {
			if (saved_command == 0) saved_command = BlkValueCreate(TEXT_TY);
			BlkValueCast(saved_command, SNIPPET_TY, players_command);
			text_of_command = BlkValueCreate(TEXT_TY);
			BlkValueCopy(text_of_command, parsed_number);
			SetPlayersCommand(text_of_command);
			parsed_number = players_command;
		}
	}
	if (K2 ~= OBJECT_TY) {
		parsed_number = BlkValueRead(stora, STORA_SECOND_F);
		if ((K2 == UNDERSTANDING_TY) && (text_of_command == 0)) {
			if (saved_command == 0) saved_command = BlkValueCreate(TEXT_TY);
			BlkValueCast(saved_command, SNIPPET_TY, players_command);
			text_of_command = BlkValueCreate(TEXT_TY);
			BlkValueCopy(text_of_command, parsed_number);
			SetPlayersCommand(text_of_command);
			parsed_number = players_command;
		}
	}	
	DB_Action(
		BlkValueRead(stora, STORA_ACTOR_F),
		BlkValueRead(stora, STORA_REQUEST_F),
		BlkValueRead(stora, STORA_ACTION_F),
		BlkValueRead(stora, STORA_NOUN_F),
		BlkValueRead(stora, STORA_SECOND_F), true);
	parsed_number = saved_pn; action = saved_action;
	if (text_of_command) {
		SetPlayersCommand(saved_command);
		BlkValueFree(saved_command);
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! StoredAction.i6t: Involvement
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ STORED_ACTION_TY_Involves stora item at;
	at = FindAction(BlkValueRead(stora, STORA_ACTION_F));
	if (at) {
		if ((ActionData-->(at+AD_NOUN_KOV) == OBJECT_TY) &&
			(BlkValueRead(stora, STORA_NOUN_F) == item)) rtrue;
		if ((ActionData-->(at+AD_SECOND_KOV) == OBJECT_TY) &&
			(BlkValueRead(stora, STORA_SECOND_F) == item)) rtrue;
	}
	if (BlkValueRead(stora, STORA_ACTOR_F) == item) rtrue;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! StoredAction.i6t: Nouns
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ STORED_ACTION_TY_Part stora ind at ado;
	if (ind == STORA_NOUN_F or STORA_SECOND_F) {
		if (ind == STORA_NOUN_F) ado = AD_NOUN_KOV; else ado = AD_SECOND_KOV;
		at = FindAction(BlkValueRead(stora, STORA_ACTION_F));
		if ((at) && (ActionData-->(at+ado) == OBJECT_TY)) return BlkValueRead(stora, ind);
		return nothing;
	}
	return BlkValueRead(stora, ind);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! StoredAction.i6t: Pattern Matching
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Array SAT_Tmp-->7;
[ STORED_ACTION_TY_Adopt stora at;
	SAT_Tmp-->1 = action;
	SAT_Tmp-->2 = noun;
	SAT_Tmp-->3 = second;
	SAT_Tmp-->4 = actor;
	SAT_Tmp-->5 = act_requester;
	SAT_Tmp-->6 = parsed_number;
	action = BlkValueRead(stora, STORA_ACTION_F);
	at = FindAction(-1);
	if (ActionData-->(at+AD_NOUN_KOV) == OBJECT_TY)
		noun = BlkValueRead(stora, STORA_NOUN_F);
	else {
		parsed_number = BlkValueRead(stora, STORA_NOUN_F);
		noun = nothing;
	}
	if (ActionData-->(at+AD_SECOND_KOV) == OBJECT_TY)
		second = BlkValueRead(stora, STORA_SECOND_F);
	else {
		parsed_number = BlkValueRead(stora, STORA_SECOND_F);
		second = nothing;
	}
	actor = BlkValueRead(stora, STORA_ACTOR_F);
	if (BlkValueRead(stora, STORA_REQUEST_F)) act_requester = player; else act_requester = nothing;
];

[ STORED_ACTION_TY_Unadopt;
	action = SAT_Tmp-->1;
	noun = SAT_Tmp-->2;
	second = SAT_Tmp-->3;	
	actor = SAT_Tmp-->4;	
	act_requester = SAT_Tmp-->5;
	parsed_number = SAT_Tmp-->6;
	return SAT_Tmp-->0;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! StoredAction.i6t: Current Action
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ STORED_ACTION_TY_Current stora at text_of_command;
	if ((stora==0) || (BlkValueWeakKind(stora) ~= STORED_ACTION_TY)) return 0;
	BlkValueWrite(stora, STORA_ACTION_F, action);
	at = FindAction(-1);

	if (ActionData-->(at+AD_NOUN_KOV) == OBJECT_TY)
		BlkValueWrite(stora, STORA_NOUN_F, noun);
	else
		BlkValueWrite(stora, STORA_NOUN_F, parsed_number);
	if (ActionData-->(at+AD_SECOND_KOV) == OBJECT_TY)
		BlkValueWrite(stora, STORA_SECOND_F, second);
	else
		BlkValueWrite(stora, STORA_SECOND_F, parsed_number);
	BlkValueWrite(stora, STORA_ACTOR_F, actor);
	if (act_requester) BlkValueWrite(stora, STORA_REQUEST_F, true);
	else BlkValueWrite(stora, STORA_REQUEST_F, false);

	if ((at) && ((ActionData-->(at+AD_NOUN_KOV) == UNDERSTANDING_TY) ||
			(ActionData-->(at+AD_SECOND_KOV) == UNDERSTANDING_TY))) {
		text_of_command = BlkValueRead(stora, STORA_COMMAND_TEXT_F);
		if (text_of_command == 0) {
			text_of_command = BlkValueCreate(TEXT_TY);
			BlkValueWrite(stora, STORA_COMMAND_TEXT_F, text_of_command);
		}
		BlkValueCast(text_of_command, SNIPPET_TY, players_command);
	} else BlkValueWrite(stora, STORA_COMMAND_TEXT_F, 0);

	return stora;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! StoredAction.i6t: Trying
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ STORED_ACTION_TY_Try stora ks  text_of_command saved_command;
	if ((stora==0) || (BlkValueWeakKind(stora) ~= STORED_ACTION_TY)) return;
	if (ks) { @push keep_silent; keep_silent=1; }
	text_of_command = BlkValueRead(stora, STORA_COMMAND_TEXT_F);
	if (text_of_command) {
		saved_command = BlkValueCreate(TEXT_TY);
		BlkValueCast(saved_command, SNIPPET_TY, players_command);
		SetPlayersCommand(text_of_command);
	}
	TryAction(
		BlkValueRead(stora, STORA_REQUEST_F),
		BlkValueRead(stora, STORA_ACTOR_F),
		BlkValueRead(stora, STORA_ACTION_F),
		BlkValueRead(stora, STORA_NOUN_F),
		BlkValueRead(stora, STORA_SECOND_F));
	if (text_of_command) {
		SetPlayersCommand(saved_command);
		BlkValueFree(saved_command);
	}
	if (ks) { @pull keep_silent; }
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: Block Format
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant LIST_ITEM_KOV_F = 0; ! The kind of the items
Constant LIST_LENGTH_F = 1;   ! The number of items
Constant LIST_ITEM_BASE = 2;  ! List items begin at this entry


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: KOV Support
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LIST_OF_TY_Support task arg1 arg2 arg3;
	switch(task) {
		CREATE_KOVS:      return LIST_OF_TY_Create(arg1, arg2);
		DESTROY_KOVS:     LIST_OF_TY_Destroy(arg1);
		MAKEMUTABLE_KOVS: return 1;
		COPYKIND_KOVS:    return LIST_OF_TY_CopyKind(arg1, arg2);
		COPYQUICK_KOVS:   return LIST_OF_TY_QuickCopy(arg1, arg2);
		COPYSB_KOVS:	  BlkValueCopySB1(arg1, arg2);
		KINDDATA_KOVS:    return LIST_OF_TY_KindData(arg1, arg2);
		EXTENT_KOVS:      return BlkValueRead(arg1, LIST_LENGTH_F) + LIST_ITEM_BASE;
		COPY_KOVS:        LIST_OF_TY_Copy(arg1, arg2, arg3);
		COMPARE_KOVS:     return LIST_OF_TY_Compare(arg1, arg2);
		HASH_KOVS:        return LIST_OF_TY_Hash(arg1);
		DEBUG_KOVS:       print " = {", (LIST_OF_TY_Say) arg1, "} of kind ",
                              BlkValueRead(arg1, LIST_ITEM_KOV_F);
	}
	! We choose not to respond to: CAST_KOVS, READ_FILE_KOVS, WRITE_FILE_KOVS
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: Creation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LIST_OF_TY_Create skov sb list;
	skov = KindBaseTerm(skov, 0);
	list = FlexAllocate(27*WORDSIZE, LIST_OF_TY, BLK_FLAG_MULTIPLE + BLK_FLAG_WORD);
	BlkValueWrite(list, LIST_ITEM_KOV_F, skov, true);
	BlkValueWrite(list, LIST_LENGTH_F, 0, true);
	sb = BlkValueCreateSB1(sb, list);
	return sb;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: Destruction
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LIST_OF_TY_Destroy list no_items i k;
	k = BlkValueRead(list, LIST_ITEM_KOV_F);
	if (KOVIsBlockValue(k)) {
		no_items = BlkValueRead(list, LIST_LENGTH_F);
		for (i=0: i<no_items: i++) BlkValueFree(BlkValueRead(list, i+LIST_ITEM_BASE));
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: Copying
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LIST_OF_TY_CopyKind to from;
	BlkValueWrite(to, LIST_ITEM_KOV_F, BlkValueRead(from, LIST_ITEM_KOV_F));
];

[ LIST_OF_TY_QuickCopy to from;
	if (BlkValueRead(to, LIST_ITEM_KOV_F) ~= BlkValueRead(from, LIST_ITEM_KOV_F))
		rfalse;
	rtrue;
];

[ LIST_OF_TY_KindData list;
	return BlkValueRead(list, LIST_ITEM_KOV_F);
];

[ LIST_OF_TY_Copy lto lfrom  precopied_list_kov no_items i nv bk val splk;
	no_items = BlkValueRead(lfrom, LIST_LENGTH_F);
	bk = BlkValueRead(lfrom, LIST_ITEM_KOV_F);
	if (precopied_list_kov ~= 0 or UNKNOWN_TY)
		BlkValueWrite(lto, LIST_ITEM_KOV_F, precopied_list_kov);
	else BlkValueWrite(lto, LIST_ITEM_KOV_F, bk);
	if (KOVIsBlockValue(bk)) {
		for (i=0: i<no_items: i++) {
			val = BlkValueRead(lfrom, i+LIST_ITEM_BASE);
			if (precopied_list_kov ~= 0 or UNKNOWN_TY)
				nv = BlkValueCreate(precopied_list_kov);
			else
				nv = BlkValueCreate(bk);
			BlkValueCopy(nv, val);
			BlkValueWrite(lto, i+LIST_ITEM_BASE, nv);
		}
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: Comparison
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LIST_OF_TY_Compare listleft listright delta no_items i cf;
	delta = BlkValueRead(listleft, LIST_LENGTH_F) - BlkValueRead(listright, LIST_LENGTH_F);
	if (delta) return delta;
	no_items = BlkValueRead(listleft, LIST_LENGTH_F);
	if (no_items == 0) return 0;
	delta = BlkValueRead(listleft, LIST_ITEM_KOV_F) - BlkValueRead(listright, LIST_ITEM_KOV_F);
	if (delta) return delta;
	cf = LIST_OF_TY_ComparisonFn(listleft);
	if (cf == 0 or UnsignedCompare) {
		for (i=0: i<no_items: i++) {
			delta = BlkValueRead(listleft, i+LIST_ITEM_BASE) -
				BlkValueRead(listright, i+LIST_ITEM_BASE);
			if (delta) return delta;
		}
	} else {
		for (i=0: i<no_items: i++) {
			delta = cf(BlkValueRead(listleft, i+LIST_ITEM_BASE),
				BlkValueRead(listright, i+LIST_ITEM_BASE));
			if (delta) return delta;
		}
	}
	return 0;
];

[ LIST_OF_TY_ComparisonFn list;
	if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) return 0;
	return KOVComparisonFunction(BlkValueRead(list, LIST_ITEM_KOV_F));
];

[ LIST_OF_TY_Distinguish txb1 txb2;
	if (LIST_OF_TY_Compare(txb1, txb2) == 0) rfalse;
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: Hashing
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LIST_OF_TY_Hash list  len kov rv i;
	rv = 0;
	len = BlkValueRead(list, LIST_LENGTH_F);
	kov = BlkValueRead(list, LIST_ITEM_KOV_F);
	for (i=0: i<len: i++)
		rv = rv * 33 + GetHashValue(kov, BlkValueRead(list, i+LIST_ITEM_BASE));
	return rv;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: Printing
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LIST_OF_TY_Say list format no_items v i bk;
	if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) return;
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	bk = KindAtomic(BlkValueRead(list, LIST_ITEM_KOV_F));
	! print no_items, " of kov=", BlkValueRead(list, LIST_ITEM_KOV_F), ":";
	if (format == 1) print "{";
	for (i=0:i<no_items:i++) {
		v = BlkValueRead(list, i+LIST_ITEM_BASE);
		switch (format) {
			2: print (the) v;
			3: print (a) v;
			default:
				if (bk == LIST_OF_TY) LIST_OF_TY_Say(v, 1);
				else if ((bk == TEXT_TY) && (format == 1)) {
					print "~"; PrintKindValuePair(bk, v); print "~";
				}
				else PrintKindValuePair(bk, v);
		}
		if (i<no_items-2) print ", ";
		if (i==no_items-2) {
			if (format == 1) print ", "; else {
				#ifdef SERIAL_COMMA; if (no_items ~= 2) print ","; #endif;
				LIST_WRITER_INTERNAL_RM('C');
			}
		}
	}
	if (format == 1) print "}";
	prior_named_list = no_items; prior_named_list_gender = -1;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: List From Description
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LIST_OF_TY_Desc list desc kov obj no_items ex len i;
	if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) return false;
	ex = BlkValueLBCapacity(list);
	len = desc(-3);
	if (len+LIST_ITEM_BASE > ex) {
		if (BlkValueSetLBCapacity(list, len+LIST_ITEM_BASE) == false)
			return 0;
	}
	if (kov) BlkValueWrite(list, LIST_ITEM_KOV_F, kov);
	else BlkValueWrite(list, LIST_ITEM_KOV_F, OBJECT_TY);
	BlkValueWrite(list, LIST_LENGTH_F, len);
	obj = 0;
	for (i=0: i<len: i++) {
		obj = desc(-2, obj, i);
		! print "i = ", i, " and obj = ", obj, "^";
		BlkValueWrite(list, i+LIST_ITEM_BASE, obj);
	}
	return list;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: Find Item
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LIST_OF_TY_FindItem list v i no_items cf;
	if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) rfalse;
	cf = LIST_OF_TY_ComparisonFn(list);
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	if (cf == 0 or UnsignedCompare) {
		for (i=0: i<no_items: i++)
			if (v == BlkValueRead(list, i+LIST_ITEM_BASE)) rtrue;
	} else {
		for (i=0: i<no_items: i++)
			if (cf(v, BlkValueRead(list, i+LIST_ITEM_BASE)) == 0) rtrue;
	}
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: Insert Item
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LIST_OF_TY_InsertItem list v posnflag posn nodups i no_items ex nv contents_kind;
	if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) return false;
	if (nodups && (LIST_OF_TY_FindItem(list, v))) return list;
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	contents_kind = BlkValueRead(list, LIST_ITEM_KOV_F);
	if ((posnflag) && ((posn<1) || (posn > no_items+1))) {
		print "*** Couldn't add at entry ", posn, " in the list ";
		LIST_OF_TY_Say(list, true);
		print ", which has entries in the range 1 to ", no_items, " ***^";
		RunTimeProblem(RTP_LISTRANGEERROR);
		rfalse;
	}
	ex = BlkValueLBCapacity(list);
	if (no_items+LIST_ITEM_BASE+1 > ex) {
		if (BlkValueSetLBCapacity(list, ex+16) == false) return 0;
	}
	if (KOVIsBlockValue(contents_kind)) {
		nv = BlkValueCreate(contents_kind);
		BlkValueCopy(nv, v);
		v = nv;
	}
	if (posnflag) {
		posn--;
		for (i=no_items:i>posn:i--) {
			BlkValueWrite(list, i+LIST_ITEM_BASE,
				BlkValueRead(list, i-1+LIST_ITEM_BASE));			
		}
		BlkValueWrite(list, posn+LIST_ITEM_BASE, v);
	} else {
		BlkValueWrite(list, no_items+LIST_ITEM_BASE, v);
	}
	BlkValueWrite(list, LIST_LENGTH_F, no_items+1);
	return list;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: Append List
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LIST_OF_TY_AppendList list more posnflag posn nodups v i j no_items msize ex nv;
	if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) return false;
	if ((more==0) || (BlkValueWeakKind(more) ~= LIST_OF_TY)) return list;
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	if ((posnflag) && ((posn<1) || (posn > no_items+1))) {
		print "*** Couldn't add at entry ", posn, " in the list ";
		LIST_OF_TY_Say(list, true);
		print ", which has entries in the range 1 to ", no_items, " ***^";
		RunTimeProblem(RTP_LISTRANGEERROR);
		rfalse;
	}
	msize = BlkValueRead(more, LIST_LENGTH_F);
	ex = BlkValueLBCapacity(list);
	if (no_items+msize+LIST_ITEM_BASE > ex) {
		if (BlkValueSetLBCapacity(list, no_items+msize+LIST_ITEM_BASE+8) == false)
			return 0;
	}
	if (posnflag) {
		posn--;
		for (i=no_items+msize:i>=posn+msize:i--) {
			BlkValueWrite(list, i+LIST_ITEM_BASE,
				BlkValueRead(list, i-msize+LIST_ITEM_BASE));			
		}
		! BlkValueWrite(list, posn, v);
		for (j=0: j<msize: j++) {
			v = BlkValueRead(more, j+LIST_ITEM_BASE);
			if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F))) {
				nv = BlkValueCreate(BlkValueRead(list, LIST_ITEM_KOV_F));
				BlkValueCopy(nv, v);
				v = nv;
			}
			BlkValueWrite(list, posn+j+LIST_ITEM_BASE, v);
		}
	} else {
		for (i=0, j=0: i<msize: i++) {
			v = BlkValueRead(more, i+LIST_ITEM_BASE);
			if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F))) {
				nv = BlkValueCreate(BlkValueRead(list, LIST_ITEM_KOV_F));
				BlkValueCopy(nv, v);
				v = nv;
			}
			if ((nodups == 0) || (LIST_OF_TY_FindItem(list, v) == false)) {
				BlkValueWrite(list, no_items+j+LIST_ITEM_BASE, v);
				j++;
			}
		}
	}
	BlkValueWrite(list, LIST_LENGTH_F, no_items+j);
	return list;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: Remove Value
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LIST_OF_TY_RemoveValue list v forgive i j no_items odsize f cf delendum;
	if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) rfalse;
	cf = LIST_OF_TY_ComparisonFn(list);
	no_items = BlkValueRead(list, LIST_LENGTH_F); odsize = no_items;
	for (i=0: i<no_items: i++) {
		delendum = BlkValueRead(list, i+LIST_ITEM_BASE);
		if (cf == 0 or UnsignedCompare)
			f = (v == delendum);
		else
			f = (cf(v, delendum) == 0);
		if (f) {
			if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F)))
				BlkValueFree(delendum);
			for (j=i+1: j<no_items: j++)
				BlkValueWrite(list, j-1+LIST_ITEM_BASE,
					BlkValueRead(list, j+LIST_ITEM_BASE));
			no_items--; i--;
			BlkValueWrite(list, LIST_LENGTH_F, no_items);
		}
	}
	if (odsize ~= no_items) rfalse;
	if (forgive) rfalse;
	print "*** Couldn't remove: the value ";
	PrintKindValuePair(BlkValueRead(list, LIST_ITEM_KOV_F), v);
	print " was not present in the list ";
	LIST_OF_TY_Say(list, true);
	print " ***^";
	RunTimeProblem(RTP_LISTRANGEERROR);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: Remove Item Range
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LIST_OF_TY_RemoveItemRange list from to forgive i d no_items;
	if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) rfalse;
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	if ((from > to) || (from <= 0) || (to > no_items)) {
		if (forgive) {
			if (from <= 0) from = 1;
			if (to >= no_items) to = no_items;
			if (from > to) return list;
		} else {
			print "*** Couldn't remove entries ", from, " to ", to, " from the list ";
			LIST_OF_TY_Say(list, true);
			print ", which has entries in the range 1 to ", no_items, " ***^";
			RunTimeProblem(RTP_LISTRANGEERROR);
			rfalse;
		}
	}
	to--; from--;
	d = to-from+1;
	if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F)))
		for (i=0: i<d: i++)
			BlkValueFree(BlkValueRead(list, from+i+LIST_ITEM_BASE));
	for (i=from: i<no_items-d: i++)
		BlkValueWrite(list, i+LIST_ITEM_BASE,
			BlkValueRead(list, i+d+LIST_ITEM_BASE));
	BlkValueWrite(list, LIST_LENGTH_F, no_items-d);
	return list;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: Remove List
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LIST_OF_TY_Remove_List list rlist i j k v w no_items odsize rsize cf f;
	if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) rfalse;
	no_items = BlkValueRead(list, LIST_LENGTH_F); odsize = no_items;
	rsize = BlkValueRead(rlist, LIST_LENGTH_F);
	cf = LIST_OF_TY_ComparisonFn(list);
	for (i=0: i<no_items: i++) {
		v = BlkValueRead(list, i+LIST_ITEM_BASE);
		for (k=0: k<rsize: k++) {
			w = BlkValueRead(rlist, k+LIST_ITEM_BASE);
			if (cf == 0 or UnsignedCompare)
				f = (v == w);
			else
				f = (cf(v, w) == 0);
			if (f) {
				if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F)))
					BlkValueFree(v);
				for (j=i+1: j<no_items: j++)
					BlkValueWrite(list, j+LIST_ITEM_BASE-1, 
						BlkValueRead(list, j+LIST_ITEM_BASE));
				no_items--; i--;
				BlkValueWrite(list, LIST_LENGTH_F, no_items);
				break;
			}
		}
	}
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: Get Length
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LIST_OF_TY_GetLength list;
	if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) return 0;
	return BlkValueRead(list, LIST_LENGTH_F);
];

[ LIST_OF_TY_Empty list;
	if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) rfalse;
	if (BlkValueRead(list, LIST_LENGTH_F) == 0) rtrue;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: Set Length
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LIST_OF_TY_SetLength list newsize this_way_only truncation_end no_items ex i dv;
	if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) return 0;
	if (newsize < 0) "*** Cannot resize a list to negative length ***";
	BlkMakeMutable(list);
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	if (no_items < newsize) {
		if (this_way_only == -1) return list;
		ex = BlkValueLBCapacity(list);
		if (newsize+LIST_ITEM_BASE > ex) {
			if (BlkValueSetLBCapacity(list, newsize+LIST_ITEM_BASE) == false)
				return 0;
		}
		dv = DefaultValueOfKOV(BlkValueRead(list, LIST_ITEM_KOV_F));
		for (i=no_items: i<newsize: i++)
			BlkValueWrite(list, LIST_ITEM_BASE+i, dv);
		BlkValueWrite(list, LIST_LENGTH_F, newsize);
	}
	if (no_items > newsize) {
		if (this_way_only == 1) return list;
		if (truncation_end == -1) {
			if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F)))
				for (i=0: i<no_items-newsize: i++)
					BlkValueFree(BlkValueRead(list, LIST_ITEM_BASE+i));
			for (i=0: i<newsize: i++)
				BlkValueWrite(list, LIST_ITEM_BASE+i,
					BlkValueRead(list, LIST_ITEM_BASE+no_items-newsize+i));
		} else {
			if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F)))
				for (i=newsize: i<no_items: i++)
					BlkValueFree(BlkValueRead(list, LIST_ITEM_BASE+i));
		}
		BlkValueWrite(list, LIST_LENGTH_F, newsize);
	}
	return list;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: Get Item
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LIST_OF_TY_GetItem list i forgive no_items;
	if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) return false;
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	if ((i<=0) || (i>no_items)) {
		if (forgive) return false;
		print "*** Couldn't read from entry ", i, " of a list which";
		switch (no_items) {
			0: print " is empty ***^";
			1: print " has only one entry, numbered 1 ***^";
			default: print " has entries numbered from 1 to ", no_items, " ***^";
		}
		RunTimeProblem(RTP_LISTRANGEERROR);
		if (no_items >= 1) i = 1;
		else return false;
	}
	return BlkValueRead(list, LIST_ITEM_BASE+i-1);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: Write Item
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ WriteLIST_OF_TY_GetItem list i val no_items;
	if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) return false;
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	if ((i<=0) || (i>no_items)) {
		print "*** Couldn't write to list entry ", i, " of a list which";
		switch (no_items) {
			0: print " is empty ***^";
			1: print " has only one entry, numbered 1 ***^";
			default: print " has entries numbered from 1 to ", no_items, " ***^";
		}
		return RunTimeProblem(RTP_LISTRANGEERROR);
	}
	BlkValueWrite(list, LIST_ITEM_BASE+i-1, val);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: Put Item
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LIST_OF_TY_PutItem list i v  no_items nv;
	if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) return false;
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F))) {
		nv = BlkValueCreate(BlkValueRead(list, LIST_ITEM_KOV_F));
		BlkValueCopy(nv, v);
		v = nv;
	}
	if ((i<=0) || (i>no_items)) return false;
	BlkValueWrite(list, LIST_ITEM_BASE+i-1, v);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: Multiple Object List
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LIST_OF_TY_Mol list len i;
	if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) return 0;
	len = multiple_object-->0;
	LIST_OF_TY_SetLength(list, len);
	for (i=1: i<=len: i++)
		LIST_OF_TY_PutItem(list, i, multiple_object-->i);
	return list;
];

[ LIST_OF_TY_Set_Mol list len i;
	if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) return 0;
	len = BlkValueRead(list, LIST_LENGTH_F);
	if (len > 63) len = 63;
	multiple_object-->0 = len;
	for (i=1: i<=len: i++)
		multiple_object-->i = BlkValueRead(list, LIST_ITEM_BASE+i-1);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: Reversing
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LIST_OF_TY_Reverse list no_items i v;
	if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) return 0;
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	if (no_items < 2) return list;
	for (i=0:i*2<no_items:i++) {
		v = BlkValueRead(list, LIST_ITEM_BASE+i);
		BlkValueWrite(list, LIST_ITEM_BASE+i,
			BlkValueRead(list, LIST_ITEM_BASE+no_items-1-i));
		BlkValueWrite(list, LIST_ITEM_BASE+no_items-1-i, v);
	}
	return list;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: Rotation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LIST_OF_TY_Rotate list backwards  no_items i v;
	if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) return 0;
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	if (no_items < 2) return list;
	if (backwards) {
		v = BlkValueRead(list, LIST_ITEM_BASE);
		for (i=0:i<no_items-1:i++)
			BlkValueWrite(list, LIST_ITEM_BASE+i,
				BlkValueRead(list, LIST_ITEM_BASE+i+1));
		BlkValueWrite(list, no_items-1+LIST_ITEM_BASE, v);
	} else {
		v = BlkValueRead(list, no_items-1+LIST_ITEM_BASE);
		for (i=no_items-1:i>0:i--)
			BlkValueWrite(list, LIST_ITEM_BASE+i,
				BlkValueRead(list, LIST_ITEM_BASE+i-1));
		BlkValueWrite(list, LIST_ITEM_BASE, v);
	}
	return list;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: Sorting
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Global LIST_OF_TY_Sort_cf;

[ LIST_OF_TY_Sort list dir prop cf  i j no_items v;
	BlkMakeMutable(list);
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	if (dir == 2) {
		if (no_items < 2) return;
		for (i=1:i<no_items:i++) {
			j = random(i+1) - 1;
			v = BlkValueRead(list, LIST_ITEM_BASE+i);
			BlkValueWrite(list, LIST_ITEM_BASE+i, BlkValueRead(list, LIST_ITEM_BASE+j));
			BlkValueWrite(list, LIST_ITEM_BASE+j, v);
		}
		return;
	}
	SetSortDomain(ListSwapEntries, ListCompareEntries);
	if (cf) LIST_OF_TY_Sort_cf = BlkValueCompare;
	else LIST_OF_TY_Sort_cf = 0;
	SortArray(list, prop, dir, no_items, false, 0);
];

[ ListSwapEntries list i j v;
	if (i==j) return;
	v = BlkValueRead(list, LIST_ITEM_BASE+i-1);
	BlkValueWrite(list, LIST_ITEM_BASE+i-1, BlkValueRead(list, LIST_ITEM_BASE+j-1));
	BlkValueWrite(list, LIST_ITEM_BASE+j-1, v);
];

[ ListCompareEntries list col i j d cf;
	if (i==j) return 0;
	i = BlkValueRead(list, LIST_ITEM_BASE+i-1);
	j = BlkValueRead(list, LIST_ITEM_BASE+j-1);
	if (I7S_Col) {
		if (i provides I7S_Col) i=i.I7S_Col; else i=0;
		if (j provides I7S_Col) j=j.I7S_Col; else j=0;
		cf = LIST_OF_TY_Sort_cf;
	} else {
		cf = LIST_OF_TY_ComparisonFn(list);
	}
	if (cf == 0) {
		if (i > j) return 1;
		if (i < j) return -1;
		return 0;
	} else
		return cf(i, j);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Combinations.i6t: Block Format
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant COMBINATION_KIND_F = 0;    ! Strong kind ID
Constant COMBINATION_ITEM_BASE = 1; ! List items begin at this entry


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Combinations.i6t: KOV Support
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ COMBINATION_TY_Support task arg1 arg2 arg3;
	switch(task) {
		CREATE_KOVS:      return COMBINATION_TY_Create(arg1, arg2);
		DESTROY_KOVS:     COMBINATION_TY_Destroy(arg1);
		MAKEMUTABLE_KOVS: return 1;
		COPYKIND_KOVS:    return COMBINATION_TY_CopyKind(arg1, arg2);
		COPYQUICK_KOVS:   rtrue;
		COPYSB_KOVS:	  BlkValueCopySB1(arg1, arg2);
		KINDDATA_KOVS:    return COMBINATION_TY_KindData(arg1);
		EXTENT_KOVS:      return -1;
		COPY_KOVS:        COMBINATION_TY_Copy(arg1, arg2, arg3);
		COMPARE_KOVS:     return COMBINATION_TY_Compare(arg1, arg2);
		HASH_KOVS:        return COMBINATION_TY_Hash(arg1);
		DEBUG_KOVS:       print " = ", (COMBINATION_TY_Say) arg1;
	}
	! We choose not to respond to: CAST_KOVS, READ_FILE_KOVS, WRITE_FILE_KOVS
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Combinations.i6t: Creation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ COMBINATION_TY_Create kind sb long_block N i bk v;
	N = KindBaseArity(kind);
	long_block = FlexAllocate(
		(COMBINATION_ITEM_BASE+N)*WORDSIZE, COMBINATION_TY, BLK_FLAG_WORD);
	BlkValueWrite(long_block, COMBINATION_KIND_F, kind, true);
	for (i=0: i<N: i++) {
		bk = KindBaseTerm(kind, i);
		if (KOVIsBlockValue(bk)) v = BlkValueCreate(bk);
		else v = DefaultValueOfKOV(bk);
		BlkValueWrite(long_block, COMBINATION_ITEM_BASE+i, v, true);
	}
	return BlkValueCreateSB1(sb, long_block);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Combinations.i6t: Destruction
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ COMBINATION_TY_Destroy comb kind no_items i bk;
	kind = BlkValueRead(comb, COMBINATION_KIND_F);
	no_items = KindBaseArity(kind);
	for (i=0: i<no_items: i++) {
		bk = KindBaseTerm(kind, i);
		if (KOVIsBlockValue(bk))
			BlkValueFree(BlkValueRead(comb, i+COMBINATION_ITEM_BASE));
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Combinations.i6t: Copying
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ COMBINATION_TY_CopyKind to from;
	BlkValueWrite(to, COMBINATION_KIND_F, BlkValueRead(from, COMBINATION_KIND_F));
];

[ COMBINATION_TY_CopySB to from;
	BlkValueCopySB1(to, from);
];

[ COMBINATION_TY_KindData comb;
	return BlkValueRead(comb, COMBINATION_KIND_F);
];

[ COMBINATION_TY_Copy to_comb from_comb precopied_comb_kov  no_items i nv kind bk;
	! kind = BlkValueRead(to_comb, COMBINATION_KIND_F);
	no_items = KindBaseArity(precopied_comb_kov);
	BlkValueWrite(to_comb, COMBINATION_KIND_F, precopied_comb_kov);
	for (i=0: i<no_items: i++) {
		bk = KindBaseTerm(kind, i);
		if (KOVIsBlockValue(bk)) {
			nv = BlkValueCreate(bk);
			BlkValueCopy(nv, BlkValueRead(from_comb, i+COMBINATION_ITEM_BASE));
			BlkValueWrite(to_comb, i+COMBINATION_ITEM_BASE, nv);
		}
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Combinations.i6t: Comparison
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ COMBINATION_TY_Compare left_comb right_comb delta no_items i cf kind bk;
	kind = BlkValueRead(left_comb, COMBINATION_KIND_F);
	no_items = KindBaseArity(kind);
	for (i=0: i<no_items: i++) {
		bk = KindBaseTerm(kind, i);
		cf = KOVComparisonFunction(bk);
		if (cf == 0 or UnsignedCompare) {
			delta = BlkValueRead(left_comb, i+COMBINATION_ITEM_BASE) -
				BlkValueRead(right_comb, i+COMBINATION_ITEM_BASE);
			if (delta) return delta;
		} else {
			delta = cf(BlkValueRead(left_comb, i+COMBINATION_ITEM_BASE),
				BlkValueRead(right_comb, i+COMBINATION_ITEM_BASE));
			if (delta) return delta;
		}
	}
	return 0;
];

[ COMBINATION_TY_Distinguish left_comb right_comb;
	if (COMBINATION_TY_Compare(left_comb, right_comb) == 0) rfalse;
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Combinations.i6t: Hashing
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ COMBINATION_TY_Hash comb  kind rv no_items i bk;
	rv = 0;
	kind = BlkValueRead(comb, COMBINATION_KIND_F);
	no_items = KindBaseArity(kind);
	for (i=0: i<no_items: i++) {
		bk = KindBaseTerm(kind, i);
		rv = rv * 33 + GetHashValue(bk, BlkValueRead(comb, i+COMBINATION_ITEM_BASE));
	}
	return rv;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Combinations.i6t: Printing
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ COMBINATION_TY_Say comb format no_items v i kind bk;
	if ((comb==0) || (BlkValueWeakKind(comb) ~= COMBINATION_TY)) return;
	kind = BlkValueRead(comb, COMBINATION_KIND_F);
	no_items = KindBaseArity(kind);
	print "(";
	for (i=0: i<no_items: i++) {
		if (i>0) print ", ";
		bk = KindBaseTerm(kind, i);
		v = BlkValueRead(comb, i+COMBINATION_ITEM_BASE);
		if (bk == LIST_OF_TY) LIST_OF_TY_Say(v, 1);
		else PrintKindValuePair(bk, v);
	}
	print ")";
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: Block Format
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant RRV_NAME     		RR_NAME-5;        ! Packed string, e.g. "containment relation"
Constant RRV_PERMISSIONS	RR_PERMISSIONS-5; ! A bitmap of what operations this supports
Constant RRV_STORAGE		RR_STORAGE-5;     ! Data location, depending on format
Constant RRV_KIND			RR_KIND-5;        ! Strong kind ID of the relation
Constant RRV_HANDLER		RR_HANDLER-5;     ! Routine to perform operations on this
Constant RRV_DESCRIPTION	RR_DESCRIPTION-5; ! Packed string, e.g. "contains"
Constant RRV_USED			6;
Constant RRV_FILLED			7;
Constant RRV_DATA_BASE		8;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: KOV Support
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ RELATION_TY_Support task arg1 arg2 arg3;
	switch(task) {
		CREATE_KOVS:      return RELATION_TY_Create(arg1, 0, arg2);
		DESTROY_KOVS:     RELATION_TY_Destroy(arg1);
		MAKEMUTABLE_KOVS: return 1;
		COPYQUICK_KOVS:   rtrue;
		COPYSB_KOVS:	  BlkValueCopySB1(arg1, arg2);
		KINDDATA_KOVS:    return 0;
		EXTENT_KOVS:      return -1;
		COPY_KOVS:        RELATION_TY_Copy(arg1, arg2);
		COMPARE_KOVS:     return RELATION_TY_Compare(arg1, arg2);
		HASH_KOVS:        return arg1;
		DEBUG_KOVS:       print " = ", (RELATION_TY_Say) arg1;
	}
	! We choose not to respond to: CAST_KOVS, COPYKIND_KOVS, READ_FILE_KOVS, WRITE_FILE_KOVS
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: Other Definitions
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

! valencies
Constant RRVAL_V_TO_V		0;
Constant RRVAL_V_TO_O		RELS_Y_UNIQUE;
Constant RRVAL_O_TO_V		RELS_X_UNIQUE;
Constant RRVAL_O_TO_O		RELS_X_UNIQUE+RELS_Y_UNIQUE;
Constant RRVAL_EQUIV		RELS_EQUIVALENCE+RELS_SYMMETRIC;
Constant RRVAL_SYM_V_TO_V	RELS_SYMMETRIC;
Constant RRVAL_SYM_O_TO_O	RELS_SYMMETRIC+RELS_X_UNIQUE+RELS_Y_UNIQUE;

! dictionary entry flags
Constant RRF_USED		$0001;	! entry contains a value
Constant RRF_DELETED	$0002;	! entry used to contain a value
Constant RRF_SINGLE		$0004;	! entry's Y is a value, not a list
Constant RRF_HASX		$0010;	! 2-in-1 entry contains a corresponding key
Constant RRF_HASY		$0020;	! 2-in-1 entry contains a corresponding value
Constant RRF_ENTKEYX	$0040;	! 2-in-1 entry key is left side KOV
Constant RRF_ENTKEYY	$0080;	! 2-in-1 entry key is right side KOV

! permission/task constants (those commented out here are generated by I7)
!Constant RELS_SYMMETRIC $8000;
!Constant RELS_EQUIVALENCE $4000;
!Constant RELS_X_UNIQUE $2000;
!Constant RELS_Y_UNIQUE $1000;
!Constant RELS_TEST $0800;
!Constant RELS_ASSERT_TRUE $0400;
!Constant RELS_ASSERT_FALSE $0200;
!Constant RELS_SHOW $0100;
!Constant RELS_ROUTE_FIND $0080;
!Constant RELS_ROUTE_FIND_COUNT $0040;
Constant RELS_COPY $0020;
Constant RELS_DESTROY $0010;
!Constant RELS_LOOKUP_ANY $0008;
!Constant RELS_LOOKUP_ALL_X $0004;
!Constant RELS_LOOKUP_ALL_Y $0002;
!Constant RELS_LIST $0001;

Constant RELS_EMPTY $0003;
Constant RELS_SET_VALENCY $0005;

! RELS_LOOKUP_ANY mode selection constants
Constant RLANY_GET_X 1;
Constant RLANY_GET_Y 2;
Constant RLANY_CAN_GET_X 3;
Constant RLANY_CAN_GET_Y 4;

! RELS_LIST mode selection constant
Constant RLIST_ALL_X 1;
Constant RLIST_ALL_Y 2;
Constant RLIST_ALL_PAIRS 3;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: Tunable Parameters
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant RRP_MIN_SIZE      8;   ! minimum number of entries (DO NOT CHANGE)
Constant RRP_PERTURB_SHIFT 5;   ! affects the probe sequence
Constant RRP_RESIZE_SMALL  4;   ! resize factor for small tables
Constant RRP_RESIZE_LARGE  2;   ! resize factor for large tables
Constant RRP_LARGE_IS      256; ! how many entries make a table "large"?
Constant RRP_CROWDED_IS    2;   ! when filled entries outnumber unfilled by _ to 1


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: Abstract Relations
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ RelationTest relation task X Y  handler rv;
	handler = RlnGetF(relation, RR_HANDLER);
	return handler(relation, task, X, Y);
];

[ RlnGetF rel fld i;
	rel = BlkValueGetLongBlock(rel);
	return rel-->fld;
];

[ RlnSetF rel fld v;
	rel = BlkValueGetLongBlock(rel);
	rel-->fld = v;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: Empty Relations
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ EmptyRelationHandler relation task X Y;
	if (task == RELS_EMPTY) rtrue;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: Creation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ RELATION_TY_Create kov from sb rel i skov handler;
	rel = FlexAllocate((RRV_DATA_BASE + 3*RRP_MIN_SIZE)*WORDSIZE,
		RELATION_TY, BLK_FLAG_WORD+BLK_FLAG_MULTIPLE);
	if ((from == 0) && (kov ~= 0)) from = DefaultValueFinder(kov);
	if (from) {
		for (i=0: i<RRV_DATA_BASE: i++) BlkValueWrite(rel, i, BlkValueRead(from, i), true);
		if (BlkValueRead(from, RRV_HANDLER) == EmptyRelationHandler) {
			handler = ChooseRelationHandler(BlkValueRead(rel, RRV_KIND, true));
			BlkValueWrite(rel, RRV_NAME, "anonymous relation", true);
			BlkValueWrite(rel, RRV_PERMISSIONS,
				RELS_TEST+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_SHOW, true);
			BlkValueWrite(rel, RRV_HANDLER, handler, true);
			BlkValueWrite(rel, RRV_STORAGE, RRP_MIN_SIZE-1, true);
			BlkValueWrite(rel, RRV_DESCRIPTION, "an anonymous relation", true);
			BlkValueWrite(rel, RRV_USED, 0, true);
			BlkValueWrite(rel, RRV_FILLED, 0, true);
		}
	} else {
		handler = ChooseRelationHandler(kov);
		BlkValueWrite(rel, RRV_NAME, "anonymous relation", true);
		BlkValueWrite(rel, RRV_PERMISSIONS,
			RELS_TEST+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_SHOW, true);
		BlkValueWrite(rel, RRV_STORAGE, RRP_MIN_SIZE-1, true);
		BlkValueWrite(rel, RRV_KIND, kov, true);
		BlkValueWrite(rel, RRV_HANDLER, handler, true);
		BlkValueWrite(rel, RRV_DESCRIPTION, "an anonymous relation", true);
		BlkValueWrite(rel, RRV_USED, 0, true);
		BlkValueWrite(rel, RRV_FILLED, 0, true);
	}

	return BlkValueCreateSB1(sb, rel);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: Destruction
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ RELATION_TY_Destroy rel  handler;
	handler = BlkValueRead(rel, RRV_HANDLER);
	handler(rel, RELS_DESTROY);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: Copying
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ RELATION_TY_Copy lto lfrom  handler;
	handler = BlkValueRead(lto, RRV_HANDLER);
	handler(lto, RELS_COPY);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: Comparison
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ RELATION_TY_Compare rleft rright ind1 ind2;
	ind1 = BlkValueRead(rleft, RRV_HANDLER);
	ind2 = BlkValueRead(rright, RRV_HANDLER);
	if (ind1 ~= ind2) return ind1 - ind2;
	if (IsMutableRelationHandler(ind1) == false) return 0;
	return rleft - rright;
];

[ RELATION_TY_Distinguish rleft rright;
	if (RELATION_TY_Compare(rleft, rright) == 0) rfalse;
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: Printing
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ RELATION_TY_Say rel;
	if (rel == 0) print "(null relation)"; ! shouldn't happen
	else print (string) RlnGetF(rel, RR_NAME);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: Naming
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ RELATION_TY_Name rel txt;
	if (rel) {
		BlkValueWrite(rel, RRV_NAME, txt);
		BlkValueWrite(rel, RRV_DESCRIPTION, txt);
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: Choose Relation Handler
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ChooseRelationHandler kov sym;
	if (KOVIsBlockValue(KindBaseTerm(kov, 0))) {
		if (sym) return SymHashListRelationHandler;
		return HashListRelationHandler;
	}
	if (sym) return SymDoubleHashSetRelationHandler;
	return DoubleHashSetRelationHandler;
];

[ IsMutableRelationHandler h;
	if (h == SymHashListRelationHandler or HashListRelationHandler or
		SymDoubleHashSetRelationHandler or DoubleHashSetRelationHandler) rtrue;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: Valency
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ RELATION_TY_SetValency rel val  kov filled cur handler ext;
	filled = BlkValueRead(rel, RRV_FILLED);
	if (filled) { print "*** Illegal valency change ***^"; rfalse; }
	kov = BlkValueRead(rel, RRV_KIND);
	if (val == RRVAL_EQUIV or RRVAL_SYM_V_TO_V or RRVAL_SYM_O_TO_O) {
		if (KindBaseTerm(kov, 0) ~= KindBaseTerm(kov, 1)) {
			print "*** Relation cannot be made symmetric ***^";
			rfalse;
		}
	}
	cur = BlkValueRead(rel, RRV_HANDLER);
	switch (val) {
		RRVAL_V_TO_V:		handler = ChooseRelationHandler(kov, false);
		RRVAL_V_TO_O:		handler = HashTableRelationHandler;
		RRVAL_O_TO_V:		handler = ReversedHashTableRelationHandler;
		RRVAL_O_TO_O:		handler = TwoInOneHashTableRelationHandler;
		RRVAL_EQUIV:		handler = EquivHashTableRelationHandler;
		RRVAL_SYM_V_TO_V:	handler = ChooseRelationHandler(kov, true);
		RRVAL_SYM_O_TO_O:	handler = Sym2in1HashTableRelationHandler;
		default:		print "*** Illegal valency value ***^"; rfalse;
	}
	if (cur == handler) rtrue;
	! adjust size when going to or from 2-in-1
	if (cur == TwoInOneHashTableRelationHandler) {
		ext = BlkValueRead(rel, RRV_STORAGE) + 1;
		BlkValueSetLBCapacity(rel, RRV_DATA_BASE + 3*ext);
	} else if (handler == TwoInOneHashTableRelationHandler) {
		ext = BlkValueRead(rel, RRV_STORAGE) + 1;
		BlkValueSetLBCapacity(rel, RRV_DATA_BASE + 4*ext);
	}
	BlkValueWrite(rel, RRV_HANDLER, handler);
];

[ RELATION_TY_GetValency rel  handler;
	return BlkValueRead(rel, RRV_PERMISSIONS) & VALENCY_MASK;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: Double Hash Set Relation Handler
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ DoubleHashSetRelationHandler rel task X Y sym  kov kx ky at tmp v;
	kov = BlkValueRead(rel, RRV_KIND);
	kx = KindBaseTerm(kov, 0); ky = KindBaseTerm(kov, 1);
	if (task == RELS_SET_VALENCY) {
		return RELATION_TY_SetValency(rel, X);
	} else if (task == RELS_DESTROY) {
		! clear
		kx = KOVIsBlockValue(kx); ky = KOVIsBlockValue(ky);
		if (~~(kx || ky)) return;
		for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
			tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at);
			if (tmp & RRF_USED) {
				if (kx) BlkValueFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1));
				if (ky) BlkValueFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2));
			}
			at--;
		}
		return;
	} else if (task == RELS_COPY) {
		X = KOVIsBlockValue(kx); Y = KOVIsBlockValue(ky);
		if (~~(X || Y)) return;
		at = BlkValueRead(rel, RRV_STORAGE);
		while (at >= 0) {
			tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at);
			if (tmp & RRF_USED) {
				if (X) {
					tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1);
					tmp = BlkValueCopy(BlkValueCreate(kx), tmp);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, tmp);
				}
				if (Y) {
					tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);
					tmp = BlkValueCopy(BlkValueCreate(ky), tmp);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, tmp);
				}
			}
			at--;
		}
		return;
	} else if (task == RELS_SHOW) {
		print (string) BlkValueRead(rel, RRV_DESCRIPTION), ":^";
		if (sym) {
			kov = KOVComparisonFunction(kx);
			if (~~kov) kov = UnsignedCompare;
		}
		for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
			tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at);
			if (tmp & RRF_USED) {
				X = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1);
				Y = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);
				if (sym && (kov(X, Y) > 0)) continue;
				print "  ";
				PrintKindValuePair(kx, X);
				if (sym) print " <=> "; else print " >=> ";
				PrintKindValuePair(ky, Y);
				print "^";
			}
		}
		return;
	} else if (task == RELS_EMPTY) {
		if (BlkValueRead(rel, RRV_USED) == 0) rtrue;
		if (X == 1) {
			DoubleHashSetRelationHandler(rel, RELS_DESTROY);
			for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
				tmp = RRV_DATA_BASE + 3*at;
				BlkValueWrite(rel, tmp, 0);
				BlkValueWrite(rel, tmp + 1, 0);
				BlkValueWrite(rel, tmp + 2, 0);
			}
			BlkValueWrite(rel, RRV_USED, 0);
			BlkValueWrite(rel, RRV_FILLED, 0);
			rtrue;
		}
		rfalse;
	} else if (task == RELS_LOOKUP_ANY) {
		for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
			tmp = RRV_DATA_BASE + 3*at;
			if (BlkValueRead(rel, tmp) & RRF_USED) {
				if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
					v = BlkValueRead(rel, tmp + 2);
					if (KOVIsBlockValue(ky)) {
						if (BlkValueCompare(v, X) ~= 0) continue;
					} else {
						if (v ~= X) continue;
					}
					if (Y == RLANY_CAN_GET_X) rtrue;
					return BlkValueRead(rel, tmp + 1);
				} else {
					v = BlkValueRead(rel, tmp + 1);
					if (KOVIsBlockValue(kx)) {
						if (BlkValueCompare(v, X) ~= 0) continue;
					} else {
						if (v ~= X) continue;
					}
					if (Y == RLANY_CAN_GET_Y) rtrue;
					return BlkValueRead(rel, tmp + 2);
				}
			}
		}
		if (Y == RLANY_GET_X or RLANY_GET_Y)
			print "*** Lookup failed: value not found ***^";
		rfalse;
	} else if (task == RELS_LOOKUP_ALL_X) {
		if (BlkValueWeakKind(Y) ~= LIST_OF_TY) rfalse;
		LIST_OF_TY_SetLength(Y, 0);
		for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
			tmp = RRV_DATA_BASE + 3*at;
			if (BlkValueRead(rel, tmp) & RRF_USED) {
				v = BlkValueRead(rel, tmp + 2);
				if (KOVIsBlockValue(ky)) {
					if (BlkValueCompare(v, X) ~= 0) continue;
				} else {
					if (v ~= X) continue;
				}
				LIST_OF_TY_InsertItem(Y, BlkValueRead(rel, tmp + 1));
			}
		}
		return Y;
	} else if (task == RELS_LOOKUP_ALL_Y) {
		if (BlkValueWeakKind(Y) ~= LIST_OF_TY) rfalse;
		LIST_OF_TY_SetLength(Y, 0);
		for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
			tmp = RRV_DATA_BASE + 3*at;
			if (BlkValueRead(rel, tmp) & RRF_USED) {
				v = BlkValueRead(rel, tmp + 1);
				if (KOVIsBlockValue(kx)) {
					if (BlkValueCompare(v, X) ~= 0) continue;
				} else {
					if (v ~= X) continue;
				}
				LIST_OF_TY_InsertItem(Y, BlkValueRead(rel, tmp + 2));
			}
		}
		return Y;
	} else if (task == RELS_LIST) {
		if (X == 0 || BlkValueWeakKind(X) ~= LIST_OF_TY) rfalse;
		LIST_OF_TY_SetLength(X, 0);
		switch (Y) {
			RLIST_ALL_X, RLIST_ALL_Y:
				for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
					tmp = RRV_DATA_BASE + 3*at;
					if (BlkValueRead(rel, tmp) & RRF_USED) {
						tmp++;
						if (Y == RLIST_ALL_Y) tmp++;
						v = BlkValueRead(rel, tmp);
						LIST_OF_TY_InsertItem(X, v, false, 0, true);
					}
				}
				return X;
			RLIST_ALL_PAIRS:
				! LIST_OF_TY_InsertItem will make a deep copy of the item,
				! so we can reuse a single combination value here
				
				Y = BlkValueCreate(kov);
				for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
					tmp = RRV_DATA_BASE + 3*at;
					if (BlkValueRead(rel, tmp) & RRF_USED) {
						v = BlkValueRead(rel, tmp + 1);
						BlkValueWrite(Y, COMBINATION_ITEM_BASE, v);
						v = BlkValueRead(rel, tmp + 2);
						BlkValueWrite(Y, COMBINATION_ITEM_BASE + 1, v);
						LIST_OF_TY_InsertItem(X, Y);
					}
				}
				BlkValueWrite(Y, COMBINATION_ITEM_BASE, 0);
				BlkValueWrite(Y, COMBINATION_ITEM_BASE + 1, 0);
				BlkValueFree(Y);
				return X;
		}
		rfalse;
	}
	at = DoubleHashSetLookUp(rel, kx, ky, X, Y);
	switch(task) {
		RELS_TEST:
			if (at >= 0) rtrue;
			rfalse;
		RELS_ASSERT_TRUE:
			if (at >= 0) rtrue;
			at = ~at;
			BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) + 1);
			if (BlkValueRead(rel, RRV_DATA_BASE + 3*at) == 0)
				BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_FILLED) + 1);
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at, RRF_USED+RRF_SINGLE);
			if (KOVIsBlockValue(kx)) { X = BlkValueCopy(BlkValueCreate(kx), X); }
			if (KOVIsBlockValue(ky)) { Y = BlkValueCopy(BlkValueCreate(ky), Y); }
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, X);
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, Y);
			DoubleHashSetCheckResize(rel);
			rtrue;
		RELS_ASSERT_FALSE:
			if (at < 0) rtrue;
			BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) - 1);
			if (KOVIsBlockValue(kx))
				BlkValueFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1));
			if (KOVIsBlockValue(ky))
				BlkValueFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2));
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at, RRF_DELETED);
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, 0);
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, 0);
			rtrue;
	}
];

[ DoubleHashSetLookUp rel kx ky X Y  hashv i free mask perturb flags;
	! calculate a hash value for the pair
	hashv = GetHashValue(kx, x) + GetHashValue(ky, y);
	! look in the first expected slot
	mask = BlkValueRead(rel, RRV_STORAGE);
	i = hashv & mask;
	flags = BlkValueRead(rel, RRV_DATA_BASE + 3*i);
	if (flags == 0) return ~i;
	if (DoubleHashSetEntryMatches(rel, i, kx, ky, X, Y)) return i;
	! not here, keep looking in sequence
	free = -1;
	if (flags & RRF_DELETED) free = i;
	perturb = hashv;
	hashv = i;
	for (::) {
		hashv = hashv*5 + perturb + 1;
		i = hashv & mask;
		flags = BlkValueRead(rel, RRV_DATA_BASE + 3*i);
		if (flags == 0) {
			if (free >= 0) return ~free;
			return ~i;
		}
		if (DoubleHashSetEntryMatches(rel, i, kx, ky, X, Y))
			return i;
		if ((free < 0) && (flags & RRF_DELETED)) free = i;
		#ifdef TARGET_ZCODE;
		@log_shift perturb (-RRP_PERTURB_SHIFT) -> perturb;
		#ifnot;
		@ushiftr perturb RRP_PERTURB_SHIFT perturb;
		#endif;
	}
];

[ DoubleHashSetCheckResize rel  filled ext newext temp i at kov kx ky F X Y;
	filled = BlkValueRead(rel, RRV_FILLED);
	ext = BlkValueRead(rel, RRV_STORAGE) + 1;
	if (filled >= (ext - filled) * RRP_CROWDED_IS) {
		! copy entries to temporary space
		temp = FlexAllocate(ext * (3*WORDSIZE), TEXT_TY, BLK_FLAG_WORD+BLK_FLAG_MULTIPLE);
		for (i=0: i<ext*3: i++)
			BlkValueWrite(temp, i, BlkValueRead(rel, RRV_DATA_BASE+i), true);
		! resize and clear our data
		if (ext >= RRP_LARGE_IS) newext = ext * RRP_RESIZE_LARGE;
		else newext = ext * RRP_RESIZE_SMALL;
		BlkValueSetLBCapacity(rel, RRV_DATA_BASE + newext*3);
		BlkValueWrite(rel, RRV_STORAGE, newext - 1);
		BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_USED));
		for (i=0: i<newext*3: i++)
			BlkValueWrite(rel, RRV_DATA_BASE+i, 0);
		! copy entries back from temporary space
		kov = BlkValueRead(rel, RRV_KIND);
		kx = KindBaseTerm(kov, 0); ky = KindBaseTerm(kov, 1);
		for (i=0: i<ext: i++) {
			F = BlkValueRead(temp, 3*i, true);
			if (F == 0 || (F & RRF_DELETED)) continue;
			X = BlkValueRead(temp, 3*i + 1, true);
			Y = BlkValueRead(temp, 3*i + 2, true);
			at = DoubleHashSetLookUp(rel, kx, ky, X, Y);
			if (at >= 0) { print "*** Duplicate entry while resizing ***^"; rfalse; }
			at = ~at;
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at, F);
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, X);
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, Y);
		}
		! done with temporary space
		FlexFree(temp);
	}
];

[ DoubleHashSetEntryMatches rel at kx ky X Y  cx cy;
	cx = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1);
	if (KOVIsBlockValue(kx)) {
		if (BlkValueCompare(cx, X) ~= 0) rfalse;
	} else {
		if (cx ~= X) rfalse;
	}
	cy = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);
	if (KOVIsBlockValue(ky)) {
		if (BlkValueCompare(cy, Y) ~= 0) rfalse;
	} else {
		if (cy ~= Y) rfalse;
	}
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: Hash List Relation Handler
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ HashListRelationHandler rel task X Y  sym kov kx ky;
	kov = BlkValueRead(rel, RRV_KIND);
	kx = KindBaseTerm(kov, 0); ky = KindBaseTerm(kov, 1);
	return HashCoreRelationHandler(rel, task, kx, ky, X, Y, 1);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: Hash Table Relation Handler
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ HashTableRelationHandler rel task X Y  kov kx ky;
	kov = BlkValueRead(rel, RRV_KIND);
	kx = KindBaseTerm(kov, 0); ky = KindBaseTerm(kov, 1);
	return HashCoreRelationHandler(rel, task, kx, ky, X, Y, 0);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: Reversed Hash Table Relation Handler
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ReversedHashTableRelationHandler rel task X Y  kov kx ky swap;
	kov = BlkValueRead(rel, RRV_KIND);
	kx = KindBaseTerm(kov, 0); ky = KindBaseTerm(kov, 1);
	switch (task) {
		RELS_SET_VALENCY:
			return RELATION_TY_SetValency(rel, X);
		RELS_TEST, RELS_ASSERT_TRUE, RELS_ASSERT_FALSE:
			return HashCoreRelationHandler(rel, task, ky, kx, Y, X, 0);
		RELS_LOOKUP_ANY:
			switch (Y) {
				RLANY_GET_X: Y = RLANY_GET_Y;
				RLANY_GET_Y: Y = RLANY_GET_X;
				RLANY_CAN_GET_X: Y = RLANY_CAN_GET_Y;
				RLANY_CAN_GET_Y: Y = RLANY_CAN_GET_X;
			}
		RELS_LOOKUP_ALL_X:
			task = RELS_LOOKUP_ALL_Y;
		RELS_LOOKUP_ALL_Y:
			task = RELS_LOOKUP_ALL_X;
		RELS_SHOW:
			swap=X; X=Y; Y=swap;
			swap=kx; kx=ky; ky=swap;
 		RELS_LIST:
			switch (Y) {
				RLIST_ALL_X: Y = RLIST_ALL_Y;
				RLIST_ALL_Y: Y = RLIST_ALL_X;
			}
	}
	return HashCoreRelationHandler(rel, task, kx, ky, X, Y, 0);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: Symmetric Relation Handlers
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SymDoubleHashSetRelationHandler rel task X Y;
	if (task == RELS_ASSERT_TRUE or RELS_ASSERT_FALSE)
		DoubleHashSetRelationHandler(rel, task, Y, X);
	return DoubleHashSetRelationHandler(rel, task, X, Y, 1);
];

[ SymHashListRelationHandler rel task X Y;
	if (task == RELS_ASSERT_TRUE or RELS_ASSERT_FALSE)
		HashListRelationHandler(rel, task, Y, X);
	return HashListRelationHandler(rel, task, X, Y);
];

[ Sym2in1HashTableRelationHandler rel task X Y;
	if (task == RELS_ASSERT_TRUE or RELS_ASSERT_FALSE)
		TwoInOneHashTableRelationHandler(rel, task, Y, X);
	return TwoInOneHashTableRelationHandler(rel, task, X, Y, 1);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: Hash Core Relation Handler
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ HashCoreRelationHandler rel task kx ky X Y mult  sym rev at tmp fl;
	if (task == RELS_SET_VALENCY) {
		return RELATION_TY_SetValency(rel, X);
	} else if (task == RELS_DESTROY) {
		! clear
		kx = KOVIsBlockValue(kx); ky = KOVIsBlockValue(ky);
		if (~~(kx || ky)) return;
		at = BlkValueRead(rel, RRV_STORAGE);
		while (at >= 0) {
			fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);
			if (fl & RRF_USED) {
				if (kx) BlkValueFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1));
				if (ky || ~~(fl & RRF_SINGLE))
					BlkValueFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2));
			}
			at--;
		}
		return;
	} else if (task == RELS_COPY) {
		X = KOVIsBlockValue(kx); Y = KOVIsBlockValue(ky);
		if (~~(X || Y)) return;
		at = BlkValueRead(rel, RRV_STORAGE);
		while (at >= 0) {
			fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);
			if (fl & RRF_USED) {
				if (X) {
					tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1);
					tmp = BlkValueCopy(BlkValueCreate(kx), tmp);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, tmp);
				}
				if (Y || ~~(fl & RRF_SINGLE)) {
					tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);
					tmp = BlkValueCopy(BlkValueCreate(BlkValueWeakKind(tmp)), tmp);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, tmp);
				}
			}
			at--;
		}
		return;
	} else if (task == RELS_SHOW) {
		print (string) BlkValueRead(rel, RRV_DESCRIPTION), ":^";
		! Z-machine doesn't have the room to let us pass sym/rev as parameters
		switch (RELATION_TY_GetValency(rel)) {
			RRVAL_SYM_V_TO_V:
				sym = 1;
				tmp = KOVComparisonFunction(kx);
				if (~~tmp) tmp = UnsignedCompare;
			RRVAL_O_TO_V:
				rev = 1;
		}
		for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
			fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);
			if (fl & RRF_USED) {
				X = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1);
				Y = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);
				if (fl & RRF_SINGLE) {
					if (sym && tmp(X, Y) > 0) continue;
					print "  ";
					if (rev) PrintKindValuePair(ky, Y);
					else PrintKindValuePair(kx, X);
					if (sym) print " <=> "; else print " >=> ";
					if (rev) PrintKindValuePair(kx, X);
					else PrintKindValuePair(ky, Y);
					print "^";
				} else {
					for (mult=1: mult<=LIST_OF_TY_GetLength(Y): mult++) {
						fl = LIST_OF_TY_GetItem(Y, mult);
						if (sym && tmp(X, fl) > 0) continue;
						print "  ";
						if (rev) PrintKindValuePair(ky, fl);
						else PrintKindValuePair(kx, X);
						if (sym) print " <=> "; else print " >=> ";
						if (rev) PrintKindValuePair(kx, X);
						else PrintKindValuePair(ky, fl);
						print "^";
					}
				}
			}
		}
		return;
	} else if (task == RELS_EMPTY) {
		if (BlkValueRead(rel, RRV_USED) == 0) rtrue;
		if (X == 1) {
			HashCoreRelationHandler(rel, RELS_DESTROY);
			for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
				tmp = RRV_DATA_BASE + 3*at;
				BlkValueWrite(rel, tmp, 0);
				BlkValueWrite(rel, tmp + 1, 0);
				BlkValueWrite(rel, tmp + 2, 0);
			}
			BlkValueWrite(rel, RRV_USED, 0);
			BlkValueWrite(rel, RRV_FILLED, 0);
			rtrue;
		}
		rfalse;
	} else if (task == RELS_LOOKUP_ANY) {
		if (Y == RLANY_GET_Y or RLANY_CAN_GET_Y) {
			at = HashCoreLookUp(rel, kx, X);
			if (at >= 0) {
				if (Y == RLANY_CAN_GET_Y) rtrue;
				tmp = RRV_DATA_BASE + 3*at;
				fl = BlkValueRead(rel, tmp);
				tmp = BlkValueRead(rel, tmp + 2);
				if (fl & RRF_SINGLE) return tmp;
				return LIST_OF_TY_GetItem(tmp, 1);
			}
		} else {
			for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
				tmp = RRV_DATA_BASE + 3*at;
				fl = BlkValueRead(rel, tmp);
				if (fl & RRF_USED) {
					sym = BlkValueRead(rel, tmp + 2);
					if (fl & RRF_SINGLE) {
						if (KOVIsBlockValue(ky)) {
							if (BlkValueCompare(X, sym) ~= 0) continue;
						} else {
							if (X ~= sym) continue;
						}
					} else {
						if (LIST_OF_TY_FindItem(sym, X) == 0) continue;
					}
					if (Y == RLANY_CAN_GET_X) rtrue;
					return BlkValueRead(rel, tmp + 1);
				}
			}
		}
		if (Y == RLANY_GET_X or RLANY_GET_Y)
			print "*** Lookup failed: value not found ***^";
		rfalse;
	} else if (task == RELS_LOOKUP_ALL_X) {
		if (BlkValueWeakKind(Y) ~= LIST_OF_TY) rfalse;
		LIST_OF_TY_SetLength(Y, 0);
		for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
			tmp = RRV_DATA_BASE + 3*at;
			fl = BlkValueRead(rel, tmp);
			if (fl & RRF_USED) {
				sym = BlkValueRead(rel, tmp + 2);
				if (fl & RRF_SINGLE) {
					if (KOVIsBlockValue(ky)) {
						if (BlkValueCompare(X, sym) ~= 0) continue;
					} else {
						if (X ~= sym) continue;
					}
				} else {
					if (LIST_OF_TY_FindItem(sym, X) == 0) continue;
				}
				LIST_OF_TY_InsertItem(Y, BlkValueRead(rel, tmp + 1));
			}
		}
		return Y;
	} else if (task == RELS_LOOKUP_ALL_Y) {
		if (BlkValueWeakKind(Y) ~= LIST_OF_TY) rfalse;
		LIST_OF_TY_SetLength(Y, 0);
		at = HashCoreLookUp(rel, kx, X);
		if (at >= 0) {
			tmp = RRV_DATA_BASE + 3*at;
			fl = BlkValueRead(rel, tmp);
			tmp = BlkValueRead(rel, tmp + 2);
			if (fl & RRF_SINGLE)
				LIST_OF_TY_InsertItem(Y, tmp);
			else
				LIST_OF_TY_AppendList(Y, tmp);
		}
		return Y;
	} else if (task == RELS_LIST) {
		if (BlkValueWeakKind(X) ~= LIST_OF_TY) rfalse;
		LIST_OF_TY_SetLength(X, 0);
		switch (Y) {
			RLIST_ALL_X:
				for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
					tmp = RRV_DATA_BASE + 3*at;
					fl = BlkValueRead(rel, tmp);
					if (fl & RRF_USED)
						LIST_OF_TY_InsertItem(X, BlkValueRead(rel, tmp + 1));
				}
				return X;
			RLIST_ALL_Y:
				for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
					tmp = RRV_DATA_BASE + 3*at;
					fl = BlkValueRead(rel, tmp);
					if (fl & RRF_USED) {
						tmp = BlkValueRead(rel, tmp + 2);
						if (fl & RRF_SINGLE)
							LIST_OF_TY_InsertItem(X, tmp, false, 0, true);
						else
							LIST_OF_TY_AppendList(X, tmp, false, 0, true);
					}
				}
				return X;
			RLIST_ALL_PAIRS:
				if (RELATION_TY_GetValency(rel) == RRVAL_O_TO_V) rev = 1;
				! LIST_OF_TY_InsertItem will make a deep copy of the item,
				! so we can reuse a single combination value here
				Y = BlkValueCreate(COMBINATION_TY, tmp);
				for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
					tmp = RRV_DATA_BASE + 3*at;
					fl = BlkValueRead(rel, tmp);
					if (fl & RRF_USED) {
						BlkValueWrite(Y, COMBINATION_ITEM_BASE + rev, BlkValueRead(rel, tmp + 1));
						tmp = BlkValueRead(rel, tmp + 2);
						if (fl & RRF_SINGLE) {
							BlkValueWrite(Y, COMBINATION_ITEM_BASE + 1 - rev, tmp);
							LIST_OF_TY_InsertItem(X, Y);
						} else {
							for (mult = LIST_OF_TY_GetLength(tmp): mult > 0: mult--) {
								BlkValueWrite(Y, COMBINATION_ITEM_BASE + 1 - rev,
									LIST_OF_TY_GetItem(tmp, mult));
								LIST_OF_TY_InsertItem(X, Y);
							}
						}
					}
				}
				BlkValueWrite(Y, COMBINATION_ITEM_BASE, 0);
				BlkValueWrite(Y, COMBINATION_ITEM_BASE + 1, 0);
				BlkValueFree(Y);
				return X;
		}
		rfalse;
	}
	at = HashCoreLookUp(rel, kx, X);
	switch(task) {
		RELS_TEST:
			if (at < 0) rfalse;
			fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);
			tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);
			if (fl & RRF_SINGLE) {
				if (KOVIsBlockValue(ky)) {
					if (BlkValueCompare(tmp, Y) == 0) rtrue;
				} else {
					if (tmp == Y) rtrue;
				}
				rfalse;
			} else {
				return LIST_OF_TY_FindItem(tmp, Y);
			}
		RELS_ASSERT_TRUE:
			if (at < 0) {
				! no entry exists for this key, just add one
				at = ~at;
				BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) + 1);
				if (BlkValueRead(rel, RRV_DATA_BASE + 3*at) == 0)
					BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_FILLED) + 1);
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at, RRF_USED+RRF_SINGLE);
				if (KOVIsBlockValue(kx)) { X = BlkValueCopy(BlkValueCreate(kx), X); }
				if (KOVIsBlockValue(ky)) { Y = BlkValueCopy(BlkValueCreate(ky), Y); }
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, X);
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, Y);
				HashCoreCheckResize(rel);
				break;
			}
			! an entry exists: could be a list or a single value
			fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);		! flags
			tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);	! value or list
			if (fl & RRF_SINGLE) {
				! if Y is the same as the stored key, we have nothing to do
				if (KOVIsBlockValue(ky)) {
					if (BlkValueCompare(tmp, Y) == 0) rtrue;
				} else {
					if (tmp == Y) rtrue;
				}
				! it's different: either replace it or expand into a list,
				! depending on the value of mult
				if (mult) {
					fl = BlkValueCreate(LIST_OF_TY);	! new list
					BlkValueWrite(fl, LIST_ITEM_KOV_F, ky);
					LIST_OF_TY_SetLength(fl, 2);
					BlkValueWrite(fl, LIST_ITEM_BASE, tmp);	! do not copy
					LIST_OF_TY_PutItem(fl, 2, Y);		! copy if needed
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, fl);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at, RRF_USED);
				} else {
					if (KOVIsBlockValue(ky)) {
						BlkValueFree(tmp);
						Y = BlkValueCopy(BlkValueCreate(ky), Y);
					}
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, Y);
				}
			} else {
				! if Y is present already, do nothing. otherwise add it.
				LIST_OF_TY_InsertItem(tmp, Y, 0, 0, 1);
			}
			rtrue;
		RELS_ASSERT_FALSE:
			if (at < 0) rtrue;
			! an entry exists: could be a list or a single value
			fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);		! flags
			tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);	! value or list
			if (fl & RRF_SINGLE) {
				! if the stored key isn't Y, we have nothing to do
				if (KOVIsBlockValue(ky)) {
					if (BlkValueCompare(tmp, Y) ~= 0) rtrue;
				} else {
					if (tmp ~= Y) rtrue;
				}
				! delete the entry
				if (KOVIsBlockValue(ky))
					BlkValueFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2));
				.DeleteEntryIgnoringY;
				BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) - 1);
				if (KOVIsBlockValue(kx))
					BlkValueFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1));
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at, RRF_DELETED);
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, 0);
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, 0);
			} else {
				! remove Y from the list if present
				LIST_OF_TY_RemoveValue(tmp, Y, 1);
				! if the list is now empty, delete the whole entry
				if (LIST_OF_TY_GetLength(tmp) == 0) {
					BlkValueFree(tmp);
					jump DeleteEntryIgnoringY;
				}
			}
			rtrue;
	}
	rtrue;
];

[ HashCoreLookUp rel kx X  hashv i free mask perturb flags;
!print "[HCLU rel=", rel, " kx=", kx, " X=", X, ": ";
	! calculate a hash value for the key
	hashv = GetHashValue(kx, x);
	! look in the first expected slot
	mask = BlkValueRead(rel, RRV_STORAGE);
	i = hashv & mask;
!print "hv=", hashv, ", trying ", i;
	if (HashCoreEntryMatches(rel, i, kx, X)) {
!print " - found]^";
		return i;
	}
	flags = BlkValueRead(rel, RRV_DATA_BASE + 3*i);
	if (flags == 0) {
!print " - not found]^";
		return ~i;
	}
	! not here, keep looking in sequence
	free = -1;
	if (flags & RRF_DELETED) free = i;
	perturb = hashv;
	hashv = i;
	for (::) {
		hashv = hashv*5 + perturb + 1;
		i = hashv & mask;
!print ", ", i;
		flags = BlkValueRead(rel, RRV_DATA_BASE + 3*i);
		if (flags == 0) {
!print " - not found]^";
			if (free >= 0) return ~free;
			return ~i;
		}
		if (HashCoreEntryMatches(rel, i, kx, X)) {
!print " - found]^";
			return i;
		}
		if ((free < 0) && (flags & RRF_DELETED)) free = i;
		#ifdef TARGET_ZCODE;
		@log_shift perturb (-RRP_PERTURB_SHIFT) -> perturb;
		#ifnot;
		@ushiftr perturb RRP_PERTURB_SHIFT perturb;
		#endif;
	}
];

[ HashCoreCheckResize rel  filled ext newext temp i at kov kx F X Y;
	filled = BlkValueRead(rel, RRV_FILLED);
	ext = BlkValueRead(rel, RRV_STORAGE) + 1;
	if (filled >= (ext - filled) * RRP_CROWDED_IS) {
		! copy entries to temporary space
		temp = FlexAllocate(ext * (3*WORDSIZE), TEXT_TY, BLK_FLAG_WORD+BLK_FLAG_MULTIPLE);
		for (i=0: i<ext*3: i++)
			BlkValueWrite(temp, i, BlkValueRead(rel, RRV_DATA_BASE+i), true);
		! resize and clear our data
		if (ext >= RRP_LARGE_IS) newext = ext * RRP_RESIZE_LARGE;
		else newext = ext * RRP_RESIZE_SMALL;
		BlkValueSetLBCapacity(rel, RRV_DATA_BASE + newext*3);
		BlkValueWrite(rel, RRV_STORAGE, newext - 1);
		BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_USED));
		for (i=0: i<newext*3: i++)
			BlkValueWrite(rel, RRV_DATA_BASE+i, 0);
		! copy entries back from temporary space
		kov = BlkValueRead(rel, RRV_KIND);
		kx = KindBaseTerm(kov, 0);
		for (i=0: i<ext: i++) {
			F = BlkValueRead(temp, 3*i, true);
			if (F == 0 || (F & RRF_DELETED)) continue;
			X = BlkValueRead(temp, 3*i + 1, true);
			Y = BlkValueRead(temp, 3*i + 2, true);
			at = HashCoreLookUp(rel, kx, X);
			if (at >= 0) { print "*** Duplicate entry while resizing ***^"; rfalse; }
			at = ~at;
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at, F);
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, X);
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, Y);
		}
		! done with temporary space
		FlexFree(temp);
	}
];

[ HashCoreEntryMatches rel at kx X  cx cy;
	cx = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1);
	if (KOVIsBlockValue(kx)) {
		if (BlkValueCompare(cx, X) ~= 0) rfalse;
	} else {
		if (cx ~= X) rfalse;
	}
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: Equivalence Hash Table Relation Handler
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ EquivHashTableRelationHandler rel task X Y  kx at at2 tmp fl i ext;
	kx = KindBaseTerm(BlkValueRead(rel, RRV_KIND), 0);
	if (task == RELS_SET_VALENCY) {
		return RELATION_TY_SetValency(rel, X);
	} else if (task == RELS_DESTROY) {
		! clear
		if (KOVIsBlockValue(kx)) {
			at = BlkValueRead(rel, RRV_STORAGE);
			while (at >= 0) {
				fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);
				if (fl & RRF_USED) {
					BlkValueFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1));
				}
				at--;
			}
		}
		return;
	} else if (task == RELS_COPY) {
		if (KOVIsBlockValue(kx)) {
			at = BlkValueRead(rel, RRV_STORAGE);
			while (at >= 0) {
				fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);
				if (fl & RRF_USED) {
					tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1);
					tmp = BlkValueCopy(BlkValueCreate(kx), tmp);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1);
				}
				at--;
			}
		}
		return;
	} else if (task == RELS_SHOW) {
		print (string) BlkValueRead(rel, RRV_DESCRIPTION), ":^";
		ext = BlkValueRead(rel, RRV_STORAGE);
		! flag all items by negating their group numbers
		for (at=0, X=RRV_DATA_BASE: at<=ext: at++, X=X+3)
			if (BlkValueRead(rel, X) & RRF_USED)
				BlkValueWrite(rel, X + 2, -(BlkValueRead(rel, X + 2)));
		! display groups, unflagging them as we go
		for (at=0, X=RRV_DATA_BASE, fl=0: at<=ext: at++, X=X+3, fl=0) {
			if (BlkValueRead(rel, X) & RRF_USED) {
				fl = BlkValueRead(rel, X + 2);
				if (fl > 0) continue;		! already visited
				BlkValueWrite(rel, X + 2, -fl);	! unflag it
				! display the group starting with this member, but only
				! if there are more members in the group
				tmp = BlkValueRead(rel, X + 1);
				i = 0;
				for (at2=at+1, Y=RRV_DATA_BASE+3*at2: at2<=ext: at2++, Y=Y+3) {
					if (BlkValueRead(rel, Y) & RRF_USED) {
						if (BlkValueRead(rel, Y + 2) ~= fl) continue;
						BlkValueWrite(rel, Y + 2, -fl);
						if (~~i) {
							! print the saved first member
							print "  { ";
							PrintKindValuePair(kx, tmp);
							i = 1;
						}
						print ", ";
						PrintKindValuePair(kx, BlkValueRead(rel, Y + 1));
					}
				}
				if (i) print " }^";
			}
		}
		return;
	} else if (task == RELS_EMPTY) {
		! never empty since R(x,x) is always true
		rfalse;
	} else if (task == RELS_LOOKUP_ANY) {
		! kind of a cheat, but it's faster than searching for a better value to return
		if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
		return X;
	} else if (task == RELS_LOOKUP_ALL_X or RELS_LOOKUP_ALL_Y) {
		if (BlkValueWeakKind(Y) ~= LIST_OF_TY) rfalse;
		LIST_OF_TY_SetLength(Y, 0);
		BlkValueWrite(Y, LIST_ITEM_KOV_F, kx);
		at = HashCoreLookUp(rel, kx, X);
		if (at < 0) {
			LIST_OF_TY_InsertItem(Y, X);
		} else {
			X = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);
			for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
				tmp = RRV_DATA_BASE + 3*at;
				fl = BlkValueRead(rel, tmp);
				if (fl & RRF_USED) {
					if (BlkValueRead(rel, tmp + 2) ~= X) continue;
					LIST_OF_TY_InsertItem(Y, BlkValueRead(rel, tmp + 1));
				}
			}
		}
		return Y;
	} else if (task == RELS_LIST) {
		print "*** Domains of equivalence relations cannot be listed ***^";
		return X;
	}
	at = HashCoreLookUp(rel, kx, X);
	at2 = HashCoreLookUp(rel, kx, Y);
	switch(task) {
		RELS_TEST:
			if (at < 0) {
				! X is a loner, but could still be true if X == Y
				if (KOVIsBlockValue(kx)) {
					if (BlkValueCompare(X, Y) == 0) rtrue;
				} else {
					if (X == Y) rtrue;
				}
				rfalse;
			}
			if (at2 < 0) rfalse;
			if (at == at2) rtrue;
			tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);
			if (BlkValueRead(rel, RRV_DATA_BASE + 3*at2 + 2) == tmp) rtrue;
			rfalse;
		RELS_ASSERT_TRUE:
			! if X and Y are the same, we have nothing to do
			if (KOVIsBlockValue(kx)) {
				if (BlkValueCompare(X, Y) == 0) rtrue;
			} else {
				if (X == Y) rtrue;
			}
			if (at < 0) {
				if (at2 < 0) {
					! X and Y both missing: find a new group number and add both entries
					tmp = 0;		! candidate group number
					ext = BlkValueRead(rel, RRV_STORAGE);
					for (i=0: i<=ext: i++) {
						fl = BlkValueRead(rel, RRV_DATA_BASE + 3*i);
						if (fl & RRF_USED) {
							fl = BlkValueRead(rel, RRV_DATA_BASE + 3*i + 2);
							if (fl > tmp) tmp = fl;
						}
					}
					tmp++;			! new group number
					BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) + 2);
					! add X entry
					at = ~at;
					if (KOVIsBlockValue(kx)) { X = BlkValueCopy(BlkValueCreate(kx), X); }
					fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);
					if (fl == 0)
						BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_FILLED) + 1);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at, RRF_USED+RRF_SINGLE);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, X);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, tmp);
					! add Y entry. at2 might change if X and Y have the same hash code.
					at2 = ~(HashCoreLookUp(rel, kx, Y));
					if (KOVIsBlockValue(kx)) { Y = BlkValueCopy(BlkValueCreate(kx), Y); }
					fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at2);
					if (fl == 0)
						BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_FILLED) + 1);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at2, RRF_USED+RRF_SINGLE);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at2 + 1, Y);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at2 + 2, tmp);
					jump CheckResize;
				}
				! X missing, Y present: add a new X entry
				at = ~at;
				if (KOVIsBlockValue(kx)) { X = BlkValueCopy(BlkValueCreate(kx), X); }
				BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) + 1);
				fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);
				if (fl == 0)
					BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_FILLED) + 1);
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at, RRF_USED+RRF_SINGLE);
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, X);
				tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at2 + 2);
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, tmp);
				jump CheckResize;
			}
			if (at2 < 0) {
				! X present, Y missing: add a new Y entry
				at2 = ~at2;
				if (KOVIsBlockValue(kx)) { Y = BlkValueCopy(BlkValueCreate(kx), Y); }
				BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) + 1);
				fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at2);
				if (fl == 0)
					BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_FILLED) + 1);
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at2, RRF_USED+RRF_SINGLE);
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at2 + 1, Y);
				tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at2 + 2, tmp);
				jump CheckResize;
			}
			! X and Y both present: merge higher group into lower group
			tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);	! higher group
			fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at2 + 2);	! lower group
			if (tmp < fl) { i = tmp; tmp = fl; fl = i; }
			ext = BlkValueRead(rel, RRV_STORAGE);
			for (at=0: at<=ext: at++) {
				i = RRV_DATA_BASE + 3*at + 2;
				if (BlkValueRead(rel, i) == tmp)
					BlkValueWrite(rel, i, fl);
			}
			.CheckResize;
			HashCoreCheckResize(rel);
			rtrue;
		RELS_ASSERT_FALSE:
			! if X and Y are already in different groups, we have nothing to do
			if (at < 0 || at2 < 0) rtrue;
			tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);
			if (BlkValueRead(rel, RRV_DATA_BASE + 3*at2 + 2) ~= tmp) rtrue;
			! delete the entry for X
			BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) - 1);
			if (KOVIsBlockValue(kx))
				BlkValueFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1));
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at, RRF_DELETED);
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, 0);
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, 0);
			rtrue;
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: Two-In-One Hash Table Relation Handler
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TwoInOneHashTableRelationHandler rel task X Y sym  kov kx ky at at2 tmp fl;
	kov = BlkValueRead(rel, RRV_KIND);
	kx = KindBaseTerm(kov, 0); ky = KindBaseTerm(kov, 1);
	if (task == RELS_SET_VALENCY) {
		return RELATION_TY_SetValency(rel, X);
	} else if (task == RELS_DESTROY) {
		! clear
		kx = KOVIsBlockValue(kx); ky = KOVIsBlockValue(ky);
		if (~~(kx || ky)) return;
		at = BlkValueRead(rel, RRV_STORAGE);
		while (at >= 0) {
			fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);
			if (fl & RRF_USED)
				if ((kx && (fl & RRF_ENTKEYX)) || (ky && (fl & RRF_ENTKEYY))) {
					BlkValueFree(BlkValueRead(rel, RRV_DATA_BASE + 4*at + 1));
				}
			at--;
		}
		return;
	} else if (task == RELS_COPY) {
		X = KOVIsBlockValue(kx); Y = KOVIsBlockValue(ky);
		if (~~(X || Y)) return;
		at = BlkValueRead(rel, RRV_STORAGE);
		while (at >= 0) {
			fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);
			if (fl & RRF_USED) {
				if ((X && (fl & RRF_ENTKEYX)) || (Y && (fl & RRF_ENTKEYY))) {
					! copy the entry key
					tmp = BlkValueRead(rel, RRV_DATA_BASE + 4*at + 1);
					if (fl & RRF_ENTKEYX)
						tmp = BlkValueCopy(BlkValueCreate(kx), tmp);
					else
						tmp = BlkValueCopy(BlkValueCreate(ky), tmp);
					BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 1, tmp);
					! update references in X/Y fields pointing here
					if (fl & RRF_HASX) {
						at2 = TwoInOneLookUp(rel, kx,
							BlkValueRead(rel, RRV_DATA_BASE + 4*at + 2),
							RRF_ENTKEYX);
						if (at2 >= 0)
							BlkValueWrite(rel, RRV_DATA_BASE + 4*at2 + 3, tmp);
					}
					if (fl & RRF_HASY) {
						at2 = TwoInOneLookUp(rel, ky,
							BlkValueRead(rel, RRV_DATA_BASE + 4*at + 3),
							RRF_ENTKEYY);
						if (at2 >= 0)
							BlkValueWrite(rel, RRV_DATA_BASE + 4*at2 + 2, tmp);
					}
				}
			}
			at--;
		}
		return;
	} else if (task == RELS_SHOW) {
		print (string) BlkValueRead(rel, RRV_DESCRIPTION), ":^";
		if (sym) {
			kov = KOVComparisonFunction(kx);
			if (~~kov) kov = UnsignedCompare;
		}
		for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
			fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);
			if ((fl & (RRF_USED+RRF_ENTKEYX+RRF_HASY)) ==
				(RRF_USED+RRF_ENTKEYX+RRF_HASY)) {
				X = BlkValueRead(rel, RRV_DATA_BASE + 4*at + 1);
				Y = BlkValueRead(rel, RRV_DATA_BASE + 4*at + 3);
				if (sym && kov(X, Y) > 0) continue;
				print "  ";
				PrintKindValuePair(kx, X);
				if (sym) print " <=> "; else print " >=> ";
				PrintKindValuePair(ky, Y);
				print "^";
			}
		}
		return;
	} else if (task == RELS_EMPTY) {
		if (BlkValueRead(rel, RRV_USED) == 0) rtrue;
		if (X == 1) {
			TwoInOneHashTableRelationHandler(rel, RELS_DESTROY);
			for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
				tmp = RRV_DATA_BASE + 4*at;
				BlkValueWrite(rel, tmp, 0);
				BlkValueWrite(rel, tmp + 1, 0);
				BlkValueWrite(rel, tmp + 2, 0);
				BlkValueWrite(rel, tmp + 3, 0);
			}
			BlkValueWrite(rel, RRV_USED, 0);
			BlkValueWrite(rel, RRV_FILLED, 0);
			rtrue;
		}
		rfalse;
	} else if (task == RELS_LOOKUP_ANY) {
		switch (Y) {
			RLANY_GET_X, RLANY_CAN_GET_X:
				at = TwoInOneLookUp(rel, ky, X, RRF_ENTKEYY);
				if (at >= 0) {
					tmp = RRV_DATA_BASE + 4*at;
					if (BlkValueRead(rel, tmp) & RRF_HASX) {
						if (Y == RLANY_CAN_GET_X) rtrue;
						return BlkValueRead(rel, tmp + 2);
					}
				}
			RLANY_GET_Y, RLANY_CAN_GET_Y:
				at = TwoInOneLookUp(rel, kx, X, RRF_ENTKEYX);
				if (at >= 0) {
					tmp = RRV_DATA_BASE + 4*at;
					if (BlkValueRead(rel, tmp) & RRF_HASY) {
						if (Y == RLANY_CAN_GET_Y) rtrue;
						return BlkValueRead(rel, tmp + 3);
					}
				}
		}
		if (Y == RLANY_GET_X or RLANY_GET_Y)
			print "*** Lookup failed: value not found ***^";
		rfalse;
	} else if (task == RELS_LOOKUP_ALL_X) {
		at = TwoInOneLookUp(rel, ky, X, RRF_ENTKEYY);
		if (at >= 0) {
			tmp = RRV_DATA_BASE + 4*at;
			if (BlkValueRead(rel, tmp) & RRF_HASX)
				LIST_OF_TY_InsertItem(Y, BlkValueRead(rel, tmp + 2));
		}
		return Y;
	} else if (task == RELS_LOOKUP_ALL_Y) {
		at = TwoInOneLookUp(rel, kx, X, RRF_ENTKEYX);
		if (at >= 0) {
			tmp = RRV_DATA_BASE + 4*at;
			if (BlkValueRead(rel, tmp) & RRF_HASY)
				LIST_OF_TY_InsertItem(Y, BlkValueRead(rel, tmp + 3));
		}
		return Y;
	} else if (task == RELS_LIST) {
		switch (Y) {
			RLIST_ALL_X:
				fl = RRF_USED+RRF_ENTKEYX+RRF_HASY;
				jump ListEntryKeys;
			RLIST_ALL_Y:
				fl = RRF_USED+RRF_ENTKEYY+RRF_HASX;
				.ListEntryKeys;
				for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
					tmp = RRV_DATA_BASE + 4*at;
					if ((BlkValueRead(rel, tmp) & fl) == fl)
						LIST_OF_TY_InsertItem(X, BlkValueRead(rel, tmp + 1), false, 0, true);
				}
			RLIST_ALL_PAIRS:
				tmp = BlkValueRead(X, LIST_ITEM_KOV_F);
				if (KindAtomic(tmp) ~= COMBINATION_TY) rfalse;
				! LIST_OF_TY_InsertItem will make a deep copy of the item,
				! so we can reuse a single combination value here
				Y = BlkValueCreate(tmp);
				for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
					tmp = RRV_DATA_BASE + 4*at;
					fl = BlkValueRead(rel, tmp);
					if ((fl & (RRF_USED+RRF_ENTKEYX+RRF_HASY)) ==
						(RRF_USED+RRF_ENTKEYX+RRF_HASY)) {
						BlkValueWrite(Y, COMBINATION_ITEM_BASE, BlkValueRead(rel, tmp + 1));
						BlkValueWrite(Y, COMBINATION_ITEM_BASE + 1, BlkValueRead(rel, tmp + 3));
						LIST_OF_TY_InsertItem(X, Y);
					}
				}
				BlkValueWrite(Y, COMBINATION_ITEM_BASE, 0);
				BlkValueWrite(Y, COMBINATION_ITEM_BASE + 1, 0);
				BlkValueFree(Y);
				return X;
		}
		return X;
	}
	at = TwoInOneLookUp(rel, kx, X, RRF_ENTKEYX);
	switch(task) {
		RELS_TEST:
			if (at < 0) rfalse;
			fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);
			if (~~(fl & RRF_HASY)) rfalse;
			tmp = BlkValueRead(rel, RRV_DATA_BASE + 4*at + 3);
			if (KOVIsBlockValue(ky)) {
				if (BlkValueCompare(tmp, Y) == 0) rtrue;
			} else {
				if (tmp == Y) rtrue;
			}
			rfalse;
		RELS_ASSERT_TRUE:
			if (at < 0) {
				! create a new forward entry
				at = ~at;
				BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) + 1);
				fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);
				if (fl == 0)
					BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_FILLED) + 1);
				fl = RRF_USED+RRF_HASY+RRF_ENTKEYX;
				if (kx == ky || ~~(KOVIsBlockValue(kx) || KOVIsBlockValue(ky)))
					fl = fl + RRF_ENTKEYY;
				BlkValueWrite(rel, RRV_DATA_BASE + 4*at, fl);
				if (KOVIsBlockValue(kx)) { X = BlkValueCopy(BlkValueCreate(kx), X); }
				BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 1, X);
				BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 2, 0);
			} else {
				fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);
				if (fl & RRF_HASY) {
					! if the Y we're inserting is already there, we're done
					tmp = BlkValueRead(rel, RRV_DATA_BASE + 4*at + 3);
					if (KOVIsBlockValue(ky)) {
						if (BlkValueCompare(tmp, Y) == 0) rtrue;
					} else {
						if (tmp == Y) rtrue;
					}
					! it's different, so delete the reverse entry
					at2 = TwoInOneLookUp(rel, ky, tmp, RRF_ENTKEYY);
					if (at2 >= 0) TwoInOneDelete(rel, at2, kx, ky, RRF_ENTKEYY);
				} else {
					BlkValueWrite(rel, RRV_DATA_BASE + 4*at, fl + RRF_HASY);
				}
				! use the existing copy of X
				X = BlkValueRead(rel, RRV_DATA_BASE + 4*at + 1);
			}
			! use the existing copy of Y if there is one
			at2 = TwoInOneLookUp(rel, ky, Y, RRF_ENTKEYY);
			if (KOVIsBlockValue(ky)) {
				if (at2 >= 0)
					Y = BlkValueRead(rel, RRV_DATA_BASE + 4*at2 + 1);
				else
					Y = BlkValueCopy(BlkValueCreate(ky), Y);
			}
			BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 3, Y);
			if (at2 >= 0) {
				! delete existing reverse entry (and its own forward entry)
				TwoInOneDelete(rel, at2, kx, ky, RRF_ENTKEYY, 1);
			} else {
				at2 = ~at2;
			}
			! create reverse entry
			BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) + 1);
			fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at2);
			if (fl == 0)
				BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_FILLED) + 1);
			fl = fl | (RRF_USED+RRF_HASX+RRF_ENTKEYY);
			if (kx == ky || ~~(KOVIsBlockValue(kx) || KOVIsBlockValue(ky)))
				fl = fl | RRF_ENTKEYX;
			BlkValueWrite(rel, RRV_DATA_BASE + 4*at2, fl);
			BlkValueWrite(rel, RRV_DATA_BASE + 4*at2 + 1, Y);
			BlkValueWrite(rel, RRV_DATA_BASE + 4*at2 + 2, X);
			TwoInOneCheckResize(rel);
			rtrue;
		RELS_ASSERT_FALSE:
			! we only have work to do if the entry exists and has a Y which
			! matches the Y we're deleting
			if (at < 0) rtrue;
			fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);
			if ((fl & RRF_HASY) == 0) rtrue;
			tmp = BlkValueRead(rel, RRV_DATA_BASE + 4*at + 3);
			if (KOVIsBlockValue(ky)) {
				if (BlkValueCompare(tmp, Y) ~= 0) rtrue;
			} else {
				if (tmp ~= Y) rtrue;
			}
			TwoInOneDelete(rel, at, kx, ky, RRF_ENTKEYX, 1);
			rtrue;
	}
];

[ TwoInOneDelete rel at kx ky ekflag both  fl at2 E i;
!print "[2in1DEL at=", at, " (E=", BlkValueRead(rel, RRV_DATA_BASE + 4*at + 1), ") ekflag=", ekflag, " both=", both, "]^";
	fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);
	if (ekflag == RRF_ENTKEYX) {
		if (fl & RRF_HASY) {
			i = RRV_DATA_BASE + 4*at + 3;
			if (both) E = BlkValueRead(rel, i);
			BlkValueWrite(rel, i, 0);
			! delete matching Y<-X entry if needed
			if (both) {
				at2 = TwoInOneLookUp(rel, ky, E, RRF_ENTKEYY);
				if (at2 >= 0) TwoInOneDelete(rel, at2, kx, ky, RRF_ENTKEYY);
				if (at2 == at) fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);
			}
			fl = fl & ~RRF_HASY;
		}
	} else {
		if (fl & RRF_HASX) {
			i = RRV_DATA_BASE + 4*at + 2;
			if (both) E = BlkValueRead(rel, i);
			BlkValueWrite(rel, i, 0);
			! delete matching X->Y entry if needed
			if (both) {
				at2 = TwoInOneLookUp(rel, kx, E, RRF_ENTKEYX);
				if (at2 >= 0) {
					TwoInOneDelete(rel, at2, kx, ky, RRF_ENTKEYX);
					if (at2 == at) fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);
				}
			}
			fl = fl & ~RRF_HASX;
		}
	}
	if ((fl & (RRF_HASX+RRF_HASY)) == 0) {
		! entry is now empty, mark it deleted
		if (((fl & RRF_ENTKEYX) && KOVIsBlockValue(kx)) ||
		    ((ky ~= kx) && (fl & RRF_ENTKEYY) && KOVIsBlockValue(ky))) {
			BlkValueFree(BlkValueRead(rel, RRV_DATA_BASE + 4*at + 1));
		}
		BlkValueWrite(rel, RRV_DATA_BASE + 4*at, RRF_DELETED);
		BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 1, 0);
		BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 2, 0);
		BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 3, 0);
		BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) - 1);
	} else {
		BlkValueWrite(rel, RRV_DATA_BASE + 4*at, fl);
	}
];

[ TwoInOneLookUp rel ke E ekflag  hashv i free mask perturb flags;
!print "[2in1LU rel=", rel, " ke=", ke, " E=", E, " ekf=", ekflag, ": ";
	! calculate a hash value for the key
	hashv = GetHashValue(ke, E);
	! look in the first expected slot
	mask = BlkValueRead(rel, RRV_STORAGE);
	i = hashv & mask;
!print "hv=", hashv, ", trying ", i;
	flags = BlkValueRead(rel, RRV_DATA_BASE + 4*i);
	if (flags == 0) {
!print " - not found]^";
		return ~i;
	}
	if ((flags & ekflag) && TwoInOneEntryMatches(rel, i, ke, E)) {
!print " - found]^";
		return i;
	}
	! not here, keep looking in sequence
	free = -1;
	if (flags & RRF_DELETED) free = i;
	perturb = hashv;
	hashv = i;
	for (::) {
		hashv = hashv*5 + perturb + 1;
		i = hashv & mask;
!print ", ", i;
		flags = BlkValueRead(rel, RRV_DATA_BASE + 4*i);
		if (flags == 0) {
!print " - not found]^";
			if (free >= 0) return ~free;
			return ~i;
		}
		if ((flags & ekflag) && TwoInOneEntryMatches(rel, i, ke, E)) {
!print " - found]^";
			return i;
		}
		if ((free < 0) && (flags & RRF_DELETED)) free = i;
		#ifdef TARGET_ZCODE;
		@log_shift perturb (-RRP_PERTURB_SHIFT) -> perturb;
		#ifnot;
		@ushiftr perturb RRP_PERTURB_SHIFT perturb;
		#endif;
	}
];

[ TwoInOneCheckResize rel  filled ext newext temp i at kov kx ky F E X Y;
	filled = BlkValueRead(rel, RRV_FILLED);
	ext = BlkValueRead(rel, RRV_STORAGE) + 1;
	if (filled >= (ext - filled) * RRP_CROWDED_IS) {
		! copy entries to temporary space
		temp = FlexAllocate(ext * (4*WORDSIZE), TEXT_TY, BLK_FLAG_WORD+BLK_FLAG_MULTIPLE);
		for (i=0: i<ext*4: i++)
			BlkValueWrite(temp, i, BlkValueRead(rel, RRV_DATA_BASE+i), true);
		! resize and clear our data
		if (ext >= RRP_LARGE_IS) newext = ext * RRP_RESIZE_LARGE;
		else newext = ext * RRP_RESIZE_SMALL;
		BlkValueSetLBCapacity(rel, RRV_DATA_BASE + newext*4);
		BlkValueWrite(rel, RRV_STORAGE, newext - 1);
		BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_USED));
		for (i=0: i<newext*4: i++)
			BlkValueWrite(rel, RRV_DATA_BASE+i, 0);
		! copy entries back from temporary space
		kov = BlkValueRead(rel, RRV_KIND);
		kx = KindBaseTerm(kov, 0); ky = KindBaseTerm(kov, 1);
		for (i=0: i<ext: i++) {
			F = BlkValueRead(temp, 4*i, true);
			if (F == 0 || (F & RRF_DELETED)) continue;
			E = BlkValueRead(temp, 4*i + 1, true);
			X = BlkValueRead(temp, 4*i + 2, true);
			Y = BlkValueRead(temp, 4*i + 3, true);
			if (F & RRF_ENTKEYX) at = TwoInOneLookUp(rel, kx, E, RRF_ENTKEYX);
			else at = TwoInOneLookUp(rel, ky, E, RRF_ENTKEYY);
			if (at >= 0) { print "*** Duplicate entry while resizing ***^"; rfalse; }
			at = ~at;
			BlkValueWrite(rel, RRV_DATA_BASE + 4*at, F);
			BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 1, E);
			BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 2, X);
			BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 3, Y);
		}
		! done with temporary space
		FlexFree(temp);
	}
];

[ TwoInOneEntryMatches rel at ke E  ce;
	ce = BlkValueRead(rel, RRV_DATA_BASE + 4*at + 1);
	if (KOVIsBlockValue(ke)) {
		if (BlkValueCompare(ce, E) ~= 0) rfalse;
	} else {
		if (ce ~= E) rfalse;
	}
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: Empty
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ RELATION_TY_Empty rel set  handler;
	handler = RlnGetF(rel, RR_HANDLER);
	return handler(rel, RELS_EMPTY, set);
];


Array ResourceIDsOfFigures --> 0 1  0;

Array ResourceIDsOfSounds --> 0  0;



Array BC_0 --> PACKED_TEXT_STORAGE TX_PS_2;
Array BC_1 --> PACKED_TEXT_STORAGE TX_PS_3;
Array BC_2 --> PACKED_TEXT_STORAGE TX_PS_4;
Array BC_3 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_4 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_5 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_6 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_7 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_8 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_9 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_10 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_11 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_12 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_13 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_14 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_15 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_16 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_17 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_18 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_19 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_20 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_21 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_22 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_23 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_24 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_25 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_26 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_27 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_28 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_29 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_30 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_31 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_32 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_33 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_34 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_35 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_36 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_37 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_38 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_39 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_40 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_41 --> PACKED_TEXT_STORAGE TX_PS_6;
Array BC_42 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_43 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_44 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_45 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_46 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_47 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_48 --> PACKED_TEXT_STORAGE TX_PS_7;
Array BC_49 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_50 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_51 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_52 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_53 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_54 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_55 --> PACKED_TEXT_STORAGE TX_PS_8;
Array BC_56 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_57 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_58 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_59 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_60 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_61 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_62 --> PACKED_TEXT_STORAGE TX_PS_9;
Array BC_63 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_64 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_65 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_66 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_67 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_68 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_69 --> PACKED_TEXT_STORAGE TX_PS_10;
Array BC_70 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_71 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_72 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_73 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_74 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_75 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_76 --> PACKED_TEXT_STORAGE TX_PS_11;
Array BC_77 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_78 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_79 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_80 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_81 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_82 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_83 --> PACKED_TEXT_STORAGE TX_PS_12;
Array BC_84 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_85 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_86 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_87 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_88 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_89 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_90 --> PACKED_TEXT_STORAGE TX_PS_13;
Array BC_91 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_92 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_93 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_94 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_95 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_96 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_97 --> PACKED_TEXT_STORAGE TX_PS_14;
Array BC_98 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_99 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_100 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_101 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_102 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_103 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_104 --> PACKED_TEXT_STORAGE TX_PS_15;
Array BC_105 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_106 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_107 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_108 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_109 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_110 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_111 --> PACKED_TEXT_STORAGE TX_PS_16;
Array BC_112 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_113 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_114 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_115 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_116 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_117 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_118 --> PACKED_TEXT_STORAGE TX_PS_17;
Array BC_119 --> PACKED_TEXT_STORAGE TX_PS_18;
Array BC_120 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_121 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_122 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_123 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_124 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_125 --> PACKED_TEXT_STORAGE TX_PS_19;
Array BC_126 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_127 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_128 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_129 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_130 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_131 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_132 --> PACKED_TEXT_STORAGE TX_PS_20;
Array BC_133 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_134 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_135 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_136 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_137 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_138 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_139 --> PACKED_TEXT_STORAGE TX_PS_21;
Array BC_140 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_141 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_142 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_143 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_144 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_145 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_146 --> PACKED_TEXT_STORAGE TX_PS_22;
Array BC_147 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_148 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_149 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_150 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_151 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_152 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_153 --> PACKED_TEXT_STORAGE TX_PS_23;
Array BC_154 --> PACKED_TEXT_STORAGE TX_PS_24;
Array BC_155 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_156 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_157 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_158 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_159 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_160 --> PACKED_TEXT_STORAGE TX_PS_25;
Array BC_161 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_162 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_163 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_164 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_165 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_166 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_167 --> PACKED_TEXT_STORAGE TX_PS_26;
Array BC_168 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_169 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_170 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_171 --> PACKED_TEXT_STORAGE TX_PS_27;
Array BC_172 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_173 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_174 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_175 --> PACKED_TEXT_STORAGE TX_PS_28;
Array BC_176 --> PACKED_TEXT_STORAGE TX_PS_29;
Array BC_177 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_178 --> PACKED_TEXT_STORAGE TX_PS_27;
Array BC_179 --> PACKED_TEXT_STORAGE TX_PS_30;
Array BC_180 --> PACKED_TEXT_STORAGE TX_PS_29;
Array BC_181 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_182 --> PACKED_TEXT_STORAGE TX_PS_27;
Array BC_183 --> PACKED_TEXT_STORAGE TX_PS_31;
Array BC_184 --> PACKED_TEXT_STORAGE TX_PS_29;
Array BC_185 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_186 --> PACKED_TEXT_STORAGE TX_PS_27;
Array BC_187 --> PACKED_TEXT_STORAGE TX_PS_32;
Array BC_188 --> PACKED_TEXT_STORAGE TX_PS_29;
Array BC_189 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_190 --> PACKED_TEXT_STORAGE TX_PS_27;
Array BC_191 --> PACKED_TEXT_STORAGE TX_PS_33;
Array BC_192 --> PACKED_TEXT_STORAGE TX_PS_29;
Array BC_193 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_194 --> PACKED_TEXT_STORAGE TX_PS_27;
Array BC_195 --> PACKED_TEXT_STORAGE TX_PS_34;
Array BC_196 --> PACKED_TEXT_STORAGE TX_PS_29;
Array BC_197 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_198 --> PACKED_TEXT_STORAGE TX_PS_27;
Array BC_199 --> PACKED_TEXT_STORAGE TX_PS_35;
Array BC_200 --> PACKED_TEXT_STORAGE TX_PS_29;
Array BC_201 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_202 --> PACKED_TEXT_STORAGE TX_PS_27;
Array BC_203 --> PACKED_TEXT_STORAGE TX_PS_36;
Array BC_204 --> PACKED_TEXT_STORAGE TX_PS_29;
Array BC_205 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_206 --> PACKED_TEXT_STORAGE TX_PS_27;
Array BC_207 --> PACKED_TEXT_STORAGE TX_PS_37;
Array BC_208 --> PACKED_TEXT_STORAGE TX_PS_29;
Array BC_209 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_210 --> PACKED_TEXT_STORAGE TX_PS_27;
Array BC_211 --> PACKED_TEXT_STORAGE TX_PS_38;
Array BC_212 --> PACKED_TEXT_STORAGE TX_PS_29;
Array BC_213 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_214 --> PACKED_TEXT_STORAGE TX_PS_27;
Array BC_215 --> PACKED_TEXT_STORAGE TX_PS_39;
Array BC_216 --> PACKED_TEXT_STORAGE TX_PS_29;
Array BC_217 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_218 --> PACKED_TEXT_STORAGE TX_PS_27;
Array BC_219 --> PACKED_TEXT_STORAGE TX_PS_40;
Array BC_220 --> PACKED_TEXT_STORAGE TX_PS_29;
Array BC_221 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_222 --> PACKED_TEXT_STORAGE TX_PS_27;
Array BC_223 --> PACKED_TEXT_STORAGE TX_PS_41;
Array BC_224 --> PACKED_TEXT_STORAGE TX_PS_42;
Array BC_225 --> PACKED_TEXT_STORAGE TX_PS_43;
Array BC_226 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_227 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_228 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_229 --> PACKED_TEXT_STORAGE TX_PS_9;
Array BC_230 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_231 --> PACKED_TEXT_STORAGE TX_PS_44;
Array BC_232 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_233 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_234 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_235 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_236 --> PACKED_TEXT_STORAGE TX_PS_14;
Array BC_237 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_238 --> PACKED_TEXT_STORAGE TX_PS_45;
Array BC_239 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_132;
Array BC_240 --> PACKED_TEXT_STORAGE TX_PS_45;
Array BC_241 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_242 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_243 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_244 --> PACKED_TEXT_STORAGE TX_PS_46;
Array BC_245 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_133;
Array BC_246 --> PACKED_TEXT_STORAGE TX_PS_47;
Array BC_247 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_248 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_249 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_250 --> PACKED_TEXT_STORAGE TX_PS_48;
Array BC_251 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_252 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_253 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_254 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_255 --> PACKED_TEXT_STORAGE TX_PS_14;
Array BC_256 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_257 --> PACKED_TEXT_STORAGE TX_PS_49;
Array BC_258 --> PACKED_TEXT_STORAGE TX_PS_49;
Array BC_259 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_260 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_261 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_262 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_263 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_264 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_265 --> PACKED_TEXT_STORAGE TX_PS_50;
Array BC_266 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_134;
Array BC_267 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_135;
Array BC_268 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_269 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_270 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_271 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_272 --> PACKED_TEXT_STORAGE TX_PS_51;
Array BC_273 --> PACKED_TEXT_STORAGE TX_PS_52;
Array BC_274 --> PACKED_TEXT_STORAGE TX_PS_51;
Array BC_275 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_276 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_277 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_278 --> PACKED_TEXT_STORAGE TX_PS_10;
Array BC_279 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_280 --> PACKED_TEXT_STORAGE TX_PS_53;
Array BC_281 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_136;
Array BC_282 --> PACKED_TEXT_STORAGE TX_PS_54;
Array BC_283 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_284 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_285 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_286 --> PACKED_TEXT_STORAGE TX_PS_55;
Array BC_287 --> PACKED_TEXT_STORAGE TX_PS_56;
Array BC_288 --> PACKED_TEXT_STORAGE TX_PS_55;
Array BC_289 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_290 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_291 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_292 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_293 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_294 --> PACKED_TEXT_STORAGE TX_PS_57;
Array BC_295 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_296 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_297 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_298 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_299 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_300 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_301 --> PACKED_TEXT_STORAGE TX_PS_58;
Array BC_302 --> PACKED_TEXT_STORAGE TX_PS_58;
Array BC_303 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_304 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_305 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_306 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_307 --> PACKED_TEXT_STORAGE TX_PS_59;
Array BC_308 --> PACKED_TEXT_STORAGE TX_PS_59;
Array BC_309 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_310 --> PACKED_TEXT_STORAGE TX_PS_26;
Array BC_311 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_312 --> PACKED_TEXT_STORAGE TX_PS_60;
Array BC_313 --> PACKED_TEXT_STORAGE TX_PS_61;
Array BC_314 --> PACKED_TEXT_STORAGE TX_PS_60;
Array BC_315 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_316 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_317 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_318 --> PACKED_TEXT_STORAGE TX_PS_62;
Array BC_319 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_320 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_321 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_322 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_323 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_324 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_325 --> PACKED_TEXT_STORAGE TX_PS_63;
Array BC_326 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_327 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_328 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_329 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_330 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_331 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_332 --> PACKED_TEXT_STORAGE TX_PS_64;
Array BC_333 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_334 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_335 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_336 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_337 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_338 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_339 --> PACKED_TEXT_STORAGE TX_PS_65;
Array BC_340 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_341 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_342 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_343 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_344 --> PACKED_TEXT_STORAGE TX_PS_20;
Array BC_345 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_346 --> PACKED_TEXT_STORAGE TX_PS_66;
Array BC_347 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_137;
Array BC_348 --> PACKED_TEXT_STORAGE TX_PS_66;
Array BC_349 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_350 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_351 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_352 --> PACKED_TEXT_STORAGE TX_PS_67;
Array BC_353 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_138;
Array BC_354 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_139;
Array BC_355 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_356 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_357 --> PACKED_TEXT_STORAGE TX_PS_11;
Array BC_358 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_359 --> PACKED_TEXT_STORAGE TX_PS_68;
Array BC_360 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_361 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_362 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_363 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_364 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_365 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_366 --> PACKED_TEXT_STORAGE TX_PS_69;
Array BC_367 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_368 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_369 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_370 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_371 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_372 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_373 --> PACKED_TEXT_STORAGE TX_PS_70;
Array BC_374 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_375 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_376 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_377 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_378 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_379 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_380 --> PACKED_TEXT_STORAGE TX_PS_71;
Array BC_381 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_382 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_383 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_384 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_385 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_386 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_387 --> PACKED_TEXT_STORAGE TX_PS_72;
Array BC_388 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_389 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_390 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_391 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_392 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_393 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_394 --> PACKED_TEXT_STORAGE TX_PS_73;
Array BC_395 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_140;
Array BC_396 --> PACKED_TEXT_STORAGE TX_PS_73;
Array BC_397 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_398 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_399 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_400 --> PACKED_TEXT_STORAGE TX_PS_74;
Array BC_401 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_402 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_403 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_404 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_405 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_406 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_407 --> PACKED_TEXT_STORAGE TX_PS_75;
Array BC_408 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_409 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_410 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_411 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_412 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_413 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_414 --> PACKED_TEXT_STORAGE TX_PS_76;
Array BC_415 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_416 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_417 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_418 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_419 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_420 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_421 --> PACKED_TEXT_STORAGE TX_PS_77;
Array BC_422 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_141;
Array BC_423 --> PACKED_TEXT_STORAGE TX_PS_77;
Array BC_424 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_425 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_426 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_427 --> PACKED_TEXT_STORAGE TX_PS_78;
Array BC_428 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_429 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_430 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_431 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_432 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_433 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_434 --> PACKED_TEXT_STORAGE TX_PS_79;
Array BC_435 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_436 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_437 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_438 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_439 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_440 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_441 --> PACKED_TEXT_STORAGE TX_PS_80;
Array BC_442 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_443 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_444 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_445 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_446 --> PACKED_TEXT_STORAGE TX_PS_14;
Array BC_447 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_448 --> PACKED_TEXT_STORAGE TX_PS_81;
Array BC_449 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_142;
Array BC_450 --> PACKED_TEXT_STORAGE TX_PS_81;
Array BC_451 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_452 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_453 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_454 --> PACKED_TEXT_STORAGE TX_PS_82;
Array BC_455 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_456 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_457 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_458 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_459 --> PACKED_TEXT_STORAGE TX_PS_7;
Array BC_460 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_461 --> PACKED_TEXT_STORAGE TX_PS_82;
Array BC_462 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_463 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_464 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_465 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_466 --> PACKED_TEXT_STORAGE TX_PS_7;
Array BC_467 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_468 --> PACKED_TEXT_STORAGE TX_PS_83;
Array BC_469 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_470 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_471 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_472 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_473 --> PACKED_TEXT_STORAGE TX_PS_8;
Array BC_474 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_475 --> PACKED_TEXT_STORAGE TX_PS_84;
Array BC_476 --> PACKED_TEXT_STORAGE TX_PS_85;
Array BC_477 --> PACKED_TEXT_STORAGE TX_PS_84;
Array BC_478 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_479 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_480 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_481 --> PACKED_TEXT_STORAGE TX_PS_10;
Array BC_482 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_483 --> PACKED_TEXT_STORAGE TX_PS_86;
Array BC_484 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_143;
Array BC_485 --> PACKED_TEXT_STORAGE TX_PS_86;
Array BC_486 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_487 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_488 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_489 --> PACKED_TEXT_STORAGE TX_PS_87;
Array BC_490 --> PACKED_TEXT_STORAGE TX_PS_87;
Array BC_491 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_492 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_493 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_494 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_495 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_496 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_497 --> PACKED_TEXT_STORAGE TX_PS_88;
Array BC_498 --> PACKED_TEXT_STORAGE TX_PS_88;
Array BC_499 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_500 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_501 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_502 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_503 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_504 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_505 --> PACKED_TEXT_STORAGE TX_PS_89;
Array BC_506 --> PACKED_TEXT_STORAGE TX_PS_90;
Array BC_507 --> PACKED_TEXT_STORAGE TX_PS_89;
Array BC_508 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_509 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_510 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_511 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_512 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_513 --> PACKED_TEXT_STORAGE TX_PS_91;
Array BC_514 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_144;
Array BC_515 --> PACKED_TEXT_STORAGE TX_PS_91;
Array BC_516 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_517 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_518 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_519 --> PACKED_TEXT_STORAGE TX_PS_92;
Array BC_520 --> PACKED_TEXT_STORAGE TX_PS_93;
Array BC_521 --> PACKED_TEXT_STORAGE TX_PS_92;
Array BC_522 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_523 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_524 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_525 --> PACKED_TEXT_STORAGE TX_PS_9;
Array BC_526 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_527 --> PACKED_TEXT_STORAGE TX_PS_94;
Array BC_528 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_529 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_530 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_531 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_532 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_533 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_534 --> PACKED_TEXT_STORAGE TX_PS_95;
Array BC_535 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_536 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_537 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_538 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_539 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_540 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_541 --> PACKED_TEXT_STORAGE TX_PS_96;
Array BC_542 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_543 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_544 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_545 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_546 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_547 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_548 --> PACKED_TEXT_STORAGE TX_PS_97;
Array BC_549 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_145;
Array BC_550 --> PACKED_TEXT_STORAGE TX_PS_97;
Array BC_551 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_552 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_553 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_554 --> PACKED_TEXT_STORAGE TX_PS_98;
Array BC_555 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_556 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_557 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_558 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_559 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_560 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_561 --> PACKED_TEXT_STORAGE TX_PS_99;
Array BC_562 --> PACKED_TEXT_STORAGE TX_PS_100;
Array BC_563 --> PACKED_TEXT_STORAGE TX_PS_101;
Array BC_564 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_565 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_566 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_567 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_568 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_569 --> PACKED_TEXT_STORAGE TX_PS_102;
Array BC_570 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_146;
Array BC_571 --> PACKED_TEXT_STORAGE TX_PS_102;
Array BC_572 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_573 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_574 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_575 --> PACKED_TEXT_STORAGE TX_PS_103;
Array BC_576 --> PACKED_TEXT_STORAGE TX_PS_104;
Array BC_577 --> PACKED_TEXT_STORAGE TX_PS_103;
Array BC_578 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_579 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_580 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_581 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_582 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_583 --> PACKED_TEXT_STORAGE TX_PS_105;
Array BC_584 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_147;
Array BC_585 --> PACKED_TEXT_STORAGE TX_PS_105;
Array BC_586 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_587 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_588 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_589 --> PACKED_TEXT_STORAGE TX_PS_106;
Array BC_590 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_591 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_592 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_593 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_594 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_595 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_596 --> PACKED_TEXT_STORAGE TX_PS_107;
Array BC_597 --> PACKED_TEXT_STORAGE TX_PS_108;
Array BC_598 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_599 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_600 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_601 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_602 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_603 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_604 --> PACKED_TEXT_STORAGE TX_PS_109;
Array BC_605 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_148;
Array BC_606 --> PACKED_TEXT_STORAGE TX_PS_109;
Array BC_607 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_608 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_609 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_610 --> PACKED_TEXT_STORAGE TX_PS_110;
Array BC_611 --> PACKED_TEXT_STORAGE TX_PS_111;
Array BC_612 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_613 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_614 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_615 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_616 --> PACKED_TEXT_STORAGE TX_PS_9;
Array BC_617 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_618 --> PACKED_TEXT_STORAGE TX_PS_112;
Array BC_619 --> PACKED_TEXT_STORAGE TX_PS_113;
Array BC_620 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_621 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_622 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_623 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_624 --> PACKED_TEXT_STORAGE TX_PS_9;
Array BC_625 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_626 --> PACKED_TEXT_STORAGE TX_PS_114;
Array BC_627 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_149;
Array BC_628 --> PACKED_TEXT_STORAGE TX_PS_114;
Array BC_629 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_630 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_631 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_632 --> PACKED_TEXT_STORAGE TX_PS_115;
Array BC_633 --> PACKED_TEXT_STORAGE TX_PS_116;
Array BC_634 --> PACKED_TEXT_STORAGE TX_PS_115;
Array BC_635 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_636 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_637 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_638 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_639 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_640 --> PACKED_TEXT_STORAGE TX_PS_117;
Array BC_641 --> PACKED_TEXT_STORAGE TX_PS_118;
Array BC_642 --> PACKED_TEXT_STORAGE TX_PS_117;
Array BC_643 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_644 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_645 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_646 --> PACKED_TEXT_STORAGE TX_PS_9;
Array BC_647 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_648 --> PACKED_TEXT_STORAGE TX_PS_119;
Array BC_649 --> PACKED_TEXT_STORAGE TX_PS_120;
Array BC_650 --> PACKED_TEXT_STORAGE TX_PS_119;
Array BC_651 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_652 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_653 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_654 --> PACKED_TEXT_STORAGE TX_PS_9;
Array BC_655 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_656 --> PACKED_TEXT_STORAGE TX_PS_121;
Array BC_657 --> PACKED_TEXT_STORAGE TX_PS_122;
Array BC_658 --> PACKED_TEXT_STORAGE TX_PS_121;
Array BC_659 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_660 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_661 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_662 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_663 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_664 --> PACKED_TEXT_STORAGE TX_PS_123;
Array BC_665 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_150;
Array BC_666 --> PACKED_TEXT_STORAGE TX_PS_123;
Array BC_667 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_668 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_669 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_670 --> PACKED_TEXT_STORAGE TX_PS_124;
Array BC_671 --> PACKED_TEXT_STORAGE TX_PS_125;
Array BC_672 --> PACKED_TEXT_STORAGE TX_PS_124;
Array BC_673 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_674 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_675 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_676 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_677 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_678 --> PACKED_TEXT_STORAGE TX_PS_126;
Array BC_679 --> PACKED_TEXT_STORAGE TX_PS_126;
Array BC_680 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_681 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_682 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_683 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_684 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_685 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_686 --> PACKED_TEXT_STORAGE TX_PS_127;
Array BC_687 --> PACKED_TEXT_STORAGE TX_PS_127;
Array BC_688 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_689 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_690 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_691 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_692 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_693 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_694 --> PACKED_TEXT_STORAGE TX_PS_128;
Array BC_695 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_151;
Array BC_696 --> PACKED_TEXT_STORAGE TX_PS_128;
Array BC_697 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_698 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_699 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_700 --> PACKED_TEXT_STORAGE TX_PS_129;
Array BC_701 --> PACKED_TEXT_STORAGE TX_PS_130;
Array BC_702 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_703 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_704 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_705 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_706 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_707 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_708 --> PACKED_TEXT_STORAGE TX_PS_131;
Array BC_709 --> PACKED_TEXT_STORAGE TX_PS_131;
Array BC_710 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_711 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_712 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_713 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_714 --> PACKED_TEXT_STORAGE TX_PS_13;
Array BC_715 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_716 --> PACKED_TEXT_STORAGE TX_PS_132;
Array BC_717 --> PACKED_TEXT_STORAGE TX_PS_133;
Array BC_718 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_719 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_720 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_721 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_722 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_723 --> PACKED_TEXT_STORAGE TX_PS_134;
Array BC_724 --> PACKED_TEXT_STORAGE TX_PS_135;
Array BC_725 --> PACKED_TEXT_STORAGE TX_PS_134;
Array BC_726 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_727 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_728 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_729 --> PACKED_TEXT_STORAGE TX_PS_136;
Array BC_730 --> PACKED_TEXT_STORAGE TX_PS_137;
Array BC_731 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_732 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_733 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_734 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_735 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_736 --> PACKED_TEXT_STORAGE TX_PS_138;
Array BC_737 --> PACKED_TEXT_STORAGE TX_PS_18;
Array BC_738 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_739 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_740 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_741 --> PACKED_TEXT_STORAGE TX_PS_17;
Array BC_742 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_743 --> PACKED_TEXT_STORAGE TX_PS_139;
Array BC_744 --> PACKED_TEXT_STORAGE TX_PS_18;
Array BC_745 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_746 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_747 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_748 --> PACKED_TEXT_STORAGE TX_PS_17;
Array BC_749 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_750 --> PACKED_TEXT_STORAGE TX_PS_140;
Array BC_751 --> PACKED_TEXT_STORAGE TX_PS_18;
Array BC_752 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_753 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_754 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_755 --> PACKED_TEXT_STORAGE TX_PS_17;
Array BC_756 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_757 --> PACKED_TEXT_STORAGE TX_PS_141;
Array BC_758 --> PACKED_TEXT_STORAGE TX_PS_142;
Array BC_759 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_152;
Array BC_760 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_761 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_762 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_763 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_764 --> PACKED_TEXT_STORAGE TX_PS_143;
Array BC_765 --> PACKED_TEXT_STORAGE TX_PS_143;
Array BC_766 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_767 --> PACKED_TEXT_STORAGE TX_PS_26;
Array BC_768 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_769 --> PACKED_TEXT_STORAGE TX_PS_144;
Array BC_770 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_153;
Array BC_771 --> PACKED_TEXT_STORAGE TX_PS_144;
Array BC_772 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_773 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_774 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_775 --> PACKED_TEXT_STORAGE TX_PS_145;
Array BC_776 --> PACKED_TEXT_STORAGE TX_PS_145;
Array BC_777 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_778 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_779 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_780 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_781 --> PACKED_TEXT_STORAGE TX_PS_9;
Array BC_782 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_783 --> PACKED_TEXT_STORAGE TX_PS_146;
Array BC_784 --> PACKED_TEXT_STORAGE TX_PS_146;
Array BC_785 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_786 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_787 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_788 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_789 --> PACKED_TEXT_STORAGE TX_PS_9;
Array BC_790 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_791 --> PACKED_TEXT_STORAGE TX_PS_147;
Array BC_792 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_154;
Array BC_793 --> PACKED_TEXT_STORAGE TX_PS_147;
Array BC_794 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_795 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_796 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_797 --> PACKED_TEXT_STORAGE TX_PS_148;
Array BC_798 --> PACKED_TEXT_STORAGE TX_PS_148;
Array BC_799 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_800 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_801 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_802 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_803 --> PACKED_TEXT_STORAGE TX_PS_9;
Array BC_804 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_805 --> PACKED_TEXT_STORAGE TX_PS_149;
Array BC_806 --> PACKED_TEXT_STORAGE TX_PS_149;
Array BC_807 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_808 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_809 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_810 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_811 --> PACKED_TEXT_STORAGE TX_PS_9;
Array BC_812 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_813 --> PACKED_TEXT_STORAGE TX_PS_150;
Array BC_814 --> PACKED_TEXT_STORAGE TX_PS_150;
Array BC_815 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_816 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_817 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_818 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_819 --> PACKED_TEXT_STORAGE TX_PS_9;
Array BC_820 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_821 --> PACKED_TEXT_STORAGE TX_PS_151;
Array BC_822 --> PACKED_TEXT_STORAGE TX_PS_151;
Array BC_823 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_824 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_825 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_826 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_827 --> PACKED_TEXT_STORAGE TX_PS_152;
Array BC_828 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_155;
Array BC_829 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_830 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_831 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_832 --> PACKED_TEXT_STORAGE TX_PS_20;
Array BC_833 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_834 --> PACKED_TEXT_STORAGE TX_PS_153;
Array BC_835 --> PACKED_TEXT_STORAGE TX_PS_154;
Array BC_836 --> PACKED_TEXT_STORAGE TX_PS_153;
Array BC_837 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_838 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_839 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_840 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_841 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_842 --> PACKED_TEXT_STORAGE TX_PS_155;
Array BC_843 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_156;
Array BC_844 --> PACKED_TEXT_STORAGE TX_PS_155;
Array BC_845 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_846 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_847 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_848 --> PACKED_TEXT_STORAGE TX_PS_156;
Array BC_849 --> PACKED_TEXT_STORAGE TX_PS_156;
Array BC_850 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_851 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_852 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_853 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_854 --> PACKED_TEXT_STORAGE TX_PS_14;
Array BC_855 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_856 --> PACKED_TEXT_STORAGE TX_PS_157;
Array BC_857 --> PACKED_TEXT_STORAGE TX_PS_158;
Array BC_858 --> PACKED_TEXT_STORAGE TX_PS_157;
Array BC_859 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_860 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_861 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_862 --> PACKED_TEXT_STORAGE TX_PS_9;
Array BC_863 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_864 --> PACKED_TEXT_STORAGE TX_PS_159;
Array BC_865 --> PACKED_TEXT_STORAGE TX_PS_159;
Array BC_866 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_867 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_868 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_869 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_870 --> PACKED_TEXT_STORAGE TX_PS_14;
Array BC_871 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_872 --> PACKED_TEXT_STORAGE TX_PS_160;
Array BC_873 --> PACKED_TEXT_STORAGE TX_PS_161;
Array BC_874 --> PACKED_TEXT_STORAGE TX_PS_160;
Array BC_875 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_876 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_877 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_878 --> PACKED_TEXT_STORAGE TX_PS_9;
Array BC_879 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_880 --> PACKED_TEXT_STORAGE TX_PS_162;
Array BC_881 --> PACKED_TEXT_STORAGE TX_PS_163;
Array BC_882 --> PACKED_TEXT_STORAGE TX_PS_162;
Array BC_883 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_884 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_885 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_886 --> PACKED_TEXT_STORAGE TX_PS_9;
Array BC_887 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_888 --> PACKED_TEXT_STORAGE TX_PS_164;
Array BC_889 --> PACKED_TEXT_STORAGE TX_PS_164;
Array BC_890 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_891 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_892 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_893 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_894 --> PACKED_TEXT_STORAGE TX_PS_14;
Array BC_895 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_896 --> PACKED_TEXT_STORAGE TX_PS_165;
Array BC_897 --> PACKED_TEXT_STORAGE TX_PS_166;
Array BC_898 --> PACKED_TEXT_STORAGE TX_PS_165;
Array BC_899 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_900 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_901 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_902 --> PACKED_TEXT_STORAGE TX_PS_9;
Array BC_903 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_904 --> PACKED_TEXT_STORAGE TX_PS_167;
Array BC_905 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_157;
Array BC_906 --> PACKED_TEXT_STORAGE TX_PS_167;
Array BC_907 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_908 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_909 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_910 --> PACKED_TEXT_STORAGE TX_PS_168;
Array BC_911 --> PACKED_TEXT_STORAGE TX_PS_168;
Array BC_912 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_913 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_914 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_915 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_916 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_917 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_918 --> PACKED_TEXT_STORAGE TX_PS_169;
Array BC_919 --> PACKED_TEXT_STORAGE TX_PS_170;
Array BC_920 --> PACKED_TEXT_STORAGE TX_PS_169;
Array BC_921 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_922 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_923 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_924 --> PACKED_TEXT_STORAGE TX_PS_11;
Array BC_925 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_926 --> PACKED_TEXT_STORAGE TX_PS_171;
Array BC_927 --> PACKED_TEXT_STORAGE TX_PS_172;
Array BC_928 --> PACKED_TEXT_STORAGE TX_PS_171;
Array BC_929 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_930 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_931 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_932 --> PACKED_TEXT_STORAGE TX_PS_173;
Array BC_933 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_934 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_935 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_936 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_937 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_938 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_939 --> PACKED_TEXT_STORAGE TX_PS_174;
Array BC_940 --> PACKED_TEXT_STORAGE TX_PS_175;
Array BC_941 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_942 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_943 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_944 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_945 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_946 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_947 --> PACKED_TEXT_STORAGE TX_PS_176;
Array BC_948 --> PACKED_TEXT_STORAGE TX_PS_177;
Array BC_949 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_950 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_951 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_952 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_953 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_954 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_955 --> PACKED_TEXT_STORAGE TX_PS_178;
Array BC_956 --> PACKED_TEXT_STORAGE TX_PS_179;
Array BC_957 --> PACKED_TEXT_STORAGE TX_PS_178;
Array BC_958 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_959 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_960 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_961 --> PACKED_TEXT_STORAGE TX_PS_180;
Array BC_962 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_963 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_964 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_965 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_966 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_967 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_968 --> PACKED_TEXT_STORAGE TX_PS_181;
Array BC_969 --> PACKED_TEXT_STORAGE TX_PS_182;
Array BC_970 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_971 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_972 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_973 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_974 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_975 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_976 --> PACKED_TEXT_STORAGE TX_PS_183;
Array BC_977 --> PACKED_TEXT_STORAGE TX_PS_184;
Array BC_978 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_979 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_980 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_981 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_982 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_983 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_984 --> PACKED_TEXT_STORAGE TX_PS_185;
Array BC_985 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_158;
Array BC_986 --> PACKED_TEXT_STORAGE TX_PS_185;
Array BC_987 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_988 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_989 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_990 --> PACKED_TEXT_STORAGE TX_PS_186;
Array BC_991 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_159;
Array BC_992 --> PACKED_TEXT_STORAGE TX_PS_186;
Array BC_993 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_994 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_995 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_996 --> PACKED_TEXT_STORAGE TX_PS_187;
Array BC_997 --> PACKED_TEXT_STORAGE TX_PS_188;
Array BC_998 --> PACKED_TEXT_STORAGE TX_PS_187;
Array BC_999 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1000 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1001 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1002 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1003 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1004 --> PACKED_TEXT_STORAGE TX_PS_189;
Array BC_1005 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1006 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1007 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1008 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1009 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1010 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1011 --> PACKED_TEXT_STORAGE TX_PS_190;
Array BC_1012 --> PACKED_TEXT_STORAGE TX_PS_191;
Array BC_1013 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1014 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1015 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1016 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1017 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1018 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1019 --> PACKED_TEXT_STORAGE TX_PS_192;
Array BC_1020 --> PACKED_TEXT_STORAGE TX_PS_179;
Array BC_1021 --> PACKED_TEXT_STORAGE TX_PS_192;
Array BC_1022 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1023 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1024 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1025 --> PACKED_TEXT_STORAGE TX_PS_193;
Array BC_1026 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1027 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1028 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1029 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1030 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1031 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1032 --> PACKED_TEXT_STORAGE TX_PS_194;
Array BC_1033 --> PACKED_TEXT_STORAGE TX_PS_195;
Array BC_1034 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1035 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1036 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1037 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1038 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1039 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1040 --> PACKED_TEXT_STORAGE TX_PS_196;
Array BC_1041 --> PACKED_TEXT_STORAGE TX_PS_196;
Array BC_1042 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1043 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1044 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1045 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1046 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1047 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1048 --> PACKED_TEXT_STORAGE TX_PS_197;
Array BC_1049 --> PACKED_TEXT_STORAGE TX_PS_197;
Array BC_1050 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1051 --> PACKED_TEXT_STORAGE TX_PS_26;
Array BC_1052 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1053 --> PACKED_TEXT_STORAGE TX_PS_198;
Array BC_1054 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_160;
Array BC_1055 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1056 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1057 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1058 --> PACKED_TEXT_STORAGE TX_PS_199;
Array BC_1059 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_161;
Array BC_1060 --> PACKED_TEXT_STORAGE TX_PS_199;
Array BC_1061 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1062 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1063 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1064 --> PACKED_TEXT_STORAGE TX_PS_200;
Array BC_1065 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_162;
Array BC_1066 --> PACKED_TEXT_STORAGE TX_PS_200;
Array BC_1067 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1068 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1069 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1070 --> PACKED_TEXT_STORAGE TX_PS_201;
Array BC_1071 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_163;
Array BC_1072 --> PACKED_TEXT_STORAGE TX_PS_201;
Array BC_1073 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1074 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1075 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1076 --> PACKED_TEXT_STORAGE TX_PS_11;
Array BC_1077 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1078 --> PACKED_TEXT_STORAGE TX_PS_202;
Array BC_1079 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_164;
Array BC_1080 --> PACKED_TEXT_STORAGE TX_PS_202;
Array BC_1081 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1082 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1083 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1084 --> PACKED_TEXT_STORAGE TX_PS_11;
Array BC_1085 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1086 --> PACKED_TEXT_STORAGE TX_PS_203;
Array BC_1087 --> PACKED_TEXT_STORAGE TX_PS_204;
Array BC_1088 --> PACKED_TEXT_STORAGE TX_PS_203;
Array BC_1089 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1090 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1091 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1092 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_1093 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1094 --> PACKED_TEXT_STORAGE TX_PS_205;
Array BC_1095 --> PACKED_TEXT_STORAGE TX_PS_206;
Array BC_1096 --> PACKED_TEXT_STORAGE TX_PS_205;
Array BC_1097 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1098 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1099 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1100 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_1101 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1102 --> PACKED_TEXT_STORAGE TX_PS_207;
Array BC_1103 --> PACKED_TEXT_STORAGE TX_PS_208;
Array BC_1104 --> PACKED_TEXT_STORAGE TX_PS_209;
Array BC_1105 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1106 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1107 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1108 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_1109 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1110 --> PACKED_TEXT_STORAGE TX_PS_210;
Array BC_1111 --> PACKED_TEXT_STORAGE TX_PS_211;
Array BC_1112 --> PACKED_TEXT_STORAGE TX_PS_212;
Array BC_1113 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1114 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1115 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1116 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1117 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1118 --> PACKED_TEXT_STORAGE TX_PS_213;
Array BC_1119 --> PACKED_TEXT_STORAGE TX_PS_214;
Array BC_1120 --> PACKED_TEXT_STORAGE TX_PS_213;
Array BC_1121 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1122 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1123 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1124 --> PACKED_TEXT_STORAGE TX_PS_215;
Array BC_1125 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1126 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1127 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1128 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1129 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1130 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1131 --> PACKED_TEXT_STORAGE TX_PS_216;
Array BC_1132 --> PACKED_TEXT_STORAGE TX_PS_217;
Array BC_1133 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1134 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1135 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1136 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1137 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1138 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1139 --> PACKED_TEXT_STORAGE TX_PS_218;
Array BC_1140 --> PACKED_TEXT_STORAGE TX_PS_219;
Array BC_1141 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1142 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1143 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1144 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1145 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1146 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1147 --> PACKED_TEXT_STORAGE TX_PS_220;
Array BC_1148 --> PACKED_TEXT_STORAGE TX_PS_221;
Array BC_1149 --> PACKED_TEXT_STORAGE TX_PS_220;
Array BC_1150 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1151 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1152 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1153 --> PACKED_TEXT_STORAGE TX_PS_15;
Array BC_1154 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1155 --> PACKED_TEXT_STORAGE TX_PS_222;
Array BC_1156 --> PACKED_TEXT_STORAGE TX_PS_223;
Array BC_1157 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1158 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1159 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1160 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1161 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1162 --> PACKED_TEXT_STORAGE TX_PS_224;
Array BC_1163 --> PACKED_TEXT_STORAGE TX_PS_225;
Array BC_1164 --> PACKED_TEXT_STORAGE TX_PS_226;
Array BC_1165 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1166 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1167 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1168 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_1169 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1170 --> PACKED_TEXT_STORAGE TX_PS_227;
Array BC_1171 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_165;
Array BC_1172 --> PACKED_TEXT_STORAGE TX_PS_227;
Array BC_1173 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1174 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1175 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1176 --> PACKED_TEXT_STORAGE TX_PS_228;
Array BC_1177 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1178 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1179 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1180 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1181 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1182 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1183 --> PACKED_TEXT_STORAGE TX_PS_229;
Array BC_1184 --> PACKED_TEXT_STORAGE TX_PS_230;
Array BC_1185 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1186 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1187 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1188 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1189 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1190 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1191 --> PACKED_TEXT_STORAGE TX_PS_231;
Array BC_1192 --> PACKED_TEXT_STORAGE TX_PS_232;
Array BC_1193 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1194 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1195 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1196 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1197 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1198 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1199 --> PACKED_TEXT_STORAGE TX_PS_233;
Array BC_1200 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_166;
Array BC_1201 --> PACKED_TEXT_STORAGE TX_PS_233;
Array BC_1202 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1203 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1204 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1205 --> PACKED_TEXT_STORAGE TX_PS_234;
Array BC_1206 --> PACKED_TEXT_STORAGE TX_PS_235;
Array BC_1207 --> PACKED_TEXT_STORAGE TX_PS_234;
Array BC_1208 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1209 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1210 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1211 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1212 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1213 --> PACKED_TEXT_STORAGE TX_PS_236;
Array BC_1214 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_167;
Array BC_1215 --> PACKED_TEXT_STORAGE TX_PS_236;
Array BC_1216 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1217 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1218 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1219 --> PACKED_TEXT_STORAGE TX_PS_237;
Array BC_1220 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_168;
Array BC_1221 --> PACKED_TEXT_STORAGE TX_PS_237;
Array BC_1222 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1223 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1224 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1225 --> PACKED_TEXT_STORAGE TX_PS_238;
Array BC_1226 --> PACKED_TEXT_STORAGE TX_PS_238;
Array BC_1227 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1228 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1229 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1230 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1231 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1232 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1233 --> PACKED_TEXT_STORAGE TX_PS_239;
Array BC_1234 --> PACKED_TEXT_STORAGE TX_PS_239;
Array BC_1235 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1236 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1237 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1238 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1239 --> PACKED_TEXT_STORAGE TX_PS_14;
Array BC_1240 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1241 --> PACKED_TEXT_STORAGE TX_PS_240;
Array BC_1242 --> PACKED_TEXT_STORAGE TX_PS_240;
Array BC_1243 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1244 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1245 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1246 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1247 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_1248 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1249 --> PACKED_TEXT_STORAGE TX_PS_241;
Array BC_1250 --> PACKED_TEXT_STORAGE TX_PS_241;
Array BC_1251 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1252 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1253 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1254 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1255 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_1256 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1257 --> PACKED_TEXT_STORAGE TX_PS_242;
Array BC_1258 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_169;
Array BC_1259 --> PACKED_TEXT_STORAGE TX_PS_242;
Array BC_1260 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1261 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1262 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1263 --> PACKED_TEXT_STORAGE TX_PS_243;
Array BC_1264 --> PACKED_TEXT_STORAGE TX_PS_244;
Array BC_1265 --> PACKED_TEXT_STORAGE TX_PS_243;
Array BC_1266 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1267 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1268 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1269 --> PACKED_TEXT_STORAGE TX_PS_14;
Array BC_1270 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1271 --> PACKED_TEXT_STORAGE TX_PS_245;
Array BC_1272 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_170;
Array BC_1273 --> PACKED_TEXT_STORAGE TX_PS_245;
Array BC_1274 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1275 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1276 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1277 --> PACKED_TEXT_STORAGE TX_PS_246;
Array BC_1278 --> PACKED_TEXT_STORAGE TX_PS_247;
Array BC_1279 --> PACKED_TEXT_STORAGE TX_PS_246;
Array BC_1280 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1281 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1282 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1283 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_1284 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1285 --> PACKED_TEXT_STORAGE TX_PS_248;
Array BC_1286 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_171;
Array BC_1287 --> PACKED_TEXT_STORAGE TX_PS_248;
Array BC_1288 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1289 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1290 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1291 --> PACKED_TEXT_STORAGE TX_PS_249;
Array BC_1292 --> PACKED_TEXT_STORAGE TX_PS_250;
Array BC_1293 --> PACKED_TEXT_STORAGE TX_PS_249;
Array BC_1294 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1295 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1296 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1297 --> PACKED_TEXT_STORAGE TX_PS_9;
Array BC_1298 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1299 --> PACKED_TEXT_STORAGE TX_PS_251;
Array BC_1300 --> PACKED_TEXT_STORAGE TX_PS_252;
Array BC_1301 --> PACKED_TEXT_STORAGE TX_PS_251;
Array BC_1302 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1303 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1304 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1305 --> PACKED_TEXT_STORAGE TX_PS_9;
Array BC_1306 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1307 --> PACKED_TEXT_STORAGE TX_PS_253;
Array BC_1308 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_172;
Array BC_1309 --> PACKED_TEXT_STORAGE TX_PS_253;
Array BC_1310 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1311 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1312 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1313 --> PACKED_TEXT_STORAGE TX_PS_254;
Array BC_1314 --> PACKED_TEXT_STORAGE TX_PS_254;
Array BC_1315 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1316 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1317 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1318 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1319 --> PACKED_TEXT_STORAGE TX_PS_14;
Array BC_1320 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1321 --> PACKED_TEXT_STORAGE TX_PS_255;
Array BC_1322 --> PACKED_TEXT_STORAGE TX_PS_256;
Array BC_1323 --> PACKED_TEXT_STORAGE TX_PS_255;
Array BC_1324 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1325 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1326 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1327 --> PACKED_TEXT_STORAGE TX_PS_9;
Array BC_1328 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1329 --> PACKED_TEXT_STORAGE TX_PS_257;
Array BC_1330 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1331 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1332 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1333 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1334 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1335 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1336 --> PACKED_TEXT_STORAGE TX_PS_258;
Array BC_1337 --> PACKED_TEXT_STORAGE TX_PS_258;
Array BC_1338 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1339 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1340 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1341 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1342 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_1343 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1344 --> PACKED_TEXT_STORAGE TX_PS_259;
Array BC_1345 --> PACKED_TEXT_STORAGE TX_PS_260;
Array BC_1346 --> PACKED_TEXT_STORAGE TX_PS_259;
Array BC_1347 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1348 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1349 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1350 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1351 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1352 --> PACKED_TEXT_STORAGE TX_PS_261;
Array BC_1353 --> PACKED_TEXT_STORAGE TX_PS_262;
Array BC_1354 --> PACKED_TEXT_STORAGE TX_PS_261;
Array BC_1355 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1356 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1357 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1358 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1359 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1360 --> PACKED_TEXT_STORAGE TX_PS_263;
Array BC_1361 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_173;
Array BC_1362 --> PACKED_TEXT_STORAGE TX_PS_263;
Array BC_1363 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1364 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1365 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1366 --> PACKED_TEXT_STORAGE TX_PS_264;
Array BC_1367 --> PACKED_TEXT_STORAGE TX_PS_264;
Array BC_1368 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1369 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1370 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1371 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1372 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1373 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1374 --> PACKED_TEXT_STORAGE TX_PS_265;
Array BC_1375 --> PACKED_TEXT_STORAGE TX_PS_266;
Array BC_1376 --> PACKED_TEXT_STORAGE TX_PS_265;
Array BC_1377 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1378 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1379 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1380 --> PACKED_TEXT_STORAGE TX_PS_9;
Array BC_1381 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1382 --> PACKED_TEXT_STORAGE TX_PS_267;
Array BC_1383 --> PACKED_TEXT_STORAGE TX_PS_268;
Array BC_1384 --> PACKED_TEXT_STORAGE TX_PS_267;
Array BC_1385 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1386 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1387 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1388 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1389 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1390 --> PACKED_TEXT_STORAGE TX_PS_269;
Array BC_1391 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_174;
Array BC_1392 --> PACKED_TEXT_STORAGE TX_PS_269;
Array BC_1393 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1394 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1395 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1396 --> PACKED_TEXT_STORAGE TX_PS_270;
Array BC_1397 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1398 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1399 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1400 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1401 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1402 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1403 --> PACKED_TEXT_STORAGE TX_PS_271;
Array BC_1404 --> PACKED_TEXT_STORAGE TX_PS_272;
Array BC_1405 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1406 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1407 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1408 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1409 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1410 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1411 --> PACKED_TEXT_STORAGE TX_PS_273;
Array BC_1412 --> PACKED_TEXT_STORAGE TX_PS_274;
Array BC_1413 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1414 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1415 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1416 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1417 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1418 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1419 --> PACKED_TEXT_STORAGE TX_PS_275;
Array BC_1420 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_175;
Array BC_1421 --> PACKED_TEXT_STORAGE TX_PS_275;
Array BC_1422 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1423 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1424 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1425 --> PACKED_TEXT_STORAGE TX_PS_276;
Array BC_1426 --> PACKED_TEXT_STORAGE TX_PS_277;
Array BC_1427 --> PACKED_TEXT_STORAGE TX_PS_276;
Array BC_1428 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1429 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1430 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1431 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1432 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1433 --> PACKED_TEXT_STORAGE TX_PS_278;
Array BC_1434 --> PACKED_TEXT_STORAGE TX_PS_279;
Array BC_1435 --> PACKED_TEXT_STORAGE TX_PS_278;
Array BC_1436 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1437 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1438 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1439 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1440 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1441 --> PACKED_TEXT_STORAGE TX_PS_280;
Array BC_1442 --> PACKED_TEXT_STORAGE TX_PS_280;
Array BC_1443 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1444 --> PACKED_TEXT_STORAGE TX_PS_26;
Array BC_1445 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1446 --> PACKED_TEXT_STORAGE TX_PS_281;
Array BC_1447 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_176;
Array BC_1448 --> PACKED_TEXT_STORAGE TX_PS_281;
Array BC_1449 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1450 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1451 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1452 --> PACKED_TEXT_STORAGE TX_PS_282;
Array BC_1453 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1454 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1455 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1456 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1457 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_1458 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1459 --> PACKED_TEXT_STORAGE TX_PS_283;
Array BC_1460 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_177;
Array BC_1461 --> PACKED_TEXT_STORAGE TX_PS_283;
Array BC_1462 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1463 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1464 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1465 --> PACKED_TEXT_STORAGE TX_PS_284;
Array BC_1466 --> PACKED_TEXT_STORAGE TX_PS_284;
Array BC_1467 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1468 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1469 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1470 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1471 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_1472 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1473 --> PACKED_TEXT_STORAGE TX_PS_285;
Array BC_1474 --> PACKED_TEXT_STORAGE TX_PS_285;
Array BC_1475 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1476 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1477 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1478 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1479 --> PACKED_TEXT_STORAGE TX_PS_14;
Array BC_1480 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1481 --> PACKED_TEXT_STORAGE TX_PS_286;
Array BC_1482 --> PACKED_TEXT_STORAGE TX_PS_286;
Array BC_1483 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1484 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1485 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1486 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1487 --> PACKED_TEXT_STORAGE TX_PS_9;
Array BC_1488 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1489 --> PACKED_TEXT_STORAGE TX_PS_287;
Array BC_1490 --> PACKED_TEXT_STORAGE TX_PS_287;
Array BC_1491 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1492 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1493 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1494 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1495 --> PACKED_TEXT_STORAGE TX_PS_9;
Array BC_1496 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1497 --> PACKED_TEXT_STORAGE TX_PS_288;
Array BC_1498 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_178;
Array BC_1499 --> PACKED_TEXT_STORAGE TX_PS_288;
Array BC_1500 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1501 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1502 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1503 --> PACKED_TEXT_STORAGE TX_PS_289;
Array BC_1504 --> PACKED_TEXT_STORAGE TX_PS_289;
Array BC_1505 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1506 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1507 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1508 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1509 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_1510 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1511 --> PACKED_TEXT_STORAGE TX_PS_290;
Array BC_1512 --> PACKED_TEXT_STORAGE TX_PS_290;
Array BC_1513 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1514 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1515 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1516 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1517 --> PACKED_TEXT_STORAGE TX_PS_14;
Array BC_1518 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1519 --> PACKED_TEXT_STORAGE TX_PS_291;
Array BC_1520 --> PACKED_TEXT_STORAGE TX_PS_291;
Array BC_1521 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1522 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1523 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1524 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1525 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_1526 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1527 --> PACKED_TEXT_STORAGE TX_PS_292;
Array BC_1528 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_179;
Array BC_1529 --> PACKED_TEXT_STORAGE TX_PS_292;
Array BC_1530 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1531 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1532 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1533 --> PACKED_TEXT_STORAGE TX_PS_293;
Array BC_1534 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1535 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1536 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1537 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1538 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1539 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1540 --> PACKED_TEXT_STORAGE TX_PS_294;
Array BC_1541 --> PACKED_TEXT_STORAGE TX_PS_295;
Array BC_1542 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1543 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1544 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1545 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1546 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1547 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1548 --> PACKED_TEXT_STORAGE TX_PS_296;
Array BC_1549 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_180;
Array BC_1550 --> PACKED_TEXT_STORAGE TX_PS_296;
Array BC_1551 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1552 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1553 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1554 --> PACKED_TEXT_STORAGE TX_PS_297;
Array BC_1555 --> PACKED_TEXT_STORAGE TX_PS_297;
Array BC_1556 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1557 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1558 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1559 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1560 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1561 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1562 --> PACKED_TEXT_STORAGE TX_PS_298;
Array BC_1563 --> PACKED_TEXT_STORAGE TX_PS_298;
Array BC_1564 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1565 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1566 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1567 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1568 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1569 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1570 --> PACKED_TEXT_STORAGE TX_PS_299;
Array BC_1571 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_181;
Array BC_1572 --> PACKED_TEXT_STORAGE TX_PS_299;
Array BC_1573 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1574 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1575 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1576 --> PACKED_TEXT_STORAGE TX_PS_300;
Array BC_1577 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_182;
Array BC_1578 --> PACKED_TEXT_STORAGE TX_PS_300;
Array BC_1579 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1580 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1581 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1582 --> PACKED_TEXT_STORAGE TX_PS_301;
Array BC_1583 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_183;
Array BC_1584 --> PACKED_TEXT_STORAGE TX_PS_301;
Array BC_1585 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1586 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1587 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1588 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_1589 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1590 --> PACKED_TEXT_STORAGE TX_PS_302;
Array BC_1591 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_184;
Array BC_1592 --> PACKED_TEXT_STORAGE TX_PS_302;
Array BC_1593 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1594 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1595 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1596 --> PACKED_TEXT_STORAGE TX_PS_303;
Array BC_1597 --> PACKED_TEXT_STORAGE TX_PS_303;
Array BC_1598 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1599 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1600 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1601 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1602 --> PACKED_TEXT_STORAGE TX_PS_14;
Array BC_1603 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1604 --> PACKED_TEXT_STORAGE TX_PS_304;
Array BC_1605 --> PACKED_TEXT_STORAGE TX_PS_305;
Array BC_1606 --> PACKED_TEXT_STORAGE TX_PS_304;
Array BC_1607 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1608 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1609 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1610 --> PACKED_TEXT_STORAGE TX_PS_11;
Array BC_1611 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1612 --> PACKED_TEXT_STORAGE TX_PS_306;
Array BC_1613 --> PACKED_TEXT_STORAGE TX_PS_306;
Array BC_1614 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1615 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1616 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1617 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1618 --> PACKED_TEXT_STORAGE TX_PS_14;
Array BC_1619 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1620 --> PACKED_TEXT_STORAGE TX_PS_307;
Array BC_1621 --> PACKED_TEXT_STORAGE TX_PS_307;
Array BC_1622 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1623 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1624 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1625 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1626 --> PACKED_TEXT_STORAGE TX_PS_11;
Array BC_1627 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1628 --> PACKED_TEXT_STORAGE TX_PS_308;
Array BC_1629 --> PACKED_TEXT_STORAGE TX_PS_308;
Array BC_1630 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1631 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1632 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1633 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1634 --> PACKED_TEXT_STORAGE TX_PS_11;
Array BC_1635 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1636 --> PACKED_TEXT_STORAGE TX_PS_309;
Array BC_1637 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_185;
Array BC_1638 --> PACKED_TEXT_STORAGE TX_PS_309;
Array BC_1639 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1640 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1641 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1642 --> PACKED_TEXT_STORAGE TX_PS_310;
Array BC_1643 --> PACKED_TEXT_STORAGE TX_PS_310;
Array BC_1644 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1645 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1646 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1647 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1648 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_1649 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1650 --> PACKED_TEXT_STORAGE TX_PS_311;
Array BC_1651 --> PACKED_TEXT_STORAGE TX_PS_311;
Array BC_1652 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1653 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1654 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1655 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1656 --> PACKED_TEXT_STORAGE TX_PS_9;
Array BC_1657 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1658 --> PACKED_TEXT_STORAGE TX_PS_312;
Array BC_1659 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_186;
Array BC_1660 --> PACKED_TEXT_STORAGE TX_PS_312;
Array BC_1661 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1662 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1663 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1664 --> PACKED_TEXT_STORAGE TX_PS_313;
Array BC_1665 --> PACKED_TEXT_STORAGE TX_PS_313;
Array BC_1666 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1667 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1668 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1669 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1670 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_1671 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1672 --> PACKED_TEXT_STORAGE TX_PS_314;
Array BC_1673 --> PACKED_TEXT_STORAGE TX_PS_314;
Array BC_1674 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1675 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1676 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1677 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1678 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_1679 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1680 --> PACKED_TEXT_STORAGE TX_PS_315;
Array BC_1681 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_187;
Array BC_1682 --> PACKED_TEXT_STORAGE TX_PS_315;
Array BC_1683 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1684 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1685 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1686 --> PACKED_TEXT_STORAGE TX_PS_316;
Array BC_1687 --> PACKED_TEXT_STORAGE TX_PS_316;
Array BC_1688 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1689 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1690 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1691 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1692 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_1693 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1694 --> PACKED_TEXT_STORAGE TX_PS_317;
Array BC_1695 --> PACKED_TEXT_STORAGE TX_PS_317;
Array BC_1696 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1697 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1698 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1699 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1700 --> PACKED_TEXT_STORAGE TX_PS_12;
Array BC_1701 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1702 --> PACKED_TEXT_STORAGE TX_PS_318;
Array BC_1703 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_188;
Array BC_1704 --> PACKED_TEXT_STORAGE TX_PS_318;
Array BC_1705 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1706 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1707 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1708 --> PACKED_TEXT_STORAGE TX_PS_319;
Array BC_1709 --> PACKED_TEXT_STORAGE TX_PS_319;
Array BC_1710 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1711 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1712 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1713 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1714 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_1715 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1716 --> PACKED_TEXT_STORAGE TX_PS_320;
Array BC_1717 --> PACKED_TEXT_STORAGE TX_PS_320;
Array BC_1718 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1719 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1720 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1721 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1722 --> PACKED_TEXT_STORAGE TX_PS_12;
Array BC_1723 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1724 --> PACKED_TEXT_STORAGE TX_PS_321;
Array BC_1725 --> PACKED_TEXT_STORAGE TX_PS_322;
Array BC_1726 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1727 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1728 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1729 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1730 --> PACKED_TEXT_STORAGE TX_PS_12;
Array BC_1731 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1732 --> PACKED_TEXT_STORAGE TX_PS_323;
Array BC_1733 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_189;
Array BC_1734 --> PACKED_TEXT_STORAGE TX_PS_323;
Array BC_1735 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1736 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1737 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1738 --> PACKED_TEXT_STORAGE TX_PS_324;
Array BC_1739 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1740 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1741 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1742 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1743 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1744 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1745 --> PACKED_TEXT_STORAGE TX_PS_325;
Array BC_1746 --> PACKED_TEXT_STORAGE TX_PS_325;
Array BC_1747 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1748 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1749 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1750 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1751 --> PACKED_TEXT_STORAGE TX_PS_14;
Array BC_1752 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1753 --> PACKED_TEXT_STORAGE TX_PS_326;
Array BC_1754 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_190;
Array BC_1755 --> PACKED_TEXT_STORAGE TX_PS_326;
Array BC_1756 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1757 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1758 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1759 --> PACKED_TEXT_STORAGE TX_PS_327;
Array BC_1760 --> PACKED_TEXT_STORAGE TX_PS_327;
Array BC_1761 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1762 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1763 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1764 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1765 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_1766 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1767 --> PACKED_TEXT_STORAGE TX_PS_328;
Array BC_1768 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1769 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1770 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1771 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1772 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1773 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1774 --> PACKED_TEXT_STORAGE TX_PS_329;
Array BC_1775 --> PACKED_TEXT_STORAGE TX_PS_330;
Array BC_1776 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1777 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1778 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1779 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1780 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1781 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1782 --> PACKED_TEXT_STORAGE TX_PS_331;
Array BC_1783 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_191;
Array BC_1784 --> PACKED_TEXT_STORAGE TX_PS_331;
Array BC_1785 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1786 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1787 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1788 --> PACKED_TEXT_STORAGE TX_PS_332;
Array BC_1789 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1790 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1791 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1792 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1793 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1794 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1795 --> PACKED_TEXT_STORAGE TX_PS_333;
Array BC_1796 --> PACKED_TEXT_STORAGE TX_PS_334;
Array BC_1797 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1798 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1799 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1800 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1801 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1802 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1803 --> PACKED_TEXT_STORAGE TX_PS_335;
Array BC_1804 --> PACKED_TEXT_STORAGE TX_PS_336;
Array BC_1805 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1806 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1807 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1808 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1809 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1810 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1811 --> PACKED_TEXT_STORAGE TX_PS_337;
Array BC_1812 --> PACKED_TEXT_STORAGE TX_PS_337;
Array BC_1813 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1814 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1815 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1816 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1817 --> PACKED_TEXT_STORAGE TX_PS_14;
Array BC_1818 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1819 --> PACKED_TEXT_STORAGE TX_PS_338;
Array BC_1820 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_192;
Array BC_1821 --> PACKED_TEXT_STORAGE TX_PS_338;
Array BC_1822 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1823 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1824 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1825 --> PACKED_TEXT_STORAGE TX_PS_339;
Array BC_1826 --> PACKED_TEXT_STORAGE TX_PS_339;
Array BC_1827 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1828 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1829 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1830 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1831 --> PACKED_TEXT_STORAGE TX_PS_9;
Array BC_1832 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1833 --> PACKED_TEXT_STORAGE TX_PS_340;
Array BC_1834 --> PACKED_TEXT_STORAGE TX_PS_340;
Array BC_1835 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1836 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1837 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1838 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1839 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1840 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1841 --> PACKED_TEXT_STORAGE TX_PS_341;
Array BC_1842 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_193;
Array BC_1843 --> PACKED_TEXT_STORAGE TX_PS_341;
Array BC_1844 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1845 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1846 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1847 --> PACKED_TEXT_STORAGE TX_PS_342;
Array BC_1848 --> PACKED_TEXT_STORAGE TX_PS_342;
Array BC_1849 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1850 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1851 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1852 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1853 --> PACKED_TEXT_STORAGE TX_PS_14;
Array BC_1854 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1855 --> PACKED_TEXT_STORAGE TX_PS_343;
Array BC_1856 --> PACKED_TEXT_STORAGE TX_PS_343;
Array BC_1857 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1858 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1859 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1860 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1861 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1862 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1863 --> PACKED_TEXT_STORAGE TX_PS_344;
Array BC_1864 --> PACKED_TEXT_STORAGE TX_PS_344;
Array BC_1865 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1866 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1867 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1868 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1869 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1870 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1871 --> PACKED_TEXT_STORAGE TX_PS_345;
Array BC_1872 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_194;
Array BC_1873 --> PACKED_TEXT_STORAGE TX_PS_345;
Array BC_1874 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1875 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1876 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1877 --> PACKED_TEXT_STORAGE TX_PS_346;
Array BC_1878 --> PACKED_TEXT_STORAGE TX_PS_346;
Array BC_1879 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1880 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1881 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1882 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1883 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_1884 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1885 --> PACKED_TEXT_STORAGE TX_PS_347;
Array BC_1886 --> PACKED_TEXT_STORAGE TX_PS_348;
Array BC_1887 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1888 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1889 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1890 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1891 --> PACKED_TEXT_STORAGE TX_PS_15;
Array BC_1892 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1893 --> PACKED_TEXT_STORAGE TX_PS_349;
Array BC_1894 --> PACKED_TEXT_STORAGE TX_PS_350;
Array BC_1895 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1896 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1897 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1898 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1899 --> PACKED_TEXT_STORAGE TX_PS_9;
Array BC_1900 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1901 --> PACKED_TEXT_STORAGE TX_PS_351;
Array BC_1902 --> PACKED_TEXT_STORAGE TX_PS_352;
Array BC_1903 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1904 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1905 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1906 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1907 --> PACKED_TEXT_STORAGE TX_PS_9;
Array BC_1908 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1909 --> PACKED_TEXT_STORAGE TX_PS_353;
Array BC_1910 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_195;
Array BC_1911 --> PACKED_TEXT_STORAGE TX_PS_353;
Array BC_1912 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1913 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1914 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1915 --> PACKED_TEXT_STORAGE TX_PS_354;
Array BC_1916 --> PACKED_TEXT_STORAGE TX_PS_354;
Array BC_1917 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1918 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1919 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1920 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1921 --> PACKED_TEXT_STORAGE TX_PS_14;
Array BC_1922 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1923 --> PACKED_TEXT_STORAGE TX_PS_355;
Array BC_1924 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1925 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1926 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1927 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1928 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1929 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1930 --> PACKED_TEXT_STORAGE TX_PS_356;
Array BC_1931 --> PACKED_TEXT_STORAGE TX_PS_357;
Array BC_1932 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1933 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1934 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1935 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1936 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1937 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1938 --> PACKED_TEXT_STORAGE TX_PS_358;
Array BC_1939 --> PACKED_TEXT_STORAGE TX_PS_359;
Array BC_1940 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1941 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1942 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1943 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1944 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1945 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1946 --> PACKED_TEXT_STORAGE TX_PS_360;
Array BC_1947 --> PACKED_TEXT_STORAGE TX_PS_360;
Array BC_1948 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1949 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1950 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1951 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1952 --> PACKED_TEXT_STORAGE TX_PS_19;
Array BC_1953 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1954 --> PACKED_TEXT_STORAGE TX_PS_361;
Array BC_1955 --> PACKED_TEXT_STORAGE TX_PS_361;
Array BC_1956 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1957 --> PACKED_TEXT_STORAGE TX_PS_26;
Array BC_1958 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1959 --> PACKED_TEXT_STORAGE TX_PS_362;
Array BC_1960 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_196;
Array BC_1961 --> PACKED_TEXT_STORAGE TX_PS_362;
Array BC_1962 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1963 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1964 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1965 --> PACKED_TEXT_STORAGE TX_PS_363;
Array BC_1966 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1967 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1968 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1969 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1970 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1971 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1972 --> PACKED_TEXT_STORAGE TX_PS_364;
Array BC_1973 --> PACKED_TEXT_STORAGE TX_PS_365;
Array BC_1974 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1975 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1976 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1977 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1978 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1979 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1980 --> PACKED_TEXT_STORAGE TX_PS_366;
Array BC_1981 --> PACKED_TEXT_STORAGE TX_PS_367;
Array BC_1982 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1983 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1984 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1985 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1986 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1987 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1988 --> PACKED_TEXT_STORAGE TX_PS_368;
Array BC_1989 --> PACKED_TEXT_STORAGE TX_PS_369;
Array BC_1990 --> PACKED_TEXT_STORAGE TX_PS_368;
Array BC_1991 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1992 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1993 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1994 --> PACKED_TEXT_STORAGE TX_PS_370;
Array BC_1995 --> PACKED_TEXT_STORAGE TX_PS_370;
Array BC_1996 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1997 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1998 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1999 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2000 --> PACKED_TEXT_STORAGE TX_PS_14;
Array BC_2001 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2002 --> PACKED_TEXT_STORAGE TX_PS_371;
Array BC_2003 --> PACKED_TEXT_STORAGE TX_PS_371;
Array BC_2004 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2005 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2006 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2007 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2008 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2009 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2010 --> PACKED_TEXT_STORAGE TX_PS_372;
Array BC_2011 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2012 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2013 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2014 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2015 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2016 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2017 --> PACKED_TEXT_STORAGE TX_PS_373;
Array BC_2018 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_197;
Array BC_2019 --> PACKED_TEXT_STORAGE TX_PS_373;
Array BC_2020 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2021 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2022 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2023 --> PACKED_TEXT_STORAGE TX_PS_374;
Array BC_2024 --> PACKED_TEXT_STORAGE TX_PS_375;
Array BC_2025 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2026 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2027 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2028 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2029 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_2030 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2031 --> PACKED_TEXT_STORAGE TX_PS_376;
Array BC_2032 --> PACKED_TEXT_STORAGE TX_PS_377;
Array BC_2033 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2034 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2035 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2036 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2037 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_2038 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2039 --> PACKED_TEXT_STORAGE TX_PS_378;
Array BC_2040 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_198;
Array BC_2041 --> PACKED_TEXT_STORAGE TX_PS_378;
Array BC_2042 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2043 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2044 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2045 --> PACKED_TEXT_STORAGE TX_PS_379;
Array BC_2046 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2047 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2048 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2049 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2050 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2051 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2052 --> PACKED_TEXT_STORAGE TX_PS_380;
Array BC_2053 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_199;
Array BC_2054 --> PACKED_TEXT_STORAGE TX_PS_380;
Array BC_2055 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2056 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2057 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2058 --> PACKED_TEXT_STORAGE TX_PS_381;
Array BC_2059 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2060 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2061 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2062 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2063 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2064 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2065 --> PACKED_TEXT_STORAGE TX_PS_382;
Array BC_2066 --> PACKED_TEXT_STORAGE TX_PS_383;
Array BC_2067 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2068 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2069 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2070 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2071 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2072 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2073 --> PACKED_TEXT_STORAGE TX_PS_384;
Array BC_2074 --> PACKED_TEXT_STORAGE TX_PS_385;
Array BC_2075 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2076 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2077 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2078 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2079 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2080 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2081 --> PACKED_TEXT_STORAGE TX_PS_386;
Array BC_2082 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_200;
Array BC_2083 --> PACKED_TEXT_STORAGE TX_PS_386;
Array BC_2084 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2085 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2086 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2087 --> PACKED_TEXT_STORAGE TX_PS_387;
Array BC_2088 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2089 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2090 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2091 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2092 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2093 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2094 --> PACKED_TEXT_STORAGE TX_PS_388;
Array BC_2095 --> PACKED_TEXT_STORAGE TX_PS_389;
Array BC_2096 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2097 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2098 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2099 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2100 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2101 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2102 --> PACKED_TEXT_STORAGE TX_PS_390;
Array BC_2103 --> PACKED_TEXT_STORAGE TX_PS_391;
Array BC_2104 --> PACKED_TEXT_STORAGE TX_PS_390;
Array BC_2105 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2106 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2107 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2108 --> PACKED_TEXT_STORAGE TX_PS_392;
Array BC_2109 --> PACKED_TEXT_STORAGE TX_PS_393;
Array BC_2110 --> PACKED_TEXT_STORAGE TX_PS_392;
Array BC_2111 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2112 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2113 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2114 --> PACKED_TEXT_STORAGE TX_PS_394;
Array BC_2115 --> PACKED_TEXT_STORAGE TX_PS_395;
Array BC_2116 --> PACKED_TEXT_STORAGE TX_PS_394;
Array BC_2117 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2118 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2119 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2120 --> PACKED_TEXT_STORAGE TX_PS_396;
Array BC_2121 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2122 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2123 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2124 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2125 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2126 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2127 --> PACKED_TEXT_STORAGE TX_PS_397;
Array BC_2128 --> PACKED_TEXT_STORAGE TX_PS_398;
Array BC_2129 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2130 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2131 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2132 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2133 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2134 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2135 --> PACKED_TEXT_STORAGE TX_PS_399;
Array BC_2136 --> PACKED_TEXT_STORAGE TX_PS_400;
Array BC_2137 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2138 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2139 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2140 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2141 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2142 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2143 --> PACKED_TEXT_STORAGE TX_PS_401;
Array BC_2144 --> PACKED_TEXT_STORAGE TX_PS_402;
Array BC_2145 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2146 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2147 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2148 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2149 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2150 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2151 --> PACKED_TEXT_STORAGE TX_PS_403;
Array BC_2152 --> PACKED_TEXT_STORAGE TX_PS_404;
Array BC_2153 --> PACKED_TEXT_STORAGE TX_PS_403;
Array BC_2154 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2155 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2156 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2157 --> PACKED_TEXT_STORAGE TX_PS_405;
Array BC_2158 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2159 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2160 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2161 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2162 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2163 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2164 --> PACKED_TEXT_STORAGE TX_PS_406;
Array BC_2165 --> PACKED_TEXT_STORAGE TX_PS_407;
Array BC_2166 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2167 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2168 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2169 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2170 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2171 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2172 --> PACKED_TEXT_STORAGE TX_PS_408;
Array BC_2173 --> PACKED_TEXT_STORAGE TX_PS_409;
Array BC_2174 --> PACKED_TEXT_STORAGE TX_PS_408;
Array BC_2175 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2176 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2177 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2178 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2179 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2180 --> PACKED_TEXT_STORAGE TX_PS_410;
Array BC_2181 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_201;
Array BC_2182 --> PACKED_TEXT_STORAGE TX_PS_410;
Array BC_2183 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2184 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2185 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2186 --> PACKED_TEXT_STORAGE TX_PS_411;
Array BC_2187 --> PACKED_TEXT_STORAGE TX_PS_412;
Array BC_2188 --> PACKED_TEXT_STORAGE TX_PS_411;
Array BC_2189 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2190 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2191 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2192 --> PACKED_TEXT_STORAGE TX_PS_13;
Array BC_2193 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2194 --> PACKED_TEXT_STORAGE TX_PS_413;
Array BC_2195 --> PACKED_TEXT_STORAGE TX_PS_4;
Array BC_2196 --> PACKED_TEXT_STORAGE TX_PS_3;
Array BC_2197 --> PACKED_TEXT_STORAGE TX_PS_414;
Array BC_2198 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2199 --> PACKED_TEXT_STORAGE TX_PS_415;
Array BC_2200 --> PACKED_TEXT_STORAGE TX_PS_416;
Array BC_2201 --> PACKED_TEXT_STORAGE TX_PS_417;
Array BC_2202 --> PACKED_TEXT_STORAGE TX_PS_418;
Array BC_2203 --> PACKED_TEXT_STORAGE TX_PS_419;
Array BC_2204 --> PACKED_TEXT_STORAGE TX_PS_420;
Array BC_2205 --> PACKED_TEXT_STORAGE TX_PS_421;
Array BC_2206 --> PACKED_TEXT_STORAGE TX_PS_422;
Array BC_2207 --> PACKED_TEXT_STORAGE TX_PS_423;
Array BC_2208 --> PACKED_TEXT_STORAGE TX_PS_424;
Array BC_2209 --> PACKED_TEXT_STORAGE TX_PS_425;
Array BC_2210 --> PACKED_TEXT_STORAGE TX_PS_426;
Array BC_2211 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2212 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_202;
Array BC_2213 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2214 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2215 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2216 --> PACKED_TEXT_STORAGE TX_PS_427;
Array BC_2217 --> PACKED_TEXT_STORAGE TX_PS_428;
Array BC_2218 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_203;
Array BC_2219 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2220 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2221 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2222 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2223 --> PACKED_TEXT_STORAGE TX_PS_429;
Array BC_2224 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_204;
Array BC_2225 --> PACKED_TEXT_STORAGE TX_PS_430;
Array BC_2226 --> PACKED_TEXT_STORAGE TX_PS_431;
Array BC_2227 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_205;
Array BC_2228 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2229 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_206;
Array BC_2230 --> PACKED_TEXT_STORAGE TX_PS_432;
Array BC_2231 --> PACKED_TEXT_STORAGE TX_PS_433;
Array BC_2232 --> PACKED_TEXT_STORAGE TX_PS_434;
Array BC_2233 --> PACKED_TEXT_STORAGE TX_PS_435;
Array BC_2234 --> PACKED_TEXT_STORAGE TX_PS_436;
Array BC_2235 --> PACKED_TEXT_STORAGE TX_PS_433;
Array BC_2236 --> PACKED_TEXT_STORAGE TX_PS_437;
Array BC_2237 --> PACKED_TEXT_STORAGE TX_PS_434;
Array BC_2238 --> PACKED_TEXT_STORAGE TX_PS_435;
Array BC_2239 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2240 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2241 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2242 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;




! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Signing off
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

! End of automatically generated I6 source
! --------------------------------------------------------------------------
